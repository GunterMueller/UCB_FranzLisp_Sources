# Franz Lisp distribution Opus 38.89
mkdir franz
mkdir franz/h
mkdir franz/vax
mkdir franz/68k
mkdir liszt
mkdir liszt/vax
mkdir liszt/68k
mkdir doc
mkdir utils
mkdir pearl
mkdir lisplib
mkdir lisplib/manual
mkdir lisplib/autorun
cat >  ./Makefile  << 'EndOfFile'
# $Header: Makefile,v 1.28 84/02/03 08:09:00 jkf Exp $
# $Locker:  $
#  Makefile for total Franz Lisp system.
#
# Read the file ReadMe for directions on how to build the system.
#
#    capabilities of this directory.
# copylibrary: copies distribution copy of lisp directory to LibDir
# fast: make a new lisp and liszt assuming that a liszt and lisp
#	already exist.  Results are franz/mylisp and liszt/nliszt.
#	Use 'make install' to install it.
# install: moves franz/mylisp to ObjDir/lisp  and moves
#	liszt/nliszt to ObjDir/liszt
#
#-- the rest of the capabilities are for use when making a distribution
#   directory.
# copyallsource: copies lisp distrib files in the current directory tree 
#       to the tree CopyTo.  
#	CopyTo should exist already, but the subdirectories
#	need not exist.
#
# Before doing one of the below, you should make sure that the on line
# manual is up to date.  Go to the doc subdirectory and type 
#	'make rall install'
#
# lispdist: makes a new distribution directory in LispDist.
#	LispDist should already exist.
#
# lispscriptdist: make a shell script lisp distribution.  The result is put
# 	in LispDist as a set of text files comprising a shell script.
#	The files are broken into a nice size for transport over the berknet.
#	The first thing that lispscriptdist does is to, 
#		'make prelispscriptdist'
#	Which insures that the files are ready to go.
#	Also, the value of Version should be set to the version number of
#	lisp you are making.
#
#--- Default paths and programs
DESTDIR =
.DEFAULT: all

# the following line is modifed by './lispconf', don't modify it by hand.
#ifdef vax
Mach = vax
#else
#Mach = 68k
#endif

RootDir = /na/franz
#ifdef ucbstd
LibDir = ${DESTDIR}/usr/lib/lisp
ObjDir = ${DESTDIR}/usr/ucb
#else
#LibDir = ${DESTDIR}${RootDir}/lisplib
#ObjDir = ${DESTDIR}${RootDir}/bin
#endif
LispDist = /usr/src/ucb/lispdist
CopyTo = /dev/null
Lisp = ${ObjDir}/lisp
Liszt = ${ObjDir}/liszt
Version = 38.89

# definitions that you shouldn't change
FranzD = franz/${Mach}
LisztD = liszt/${Mach}
CcodeDir = ../../${FranzD}

#--- this directory also has some sources
Src = Makefile ReadMe lispconf lispnews scriptcat Notice cvt.awk

#make as lisp and lisp assuming that there are .s files in the
#lisplib and liszt subdirs
fromasm:
#ifdef unisoft
#	(cd as68 ; make DESTDIR=${LibDir} install)
#endif
	(cd utils     ; make LibDir=${LibDir} all)
	(cd ${LibDir} ; make LibDir=${LibDir} as nld fromasm)
	(cd ${FranzD} ; make LibDir=${LibDir} ObjDir=${ObjDir} nlisp)
	(cd ${LisztD} ; make Lisp=${CcodeDir}/nlisp fromasm)
	(cd liszt     ; make Liszt=${Mach}/nliszt lxref)

## when the lisp system is rebuilt as part of the entire Nbsd distribution,
# three calls are made: 
#   first   'make'		 	to build lisp,liszt and lxref
#   next    'make DESTDIR=xxx install'	to install the new lisp
#   finally 'make clean'		to clean out objects
#
# the 'make all' is done when just a 'make' is done
all:
	(cd utils     ; make LibDir=${LibDir} all)
	(cd ${LibDir} ; make as nld)
	(cd ${FranzD} ; make LibDir=${LibDir} ObjDir=${ObjDir} donlisp)
	(cd ${LisztD} ; make Lisp=${CcodeDir}/nlisp nliszt)
	(cd liszt     ; make Liszt=${Mach}/nliszt lxref)

	
copylibrary: 
#ifdef ucbstd
	(cd lisplib ; make CopyTo=${LibDir} copysource)
	-mkdir ${LibDir}/manual
	(cd doc; make LibDir=${LibDir} FromDir=../lisplib \
				CopyTo=${LibDir}/manual copymanual)
#endif

fast:
	date
	(cd utils ; make LibDir=${LibDir} all)
	(cd ${LibDir}; make as nld tackon)
	(cd ${FranzD}; make Lisp=${Lisp} Liszt=${Liszt} LibDir=${LibDir}\
			        ObjDir=${ObjDir} donlisp)
	(cd ${LisztD}; make Lisp=${CcodeDir}/nlisp Liszt=${Liszt} donliszt)
	(X=`pwd` ; cd ${LibDir}; make Liszt=$$X/${LisztD}/nliszt clean all)
	date
	(cd ${FranzD}; make Liszt=../../${LisztD}/nliszt \
			ObjDir=${ObjDir} LibDir=${LibDir} donlisp)
	date
	(cd ${LisztD}; make Lisp=${CcodeDir}/nlisp \
			    Liszt=./nliszt cleanobj nliszt)
	(cd liszt ; make Liszt=${Mach}/nliszt lxref)
	date

slow:
	date
	(cd utils ; make LibDir=${LibDir} all)
	(cd ${LibDir}; make as nld)
	(cd ${FranzD}; make LibDir=${LibDir} ObjDir=${ObjDir} snlisp)
	date
	(cd ${LisztD}; make Lisp=${CcodeDir}/snlisp snliszt)
	(cd ${LisztD}; make Lisp=${CcodeDir}/snlisp Liszt=./snliszt nliszt)
	rm -f ${LisztD}/snliszt
	date
	rm -f ${FranzD}/snlisp
	(X=`pwd`; cd ${FranzD};make Liszt=$$X/${LisztD}/nliszt \
				    ObjDir=${ObjDir}\
				    LibDir=${LibDir} nlisp)
	(cd ${LisztD}; make Lisp=${CcodeDir}/nlisp Liszt=./nliszt nliszt)
	(X=`pwd`; cd ${LibDir} ; make Liszt=$$X/${LisztD}/nliszt all)
	(X=`pwd`; cd ${LibDir} ; make Liszt=$$X/${LisztD}/nliszt struct-again)
	(X=`pwd`; cd ${FranzD} ;  make Liszt=$$X/${LisztD}/nliszt \
				       ObjDir=${ObjDir}\
				       LibDir=${LibDir} donlisp)
	(cd ${LisztD}; make Lisp=${CcodeDir}/nlisp Liszt=./nliszt nliszt)
	(cd liszt ; make Liszt=${Mach}/nliszt lxref)
	date

install:
	(cd ${FranzD}; make ObjDir=${ObjDir} LibDir=${LibDir} install)
	(cd ${LisztD}; make ObjDir=${ObjDir} LibDir=${LibDir} install)
	(cd liszt; make ObjDir=${ObjDir} LibDir=${LibDir} install)


copyallsource:
	-mkdir ${CopyTo}/franz
	-mkdir ${CopyTo}/franz/vax
	-mkdir ${CopyTo}/franz/68k
	-mkdir ${CopyTo}/liszt
	-mkdir ${CopyTo}/liszt/vax
	-mkdir ${CopyTo}/liszt/68k
	-mkdir ${CopyTo}/doc
	-mkdir ${CopyTo}/utils
	-mkdir ${CopyTo}/lisplib
	-mkdir ${CopyTo}/lisplib/manual
	-mkdir ${CopyTo}/lisplib/autorun
	-mkdir ${CopyTo}/pearl
	cp ${Src} ${CopyTo}
	(cd franz; make   CopyTo=${CopyTo}/franz copysource)
	(cd franz/vax; make   CopyTo=${CopyTo}/franz/vax copysource)
	(cd franz/68k; make   CopyTo=${CopyTo}/franz/68k copysource)
	(cd liszt; make  CopyTo=${CopyTo}/liszt copysource)
	(cd liszt/vax; make  CopyTo=${CopyTo}/liszt/vax copysource)
	(cd liszt/68k; make  CopyTo=${CopyTo}/liszt/68k copysource)
	(cd ${LibDir} ; make  CopyTo=${CopyTo}/lisplib copysource)
	(cd doc; make CopyTo=${CopyTo}/doc copysource)
	(cd utils; make CopyTo=${CopyTo}/utils copysource)
	(cd doc; \
          make FromDir=${LibDir} CopyTo=${CopyTo}/lisplib/manual copymanual)
	(cd pearl; make CopyTo=${CopyTo}/pearl copysource)
  
lispdist:
	(cd ${LispDist}; rm -f -r *)
	make CopyTo=${LispDist} copyallsource

copyallobjects:
	(cd franz/vax; make   CopyTo=${CopyTo}/franz/vax copyobjects)
	(cd franz/68k; make   CopyTo=${CopyTo}/franz/68k copyobjects)
	(cd liszt/vax; make  CopyTo=${CopyTo}/liszt/vax copyobjects)
	(cd ${LibDir} ; make  CopyTo=${CopyTo}/lisplib copyobjects)

prelispscriptdist:
	(cd doc ; make all)

lispscriptdist:
	(cd ${LispDist}; rm -f -r opus*)
	make prelispscriptdist
	(make genlispscript | (cd ${LispDist} ; \
			       divide -500000 -popus${Version}. -l))

xtra: 
	(cd ${LispDist}; rm -f -r x${Mach}*)
	make Mach=${Mach} setupx
	(make Mach=${Mach} genxtra) | \
	     (cd ${LispDist} ; divide -500000 -px${Mach}.${Version}. -l)

lispas:
	make genas68 > ${LispDist}/lispas

setupx:
	(X=`pwd`; cd ${LibDir};\
	make Liszt="$$X/liszt/${Mach}/nliszt -e '(sstatus feature for-${Mach})'" xtra)
	(cd liszt/${Mach}; make  -f Makefile2 xtra)

genlispscript:
	@echo \# Franz Lisp distribution Opus ${Version}
	@echo mkdir franz
	@echo mkdir franz/h
	@echo mkdir franz/vax
	@echo mkdir franz/68k
	@echo mkdir liszt
	@echo mkdir liszt/vax
	@echo mkdir liszt/68k
	@echo mkdir doc
	@echo mkdir utils
	@echo mkdir pearl
	@echo mkdir lisplib
	@echo mkdir lisplib/manual
	@echo mkdir lisplib/autorun
	@scriptcat . . ${Src}
	@echo chmod 775 lispconf
	@(cd franz ; make scriptcatall)
	@(cd franz/vax ; make scriptcatall)
	@(cd franz/68k ; make scriptcatall)
	@(cd liszt ; make scriptcatall)
	@(cd liszt/vax ; make scriptcatall)
	@(cd liszt/68k ; make scriptcatall)
	@(cd doc ; make LibDir=${LibDir} scriptcatall)
	@(cd utils ; make scriptcatall )
	@(X=`pwd` ; cd pearl ; make CdTo=$$X scriptcatall)
	@(X=`pwd` ; cd ${LibDir} ;  make CdTo=$$X scriptcatall)
	@echo \# end of Franz Lisp Distribution

genas68:
	@(echo mkdir as68;cd as68; make scriptcat)

genxtra:
	@(X=`pwd` ; cd ${LibDir} ;  make CdTo=$$X scriptcatxtra)
	@(cd liszt/${Mach} ; make -f Makefile2 scriptcatxtra)

clean:
	cd franz    ; make clean
	cd franz/vax; make clean
	cd franz/68k; make clean
	cd liszt    ; make clean
	cd liszt/vax; make clean
	cd liszt/68k; make clean
	cd doc      ; make clean

vdist-dim:
	rdist -v -d host=dim

dist-dim:
	rdist -d host=dim
EndOfFile
cat >  ./ReadMe  << 'EndOfFile'
File: ReadMe 				-[Tue Mar 29 22:03:29 1983 by jkf]-
Location: the root of the lisp distribution tree

    This directory contains a Makefile which can will direct the 
initial construction and installation of the Franz Lisp system.  After the 
lisp system is installed, the Makefiles in the subdirectories should be
used directly when modifications are made to either piece of code.

    The lisp system consists of these parts:
 1) lisp - lisp interpreter
 2) liszt - lisp compiler
 3) lxref - lisp cross reference program
 4) library of files - collection of lisp files.  Some are already loaded
	into lisp. Others are loaded on demand.  Still others are just
	contributed files.
 5) on-line manual - the lisp manual formatted for lineprinter or terminal
	perusal.  The lisp 'help' command refers to this manual
 6) lisp manual - the troff input form for the lisp manual.  If you can 
	run troff or nroff at your site then you can generate a lisp manual
	from the files in this directory.
 7) pearl  AI database program - this is a contributed program.  More details
	can be found in the file pearl/ReadMe.  This program will not
	be generated automatically by the Makefile in this directory.
	If disk space is short, the pearl subdirectory may be removed
	and it won't affect any other programs.

To build lisp, follow these steps:

1) Run './lispconf' to describe the system you will be building lisp for.
   Just type './lispconf' and it will describe the possible
   configurations.   Typically, when lisp is distributed it is configured
   to run under 4.1c on a vax.

   Look in franz/h/config.h.  You may want to alter some of the
    configuration parameters before you start.

2) Look at the path name defaults in the Makefiles in the various
    source directories ({franz,liszt}/{vax,68k},utils,lisplib).
    You can modify these defaults if you like.  It is suggested
    that you leave the lisp library in /usr/lib/lisp.
    Most code doesn't really depend on where the library is,
    just as long as when the system is built, the directory
    name is known.  However, some application programs may depend on the
    library being in /usr/lib/lisp.

3) If this is a distribution of lisp source (as opposed to a complete
    4.x distribution) then you will want to copy the
    lisp library files in lisplib into the lisp library (typically
    /usr/lib/lisp).  [If you don't want to use /usr/lib/lisp change
    the value of LibDir in the Makefile].  Now type
		make copylibrary
    and the library files in lisplib will be copied to the lisp
    library.  If an error message occurs, it may be that you don't
    have permissions to write in the lisp library.  If this is the
    case, fix the permissions and type 'make copylibrary' again.

4) If you have a working lisp system, then you may be able to bring the
    system up quickly.  Type
		make fast
    and the Makefile will attempt to build a new lisp, liszt, and lxref
    and place them in franz/mylisp, liszt/nliszt and liszt/lxref respectively.
    [See Note 1 below.]
    If it fails, then you may just have to start from scratch, see step 5.
    If it works, go to step 6.

5) To make the entire lisp system, interpreter and compiler, from scratch,
    type:
		make slow
    This may take three to four hours on an unloaded vax.
    See Note 1 below.

6) once the files are made, type
		make install
    and new versions of lisp, liszt and lxref (the compiler cross reference
    program) will be installed in ObjDir.

7) If you've changed where files live, then you should change the defaults
    in each of the makefiles: liszt/Makefile, franz/Makefile, doc/Makefile
    and /usr/lib/lisp/Makefile.


Note 1: Two files which are necessary yet which are not distributed 
are the assembler and linking loader.  The assembler is required by
liszt after it has compiled a file, the loader is required by the 'cfasl'
and 'ffasl' functions.  These programs are expected to be in 
/usr/lib/lisp/as and /usr/lib/lisp/nld.  The Makefile will copy
them from /bin/as and /bin/ld.  If you are running a Berkeley vax
distribution, this is ok.  If you are using non-berkeley as or ld
then you will have to get a copy of the berkeley as or ld and place
them in /usr/lib/lisp yourself.  We don't distribute them because
they require a Unix license and because we want to avoid distributing
object files.

Note 2: For 68000 systems, we can distribute source for the assembler,
by agreement with MIT, Megatest Corp and Sun Microsystems.  As an aid
to constructing the lisp system on machines with limited memory or swap
space, you may have received the assembly language output of the
compiler for the lisp library and compiler itself.  The 68k compiler
starts out running as 1.25 Megabytes and will grow larger as it retains
macros and other information about the functions it is compiling.
(This may be impossible on certain systems.)

The .s files are distributed in files of the form x68k.38.58.*.  The
source for the assembler is in a file called lispas.  In any case, you
should still say "cat * | sh", in order to create the appropriate
files.  To construct the assembler, assemble the .s files, and contruct
the lisp system quickly, say "make fromasm" instead of "make slow".


Changes:
  Look in franz/ChangeLog and liszt/ChangeLog for a blow by blow description
of bug fixes and new features.  Also the file lispnews in this directory
describes changes to lisp which affect the user.  This file is most
easily read with  'mail -f lispnews'.

The major changes are described next.

  opus 38: the reader has changed quite a bit.  It now uses symbolic
	syntax codes and it provides infix macros.  
	The lisp library files have been reorganized in order to make
	lisp bootstrapable.

Future bug fixes:
  When you find bugs in Lisp or Liszt, mail a letter to franz-bugs@berkeley
  or ucbvax!franz-bugs.   
  We will mail bug fixes to the franz-composers mailing list.  To get on 
  this mailing list, mail a letter to franz-friends-request@berkeley or
  ucbvax!franz-friends-request.

Documentation:
  The source (troff form, with -me macros) for the Franz Lisp Manual is
in the doc subdirectory.  There is a line printer printable version 
in lisplib/manual (which is most likely copied to /usr/lib/lisp/manual).
  There is also a system manual which may be of interest to people who
want to modify the lisp system or just understand how it works.  The file
is doc/franz.n.  


The meanings of the default directories and paths in the Makefiles
in this directory tree (and LibDir)

LibDir : [/usr/lib/lisp]
	directory containing the lisp library sources, some of which
	are required to build a lisp system.  Change this with caution,
	Some programs may depend on it being /usr/lib/lisp

DestObjDir : [/usr/ucb]
	place to put the lisp and liszt that we build.  Note that for
	the liszt -r flag to work, the lisp interpreter must be in
	/usr/ucb

ObjDir: Directory containing existing lisp and liszt (if they exist).
	if they don't exist, then you will do a 'make slow' and the value
	of ObjDir doesn't matter

LispDist: [/usr/src/cmd/lispdist]
	directory to build distribution in.

CcodeDir: [../franz]
	location of C coded kernel as seen from the liszt directory

CopyTo : used as the destination directory of some of the commands in
	the makefile.  it has a different meaning in each.


EndOfFile
cat >  ./lispconf  << 'EndOfFile'
#! /bin/csh 
#$Header: lispconf,v 1.17 85/05/22 08:33:07 sklower Exp $
#
# csh script to configure lisp
# use:
#	lispconf type
# where type is one of
#    vax_4_1 vax_4_1a vax_4_1c vax_eunice_vms
#    sun_4_1c sun_unisoft dual_unisoft pixel_unisoft lisa_uniplus3
#	sun_4_2 sun_4_2beta mc500_2_0
#
if ($#argv == 1) then
  set argument = $argv[1]
else  
  set argument = junk
endif

#fix makefile
sed "s%^RootDir = .*%RootDir = `pwd`%" Makefile > Make$$
mv Make$$ Makefile < /dev/null

switch ($argument)
 case vax_eunice_vms:
	mv franz/vax/{Makefile,Make.unix}
	mv franz/vax/{Make.vms,Makefile}
 case vax_4_1:
 case vax_4_1a:
 case vax_4_1c:
 case vax_4_2:
 case vax_4_3:
 case sun_4_1c: 
 case sun_4_2: 
 case sun_4_2beta: 
 case mc500_2_0:
 case sun_unisoft:
 case dual_unisoft:
 case pixel_unisoft:
 case lisa_unisys3:
	echo "/* this file created by ../../lispconf */" >! franz/h/lconf.h
	echo "#define $argv[1] 1" >>! franz/h/lconf.h
	rm -f franz/h/{aout,lispo}.h
	cp /usr/include/a.out.h franz/h/aout.h
	cp /usr/include/a.out.h franz/h/lispo.h
	breaksw
 default:
  echo "use: lispconf type"
  echo "  where type is one of "
  echo "  vax_4_1 vax_4_1a vax_4_1c vax_4_2 vax_4_3"
  echo "  vax_eunice_vms"
  echo "  sun_4_1c sun_unisoft dual_unisoft pixel_unisoft "
  echo "  sun_4_2beta lisa_unisys3 mc500_2_0"
  exit 1
endsw 

set ifusft=""
set ifsys3=""
switch ($argument)
 case vax_*:
	set VAX mach="vax"
	(echo vax ucbstd; cat Makefile) | awk -f cvt.awk > Make$$
	mv Make$$ Makefile < /dev/null
	breaksw
 case *_unisys3:
	set ifsys3="unisys3botch"
 case *_unisoft:
	set ifusft="unisoft"
 case sun_4_*: 
 case mc500_2_*:
	set M68K mach="68k"
	(echo 68k ucbstd $ifusft; cat Makefile)| awk -f cvt.awk>Make$$
	mv Make$$ Makefile < /dev/null
	breaksw
endsw 

# for the 68k version of the lisp compiler
# The type of makefile built depends of the type of 68k
#  system you have.  We assume that sun's and mc500's have virtual
#  memory and that dual/unisoft's have no vm (thus, define swapper).
# As long as we are checking to see if we are dealing with
# a 68000 unisoft machine; make some patches to the C part as well.
set ifsunII=""
if ($?M68K) then
	switch ($argument)
	 case *_unisys3:
	 case *_unisoft:
		(echo swapper unisoft;\
		    cat liszt/68k/Makefile) |awk -f cvt.awk > Make$$
		(echo unisoft $ifsys3;\
		    cat franz/68k/Makefile) |awk -f cvt.awk > franz/68k/Make$$
		rm -f franz/h/{lispo,aout}.h
		cp franz/h/duallispo.h franz/h/lispo.h
		cp franz/h/dualaout.h franz/h/aout.h
		cp franz/h/hpagsiz.h franz/h/pagsiz.h
		cp lisplib/autorun/unisoft lisplib/autorun/68k
		breaksw
	 case sun_4_2beta:
	 case sun_4_2:
		set ifsunII=sunII
	 case sun_4_1c:
		(echo sun; cat liszt/68k/Makefile) | awk -f cvt.awk > Make$$
		(echo sun $ifsunII; cat franz/68k/Makefile)\
				| awk -f cvt.awk > franz/68k/Make$$
		cp lisplib/autorun/sun4.2 lisplib/autorun/68k
		breaksw
	 case mc500_2_*:
		(echo mc500; cat liszt/68k/Makefile) | awk -f cvt.awk > Make$$
		(echo mc500; cat franz/68k/Makefile)\
				| awk -f cvt.awk > franz/68k/Make$$
		cp lisplib/autorun/mc500 lisplib/autorun/68k
		breaksw
	endsw
	rm -f liszt/68k/Makefile
	sed "s%^RootDir = .*%RootDir = `pwd`%" Make$$ > liszt/68k/Makefile
	rm -f Make$$
	rm -f franz/68k/Makefile
	mv franz/68k/Make$$ franz/68k/Makefile

	if ($ifusft/x == unisoft/x) then
		switch ($argument)
		 case sun_unisoft:
			set OFFSET=0x40000
			breaksw
		 case dual_unisoft:
			set OFFSET=0x800000
			breaksw
		 case pixel_unisoft:
		 case lisa_unisys3:
			set OFFSET=0x20000
			breaksw
		endsw
		sed "s%^OFFSET = .*%OFFSET = $OFFSET%"\
				lisplib/autorun/68k > temp$$
		mv temp$$ lisplib/autorun/68k </dev/null
	endif
endif
EndOfFile
cat >  ./lispnews  << 'EndOfFile'
From jkf Tue Apr 13 00:12:22 1982
To: /na/doe/jkf/lispnews
Subject: new features
Status: RO

 In response to requests from franz users, these enhancements have been
made:

In Lisp 38.07,  if the lisp variable 'displace-macros' is set to non-nil,
then when a macro expansion is done by the evaluator, the resulting
expansion replaces the original call.  This means that macro expansion
is only done once.  

In Liszt 8.03, the 'function' function is open coded.  If you have
	(function (lambda ....))
in your code then the lambda expression is compiled as a separate function
and the result of the function call is a 'bcd' object which points
to that compiled lambda.



From jkf Sun Apr 18 13:16:46 1982
To: local-lisp
Subject: opus 38.09
Status: RO

 The new features of this version are:
	If the load function ends up fasl'ing in a file, then load will
  do what is necessary to insure that the new functions are linked in
  correctly. Previously, if you turned on the transfer tables with
  (sstatus translink on) or (sstatus translink t) and then fasl'ed in
  functions which already existed, the old versions of the functions
  would still be used, unless you did (sstatus translink on) yourself.
  Now this is done automatically.

      tyi now accepts a second argument which is the object to return
  upon eof.  -1 is the default.

     (pp-form 'g_obj ['p_port]) should be used instead of $prpr
 for pretty printing a form.

     The storage allocator and collector has been modified to add
 two new data types: vector and vector immediate.  They are not in
 their final form so I suggest that you not try to use them. 
 However, be on the lookout for garbage collection bugs.



From jkf Wed Apr 21 07:45:54 1982
To: local-lisp
Subject: liszt 8.04
Status: RO

  the new features of liszt 8.04 are:

1) init files:
    Before liszt begins compiling, it looks for an init file to load in.
    It first searches in the current directory, and then it searches
    your home directory (getenv 'HOME).
    It looks for file names:
	.lisztrc.o  .lisztrc.l  lisztrc.o lisztrc.l
    It loads only the first one it finds.

2) interrupt handling
    If you interrupt liszt  (with ^C typically), it will remove its
    temporary file and exit.

3) preallocation of space
    It preallocates space in order to reduce the number of gc's done
    during compiling.

	
	


From jkf Wed Apr 21 13:47:50 1982
To: local-lisp
Subject: lisp opus 38.10
Status: RO

 lisp will now look for a lisprc in a way similar to liszt.

 It will first search in . and then in $HOME
 It will look for the file .lisprc or lisprc ending with .o, .l and then
just .lisprc or lisprc.

 Shortly, it will only look for files ending in .l and .o since we don't
want to encourage files with non-standard filename extensions.


 


From jkf Wed Apr 21 23:40:59 1982
To: local-lisp
Subject: lisp opus 38.11
Status: RO

 I finally got sick of showstack and baktrace and rewrote them in lisp,
rincorporating some of the features people have been requesting.
Showstack now works as follows:
	(showstack) : show all interesting forms.  Forms resulting from
		      the trace package are not printed as well as 
		      extraneous calls to eval.  In the form printed,
		      the special form <**> means 'the previous expression
		      printed'.  prinlevel and prinlength are set to 
		      reasonable values to prevent the expression from
		      getting too large
	(showstack t) : same as above but print all expressions.
	(showstack 5) : print only the first 5 expressions. of course, 5
		      is not the only possible numeric argument.
	(showstack lev 3) : set prinlevel to 3 before printing
	(showstack len 4) : set prinlength to 4 before printing
 the above arguments can be used in combination.

The default value of prinlevel is showstack-prinlevel, that of prinlength
is showstack-prinlength.  the default showstack printer is the
value of showstack-printer (default is 'print').

baktrace accepts the same arguments as showstack, but it ignores the
prinlevel and prinlength arguments.




From jkf Sat Apr 24 08:55:18 1982
To: local-lisp
Subject: lisp opus 38.12, liszt 8.05
Status: RO

  these changes and enhancements were made:

1) the function 'function' in the interpreter acts just like 'quote'
   In the compiler, 'function' will act like 'quote' unless the
   argument is a lambda expression, in which case liszt will replace
   the lambda expression with a unique symbol.  That unique symbol's
   function cell will contain a compiled version of the lambda 
   expression.   These changes will make Franz compatible with Maclisp
   type lisps, as far as the treatment of 'function'

2) Mechanisms were added to permit user written C or Fortran code to call 
   lisp code. Everything isn't quite ready yet.

3) Signal was fixed so that if you ask for a signal to be ignored, the
   operating system will be notified.  The correct way to fork a lisp
   is now:
	(cond ((fork) (signal 2 (prog1 (signal 2) (wait)))))

4) You can select the default function trace uses to print the arguments and
   results.  Just lambda bind trace-printer to the name of the function
   you want it to use.  The standard trace-printer sets prinlevel and
   prinlength to the values of trace-prinlevel and trace-prinlength before
   printing.  By default, trace-prinlevel is 4, and trace-prinlength is 5


   


From jkf Sun Apr 25 23:46:16 1982
To: local-lisp
Subject: lisp opus 38.13
Status: RO

  Functions 1+ and 1- are now part of the interpreter, rather than
being made equivalent to add1 and sub1.



From jkf Wed Apr 28 09:52:43 1982
To: local-lisp
Subject: Opus 38.14
Status: RO

  Has these new features:
	1) the message [load filename] will appear before load
	   reads in a lisp source file.  This can be disabled by
	   setting $ldprint to nil.
	2) a function 'truename' as been added.  It takes a port
	   and returns the name of the file associated with that port.
	   It returns a string if there is a file associated with
	   the port, otherwise it returns nil.



From jkf Wed Apr 28 10:36:34 1982
To: local-lisp
Subject: more on opus 38.14
Status: RO

 $ldprint is lambda bound to nil during the loading of the lisprc file.




From jkf Wed May  5 08:30:00 1982
To: local-lisp
Subject: opus 38.15
Status: RO

 a minor modification: 'makhunk' is now more efficient.


From jkf Wed May  5 20:56:40 1982
To: local-lisp
Subject: Opus 38.16
Status: RO

 A new function was added:
	(hunk-to-list 'h_hunk) 
	returns the elements of h_hunk as a list.

 Also, the error message printed when an oversized print name is encountered
has been improved.



From jkf Fri May  7 20:03:40 1982
To: local-lisp
Subject: Liszt version 8.06
Status: RO


 Local declarations are now supported.  You can say:
(defun foo (a b)
   (declare (special a))
   ... body ...)

and the special declaration for 'a' will affect the body of function
foo only.  The 'a' which is an argument to foo will also be special
in this case.    Declarations may be 
 1) at the top level, not within a function body.
 2) at the beginning of a  'lambda' body.
 3) at the beginning of a 'prog' body
 4) at the beginning of a 'do' body.

'the beginning' means either the first, second or third form in the body.
When the compiler is searching for declarations, it will not macroexpand.


 Fixnum declarations now have meaning.  If you do
	(declare (fixnum i j))
then
	(greaterp i  j)  will be converted to (>& i j)

 The declare function is now defined in the compiler.  Previously,
the only way to declare something was for the compiler to 'compile'
the declaration form.  Now, if you load or fasl in a file with
a declare statement in it, the declare statement will have the
proper effect in the compiler.


 (function (lambda () ...)), (function (nlambda () ...)) and
 (function (lexpr () ...))  are all supported.



From jkf Wed May 12 08:15:37 1982
To: local-lisp
Subject: Lisp Opus 38.17
Status: RO

 ... has a minor bug fix:  The port returned by 'fileopen' will now print
correctly.



From jkf  Tue May 25 06:18:04 1982
Date: 25-May-82 06:17:51-PDT (Tue)
From: jkf
Subject: opus 38.18
Via: ucbkim.EtherNet (V3.100 [3/27/82]); 25-May-82 06:18:04-PDT (Tue)
To: local-lisp
Status: RO

  The msg macro will now evaluate all atom arguments except the ones 
for carriage control (N B).  Thus if you used (msg foo) you should
now use (msg "foo").



From jkf Thu May 27 08:29:29 1982
To: local-lisp
Subject: liszt 8.08
Status: RO

 Fixes a bug in the code which converts generic arithmetic to fixnum only
arithmetic.   Liszt was converting from generic to fixnum operators based on
the first argument only due to a typo in the code.

 


From jkf Wed Jun  9 07:25:19 1982
To: local-lisp
Subject: lisp Opus 38.20
Status: RO

  There is now a character macro for reading hexadecimal.
  #x1f = #X1f = #X1F = 31
  #x-1f = -31
  


From jkf Thu Jun 17 15:42:54 1982
To: local-lisp
Subject: Lisp Opus 38.21
Status: RO

  Has two routines for interfacing with termcap.  These routines were
written by morris djavaher and are meant to be called by lisp programs
which have yet to be installed.




From jkf  Tue Jun 22 09:09:25 1982
Date: 22-Jun-82 09:09:13-PDT (Tue)
From: jkf
Subject: opus 38.22
Via: ucbkim.EtherNet (V3.120 [6/17/82]); 22-Jun-82 09:09:25-PDT (Tue)
To: local-lisp
Status: RO

  setq with no arguments will now return nil.
  


From jkf  Wed Jun 30 19:05:54 1982
Date: 30-Jun-82 19:05:32-PDT (Wed)
From: jkf (John Foderaro)
Subject: liszt 8.09
Via: ucbkim.EtherNet (V3.130 [6/26/82]); 30-Jun-82 19:05:54-PDT (Wed)
To: local-lisp
Status: RO

  liszt will now look in 12 places for an init file when it starts up.
It will load in the first one it comes to only.
The files it looks for are:

  { ./ , $HOME } { .lisztrc , lisztrc } { .o , .l , }

 


From jkf  Tue Sep 14 08:53:03 1982
Date: 14-Sep-82 08:52:44-PDT (Tue)
From: jkf (John Foderaro)
Subject: lisp opus 38.26
Message-Id: <8208141553.9999@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.193 [9/6/82]) id a09999;
	14-Sep-82 08:53:03-PDT (Tue)
To: local-lisp
Status: RO

  Franz used to read the symbols 4dxx 4Dxx and 4Exx as 4exx.  Now it reads
them (and other similar symbols) correctly.




From jkf  Sat Oct  2 15:15:48 1982
Date: 2-Oct-82 15:15:32-PDT (Sat)
From: jkf (John Foderaro)
Subject: lisp opus 38.27
Message-Id: <8209022215.10796@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.193 [9/6/82]) id a10796;
	2-Oct-82 15:15:48-PDT (Sat)
To: local-lisp
Status: RO

  If you set the variable top-level-print to a non nil value, then that
value will be used by the top-level to print out the result of the
evaluation.  This has effect in break loops too.
  For example, if you want the pretty printer to print out the top level
values, type  (setq top-level-print 'pp-form).


  


From jkf  Sun Oct  3 19:28:45 1982
Date: 3-Oct-82 19:28:29-PDT (Sun)
From: jkf (John Foderaro)
Subject: lisp opus 38.28
Message-Id: <8209040228.9829@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.193 [9/6/82]) id a09829;
	3-Oct-82 19:28:45-PDT (Sun)
To: local-lisp
Status: RO

 A modification has been made to the load function.
   Normally if you type (load 'x), the load function will first try to fasl
the file x.o and failing that it will try to load x.l
   If you (setq load-most-recent t),  and if x.l and x.o both exist, then
load will fasl or load the most recently modified file.
   The load-most-recent flag only has an effect if you type the filename
without a trailing .l or .o.




From jkf  Tue Oct  5 21:01:55 1982
Date: 5-Oct-82 21:01:33-PDT (Tue)
From: jkf (John Foderaro)
Subject: liszt 8.12, lisp 38.29
Message-Id: <8209060401.6358@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.193 [9/6/82]) id a06358;
	5-Oct-82 21:01:55-PDT (Tue)
To: local-lisp
Status: RO

  Liszt will now check that you are passing the correct number of arguments
to functions.   As a result, some files which have compiled without
complaint in the past may compile now with warnings or errors.  In this
note, I'll explain what the compiler knows, what it looks for in your
program, and how you can help the compiler understand your program.

  For each function, liszt either knows nothing about the the number of
arguments to a function, or it knows the minimum number of arguments, or the
maximum number of arguments, or both the minimum and maximum number of
arguments.   This information comes about in one of three ways:
  1) it is known when liszt starts (by virtue of a value stored under the
     fcn-info indicator on a function's property list)
  2) it is declared by the user, either via (declare (*arginfo ...))
     or (declare (*args ...)) [see below]
  3) it is determined when a (lambda) function is compiled.
     When a lambda is compiled, the compiler can easily figure out the
       minimum and maximum number of arguments.
     When an nlambda or lexpr function is compiled, the compiler doesn't
     make a guess as to how many arguments are expected.  The user should
     use the (declare (*args ...)) form to tell the compiler how many
     arguments are expected.
     For lexpr's generated via 'defun' using &optional and &rest keywords,
     the correct declaration is generated automatically.
Once liszt determines the number of arguments to a function, it uses that
information to check that the function is called with the correct number of
arguments.  It does not check calls to the function that occured before it
determined the correct number of arguments.  [This backward checking will
be added sometime in the future.]

  If liszt finds that a function is called with the wrong number of
arguments, it prints an informative message.  That message is a error if the
function being called is one which is open coded by the compiler. The
message is a warning otherwise.  The reason for the distinction is that
you are free to redefine functions not open coded by the compiler. If the
number of arguments is not correct, it may just be that the compiler's
database and your code are refering to two different functions.
If you redefine system functions, you should use the
(declare (*arginfo ...)) form to let the compiler know about the number
of arguments expected by your version of the functions.

  You can declare the number of arguments to functions using this form

(declare (*arginfo (fcnname1 min1 max1) (fcnname2 min2 max2) ...))
  where each min or max is either a fixnum or nil (meaning "I don't know")
  
for example, here are some `correct' declarations:

(declare (*arginfo (read 0 2) (cons 2 2) (boole 3 nil) (append nil nil)))
  
 explanation:
   (read 0 2) means that the function read expects between 0 and 2
   	arguments (inclusive).
   (cons 2 2) means that cons expects 2 arguments.
   (boole 3 nil) means that boole expects at least 3 arguments.
   (append nil nil) means that append expects any number of arguments,
      this is equivalent to (append 0 nil).
      

The *arginfo declaration is usually made at the top level of a file.

To declare the argument characteristics of the current function being
compiled use the '*args' declaration. It looks somewhat like the
*arginfo declaration.

It is best explained with examples

(def read
   (lexpr (n)
       (declare (*args 0 2))
       ... code for read
       ))

(def process
  (nlambda (x)
      (declare (*args 1 3))
      ... code for process
      ))

Note: the *args declaration is not needed for lambda's.



  If you get an error or warning which you believe is incorrect, it is
probably due to an incorrect database entry.  Please let me know and I will
fix it immediately.   I expect that there will be quite a few of these
errors because much of the database was built by hand.


     



From jkf  Fri Oct  8 12:55:45 1982
Date: 8-Oct-82 12:55:31-PDT (Fri)
From: jkf (John Foderaro)
Subject: lisp 38.30, liszt 8.13
Message-Id: <8209081955.4140@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.193 [9/6/82]) id a04140;
	8-Oct-82 12:55:45-PDT (Fri)
To: local-lisp
Status: RO

There are now three new functions for dealing with processes:
  *process
  *process-send
  *process-receive

 These functions are designed to replace the 'process' function, which, due
to its nlambda'ness, was difficult to use.  All of the above functions
are lambda's or lexpr's.

  See chapter 6 of the manual (its on-line) for the details of these
functions.  This is a quick summary:

  (*process-send 'st_command)
  tells the shell to run the command st_command concurrently, and returns
  a write-only port.  Characters written to this port will appear at
  the standard input of st_command.
  example:
     (setq p (*process-send "mail jkf"))
     (print 'HiThere p)
     (close p)

     
  (*process-receive 'st_command)
  tells the shell to run st_command concurrently, and returns a
  read-only port.  Characters written to the standard output by
  st_command will be available by reading from the given port.
  Characters written on the standard error by st_command will
  appear on lisp's the standard error (the terminal most likely).
  example:
    ; to see if foo is logged in:
    (setq p (*process-receive "u"))
    (do ((user (read p '**eof**) (read p '**eof**)))
        ((eq '**eof** user) (print 'Not-Logged-In))
	(cond ((eq 'foo user) (print 'Is-Logged-In))))
    (close p)


  (*process 'st_command ['g_readp ['g_writep]])
  this is the general function which process, *process-send and
  *process-receive call.  If called with one argument it
  starts the new process and waits for it to end, e.g:
  (*process (concat "vi " filename))
  In this case *process return the exit code of the process.

  The g_readp and g_writep arguments, if given, tell *process to
  run the process concurrently.  If g_read is non nil then
  *process will return a port just like *process-receive.
  If g_writep is non-nil, then *process will set up a pipe like
  *process-send.
  *process will return a list of the form
    (readport writeport process-id)
    where readport and writeport will only be a port if g_readp
    or g_writep are non nil.


 A little know fact about processes is that  a process, once started,
cannot die and disappear until its parent asks about its status.
Take the mail example given above:
     (setq p (*process-send "mail jkf"))
     (print 'HiThere p)
     (close p)
after the mail process finishes it work, it will attempt to die, returning
an integer called the 'exit status'.  However until the lisp program
asks about its status the mail process will remain in existence
in a Zombie state, somewhere between life and death. ps will show this:

  PID TT STAT  TIME COMMAND
 3876 p0 Z     0:01 <exiting>

A user is only allowed a small number of processes, so if you continue
to generate processes and leave them around as Zombies, you will eventually
run out of processes.  The way to let the Zombie die is to call
the wait function, e.g.
    -> (wait)
    (3876 . 0)
    -> 
this says that process 3876 died with exit status 0.

Also, when you exit lisp the shell will clean up the Zombies.

If you start a  process with (*process "vi foo") then lisp will wait
for it to complete before continuing, so you don't have to worry about
Zombies.  You only have to worry if you run a process concurrently,
such as when you use *process-send or *process-receive.

      
       
      



From jkf  Tue Oct 12 10:44:22 1982
Date: 12-Oct-82 10:43:52-PDT (Tue)
From: jkf (John Foderaro)
Subject: lisp opus 38.31
Message-Id: <8209121744.29800@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.220 [10/11/82])
	id A29800; 12-Oct-82 10:44:22-PDT (Tue)
To: local-lisp
Status: RO

  new function:  (time-string ['x_time])
    if given no arguments, it returns the current time as a string.

    if given an argument, x_time, then it converts that argument to
      a time string and returns that string.
      The argument should represent the number of seconds since
      Jan 1, 1970 (GMT).

  note that this makes (status ctime) obsolete.
 


From jkf  Tue Oct 12 14:35:26 1982
Date: 12-Oct-82 14:34:10-PDT (Tue)
From: jkf (John Foderaro)
Subject: also in opus 38.31
Message-Id: <8209122135.5086@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.220 [10/11/82])
	id A05086; 12-Oct-82 14:35:26-PDT (Tue)
To: local-lisp
Status: RO

  If top-level-read is set to a non nil value, then the lisp
top level will funcall it to read a form for evaluation.
It will be funcalled with two arguments, a port and an eof marker.
top-level-read will be used in break levels too.
  Be very careful when setting top-level-read because if you set it
to an illegal value, there is no way to correct it.





From jkf  Tue Oct 19 18:54:18 1982
Date: 19-Oct-82 18:54:02-PDT (Tue)
From: jkf (John Foderaro)
Subject: lisp tags
Message-Id: <8209200154.195@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A00195; 19-Oct-82 18:54:18-PDT (Tue)
To: franz-friends
Status: RO

  We also use vi style tags so emacs users and vi users can share the same
tags file.  Rather than modify ctags, we use this shell script:

#!/bin/csh 
# make a tags file for lisp source files.
# use:
#	lisptags foo.l bar.l baz.l ... bof.l
# generate the file 'tags'
#
awk -f /usr/local/lib/ltags $* | sort > tags


where the file /usr/local/lib/ltags is

/^\(DEF/	{ print $2 "	" FILENAME "	?^" $0 "$?" }
/^\(def/	{ print $2 "	" FILENAME "	?^" $0 "$?" }



From jkf  Tue Oct 19 22:50:40 1982
Date: 19-Oct-82 22:50:29-PDT (Tue)
From: jkf (John Foderaro)
Subject: Lisp Opus 38.32, Liszt 8.14
Message-Id: <8209200550.3968@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A03968; 19-Oct-82 22:50:40-PDT (Tue)
To: local-lisp
Status: RO


Topic 1:
    liszt can now autoload macros.   If liszt encounters a symbol without
    a function definition but with a macro-autoload indicator on the
    property list, then the value of the indicator is a file to load which
    should define the macro.

    The interpreter's undefined function handler will also look for
    macro-autoload properties, thus you needn't give a symbol both an
    autoload and a macro-autoload property.

    The default lisp contains macro-autoload properties for the macros
    defstruct, loop and defflavor.

Topic 2:
    It is now possible to define 'compiler only macros' or cmacros.
    A cmacro acts like a normal macro, but will only be used by the
    compiler.   A cmacro is stored on the property list of a
    symbol under the indicator 'cmacro'.    Thus a function can
    have a normal definition and a cmacro definition.
    The macro 'defcmacro' has a syntax identical to 'defmacro' and
    creates cmacros instead of macros.
    For an example of the use of cmacros, see the definitions
    of nthcdr and nth in /usr/lib/lisp/common2.l

 Topic 3:
    If the form (foo ...) is macro expanded and the result also begins
    with the symbol foo, then liszt will stop macro expanding (previously
    it got into an infinite loop).
    
 Topic 4:
    The function nth has been added to Franz.
    (nth 'x_index 'l_list)
    returns the nth element of l_list, where the car of the list
    is accessed with (nth 0 'l_list)

    The macros (push 'g_value 'g_stack), and
    	       (pop 'g_stack ['g_into])
    have been added to franz.
    typical uses
      (setq foo nil)
      (push 'xxx foo)
      (push 123 foo)
      now foo = (123 xxx)
      (pop foo) returns 123
      now foo = (xxx)
      (pop foo yyy) returns xxx and sets yyy to xxx

      
 Topic 5:
    The version of Flavors written at Mit for Franz have been transported
    here.  Flavors is a system for doing object oriented programming in
    lisp.  The documentation for flavors in the Lisp Machine manual
    from Mit.  Since Lisp Machine manuals are rather scarce around here,
    perhaps we can find someone to make copies of the flavor chapter for
    those interested in it.  There is a description of the unique
    features of the Franz Flavors in /usr/lib/lisp/flavors.usage.
    As mentioned above, the flavors code will be autoloaded
    when you call 'defflavor' for the first time.
    Our local flavors expert is Eric Cooper (r.ecc).
 
    
    
    



From jkf  Fri Oct 22 15:46:51 1982
Date: 22-Oct-82 15:46:32-PDT (Fri)
From: jkf (John Foderaro)
Subject: lisp opus 38.34
Message-Id: <8209222246.5610@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A05610; 22-Oct-82 15:46:51-PDT (Fri)
To: local-lisp
Status: RO


  Franz lisp now has a form of closure called an fclosure.  A fclosure is a
compromise between a funarg and the type of functional object that we
currently have in Franz. In this short note, I'll explain through examples
what fclosures are and where you might use them, and finally describe the new
functions.  The fclosure system was designed to be compatible with the Lisp
Machine closures, so you may want to look at a Lisp Machine manual for more
information.  fclosure are related to closures in this way:
   (fclosure '(a b) 'foo) <==> (let ((a a) (b b)) (closure '(a b) 'foo))

A example of the use of fclosures:

->(setq counter 0)
0
->(setq x (fclosure '(counter) '(lambda (val) (setq counter (+ val counter)))))
fclosure[1]

The function 'fclosure' creates a new type of object called a fclosure.
A fclosure object contains a functional object, and a set of symbols and
values for the symbols.  In the above example, the fclosure functional
object is (lambda (val) (setq counter (+ val counter)))
and the set of symbols and values just contains the symbol 'counter' and
zero, the value of counter when the fclosure was created.

When  a fclosure is funcall'ed:
  1) the lisp system lambda binds the symbols in the fclosure to their
     values in the fclosure.
  2) it continues the funcall on the functional object of the fclosure
  3) finally it un-lambda binds the symbols in the fclosure and at the
     same time stores the current values of the symbols in the fclosure.

To see what that means, let us continue the example:
-> (funcall x 32)
32
-> (funcall x 21)
53

Notice that the fclosure is saving the value of the symbol 'counter'.
Each time a fclosure is created, new space is allocated for saving
the values of the symbols.
If we executed the same fclosure function:
->(setq y (fclosure '(counter) '(lambda (val) (setq counter (+ val counter)))))
fclosure[1]

We now have two independent counters:
-> (funcall y 2)
2
-> (funcall y 12)
14
-> (funcall x 3)
56

To summarize:

(fclosure 'l_vars 'g_funcobj)
 l_vars is a list of symbols (not containing nil)
 g_funcobj is lambda expression or a symbol or another fclosure

  examples: (fclosure '(foo bar baz) 'plus)
            (fclosure '(a b) #'(lambda (x) (plus x a))) notice the #'
	   		which will make the compiler compile the
			lambda expression.


There are time when you want to share variables between fclosures.
This can be done if the fclosures are created at the time times using
fclosure-list:

(fclosure-list 'l_vars1 'g_funcobj1 ['l_vars2 'g_funcobj2 ... ...])
  This creates a list of closures such that if a symbol appears in
  l_varsN and l_varsM then its value will be shared between the
  closures associated with g_funcobjN and g_funcobjM.

  example: -> (setq x (fclosure-list '(a) '(lambda (y) (setq a y))
			             '(c a) '(lambda () (setq c a))))
	    (fclosure[4] fclosure[7])
	   -> (funcall (car x) 123)   ; set the value of a in the 1st fclosure
	   123
	   -> (funcall (cadr x))     ; read the same value in the 2nd fclosure
	   123


Other fclosure functions:

(fclosure-alist 'c_fclosure)
  returns an assoc list giving the symbols and values in the fclosure

(fclosurep 'g_obj)
  returns t iff g_obj is a fclosure

(fclosure-function 'c_fclosure)
  returns the functional object of the fclosure



Note: If a throw (or error) occurs during the evaluation of a fclosure,
 which passes control out of the fclosure, then current values of the
 symbols will not be stored.   This may be a bug.  We could set up
 an unwind-protect, but it would then take longer to funcall
 a fclosure.  If you think an unwind protect is important, let me know.

Note 2: you can also 'apply' a fclosure.



  


From jkf  Sat Oct 23 08:58:07 1982
Date: 23-Oct-82 08:57:53-PDT (Sat)
From: jkf (John Foderaro)
Subject: more on closures
Message-Id: <8209231558.21572@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A21572; 23-Oct-82 08:58:07-PDT (Sat)
To: local-lisp
Status: RO

  I sent the maryland people the flavors.usage file from mit so that they
could compare their implementation with mit's.   What follows is their
analysis.   Some of the differences between the two versions is due to
different schemes for getting around the fact that franz didn't have a form
of closure.   RZ has indicated that now that franz has fclosures, it may be
possible to use more of the 'official' lisp machine flavor code.  fclosures
will probably affect the maryland implementation too:
Date:     22 Oct 82 15:39:18 EDT  (Fri)
From:     Liz Allen <liz.umcp-cs@UDel-Relay>
Subject:  flavors
To:       jkf at Ucb-C70
Via:  UMCP-CS; 23 Oct 82 9:09-EDT

Wow, implementing closure in one day is amazing.  We had thought
about writing some kind of closure...  We've been discussing how
having closures would affect our code.  It might make it easier to
read and modify, but it might be less efficient.  Can you tell us
how your implementation works and what it looks like to a user?

About the MIT implementation.  Ours is probably better in a couple
of respects but probably loses a couple of places, too.  Pros:

	1.  With ours, there is no need to discard instances when
	redefining a flavor.  The only time this would be necessary
	is if the instance variables change which rarely happens
	since methods change much more often than the instance
	variables.  Without a structure editor, you tend to reload the
	file containing flavors in order to change a method.

	2.  We can compile files with flavors (he didn't say if you
	can compile MIT's Franz flavors) and when they are compiled
	they run *fast*.  Most of the overhead occurs at combine
	time and compiled flavors shouldn't have to be recombined.

	3.  We use hunks to store instance variables (actually, an
	instance is a hunk whose cxr 0 is the name of the flavor and
	whose cxr n (> 0) are the values of instance variables).  We
	pay a price at combine time since instance variable references
	in method code are replaced with cxr and rplacx calls (but MIT
	pays the same price in putting hash calls in the methods), but
	we win over MIT since the cxr calls are much faster than the
	hash table calls.  We do have to have "ghost" methods which
	are copies of methods containing different cxr calls when the
	referenced variables of a method don't align in flavors
	which inherit the method.  This, however, happens only
	rarely.

	4.  We handle getting and setting instance variables better
	than the MIT implementation -- we don't need to send a message
	and the syntax is much better.  We recently added the
	functions << and >> which get and set instance variables, eg:

		(<< foo 'instance-var)
	and
		(>> foo 'instance-var 'value)

	where foo is a flavor instance.

	5.  Our describe function has a hook which (if the variable
	*debugging-flavors* is set to non-nil) allows the user to
	follow pointers to any instances referenced in the describe.
	This is done by assigning to a variable (made from its unique
	id) the value of the instance.

Cons:

	1.  They implement more things from Lisp Machine flavors
	(like wrappers/whoppers, init-keywords), but we really haven't
	found the need for them.  We implement less closely to LM
	flavors, but in a way that's better suited to Franz Lisp.

	2.  We didn't implement the method table as a hash table, but
	there's no reason why we couldn't.

	3.  Things we don't have, but could easily implement include:
	describe-method, defun-method/declare-flavor-instance-variables,
	and storing flavor information in hunks instead of on the
	property lists.

	4.  We don't handle method types like :and and :or.  We just
	have primary/untyped methods and :before and :after daemons.

We have people reading our documentation.  After we get some feedback
from them, we'll send the tape and docs to you.  That should be early
next week.

				-Liz Allen and Randy Trigg







From jkf  Mon Oct 25 12:56:59 1982
Date: 25-Oct-82 12:55:44-PDT (Mon)
From: jkf (John Foderaro)
Subject: lisp Opus 38.35, liszt 8.15
Message-Id: <8209251956.17542@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A17542; 25-Oct-82 12:56:59-PDT (Mon)
To: local-lisp
Status: RO


New features:
 1) tilde-expansion:  franz will now expand filenames which begin with ~
	just like csh does.  It will only do the expansion if
	the symbol tilde-expansion has a non-nil value.  The default
	value for tilde-expansion is t.
	These functions do tilde expansion: If I've left any out, let
	me know:
	 load, fasl, infile, outfile, fileopen, probef, cfasl, ffasl, chdir
	 sys:access, sys:unlink [these are new functions, see below]

 2) liszt will remove its temporary file if given a SIGTERM signal
    (SIGTERM is sent by default when you give the kill command from the shell)

 3) load will now print a helpful message if an read error occurs when it
    is reading a file.
    
 4) new functions:

     (lexpr-funcall 'function 'arg1 ... 'argn)
        This is a cross between funcall and apply.
	The last argument, argn, must be a list (possibly empty).
	The element of list argn are stacked and then the function is
	funcalled.
	For example:
	(lexpr-funcall 'list 'a 'b 'c '(d e f))
	is the same as
	(funcall 'list 'a 'b 'c 'd 'e 'f)
	
	Also
	(lexpr-funcall 'list 'a 'b 'c nil)
	is the same as
	(funcall 'list 'a 'b 'c)
 	
     (tilde-expand 'st_filename)
     returns: symbol whose pname is the filename, with a leading tilde
     	     expanded.  if st_filename doesn't begin with a tilde, it
	     just returns st_filename

     (username-to-dir 'st_name)
     returns: the home directory of the given user, if that user exists.
     	      Saves old information so doesn't have to keep searching
	      the passwd file.

     Some low level system functions.  These are listed here for completeness.
     The perform a function from the unix library (see the unix manual
      for details).
     (sys:getpwnam 'st_username)
       return passwd file info.
     (sys:access 'st_file 'x_mode)
     (sys:unlink 'st_file)


Bug fixes:
  1) patom will handle prinlevel and prinlength correctly.
  2) it is now safe for an interpreted function to redefine itself.
  3) the information return by 'evalframe' about a funcall'ed function
     is now correct.

  
  



From jkf  Mon Oct 25 14:57:00 1982
Date: 25-Oct-82 14:56:25-PDT (Mon)
From: jkf (John Foderaro)
Subject: 'if' macro: request for comments
Message-Id: <8209252157.21567@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A21567; 25-Oct-82 14:57:00-PDT (Mon)
To: local-lisp
Status: RO

  Would anyone object if we added a macro called 'if' to the default franz
system?   'if' is a common name and I want to make sure that it doesn't
break any existing code before I add it.

Some background:
 At mit the 'if' macro is used all over the place.
 Its form is
 	(if <predicate> <then-expr> [ <else-expr>])
	
 I've always felt that macros should make the code more readable and
 that the 'if' macro makes code more obscure because it isn't easy
 to tell in complicated 'if' expressions where the <then-expr>
 and <else-expr>'s begin.  Also, there is no provision for
 an 'elseif' expression.

 I wrote a macro called 'If' which uses keywords to separate clauses.
 (If <pred> 
    then <then-expr> 
  [elseif <pred> then <then-expr>]* 
  [else <else-expr>])

 These two macros are not incompatible.  one macro could do the job
 of both.  There is an ambigous case:
	(if p then x) could be (cond (p then) (t x))
			or (cond (p x))
 but it isn't likely that 'if' macro users would write something like
 that.

Thus I propose that we add a macro, if, which act's like 'If' if
its second arg is 'then' or like 'if' it the second arg is not 'then'
and there are two or three arguments.  Other cases would cause
an error.


	


From jkf  Mon Oct 25 22:37:24 1982
Date: 25-Oct-82 22:37:09-PDT (Mon)
From: jkf (John Foderaro)
Subject: opus 38.36
Message-Id: <8209260537.1666@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A01666; 25-Oct-82 22:37:24-PDT (Mon)
To: local-lisp
Status: RO

  I've added the 'if' macro to franz.  If you have any objections, it is still
not too late to voice them.
  I've also defined 'If' to be the same as 'if'.

  As I mentioned in my earlier request for comments, the 'if' macro is a
cross between the mit version and a locally written version using keywords.
The following documentation describes the various forms.
As you know, you can test out the 'if' macro by using apply. for example:

=> (apply 'if '(if a then b c  elseif d thenret else e))
(cond (a b c) (d) (t e))


;
;  This macro is compatible with both the crufty mit-version and
; the keyword version at ucb.
;
;  simple summary:
;   non-keyword use:
;	(if a b) ==> (cond (a b))
;	(if a b c d e ...) ==> (cond (a b) (t c d e ...))
;   with keywords:
;	(if a then b) ==> (cond (a b))
;	(if a thenret) ==> (cond (a))
;	(if a then b c d e) ==> (cond (a b c d e))
;	(if a then b c  else d) ==> (cond (a b c) (t d))
;	(if a then b c  elseif d  thenret  else g)
;		==> (cond (a b c) (d) (t g))
;
;   
;
;
; In the syntax description below,
;    optional parts are surrounded by [ and ],
;    + means one or more instances.
;    | means 'or'
;    <expr> is an lisp expression which isn't a keyword
;       The keywords are:  then, thenret, else, elseif.
;    <pred> is also a lisp expression which isn't a keyword.
; 
; <if-stmt> ::=  <simple-if-stmt>
; 	       | <keyword-if-stmt>
; 
; <simple-if-stmt> ::=  (if <pred> <expr>)
; 		      | (if <pred> <expr> <expr>)
; 
; <keyword-if-stmt> ::= (if <pred> <then-clause> [ <else-clause> ] )
; 
; <then-clause> ::=  then <expr>+
; 		   | thenret
; 
; <else-clause> ::=  else <expr>+
; 		   | elseif <pred> <then-clause> [ <else-clause> ]



  


From jkf  Tue Oct 26 09:20:25 1982
Date: 26-Oct-82 09:20:04-PDT (Tue)
From: jkf (John Foderaro)
Subject: no more jkfmacs
Message-Id: <8209261620.11552@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A11552; 26-Oct-82 09:20:25-PDT (Tue)
To: local-lisp
Status: RO


  Since Franz now has the push, pop, if and msg macros, there is no
reason for jkfmacs to exist.  I've removed the code in jkfmacs and
replaced it with a warning message which will be printed if you load it.
  If you used the jkfmacs version of 'push' you will have to go through
your code and switch the order of arguments.  The Franz version is
	(push value stack)
Also, the unpush macro, defined in jkfmacs, no longer exists: just use
pop with one argument.



From jkf  Wed Oct 27 20:35:07 1982
Date: 27-Oct-82 20:34:25-PDT (Wed)
From: jkf (John Foderaro)
Subject: liszt 8.16
Message-Id: <8209280335.27561@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A27561; 27-Oct-82 20:35:07-PDT (Wed)
To: local-lisp
Status: RO

  Back on May 6, a modification to liszt was made which turned 'declare'
into a user callable function which provided information to the compiler.
The purpose of the change was to permit one to 'load' a file containing
declarations, instead of 'include'ing it.  It turns out that this was a bad
idea since if the compiler were to evaluate an interpreted function with
local declarations, it would assume that those local declarations were
describing the current file being compiled.
   Thus declare has it old meaning: it is a no-op unless the compiler is
compiling the form.  If one really wants to actively declare something,
we've added the function 'liszt-declare', which looks just like declare
but can be evaluated within the compiler.

  If you are confused by all this, don't worry.  There is very little chance
that it will affect you.



From jkf  Fri Oct 29 09:34:11 1982
Date: 29-Oct-82 09:33:59-PDT (Fri)
From: jkf (John Foderaro)
Subject: cmacros
Message-Id: <8209291634.8411@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A08411; 29-Oct-82 09:34:11-PDT (Fri)
To: local-lisp
Status: RO

  A week ago, Joe Faletti mentioned that one problem with cmacros is that if
you redefine a function, the cmacro property stays around and thus the
redefinition of the function isn't communicate to the compiler.
  He suggested that whenever a function is defined (via 'def' or when fasl'ed
in) any cmacro properties should be remprop'ed.   I've been trying to think
of an alternative to this, but I can't think of one.  Unless someone
has a better idea, I'll implement his suggestion.
  This means that if you want to define the function 'foo' and a cmacro for
'foo', the cmacro definition must appear later in the file than 'foo's
definition.




From jkf  Fri Oct 29 10:11:36 1982
Date: 29-Oct-82 10:10:54-PDT (Fri)
From: jkf (John Foderaro)
Subject: LetS: An Expressional Loop Notation
Message-Id: <8209291711.9176@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A09176; 29-Oct-82 10:11:36-PDT (Fri)
To: local-lisp
Status: RO

  I've got a copy of a paper by Richard Waters (at mit) describing a system
for writing loops in lisp (and other languages).  Basically you describe the
loop in functional programming terms (similar to Backus's FP, or apl) and
the LetS package converts it into an iterative form for efficient execution
in lisp.
  We don't have the LetS code here to play with, and we probably won't be
able to get it for a while since our arpanet connection is hopelessly
clogged for anything but tiny messages.   However you might be interested in
stopping by my office and looking at the paper.




From jkf  Fri Oct 29 12:06:47 1982
Date: 29-Oct-82 12:06:08-PDT (Fri)
From: jkf (John Foderaro)
Subject: Re:  cmacros
Message-Id: <8209291906.12141@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A12141; 29-Oct-82 12:06:47-PDT (Fri)
To: baden, local-lisp
In-Reply-To: Your message of 29 Oct 1982 1159-PDT (Friday)
Status: RO

  I could make it a 'Note'.  I would prefer not to make it a warning because
such redefinition is guaranteed to occur when the compiler compiles itself
and the lisp code part of the lisp system.



From fateman Sat Oct 30 09:17:49 1982
To: franz-friends
Subject: fugue # 2
Status: RO

                        FUGUE Notes

               An occasional publication of the
    Franz Lisp User Group under Unix and Eunice (FUGUE)

                  Number 2 (October, 1982)
                edited by Richard J. Fateman
                  University of California
                     Berkeley CA 94720
                            USA
                      fateman@berkeley

1.  Welcome!

     It seems  about time to publish  the  second  of  these
newsletters,  since  we  have  accumulated  a  number of new
items.  We would also like to relay to others such  informa-
tion as has been forwarded to us. The reports of projects at
Berkeley (and elsewhere) may strike sympathetic chords  with
other research.

2.  New programs

2.1.  OPS-5

     OPS-5 is a "production system" written by Charles Forgy
of  CMU.   It  appears to work just fine in Franz, and is in
wide use.  Interested persons may obtain copies of  documen-
tation and the program from Charles.Forgy@CMU-10A. ( Charles
Forgy, Computer Science Department, Carnegie-Mellon  Univer-
sity, Pittsburgh, PA  15213)

It is their policy to send it to anyone who wants it free of
charge.

2.2.  GLISP

     GLISP is a system which provides interesting linguistic
features for generic operations and data abstraction.  Writ-
ten by Gordon Novak at Stanford University,  it  was  origi-
nally  developed for Interlisp, but has been ported to other
lisps, including Franz.

2.3.  Flavors

     There are now two distinct implementations,  apparently
with  identical  functionally,  of "flavors" as appearing in
the MIT Lisp Machine software.  One is described in TR-1174,
____________________
9   UNIX, Eunice, Franz Lisp, may be trademarks of Bell Labs,
SRI Int'l, and Univ. of Calif.



9










"Franz Flavors" by Richard J. Wood (Dept of C.S.,  Univ.  of
Maryland,  College  Pk, MD 20742).  The other was written by
Juan R. Loaiza of MIT, Laboratory for Computer Science.   We
have  a  copy  of  the  latter  on-line  here, and expect to
receive a copy of the Maryland one,  shortly.   Eric  Cooper
here at Berkeley is in charge of the flavors situation.

     There is an implementation of closures, mostly compati-
ble  with  the Lisp Machine specification, announced by John
Foderaro for Opus 38.33. The incompatibility is a result  of
what  we  perceive to be a high performance penalty for eso-
terica.

2.4.  Database Interfaces

     Jim Larus at UCB has cooked up interfaces to  both  the
INGRES  relational  database  system,  and the simpler TROLL
database system.  These will be described in his forthcoming
MS report, along with the next item.

2.5.  Cursor-control and Menus

     Larus has provided an implementation of screen  manage-
ment which uses the UNIX "curses" package for primitive win-
dow  management.   A  menu-based  interface  has  also  been
developed as part of this.

2.6.  Vaxima and Algebraic Manipulation

     A new version of vaxima, the VAX version of the MACSYMA
algebraic  manipulation system, was released in July by UCB,
incorporating some bug fixes, improved programs, and a large
number  of  user-contributed subroutine libraries.  This was
made available to test-site licensees.   Unfortunately,  MIT
has  suspended  new  test-site  licensing since about April,
1982.  We hope that MIT will be liberalizing  its  distribu-
tion policy to non-commercial sites.

     See the note below about MACSYMA being sold.

     As a counterpoint to this, UC Berkeley has  received  a
substantial grant from the System Development Foundation for
work on Mathematical Representation and Manipulation,  which
should  result in some more advanced systems for application
of  computers  to  symbolic  mathematics.   Recruiting   for
researchers,  staff,  and  students  is  underway  now,  and
interested persons should contact Richard Fateman.

2.7.  VLSI Design Rule Checker

     Lyra, written in Lisp by Michael Arnold, is a retarget-
able,  hierarchical,  design rule checker for VLSI circuits.
Lyra features a rule  compiler  (also  written  in  Lisp  of













course!)  which translates symbolic design rule descriptions
to lisp code for checking the rules.  Lyra was used for  the
RISC  project.  It  is  currently  being used extensively at
Berkeley, and will be included in the  Fall-82  distribution
of  of the Berkeley CAD tools.  For more information contact
Michael Arnold or John Ousterhout at Berkeley.

2.8.  Generic Arithmetic

     As a proposed extension to  Franz  arithmetic,  Richard
Fateman,  Keith  Sklower  and Scott Morrison, have written a
simple-minded  generic  arithmetic  package  which  includes
modules which can be loaded to support exact rational arith-
metic, software-simulated IEEE  extended  arithmetic,  arbi-
trary  precision floating point, complex, interval, and mul-
tivariate polynomial. Combinations of some of these are sup-
ported,  although  the  package is as yet incomplete in some
areas.  The IEEE arithmetic  simulation  is  written  in  C.
These  packages  are  probably  not in good enough shape for
casual use by others.


3.  New features

     Various performance enhancements  and  bug  fixes  have
been  incorporated  in  versions of Franz (now on Opus 38.33
and the compiler, Liszt 8.14) These are mentioned  in  brief
here;  more  details  accompany  updates  of  the system and
manual included in the forthcoming Berkeley 4.2BSD UNIX dis-
tribution.

3.1.  Franz

     We added a switch to cause the evaluator to save  macro
expansions so they need only be expanded once.

     We added vector and vector-immediate data types.

     We rewrote showstack and backtrace so they  are  easier
to use.

     We made the lisp to  foreign  function  interface  more
secure.  The system now allows foreign function to call lisp
functions.

     We added closures and support  flavors,  features  from
the Lisp Machine.

3.2.  Liszt

     Liszt will check the  number  of  arguments  to  system
functions and user defined functions.
9

9










     Liszt supports local declarations.

     Liszt will  automatically  compile  lambda  expressions
headed by the function `function'.

     Liszt supports compiler-only macros and  will  autoload
macros if necessary.

4.  MC68000

     Keith Sklower and Kevin Layer have been working on  the
MC68000  version  of  Franz  under the UNIX operating system
(using a DUAL System 83). While the current configuration is
a  swapping  system, the Lisp should be able to use the full
address space of the CPU. We expect to have this system run-
ning  on the UNIX 4.2 BSD SUN software, too. The base system
on the DUAL, including  the  interpreter,  reader,  bignums,
fasl, works; the compiler is being perfected.


5.  Other Lisps

     We now have, in-house tried 4  (other)  VAX  UNIX  lisp
systems:  YLISP,  Interlisp,  PSL,  and VLISP.  We know that
Interlisp can run also on  VMS  using  the  Eunice  package.
Interested parties can contact David Dyer at USC-ISI.  There
is also a version of lisp which runs  on  VMS  only,  namely
NIL,  from  MIT, which appears to be undergoing limited dis-
tribution.  Two other lisps under development under UNIX are
Yale's  answer to NIL, namely "T", and Common Lisp, from CMU
and friends.

     Counting Franz, that makes  7 lisp systems for the  VAX
computer line. Not counting variants on 2 operating systems.
A Paen to standardization.

     Dick Gabriel states some  useful  principles  for  com-
parisons  in  the conference record of the 1982 ACM Lisp and
Functional Programming Conference, which was held in August.
We  understand  he  now has a collection of some 18 programs
which he is continuing to time on various systems.

6.  Work in Progress

6.1.  BITGRAPH SUN AED-512

     Greg Foster at UCB is working on  raster-graphics  sup-
port in Franz for the 800 by 1000 b/w raster displays of the
BBN Bitgraph and/or the SUN Workstation,  and  possibly  the
color  512 by 512 AED system.  We are probably going to han-
dle mice and Bitpad (stylus) input for pointing.  There  are
lots  of  projects  we hear about with similar systems, e.g.
just recently from the University of  Maryland,  using  UNIX













and multiplexed files for window management of a 68000-based
home-grown workstation.

6.2.  RISC-LISP

     Yes, Reduced Instruction Set Computer  fans,  who  else
but  UCB  would  be  so bold... Carl Ponder is examining the
issues involved in constructing a fast lisp interpreter  and
compiler  for  the  RISC architecture.  You see, we have all
these chips...


7.  Work Contemplated

7.1.  Fast Number Compiler

     Undergraduate Jeff Cohen at  Berkeley  is  starting  to
look  at  this.   There are several industrial concerns that
have expressed interest in using such a system, but expected
it to be subsidized by someone else.

7.2.  IBM Franz

     Even more nibbles on this one, but not yet.

8.  Business News

8.1.  Eunice SOLD

     Some of you may have heard  that  the  Eunice  software
package was sold by SRI to the Wollongong Group, a UNIX sup-
port group in Palo Alto.   Prices  range  from  $2k  (educa-
tional)  to  $5k (commercial).  Naturally this package is of
interest beyond the availability of Franz Lisp.  We have not
compared  this  product  to  other similar ones, but we know
that TWG has been distributing a working Franz opus 38.

     As far as alternatives to Eunice, we  are  aware  of  a
system  developed  at  Rice University, and another by Human
Computing  Resources  (HCR)  in  Toronto.    We   have   not
evaluated either of these.

8.2.  MACSYMA SOLD

     MIT has sold exclusive rights to MACSYMA, a large alge-
braic  manipulation  system, to Symbolics, Inc. of Cambridge
Mass. This package runs in Franz Lisp, (among  other  Lisps)
We  hope that soon it will again be available to educational
institutions with VAX systems either from us  or  Symbolics,
at a nominal charge.  We understand that commercial licenses
(from Symbolics) for versions of MACSYMA  on  PDP-10s,  Lisp
Machines,  etc.   will distributed at non-nominal prices and
offered with maintenance contracts.







From liz.umcp-cs@UDel-Relay Mon Nov  1 17:43:52 1982
Date:     29 Oct 82 12:04:24 EDT  (Fri)
From:     Liz Allen <liz.umcp-cs@UDel-Relay>
Subject:  Re:  Flavor system
To:       ECC.MIT-MC at Ucb-C70, FRANZ-FRIENDS at Mit-Mc
Cc:       randy.umcp-cs at UDel-Relay
In-Reply-To: Message of 25 October 1982 16:29-EDT from ECC@MIT-MC@Berkeley
Via:  UMCP-CS; 30 Oct 82 5:40-EDT
Status: RO

	Date: 25 October 1982 16:29-EDT
	From: ECC@MIT-MC@Berkeley
	Subject:  Flavor system
	To: FRANZ-FRIENDS at MIT-MC

	Can someone give me a pointer to the Franz flavor system
	developed by U. Maryland?  I am looking for information on how to
	FTP the files -- what machine, whether public, what files, etc.

Since the U. of Maryland is not (yet) an Arpanet host, you can't
FTP files directly from here.  We are right now completing some
documentation for all of our hacks -- including documentation for
some recent improvements for our flavors system.  When that
documentation is complete, we will be ready to distribute the
packages developed here.  Besides flavors, this includes a top
level called userexec which is based on INTERLISP's top level and
a production system called YAPS similar to but more flexible than
OPS5.

We are supposed to become an Arpanet host in a few months...  (Read
open ended period of time.)  Meanwhile, if you would like to get
our code, mail me a tape, and I will mail it back with the code and
documentation on it.  I'd appreciate it if someone would volunteer
to let other folks FTP the files from their machine until we do
become an Arpanet host.  My address is:

	Liz Allen
	Univ of Maryland
	Dept of Computer Science
	College Park MD 20783
	(301) 454-4247
	liz.umcp-cs@udel-relay

				-Liz



From jkf  Wed Nov  3 15:49:29 1982
Date: 3-Nov-82 15:48:50-PST (Wed)
From: jkf (John Foderaro)
Subject: lisp opus 38.40
Message-Id: <8210032349.16460@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A16460; 3-Nov-82 15:49:29-PST (Wed)
To: local-lisp
Status: RO

  putprop will now put new properties at the head of the property list.
  
  


From ecc@UCBARPA  Thu Nov  4 10:28:49 1982
Date: 4-Nov-82 10:19:26-PST (Thu)
From: ecc@UCBARPA (Eric C. Cooper)
Subject: Lisp song
Message-Id: <8210041819.24539@UCBARPA.BERKELEY.ARPA>
Received: by UCBARPA.BERKELEY.ARPA (3.224 [10/16/82])
	id A24537; 4-Nov-82 10:19:28-PST (Thu)
Received: from UCBARPA.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A00305; 4-Nov-82 10:28:49-PST (Thu)
To: local-lisp@kim
Status: O

[This has been forwarded from uucp through Xerox through info-lispm.]

>From decvax!utzoo!utcsrgv!roderick Mon Nov  1 14:24:35 1982

Another Glitch in the Call
------- ------ -- --- ----
   (Sung to the tune of a recent Pink Floyd song.)


We don't need no indirection
We don't need no flow control
No data typing or declarations
   Hey! Did you leave the lists alone?

Chorus:
   All in all, it's just a pure-LISP function call.

We don't need no side effect-ing
We don't need no scope control
No global variables for execution
   Hey! Did you leave those args alone?

(Chorus)

We don't need no allocation
We don't need no special nodes
No dark bit-flipping in the functions
   Hey! Did you leave the bits alone?

(Chorus)

We don't need no compilation
We don't need no load control
No link edit for external bindings
   Hey! Did you leave that source alone?

(Chorus, and repeat)

From jkf  Sat Nov 13 20:53:41 1982
Date: 13-Nov-82 20:53:16-PST (Sat)
From: jkf (John Foderaro)
Subject: lisp opus 38.41
Message-Id: <8210140453.490@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.222 [10/13/82])
	id A00490; 13-Nov-82 20:53:41-PST (Sat)
To: local-lisp
Status: O

  added functions:
  	(remq 'g_val 'l_list) - just like remove but uses eq instead of equal
	(command-line-args) - returns a list of the command line arguments
		when lisp was started.  This function will return
		only those arguments typed by the user, even if the
		lisp was started with the autorun feature (liszt -r).
	(sys:gethostname) - returns the name of the machine.
	(status domain) - returns 'ucb' here.



From Paul.Rosenbloom@CMU-CS-G@CMU-CS-A Sun Nov 28 08:38:06 1982
Mail-From: CMUFTP host CMU-CS-G received by CMU-10A at 28-Nov-82 11:48:21-EST
Date: 28 Nov 1982 11:47:28-EST
From: Paul.Rosenbloom at CMU-CS-G at CMU-CS-A
Subject: (random) problems
Status: RO

I am having two problems using (random) in Franz lisp.  The first problem is
that I can't find any way to set the seed.  Every time I enter lisp, the
generator is in the same state.  I have had to resort to cfasling a c
procedure that calls srand() (as (random) seems to be defined in c by a call
on rand()).  Is there a way to do this within lisp?  The other problem is
more serious.  The generator seems to generate tight cycles for (at least)
arguments that are small powers of 2.  For example, repeatedly executing
(random 2) yields the sequence 01010101..., and (random 4) yields
01230123....  These sequences apparently occur no matter to what value I set
the seed.  Does anyone one know what I could be doing wrong, or have a
working random number generator?


From tim.unc@UDel-Relay Sun Nov 28 20:44:24 1982
Status: O

From tim.unc@UDel-Relay Sun Nov 28 20:27:43 1982
Date:     28 Nov 82 22:40:14 EST  (Sun)
From:     Tim Maroney <tim.unc@UDel-Relay>
Subject:  rng
To:       franz-friends at Ucb-C70
Via:  UNC; 28 Nov 82 23:38-EST
Status: O

To the person who asked about random number generators and deficiencies
in (random) [I can't write mail to you for some reason]:

You're not doing anything wrong; that's the way the sucker works.
One good way to get random numbers is to do the syscall that gets
you the number of seconds since whenever-it-is, and use the mod
function. This is especially good for getting a random one or zero,
by using the evenp function.

					Tim Maroney
					tim@unc@udel-relay


From jkf  Tue Nov 30 09:21:10 1982
Date: 30-Nov-82 09:21:10-PST (Tue)
From: jkf (John Foderaro)
Subject: opus 38.42
Message-Id: <8210301721.11699@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.255 [11/28/82])
	id AA11699; 30-Nov-82 09:21:10-PST (Tue)
To: local-lisp
Status: O

  added: (sys:link 'oldname 'newname) that what the ln program does.

  changed: the order of arguments to the vset functions is now:
  	(vset 'vector 'index 'value).
	
	[This shouldn't affect anyone since vectors haven't been officially
	 released yet and won't be until I make one more major modification]

	setf now knows about vectors.  You can say
		(setf (vref 'vector 'index) 'value)
	and not have to worry about the order of arguments to vset.



From jkf  Tue Nov 30 10:42:00 1982
Date: 30-Nov-82 10:42:00-PST (Tue)
From: jkf (John Foderaro)
Subject: Re: opus 38.42
Message-Id: <8210301842.13143@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.255 [11/28/82])
	id AA13143; 30-Nov-82 10:42:00-PST (Tue)
To: jeffc, local-lisp
In-Reply-To: Your message of 30 Nov 1982 1036-PST (Tuesday)
Status: O

  It can't do symbolic links (I've only been adding system calls that I had
a use for).

  setf is a generalized setq.  The target can be an expression which locates
a value.  setf figures out how to store in the target.
for example:

  (setf x 3)        ==  (setq x 3)
  (setf (car x) 3)  == (rplaca x 3)
  (setf (get foo 'bar) 3) == (putprop foo 3 'bar)

the target must be something it has been 'taught' to understand, or it can
be a macro, in which case setf macro-expands it and takes another look.

The setf macro (and a list of targets it knows about is in
/usr/lib/lisp/common2.l)




From jkf@UCBKIM  Wed Dec  1 09:13:23 1982
Date: 1-Dec-82 09:13:03-PST (Wed)
From: jkf@UCBKIM (John Foderaro)
Subject: Random Numbers in Franz
Message-Id: <8211011713.3615@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.255 [11/28/82])
	id AA03615; 1-Dec-82 09:13:03-PST (Wed)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.227 [10/22/82])
	id A18406; 1-Dec-82 09:13:23-PST (Wed)
To: franz-friends@berkeley
Status: RO

Date: 29-Nov-82 15:56:09-PST (Mon)
From: alice!sola!mitch
Subject: Random Numbers in Franz
To: alice!ucbvax!franz-friends

In general, it is very bad practice to compute a random number between 0
and n by any expression such as (mod (random) n).  In fact, Franz's
random function does exactly that, returning the number generated by the
C function rand(3) modulo n.  This technique uses only the rightmost 
bits of successive calls to rand, and the righmost n bits of congruential
sequences (like that returned by rand(3)) have a period of AT MOST 2**n
(See Knuth vol.2 p. 12).  So using the rightmost two bits will indeed give
you sequences of at most period 4.  (If your lisp doesn't have this 
behavior, you're not using the standard rand.)

A better way to do it is to use the high order bits, by dividing the entire
range up into n pieces and then seeing where you fall.  (This method is
biased if n is of the same order as the range, though.)

The code I use is:


(or (getd '$old-random) (putd '$old-random (getd 'random)))

(defun random n
  (cond ((eq n 0) ($old-random))
	((fix (quotient (boole 1 ($old-random) #o 7777777777)
			(quotient #o 7777777777 (arg 1)))))))

		Mitch Marcus





From jkf  Thu Dec  2 08:04:37 1982
Date: 2-Dec-82 08:04:37-PST (Thu)
From: jkf (John Foderaro)
Subject: Franz Lisp distribution
Message-Id: <8211021604.14414@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.255 [11/28/82])
	id AA14414; 2-Dec-82 08:04:37-PST (Thu)
To: franz-friends, net-lang-lisp@k
Status: O


	Franz Lisp Distribution
	
  This note describes our distribution policy for Franz Lisp.

What is being distributed:
  We distribute only source code in order to keep the distribution
  small and relatively Unix independent.   Makefiles are provided to
  build the entire lisp system from source, even if you don't have
  a version of lisp running already.  This process takes about 3 cpu
  hours on a Vax 780.  [This version for the Vax only, a 68000 version
  is being worked on.  Contact ucbkim.sklower@berkeley or 
  ucbkim.layer@berkeley]

  The following source is provided:
    lisp interpreter, 
    compiler (liszt),
    cross reference program (lxref),
    lisp manual,
    and other utility programs:
       trace, step, debug, cmu library functions, (and other minor ones),
       and these packages from the MIT lisp library:
	    defstruct, loop, flavors. 
   	    [These programs are provided as a convenience to those who can't
	     access the arpanet and copy them.  There is no documentation for
	     them in the Franz Lisp manual.  The best source of documentation
	     is the Lisp Machine manual (available from MIT, Symbolics
	     or LMI)]

   Regarding Flavors:  there are two implementations of flavors for
	Franz Lisp, one from MIT (contact person Richard Zippel (rz@mit-mc))
	and one from the University of Maryland (contact person
	Liz Allen  (liz.umcp-cs@udel-relay)).  Neither implementation is
	exactly like flavors on the Lisp Machine (due to differences between
	Lisp Machine lisp and Franz Lisp), and the implementations differ
	from each other.    We incorporated the Mit version into the
	standard distribution because the high bandwidth between here and
	MIT will insure that it keeps up to date with the current Franz.
	This is not to imply that it is the better implementation.
	We haven't had enough experience with flavors to judge.
	Those seriously interested in Flavors should contact Liz
	Allen and ask for the Tech Report on the Univ Of Maryland Flavors
	system.

What is the form of the distribution:
  The files are packaged in a giant (2.1Mbyte) shell script.  Running this
shell script through 'sh' will result in a directory tree.  A ReadMe file
in the current directory will contain instructions on building the lisp
system.  The shell script is broken into a number of smaller files.
The current distribution looks like:
% ls
total 2092
 195 opus38.40.aa	 195 opus38.40.ae	 195 opus38.40.ai
 195 opus38.40.ab	 195 opus38.40.af	 195 opus38.40.aj
 195 opus38.40.ac	 195 opus38.40.ag	 142 opus38.40.ak
 195 opus38.40.ad	 195 opus38.40.ah

The '38.40' means Opus 38, minor version 40.  These numbers may be different
by the time you get your distribution.  In order to extract the lisp
files from this shell script, you need only type:
	cat * | sh


To get a copy of the distribution:
  The distribution may be obtained either using FTP from an arpanet site,
or on a magnetic tape through the U.S Mail.

 Arpanet:
   The files are stored on the ucb-c70 (NCP) arpanet host in the
   directory /users/lisp/lispuser.  If you have an account on the ucb-c70,
   you are free to take FTP a copy of these files.
   If you do not have an account on the ucb-c70, send me (jkf@berkeley) a
   message and I will set up a temporary account for you.
   If you are on a TCP host, write me and we will set up an account on one
   of our Vax's for you to FTP the files.  Eventually we will have an
   anonymous login on a TCP machine.

 Mag Tape:
   In order to get a copy of the distribution mailed to you, send a check to
 cover our tape copying and mailing costs (fees are listed below).  We will
 purchase the mag tape and you are free to keep it.  Please do NOT
 send us a tape.

     Fees:
     		$50	- distribution tape mailed 3rd class
	    add $10	- a copy of the Lisp Manual (we will only
	       		  send one copy, you are free to photocopy it)
  	    add $7	- send tape via 1st class mail.

	     -or-
	     	$15	- for just a copy of the Lisp Manual

 The address to send checks to is 

	Keith Sklower
	EECS/Computer Science Division
	524 Evans Hall
	University of California
	Berkeley, CA  94720

 All checks should be made out to "Regents, University of California."
 We require pre-payment.  We will not invoice or process purchase orders.



Disclaimers:
    This distribution works on the latest versions of Unix running at
    Berkeley (4.1a).  We can't guarantee that it will work on older
    versions (although, if you are running 4.1, it is almost certain
    that it will work, but we have not verified it).
    VMS users who are using a typical Unix compatibility package will 
    probably not be able to build a lisp from this distribution unless they
    know a great deal about VMS and their compatibility package.
    At least one package (Eunice) supports Franz at this time.
    
Redistribution:
    If you get a copy of the distribution, you are free to give it to
    other people.  We appreciate being informed of new sites so they
    can be put on a mailing list (electronic and conventional).  This
    list is used to announce new releases.  To be put on this list,
    send U.S. Mail to Keith Sklower (address above) or to 
    franz-friends-request@berkeley or ucbvax!franz-friends-request



From jkf  Mon Dec  6 08:50:45 1982
Date: 6-Dec-82 08:50:45-PST (Mon)
From: jkf (John Foderaro)
Subject: opus 38.43
Message-Id: <8211061650.12951@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA12951; 6-Dec-82 08:50:45-PST (Mon)
To: local-lisp
Status: O

  The size of vectors is now recorded in bytes rather than longwords.
  We've imported a few more commands to deal with fclosures.
  (symeval-in-fclosure 'fclosure 'symbol)
  (set-in-fclosure 'fclosure 'symbol 'value)

  (let-fclosed vars function)
  



From jkf  Mon Dec 13 10:35:43 1982
Date: 13-Dec-82 10:35:43-PST (Mon)
From: jkf (John Foderaro)
Subject: enhancemants to trace
Message-Id: <8211131835.12160@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA12160; 13-Dec-82 10:35:43-PST (Mon)
To: local-lisp
Status: O

  The function 'retrace' will insure that all functions which should be
traced are indeed traced.   This will solve the problem of reloading
a file whose functions are traced.  After you load a file, you can
type (retrace) and those functions which became untraced during the loading
process, will be traced again.

  The top-level-print and top-level-read variables will now take effect
within a trace break.





From jkf  Tue Dec 14 12:40:41 1982
Date: 14-Dec-82 12:40:41-PST (Tue)
From: jkf (John Foderaro)
Subject: Re: #!, exec and lisp
Message-Id: <8211142040.10379@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA10379; 14-Dec-82 12:40:41-PST (Tue)
To: lime!burdvax!puder
Cc: franz-friends
In-Reply-To: Your message of 13-Dec-82 14:03:23-PST (Mon)
Status: O

   It is easy to make #! do a zapline.   If you have a recent version of
lisp, just execute:

(defsharp ! (x) (zapline))

(this could be put in your .lisprc, if you don't want to affect other 
people).    The problem with adding this to Franz by default is that the
sharpsign macro is shared by a number of lisps and few of them run under
Unix.   Therefore, few other lisps are going to want #! to be zapline.


  Regarding the -f switch:  The -f switch is used to communicate between the
bootstrap at the beginning of a fasl file and the lisp interpreter.  It
wasn't meant as a general 'fasl this file' switch for users to make use of.
The choice of '-f' was bad, it should have been something more unique like
'-- autorun' so that a user would be unlikely to type it.   We have avoided
assigning meanings to switches on lisp's command line because we want to give
each user the opportunity to assign whatever meaning he wants to whatever
switch he wants.   It isn't difficult to write a program to scan the command
line.

Re:
    The (setq searchlist (cvtsearchpathtolist (getenv 'PATH))) would not be
    necessary, because the exec syscall supplies the full path name, because
    the shell has already done the path searching on the command name.  The
    only place that might have to be searched is the current directory.

This isn't true.  (argv 0) is the command that you typed, not the full path
name to the command.  Only by prepending all the directories in the
search list can you find the location of the command.


				---john foderaro
				


From jkf  Mon Jan 10 15:04:02 1983
Date: 10-Jan-83 15:04:02-PST (Mon)
From: jkf (John Foderaro)
Subject: opus 38.45
Message-Id: <8300102304.19240@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA19240; 10-Jan-83 15:04:02-PST (Mon)
To: local-lisp
Status: O

  showstack will again report correctly for compiled calls if the
transfer tables are unlinked (status translink nil).



From jkf  Mon Jan 10 19:46:06 1983
Date: 10-Jan-83 19:46:06-PST (Mon)
From: jkf (John Foderaro)
Subject: opus 38.46
Message-Id: <8300110346.24831@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA24831; 10-Jan-83 19:46:06-PST (Mon)
To: local-lisp
Status: O

 This version incorporates some fixes from mit.  You shouldn't notice
any differences but if you do, let me know.





From jkf  Wed Jan 12 09:03:32 1983
Date: 12-Jan-83 09:03:32-PST (Wed)
From: jkf (John Foderaro)
Subject: opus38.47
Message-Id: <8300121703.1981@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA01981; 12-Jan-83 09:03:32-PST (Wed)
To: local-lisp
Status: O

  The setf macro will now handle all car and cdr forms (i.e. c{ad}+r).
  Thanks to peter norvig for this.

  There is a new macro called 'defvar'.  It is used to declare special
variables and optionally to give them an initial value.  It is used
at top level in a file (outside of defuns).

forms:
(defvar foo)	; declares foo to be special
(defvar bar 3)	; declares bar to be special and when this file is read in
		; bar will be given the value 3 if it is unbound.
An advantage of '(defvar foo)' over '(declare (special foo))' is that if
a file containing defvars is loaded (or fasl'ed) in during compilation,
the variables mentioned in the defvar's will be declared special.  The only
way to have that effect with '(declare (special foo))' is to 'include'
the file.  

 There is a new macro, 'environment', which can be used at the beginning of
a file to specify what sort of environment this file needs in order to be
compiled or run.  For example:
(environment (compile eval) (files mymacros othermacros)
	     (compile) (syntax maclisp))

says that when compiling or loading into the interpreter, the files
mymacros and othermacros should be loaded (if they aren't loaded already).
When compiling, the maclisp syntax should be used.
The general form of 'environment' is:
   (environment when1 what1
   	        when2 what2
		...    ...
		whenN whatN)
the when's are a subset of (eval compile load), and the symbols have the
same meaning as they do in 'eval-when'.
The what's are either
	(files file1 file2 ... fileN)
		insure that the named files are loaded.  To see if fileX
		is loaded, it looks for a 'version' property under
		fileX's property list.  Thus to prevent multiple loading,
		you should put
		(putprop 'myfile t 'version) at the end of myfile.l
	(syntax type)
		type is either maclisp, intlisp, ucilisp, franzlisp
		This sets the syntax correctly.

There are additional macros to set of standard environments:
(environment-maclisp)  sets up the maclisp environment.  This is what
	you would get by using the -m switch to liszt.

(environment-lmlisp)  sets up the lisp machine environment. This is like
	maclisp but it has additional macros.

	
It is possible to add when's and what's to the specialized environments,
e.g.
 (environment-maclisp (compile eval) (files foo bar))



  



From norvig Wed Jan 12 13:12:45 1983
To: jkf local-lisp
Subject: defvar
Status: O

Shouldn't defvar take any number of arguments, like setq?  As it is,
(defvar a 1 b 2) sets a to 1, but ignores the other arguments.

From fateman Wed Jan 12 13:23:08 1983
To: jkf local-lisp norvig
Subject: Re:  defvar
Status: O

I suspect the extra arguments to defvar are used in other systems for
storage of documentation strings in appropriate places.  E.g.
(defvar dozen 12 "initially 12 except in the baker system when it is 13")
causes some association with defvar and documentation should be put on
a file.


From jkf  Wed Jan 12 14:25:02 1983
Date: 12-Jan-83 14:25:02-PST (Wed)
From: jkf (John Foderaro)
Subject: Re: defvar
Message-Id: <8300122225.13079@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA13079; 12-Jan-83 14:25:02-PST (Wed)
To: norvig, local-lisp
In-Reply-To: Your message of 12 Jan 1983 1311-PST (Wednesday)
Status: O

 fateman is correct that there is an optional third argument for
documentation.   We don't want to add multiple arguments because defvar
it will mean that code we write here can't be transported to
other lisp which only expect one defvar argument.



From jkf  Thu Jan 13 09:49:13 1983
Date: 13-Jan-83 09:49:13-PST (Thu)
From: jkf (John Foderaro)
Subject: liszt 8.17
Message-Id: <8300131749.331@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00331; 13-Jan-83 09:49:13-PST (Thu)
To: local-lisp
Status: O

 The vector reference functions are open coded.  These are
 	vref, vrefi-byte, vrefi-word, vrefi-long



From G:alpines  Thu Jan 13 20:31:34 1983
Date: 13 Jan 1983 20:24-PST
From: alpines@G   (Harry Weeks at Vax-Populi)
Subject: Franz on 68000's
Message-Id: <83/01/13 2024.733@Vax-Populi>
Received: by UCBVAX.BERKELEY.ARPA (3.293 [1/9/83])
	id AA12970; 13-Jan-83 20:28:37-PST (Thu)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA14908; 13-Jan-83 20:31:34-PST (Thu)
To: franz@BERKELEY
Cc: franz-friends@BERKELEY
Status: O

>Date: 13 Jan 1983 20:01-PST
From: G.alpines at Berkeley (Harry Weeks at Vax-Populi)
Subject: Franz on 68000's.
To: franz-friends-request@Berkeley
Message-Id: <83/01/13 2001.733@Vax-Populi>

Please put me on your mailing list for information concerning
implementation of Franz, esp. on 68000's, but I'd like to keep
informed generally as well.  Thanks.

					Harry Weeks
					Bytek
					1730 Solano Avenue
					Berkeley, CA 94707
					
					(415) 527-1157


From jkf  Sun Jan 16 21:22:54 1983
Date: 16-Jan-83 21:22:54-PST (Sun)
From: jkf (John Foderaro)
Subject: change to lisptags program
Message-Id: <8300170522.23656@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA23656; 16-Jan-83 21:22:54-PST (Sun)
To: local-lisp
Status: O

 lisptags will now surround the search string with /'s instead of ?'s
in order to be compatible with ctags.   Both types should work with vi,
emacs people will probably have to make a minor modification to their
tags.ml file.
  My version in ~jkf/elib/tags.ml.
 





From jkf  Tue Jan 18 16:43:23 1983
Date: 18-Jan-83 16:43:23-PST (Tue)
From: jkf (John Foderaro)
Subject: lisp opus 38.48, liszt 8.19
Message-Id: <8300190043.10935@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA10935; 18-Jan-83 16:43:23-PST (Tue)
To: local-lisp
Status: O

  This is a long message so I'll put the most important thing first, in case
you choose not to read the rest of the message:
  *** object files generated by liszt 8.19 will not run in any lisp
  *** older than 38.48.    Object files which were generated by
  *** liszt's before 8.19 will continue to work in the new lisp.


There were two major changes to lisp and liszt:
 1) compiled functions will test at runtime to make sure that they
    are passed the correct number of arguments.

 2) the lambda list keywords &optional, &rest and &aux are open compiled
    in an efficient manner.

I'll refresh your memory on what the possible forms are for the & keywords:

  the formal parameter list of a def has this form
  ( required-args
    [ &optional optional-arguments ]
    [ &rest rest-argument ]
    [ &aux  aux-arguments ])

 as in this example which shows all possible forms:

 (def foo 
   (lambda (a b &optional c (d 23 d-p) (dd (bar)) &rest e &aux (f 12) g)
    	(compute)))

   
 the meaning and forms of the various parts of the formal parameter list are:

 required-args: a sequence of n (zero or more) symbols which will be bound
 	to the first n actual arguments.

 optional-args:	a sequence of m (zero or more) symbols which will be
 	bound to the next m actual arguments if they are present, or
	to default values.
	the forms of an optional argument are:
	
	foo	- bind foo to the argument if it present, otherwise bind it
		  to nil
	(foo (expr)) - bind foo to the argument if it is present, otherwise
		evaluate (expr) and bind foo to the result.

	(foo (expr) foo-p)  - bind foo to the argument if it is present, 
		otherwise evaluate (expr) and bind foo to the result.
		Also, bind foo-p to t if the argument is present, otherwise
		bind foo-p to nil.  foo-p will be treated like an &aux
		variable (see below) but it should NOT be declared in the
		&aux list!

  rest-arg : a single symbol which will be bound to a list of the rest of the
  	arguments.  This list is cons'ed up each time the function is called.

  aux-args : these args are just like arguments to let or prog within the
  	function body so this & keyword isn't really necessary (but there
	are few things in lisp that really are necessary).

	the forms of the aux arg are:

	foo - bind foo to nil
	(foo (expr))  - evaluate (expr) and bind foo to the result.



The compiler understands the &keywords but the interpreter does not.  'def'
will convert a form with &keywords to a lexpr which is almost equivalent.
The differences are:
    The interpreted form, being a lexpr, is allowed to use the 'arg'
	function.  The compiled form, even with optional args,
	is not a lexpr and thus 'arg' is illegal.

    The order that &aux variables are lambda bound is slightly different
        between interpreted and compiled code.  As long as default
	expressions reference no formal parameters after them in the
	formal parameter list, there should be no problems.

    The interpreted version will not check for the correct number of
        arguments.

Local functions cannot have &keywords.	

If you have any questions on this, send me mail.  This change should
only break functions which expect a variable number of argument and
which don't declare the fact using &optional programs.  There may be,
of course, implementation errors.  If you notice anything unusual
please let me know right away.  The old compiler will be
in /usr/ucb/oliszt for a while.



	
    
	



From layer  Thu Jan 20 01:55:55 1983
Date: 20-Jan-83 01:55:55-PST (Thu)
From: layer (Kevin Layer)
Subject: liszt 8.20
Message-Id: <8300200955.17788@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA17788; 20-Jan-83 01:55:55-PST (Thu)
To: local-lisp
Phone: (415) 652-2405
Status: O

    There are now three new command line features for liszt:

    1. -E <s-expr>, where <s-expr> will be evaluated before compilation
       starts.  For example, the setting of constants can be done in this way:

	   liszt -E '(setq foobar "***foobar-string***")' foobar.l

       and in the file being compiled, foobar is accessed as '#.foobar.

    2. -I <include-file>, where <include-file> will be loaded (via load)
       before compilation starts.

    3. A combination of the -S and -o switches will set the .s file, as in:

        liszt -S -o foo.vax.s foo.l

      where previously, the -S determined the name of the .s file (foo.s in
      the above example).
      


From jkf  Thu Jan 20 19:42:38 1983
Date: 20-Jan-83 19:42:38-PST (Thu)
From: jkf (John Foderaro)
Subject: some mods to liszt 8.20
Message-Id: <8300210342.7334@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA07334; 20-Jan-83 19:42:38-PST (Thu)
To: local-lisp
Status: O

 the -E and -I flags are now -e and -i
 there may be more than one -i flag given on the command line.
 


From fateman Thu Jan 20 20:20:31 1983
To: local-lisp
Subject: fame, if not fortune
Status: RO

In the latest Scientific American, Feb. 1983, Hofstader's column
is the first of several on the programming language "lisp".  He
mentions the particular dialect he is using .... Franz !

From wilensky  Thu Jan 20 20:57:27 1983
Date: 20-Jan-83 20:57:27-PST (Thu)
From: wilensky (Robert Wilensky)
Subject: Re: fame, if not fortune
Message-Id: <8300210457.8824@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA08824; 20-Jan-83 20:57:27-PST (Thu)
To: fateman, local-lisp
In-Reply-To: Your message of 20 Jan 1983 2019-PST (Thursday)
Status: RO


On the other hand, being referenced by Hofstader is a dubious honor.


From UCBKIM:jkf  Fri Jan 21 08:15:04 1983
Date: 21-Jan-83 08:11:01-PST (Fri)
From: UCBKIM:jkf (John Foderaro)
Subject: test message, ignore
Message-Id: <8300211611.18650@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA18650; 21-Jan-83 08:11:01-PST (Fri)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA24887; 21 Jan 83 08:09:27 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA18766; 21-Jan-83 08:15:04-PST (Fri)
To: franz-friends@BERKELEY
Status: O

 This will give our mailer a chance to tell me how many of our franz friends
are no longer reachable.



From JTSCHUDY@USC-ISIE  Sat Jan 22 16:42:19 1983
Date: 22 Jan 1983 1634-PST
From: JTSCHUDY@USC-ISIE
Subject: MAILINGLIST ADDITION
Message-Id: <8300230037.1747@UCBVAX.BERKELEY.ARPA>
Received: from USC-ISIE by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA01747; 22 Jan 83 16:37:17 PST (Sat)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA18903; 22-Jan-83 16:42:19-PST (Sat)
To: franz-friends@BERKELEY
Status: O

Hi!  My name is Jim.  I am presently attending the Naval Post Graduate
School in Monterey California.  I am in the Air Force  enrolled  in  a
DOD  sponsored  graduate  degree in Command Control and Communications
Systems Technology.

i  would  like  to  be  added to your mailing list.  My net address is
JTSCHUDY at ISIE.

Thanks - Jim.
-------


From jkf  Sat Jan 22 17:38:41 1983
Date: 22-Jan-83 17:38:41-PST (Sat)
From: jkf (John Foderaro)
Subject: opus 38.49
Message-Id: <8300230138.20020@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA20020; 22-Jan-83 17:38:41-PST (Sat)
To: local-lisp
Status: O

  A longstanding bug in the determination of the number of free dtpr objects
has been found and fixed.  The effect of this bug was that the function
which is responsible for allocating more memory pages didn't allocate
enough dtpr pages because it thought that there were a large number of
cells free.



From MCLINDEN@RUTGERS  Mon Jan 24 10:33:14 1983
Date: 24 Jan 1983 1324-EST
From: Sean McLinden  <MCLINDEN@RUTGERS>
Subject: Franz Lisp and floating point accelerator
Message-Id: <8300241825.19602@UCBVAX.BERKELEY.ARPA>
Received: from RUTGERS by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA19602; 24 Jan 83 10:25:06 PST (Mon)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA27143; 24-Jan-83 10:33:14-PST (Mon)
To: franz-friends@UCBVAX
Status: O


  Has anyone determined if a floating point accelerator speeds up
 Vax Franz Lisp jobs in any significant fashion?

  Pointers would be appreciated.

  Sean McLinden
  Decision Systems Lab
-------

From mike@rand-unix  Mon Jan 24 18:47:03 1983
Date: Monday, 24 Jan 1983 15:34-PST
From: mike@RAND-UNIX
Subject: emacs interface to franz?
Message-Id: <8300250008.58@UCBVAX.BERKELEY.ARPA>
Received: from rand-unix by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00058; 24 Jan 83 16:08:36 PST (Mon)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00921; 24-Jan-83 18:47:03-PST (Mon)
To: franz-friends@BERKELEY
Status: O


Does anyone have a snazzy interface to emacs for franz?  

Thanks,
  Michael


From @udel-relay.ARPA,@UDel-Relay:Tim@UPenn.UPenn  Tue Jan 25 16:29:19 1983
Date: 25 Jan 1983  9:58-EST
From: Tim Finin <Tim.UPenn@UDel-Relay>
Subject: emacs interface to franz?
Message-Id: <8300260022.29320@UCBVAX.BERKELEY.ARPA>
Received: from udel-relay.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA29320; 25 Jan 83 16:22:57 PST (Tue)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA01561; 25-Jan-83 16:29:19-PST (Tue)
Return-Path: <Tim@UPenn.UPenn@UDel-Relay>
To: mike@Rand-Unix
Cc: franz-friends@BERKELEY
Via:  UPenn; 25 Jan 83 19:21-EST
Status: O


We have a simple interface from Franz to Emacs, but I much prefer to go the
other way, i.e. run Franz as a inferior job under Emacs.  I believe there
are several Emacs packages which allow one to run inferior jobs in an Emacs
window (I have my own which is, unfortunately totally undocumented). Some of
the benefits of this set up include:

    - one has all of the text editing functions available in Emacs
    - one has many lisp-based editing functions available in Emacs
      (thru mock-lisp packages like electriclisp)
    - one has a history of the session in the editing buffer
    - one has an environment which supports multiple concurrent
      processes running in seperate windows.
    - it is very easy to experiment with new interface features such as
      symbol completion and re-evaluation of previously issued commands
    
Tim
    

From CARR@UTAH-20  Fri Jan 28 08:19:08 1983
Date: 28 Jan 1983 0912-MST
From: Harold Carr <CARR@UTAH-20>
Subject: franz distribution
Message-Id: <8300281615.20646@UCBVAX.BERKELEY.ARPA>
Received: from UTAH-20 by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA20646; 28 Jan 83 08:15:18 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA16991; 28-Jan-83 08:19:08-PST (Fri)
To: franz-friends@UCBVAX
Status: O

What is the distribution policy?

I work for a company that has opus 36 and is now currently running opus 37.
Here at the University of Utah we are running opus 38.04. Is it OK to
make a tape of the University's 38.04 to bring my company more up to
date? Do I have to make it more formal by signing a transfer agreement
or by obtaining the release directly from Berkeley?

                              Thanks in advance,
                                 Harold Carr
                                CARR@UTAH-20
-------

From UCBKIM:jkf  Fri Jan 28 15:09:32 1983
Date: 28-Jan-83 08:34:33-PST (Fri)
From: UCBKIM:jkf
Subject: Re: franz distribution
Message-Id: <8300281634.17319@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA17319; 28-Jan-83 08:34:33-PST (Fri)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA02275; 28 Jan 83 14:58:37 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00402; 28-Jan-83 15:09:32-PST (Fri)
To: CARR@UTAH-20
Cc: franz-friends@UCBVAX
In-Reply-To: Your message of 28 Jan 1983 0912-MST
Status: O

  Here is our current distribution policy.  This differs a bit from
the one sent out a month ago [in particular, we now have anonymous ftp]

				    -[Fri Jan 28 08:31:45 1983 by jkf]-
	Franz Lisp Distribution
	
  This note describes our distribution policy for Franz Lisp.

What is being distributed:
  We distribute only source code in order to keep the distribution
  small and relatively Unix independent.   Makefiles are provided to
  build the entire lisp system from source, even if you don't have
  a version of lisp running already.  This process takes about 3 cpu
  hours on a Vax 780.  [This version for the Vax only, a 68000 version
  is being worked on.  Contact ucbkim.sklower@berkeley or 
  ucbkim.layer@berkeley]

  The following source is provided:
    lisp interpreter, 
    compiler (liszt),
    cross reference program (lxref),
    lisp manual,
    and other utility programs:
       trace, step, debug, cmu library functions, (and other minor ones),
       and these packages from the MIT lisp library:
	    defstruct, loop. 
   	    [These programs are provided as a convenience to those who can't
	     access the arpanet and copy them.  There is no documentation for
	     them in the Franz Lisp manual.  The best source of documentation
	     is the Lisp Machine manual (available from MIT, Symbolics
	     or LMI)]

   Regarding Flavors:  there are two implementations of flavors for
	Franz Lisp, one from MIT (contact person Richard Zippel (rz@mit-mc))
	and one from the University of Maryland (contact person
	Liz Allen  (liz.umcp-cs@udel-relay)).  Neither implementation is
	exactly like flavors on the Lisp Machine (due to differences between
	Lisp Machine lisp and Franz Lisp), and the implementations differ
	from each other.    The MIT version cannot be distributed by 
	us (yet) due to licensing problems.   If you have a Lisp Machine
	Source license from Symbolics, you should be able to get a copy
	from MIT.
	For a Tech Report on Maryland flavors, write to Liz Allen.

What is the form of the distribution:
  The files are packaged in a giant (2.1Mbyte) shell script.  Running this
shell script through 'sh' will result in a directory tree.  A ReadMe file
in the current directory will contain instructions on building the lisp
system.  The shell script is broken into a number of smaller files.
The current distribution looks like:

total 2089
 489 -rw-r--r--  1 jkf        500003 Jan 26 11:33 opus38.50.aa
 489 -rw-r--r--  1 jkf        500002 Jan 26 11:35 opus38.50.ab
 489 -rw-r--r--  1 jkf        500047 Jan 26 11:37 opus38.50.ac
 489 -rw-r--r--  1 jkf        500007 Jan 26 11:38 opus38.50.ad
 133 -rw-r--r--  1 jkf        136038 Jan 26 11:39 opus38.50.ae

The '38.50' means Opus 38, minor version 50.  These numbers may be different
by the time you get your distribution.  In order to extract the lisp
files from this shell script, you need only type:
	cat * | sh


To get a copy of the distribution:
  The distribution may be obtained either using FTP from an arpanet site,
or on a magnetic tape through the U.S Mail.

 Arpanet:
   The files are stored on the arpanet host 'ucb-vax' [ if you have an out
   of date host table, it may be called 'ucb-monet' or 'ucb-ingres'. Its
   internet number is 10.2.0.78].
   You can login as 'anonymous'.   Use your name as the password.
   The files are in the subdirectory pub/lisp.
   
   For those who have accounts on ucb-vax, the full path is ~ftp/pub/lisp.

 Mag Tape:
   In order to get a copy of the distribution mailed to you, send a check to
 cover our tape copying and mailing costs (fees are listed below).  We will
 purchase the mag tape and you are free to keep it.  Please do NOT
 send us a tape.

     Fees:
     		$50	- distribution tape mailed 3rd class
	    add $10	- a copy of the Lisp Manual (we will only
	       		  send one copy, you are free to photocopy it)
  	    add $7	- send tape via 1st class mail.

	     -or-
	     	$15	- for just a copy of the Lisp Manual

 The address to send checks to is 

	Keith Sklower
	EECS/Computer Science Division
	524 Evans Hall
	University of California
	Berkeley, CA  94720

 All checks should be made out to "Regents, University of California."
 We require pre-payment.  We will not invoice or process purchase orders.



Disclaimers:
    This distribution works on the latest versions of Unix running at
    Berkeley (4.1a).  We can't guarantee that it will work on older
    versions (although, if you are running 4.1, it is almost certain
    that it will work, but we have not verified it).
    VMS users who are using a typical Unix compatibility package will 
    probably not be able to build a lisp from this distribution unless they
    know a great deal about VMS and their compatibility package.
    At least one package (Eunice) supports Franz at this time.
    
Redistribution:
    If you get a copy of the distribution, you are free to give it to
    other people.  We appreciate being informed of new sites so they
    can be put on a mailing list (electronic and conventional).  This
    list is used to announce new releases.  To be put on this list,
    send U.S. Mail to Keith Sklower (address above) or to 
    franz-friends-request@berkeley or ucbvax!franz-friends-request



From Kim:fateman  Sun Jan 30 02:12:28 1983
Date: 28 Jan 83 08:32:08 PST (Fri)
From: Kim:fateman (Richard Fateman)
Subject: Re:  franz distribution
Message-Id: <8300281631.21039@UCBVAX.BERKELEY.ARPA>
Received: by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA21039; 28 Jan 83 08:31:58 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA10132; 30-Jan-83 02:12:28-PST (Sun)
To: CARR@UTAH-20
Cc: franz-friends@ucbvax
Status: O

Our policy is that you may move copies of Franz elsewhere
without notifying us.  We continue to be interested in sharing anything
you or your company wish to provide us, in suggestions, programs, etc.


From UCBCAD:pettengi  Sun Jan 30 02:33:52 1983
Date: 28-Jan-83 10:54:51-PST (Fri)
From: UCBCAD:pettengi (Rob Pettengill)
Subject: emacs interface to franz?
Message-Id: <8300281854.26156@UCBCAD.BERKELEY.ARPA>
Received: by UCBCAD.BERKELEY.ARPA (3.256 [12/5/82])
	id AA26156; 28-Jan-83 10:54:51-PST (Fri)
Received: from UCBCAD.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00374; 28 Jan 83 12:53:44 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA10578; 30-Jan-83 02:33:52-PST (Sun)
To: mike@rand-unix, franz-friends@ucbvax
Cc: pettengi@UCBCAD
Status: O

	While I was at TI I used a very nice interface that let one start up
a Franz lisp inside an Emacs window.  It came from SRI when we got Eunice to run
under our VMS.  Try Kashtan@SRI-AI.

Rob Pettengill
E-Systems, Dallas, Tx.

From UCBKIM:jkf  Sun Jan 30 02:44:27 1983
Date: 28-Jan-83 08:34:33-PST (Fri)
From: UCBKIM:jkf (John Foderaro)
Subject: Re: franz distribution
Message-Id: <8300281634.17319@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA17319; 28-Jan-83 08:34:33-PST (Fri)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA02275; 28 Jan 83 14:58:37 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA10772; 30-Jan-83 02:44:27-PST (Sun)
To: CARR@UTAH-20
Cc: franz-friends@UCBVAX
In-Reply-To: Your message of 28 Jan 1983 0912-MST
Status: RO

  Here is our current distribution policy.  This differs a bit from
the one sent out a month ago [in particular, we now have anonymous ftp]

				    -[Fri Jan 28 08:31:45 1983 by jkf]-
	Franz Lisp Distribution
	
  This note describes our distribution policy for Franz Lisp.

What is being distributed:
  We distribute only source code in order to keep the distribution
  small and relatively Unix independent.   Makefiles are provided to
  build the entire lisp system from source, even if you don't have
  a version of lisp running already.  This process takes about 3 cpu
  hours on a Vax 780.  [This version for the Vax only, a 68000 version
  is being worked on.  Contact ucbkim.sklower@berkeley or 
  ucbkim.layer@berkeley]

  The following source is provided:
    lisp interpreter, 
    compiler (liszt),
    cross reference program (lxref),
    lisp manual,
    and other utility programs:
       trace, step, debug, cmu library functions, (and other minor ones),
       and these packages from the MIT lisp library:
	    defstruct, loop. 
   	    [These programs are provided as a convenience to those who can't
	     access the arpanet and copy them.  There is no documentation for
	     them in the Franz Lisp manual.  The best source of documentation
	     is the Lisp Machine manual (available from MIT, Symbolics
	     or LMI)]

   Regarding Flavors:  there are two implementations of flavors for
	Franz Lisp, one from MIT (contact person Richard Zippel (rz@mit-mc))
	and one from the University of Maryland (contact person
	Liz Allen  (liz.umcp-cs@udel-relay)).  Neither implementation is
	exactly like flavors on the Lisp Machine (due to differences between
	Lisp Machine lisp and Franz Lisp), and the implementations differ
	from each other.    The MIT version cannot be distributed by 
	us (yet) due to licensing problems.   If you have a Lisp Machine
	Source license from Symbolics, you should be able to get a copy
	from MIT.
	For a Tech Report on Maryland flavors, write to Liz Allen.

What is the form of the distribution:
  The files are packaged in a giant (2.1Mbyte) shell script.  Running this
shell script through 'sh' will result in a directory tree.  A ReadMe file
in the current directory will contain instructions on building the lisp
system.  The shell script is broken into a number of smaller files.
The current distribution looks like:

total 2089
 489 -rw-r--r--  1 jkf        500003 Jan 26 11:33 opus38.50.aa
 489 -rw-r--r--  1 jkf        500002 Jan 26 11:35 opus38.50.ab
 489 -rw-r--r--  1 jkf        500047 Jan 26 11:37 opus38.50.ac
 489 -rw-r--r--  1 jkf        500007 Jan 26 11:38 opus38.50.ad
 133 -rw-r--r--  1 jkf        136038 Jan 26 11:39 opus38.50.ae

The '38.50' means Opus 38, minor version 50.  These numbers may be different
by the time you get your distribution.  In order to extract the lisp
files from this shell script, you need only type:
	cat * | sh


To get a copy of the distribution:
  The distribution may be obtained either using FTP from an arpanet site,
or on a magnetic tape through the U.S Mail.

 Arpanet:
   The files are stored on the arpanet host 'ucb-vax' [ if you have an out
   of date host table, it may be called 'ucb-monet' or 'ucb-ingres'. Its
   internet number is 10.2.0.78].
   You can login as 'anonymous'.   Use your name as the password.
   The files are in the subdirectory pub/lisp.
   
   For those who have accounts on ucb-vax, the full path is ~ftp/pub/lisp.

 Mag Tape:
   In order to get a copy of the distribution mailed to you, send a check to
 cover our tape copying and mailing costs (fees are listed below).  We will
 purchase the mag tape and you are free to keep it.  Please do NOT
 send us a tape.

     Fees:
     		$50	- distribution tape mailed 3rd class
	    add $10	- a copy of the Lisp Manual (we will only
	       		  send one copy, you are free to photocopy it)
  	    add $7	- send tape via 1st class mail.

	     -or-
	     	$15	- for just a copy of the Lisp Manual

 The address to send checks to is 

	Keith Sklower
	EECS/Computer Science Division
	524 Evans Hall
	University of California
	Berkeley, CA  94720

 All checks should be made out to "Regents, University of California."
 We require pre-payment.  We will not invoice or process purchase orders.



Disclaimers:
    This distribution works on the latest versions of Unix running at
    Berkeley (4.1a).  We can't guarantee that it will work on older
    versions (although, if you are running 4.1, it is almost certain
    that it will work, but we have not verified it).
    VMS users who are using a typical Unix compatibility package will 
    probably not be able to build a lisp from this distribution unless they
    know a great deal about VMS and their compatibility package.
    At least one package (Eunice) supports Franz at this time.
    
Redistribution:
    If you get a copy of the distribution, you are free to give it to
    other people.  We appreciate being informed of new sites so they
    can be put on a mailing list (electronic and conventional).  This
    list is used to announce new releases.  To be put on this list,
    send U.S. Mail to Keith Sklower (address above) or to 
    franz-friends-request@berkeley or ucbvax!franz-friends-request



From Kim:fateman  Mon Jan 31 19:30:20 1983
Date: 28 Jan 83 08:32:08 PST (Fri)
From: Kim:fateman (Richard Fateman)
Subject: Re:  franz distribution
Message-Id: <8300281631.21039@UCBVAX.BERKELEY.ARPA>
Received: by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA21039; 28 Jan 83 08:31:58 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA03502; 31-Jan-83 19:30:20-PST (Mon)
To: CARR@UTAH-20
Cc: franz-friends@ucbvax
Status: O

Our policy is that you may move copies of Franz elsewhere
without notifying us.  We continue to be interested in sharing anything
you or your company wish to provide us, in suggestions, programs, etc.


From UCBCAD:pettengi  Mon Jan 31 19:55:02 1983
Date: 28-Jan-83 10:54:51-PST (Fri)
From: UCBCAD:pettengi (Rob Pettengill)
Subject: emacs interface to franz?
Message-Id: <8300281854.26156@UCBCAD.BERKELEY.ARPA>
Received: by UCBCAD.BERKELEY.ARPA (3.256 [12/5/82])
	id AA26156; 28-Jan-83 10:54:51-PST (Fri)
Received: from UCBCAD.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00374; 28 Jan 83 12:53:44 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA03987; 31-Jan-83 19:55:02-PST (Mon)
To: mike@rand-unix, franz-friends@ucbvax
Cc: pettengi@UCBCAD
Status: O

	While I was at TI I used a very nice interface that let one start up
a Franz lisp inside an Emacs window.  It came from SRI when we got Eunice to run
under our VMS.  Try Kashtan@SRI-AI.

Rob Pettengill
E-Systems, Dallas, Tx.

From Kim:fateman  Mon Jan 31 21:34:44 1983
Date: 28 Jan 83 08:32:08 PST (Fri)
From: Kim:fateman (Richard Fateman)
Subject: Re:  franz distribution
Message-Id: <8300281631.21039@UCBVAX.BERKELEY.ARPA>
Received: by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA21039; 28 Jan 83 08:31:58 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00642; 31-Jan-83 21:34:44-PST (Mon)
To: CARR@UTAH-20
Cc: franz-friends@ucbvax
Status: RO

Our policy is that you may move copies of Franz elsewhere
without notifying us.  We continue to be interested in sharing anything
you or your company wish to provide us, in suggestions, programs, etc.


From UCBCAD:pettengi  Mon Jan 31 22:12:30 1983
Date: 28-Jan-83 10:54:51-PST (Fri)
From: UCBCAD:pettengi (Rob Pettengill)
Subject: emacs interface to franz?
Message-Id: <8300281854.26156@UCBCAD.BERKELEY.ARPA>
Received: by UCBCAD.BERKELEY.ARPA (3.256 [12/5/82])
	id AA26156; 28-Jan-83 10:54:51-PST (Fri)
Received: from UCBCAD.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00374; 28 Jan 83 12:53:44 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA01266; 31-Jan-83 22:12:30-PST (Mon)
To: mike@rand-unix, franz-friends@ucbvax
Cc: pettengi@UCBCAD
Status: O

	While I was at TI I used a very nice interface that let one start up
a Franz lisp inside an Emacs window.  It came from SRI when we got Eunice to run
under our VMS.  Try Kashtan@SRI-AI.

Rob Pettengill
E-Systems, Dallas, Tx.

From UCBKIM:jkf  Tue Feb  1 10:35:21 1983
Date: 1-Feb-83 10:32:24-PST (Tue)
From: UCBKIM:jkf (John Foderaro)
Subject: multiple messages
Message-Id: <8301011832.599@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00599; 1-Feb-83 10:32:24-PST (Tue)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00473; 1 Feb 83 10:32:35 PST (Tue)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA00644; 1-Feb-83 10:35:21-PST (Tue)
To: franz-friends@ucbvax
Status: RO

  I'm sorry for the multiple messages.  The franz-friends mailing list is
huge and the machine which does the mailing is crashing often.  Our local
mail wizard informs me that if it crashes while in the middle of sending
mail it will not have a record of who it sent to before the crash.
  I hope you don't get too many copies of this message.
  
  



From mike@rand-unix  Wed Feb  2 05:33:01 1983
Date: Tuesday,  1 Feb 1983 15:06-PST
From: mike@RAND-UNIX
Subject: response to "emacs interface to franz?"
Message-Id: <8301021325.221@UCBVAX.BERKELEY.ARPA>
Received: from rand-unix by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00221; 2 Feb 83 05:25:50 PST (Wed)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA24463; 2-Feb-83 05:33:01-PST (Wed)
To: franz-friends@BERKELEY
Cc: mike@RAND-UNIX
Status: RO


Here are the responses that I received to my question "What's out
there for emacs?"  


------- Forwarded Messages

Received: From SU-SCORE by RAND-UNIX at Mon Jan 24 23:41:37 1983
Date: Mon 24 Jan 83 22:43:01-PST
From: Jay Lark <CSD.LARK@SU-SCORE.ARPA>
Subject: Re: emacs interface to franz?
To: mike@RAND-UNIX.ARPA
In-Reply-To: Your message of Mon 24 Jan 83 18:49:21-PST

I'm sure you've probably received several messages similar to this one,
but just in case...

There exists the capability in Unix Emacs to run a process in its own
buffer.  Typein can be directed to the process, and output is just sent
right to the buffer.  This is an excellent way of running Lisp, because 
you get all of the nice Emacs features (paren balancing, local sexpr
editing) at essentially no cost.  I have been largely unsuccessful with
trying to run Emacs under Lisp.

The process package is part of the standard Unix Emacs distribution.

Jay Lark
-------


------- Message 2

Received: From UTAH-CS by RAND-UNIX at Tue Jan 25 07:01:36 1983
Date: 25 Jan 1983 7:20-MST
From: Russ Fish <utah-gr!fish@UTAH-CS> (host 10.0.0.4)
Subject: Re: emacs interface to franz?
To: mike@RAND-UNIX
Cc: utah-gr!galway@UTAH-CS
In-Reply-To: mike's message of Monday, 24 Jan 1983 15:34-PST

We have been running our PSL (Portable Standard Lisp) in gemacs
(Gosling's emacs) windows for some time.  I suspect it would be a minor
hack to convert it to Franz, but haven't done it and am not a Franz
user.  I could mail you our .ml code if you wanted to undertake
converting it to Franz (or just using it for inspiration and hacking
your own) and distributing it to Franz folks.

It works like this:  The lisp process is associated with a gemacs
buffer/window.  In that window you can carry on a normal line-by-line
conversation, if you wish.  <CR> sends the current line, (back to mark,
which is left after the prompt) into the lisp.  We mostly use the PSL
in Rlisp syntax, which is algol-like, but this part of the code is just
a wrapping for the new-shell function in process.ml with appropriate
editting syntax set, so you could do the same with no work for any
Lisp.

You can send an expression, fn def, etc. from any other lisp-mode
window with a single keypress.  Echoing as input in the dialog window
is inhibited if a prefix arg is provided, so you don't have to look at
long exprs or fn defs again, just the lisp response.  

Sending multiple line exprs in response to a single prompt depends on
the fact that PSL numbers the prompts for history, like the c-shell.  A
gemacs mlisp output filter process monitors the output for toploop
prompts and feeds another line of input if the same prompt number comes
back, instead of printing the prompt.

The result is pretty classy.  You get the full many-window gemacs
editing environment with tags, etc. for random-access navigation and
just send chunks of code as you change them.  The extreme of usage is
"menu" like windows which contain debugging code in clusters rather
than sequences.  You select exprs with the cursor and send them in any
order.

We also provide key fns for the common case of sending single lines to
the toploop or single-character commands to the break-loop without
editting them into a buffer.

Best respond directly to me, since I am not on Franz-Friends.

-Russ Fish  (Fish@Utah-20, utah-cs!fish)



------- Message 3

Received: From UDEL-RELAY by RAND-UNIX at Tue Jan 25 18:18:55 1983
Return-Path: <israel.umcp-cs@UDel-Relay>
Date:     25 Jan 83 15:13:51 EST  (Tue)
From: Bruce Israel <israel.umcp-cs@UDel-Relay>
Subject:  Re:  emacs interface to franz?
To: mike@RAND-UNIX
In-Reply-To: Message of Monday, 24 Jan 1983 15:34-PST from mike@RAND-UNIX
		<8300250008.58@UCBVAX.BERKELEY.ARPA>
Via:  UMCP-CS; 25 Jan 83 20:45-EST

We have a few franz<->emacs interfaces, but I'm not sure what you mean.
One is the process.ml package that comes with gosling's emacs (the emacs
that I assume you are talking about).  With this package, you can run
franz inside a window from within emacs and have the facilities of an
editor along with lisp.  The other thing we have is a local Franz
package called the load1 package.  This package was written for
compiling flavors (like in the lisp machine; another local package)
and has a function called vi.  (vi 'lisp-function) will call the
editor (from the environment variable VISUAL, /usr/ucb/vi is default) on the
file which contains the definition of the lisp function, positioning
the editor at the point in the file where the function is defined.  Upon
exiting the editor, it asks you if you want to reload the modified file.
To edit a function from a file this way, the file must have been load1'ed
previously so that the info on where the function is stored and what type
it is will have been saved.  Load1 will distinguish between different
types of functions, ie. defflavors, defmethods, defmacros, defuns etc.
and will search for the correct definition in the file.  Is this what
you mean?  If you like I can send you the four or five files necessary.
- Bruce


------- Message 4

Received: From CMU-CS-VLSI by RAND-UNIX at Thu Jan 27 06:53:41 1983
Date: 27 Jan 1983 09:44-EST
From: Carl.Ebeling@CMU-CS-VLSI
Subject: Re: emacs interface to franz?
To: mike@RAND-UNIX
Message-Id: <412526661/ce@CMU-CS-VLSI>
In-Reply-To: mike@RAND-UNIX's bboard message of 27-Jan-83 04:14    

I have an electric lisp package and process package for emacs.  It
includes 'zap-function-to-lisp' among other things.  It is for
Gosling's emacs and uses the subprocess facility.  I can mail them to
you if you like.
	Carl


------- End of Forwarded Messages

From UCBKIM:jkf  Wed Feb  2 08:19:19 1983
Date: 2-Feb-83 08:14:21-PST (Wed)
From: UCBKIM:jkf (John Foderaro)
Subject: multiple messages fixed?
Message-Id: <8301021614.25937@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA25937; 2-Feb-83 08:14:21-PST (Wed)
Received: from UCBKIM.BERKELEY.ARPA by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00384; 2 Feb 83 08:10:26 PST (Wed)
Received: by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA00477; 2 Feb 83 08:14:35 PST (Wed)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA26020; 2-Feb-83 08:19:19-PST (Wed)
To: franz-friends@ucbvax
Status: RO

 I've broken the franz-friends mailing list over two machines.  I hope that
this will fix the problem of mail to franz-friends crashing ucbvax every
thirty minutes.   If you get multiple copies of this message, please do not
tell me about it, I will already know.




From jkf  Thu Feb 10 21:45:17 1983
Date: 10-Feb-83 21:45:17-PST (Thu)
From: jkf (John Foderaro)
Subject: liszt 8.21
Message-Id: <8301110545.16021@UCBKIM.BERKELEY.ARPA>
Received: by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA16021; 10-Feb-83 21:45:17-PST (Thu)
To: local-lisp
Status: O

  more functions open coded: vsize, vsize-byte, vsize-word,
  	vectorp, vectorip
	


From PSI.KROHNFELDT@UTAH-20  Fri Feb 11 15:09:11 1983
Date: 11 Feb 1983 1601-MST
From: Jed Krohnfeldt <PSI.KROHNFELDT@UTAH-20>
Subject: cfasl
Message-Id: <8301112302.7475@UCBVAX.BERKELEY.ARPA>
Received: from UTAH-20 by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA07475; 11 Feb 83 15:02:05 PST (Fri)
Received: by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA07565; 11 Feb 83 15:06:37 PST (Fri)
Received: from UCBVAX.BERKELEY.ARPA by UCBKIM.BERKELEY.ARPA (3.256 [12/5/82])
	id AA14422; 11-Feb-83 15:09:11-PST (Fri)
To: Franz-friends@UCBVAX
Status: O

I am having trouble using cfasl in franz 38.04.  I keep getting the
message "ld: /usr/ucb/lisp : no namelist".  Can anyone decipher this
for me?  Thanks...
-------

From apm@cmu-ri-isl  Mon Feb 14 07:31:54 1983
Date: 14 Feb 1983 10:24:21-EST
From: Andrew.Mendler@CMU-RI-ISL
Subject: franz lisp under5 vms 3.0
Message-Id: <8302141531.27879@UCBVAX.ARPA>
Received: from CMU-RI-ISL by UCBVAX.ARPA (3.310/3.3)
	id AA27879; 14 Feb 83 07:31:54 PST (Mon)
Received: by UCBKIM.ARPA (3.310/3.3)
	id AA01172; 14 Feb 83 15:50:41 PST (Mon)
To: franz-friends@BERKELEY.ARPA
Status: O

Does anyone have a copy of Franz Lisp and the compiler that works under
VMS version 3.0?  

From @udel-relay:tim.unc@UDel-Relay  Mon Feb 14 02:52:18 1983
Date:     13 Feb 83 14:34:48 EST  (Sun)
From: Tim Maroney <tim.unc@UDel-Relay>
Subject:  cfasl: no namelist
Return-Path: <tim.unc@UDel-Relay>
Message-Id: <8302141052.25792@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.310/3.3)
	id AA25792; 14 Feb 83 02:52:18 PST (Mon)
Received: by UCBKIM.ARPA (3.310/3.3)
	id AA02234; 14 Feb 83 16:18:42 PST (Mon)
To: franz-friends@BERKELEY.ARPA
Via:  UNC; 14 Feb 83 5:43-EST
Status: O

I don't seem to be able to write Jed Krohnfeldt, and this
answer is probably of general interest anyway. The message
"ld: no namelist" means that some well-meaning system admin
has stripped the lisp executable file to save space;
unfortunately, this makes the dynamic loading used by cfasl
impossible. Lisp will have to be recompiled (groan). No Franz
Lisp executable file should EVER be stripped.

Tim Maroney
tim.unc@udel-relay
decvax!duke!unc!tim

From Mark.Sherman@CMU-CS-A  Sat Feb 12 21:38:46 1983
Date: 13 February 1983 0034-EST (Sunday)
From: Mark.Sherman@CMU-CS-A
Subject: Space and Leakage
Message-Id: <13Feb83 003422 MS40@CMU-CS-A>
Received: from CMU-CS-A by UCBVAX.BERKELEY.ARPA (3.300 [1/17/83])
	id AA07842; 12 Feb 83 21:38:46 PST (Sat)
Received: by UCBKIM.ARPA (3.310/3.3)
	id AA02341; 14 Feb 83 16:21:29 PST (Mon)
To: franz-friends@UCB-VAX
Status: O

Can someone tell me how the maximum amount of storage that franz
lisp uses is decided? I can force the size up to (about) 3050
pages (according to "ps") and then get the message "storage exhausted".
I have been told (and have seen) other jobs get substantially more
space; can franz get more pages as well? (I am using the cshell
and have already used the limit command to raise my process
size up to 32 megabytes, or so I think.)
 
I have also been told that the garbage collector leaks, that is,
not all of the garbage is really collected. Does anyone have good
ideas about how much (or fast) this happens, or if there is some way
to minimize the lost space?
 
(Please send responses directly to me as I am not on this list.)
                        -Mark Sherman (Sherman@CMU-CS-A)

From @udel-relay:Mac.uvacs.Virginia@UDel-Relay  Fri Feb 18 21:04:31 1983
Date:     18 Feb 83 12:42:40-EST (Fri)
From: Mac.uvacs@UDel-Relay
Subject:  global nonspecial variables
Return-Path: <Mac.uvacs.Virginia@UDel-Relay>
Message-Id: <8302190504.26020@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.312/3.5)
	id AA26020; 18 Feb 83 21:04:31 PST (Fri)
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA00656; 21 Feb 83 01:59:26 PST (Mon)
To: FRANZ-FRIENDS@BERKELEY.ARPA
Via:  Virginia; 18 Feb 83 23:58-EST
Status: O

Does the Liszt compiler have any notion of global variables --
free variables with fast access, without any rebinding?

I think the MACLISP compiler has something like this for variables
beginning "**".

				Alex Colvin

				uucp: ...decvax!duke!mcnc!ncsu!uvacs!mac
				csnet:mac@virginia
				arpa: mac.uvacs@udel-relay

From jkf@UCBKIM  Mon Feb 21 09:19:56 1983
Date: 21 Feb 83 09:19:43 PST (Mon)
From: jkf@UCBKIM (John Foderaro)
Subject: Re:  global nonspecial variables
Message-Id: <8302211719.2798@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA02798; 21 Feb 83 09:19:43 PST (Mon)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.314/3.5)
	id AA13982; 21 Feb 83 09:11:52 PST (Mon)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA02805; 21 Feb 83 09:19:56 PST (Mon)
To: Mac.uvacs@UDel-Relay, FRANZ-FRIENDS@BERKELEY.ARPA
In-Reply-To: Your message of     18 Feb 83 12:42:40-EST (Fri)
Status: O

  I don't understand the distinction between what you call a global variable
and a special variable.   A special variable in Franz Lisp (and any other
shallow bound lisp) can be accessed rapidly and is only rebound if you
put it in a lambda, prog or do variable list.



From jkf@UCBKIM  Fri Feb 25 08:29:01 1983
Date: 25 Feb 83 08:28:45 PST (Fri)
From: jkf@UCBKIM (John Foderaro)
Subject: research position at edinburgh
Message-Id: <8302251628.528@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA00528; 25 Feb 83 08:28:45 PST (Fri)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.314/3.5)
	id AA00867; 25 Feb 83 08:18:48 PST (Fri)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA00537; 25 Feb 83 08:29:01 PST (Fri)
To: franz-friends@BERKELEY.ARPA
Status: O


                    DEPARTMENT OF ARTIFICIAL INTELLIGENCE
                           UNIVERSITY OF EDINBURGH

                              RESEARCH FELLOW

A Research Fellowship is available within the Programming Systems Development
Group.  The post has been created specifically to provide a modern LISP system
for the Perq computer running under ICL MicroCode UNIX, and is funded by the
Science and Engineering Research Council.

Experience in implementing systems would be advantageous, as would be a
knowledge of LISP and C.  Access will be available to an SERC DECsystem-10
running TOPS-10 and to a University VAX 750 running Berkeley UNIX, as well as
to Perqs.

The appointment will be made on the salary range 1B/1A, 5550 - 10670 pounds
sterling, according to age and experience.  The post is funded for a period of
two years from the date of appointment.

Further particulars of the post can be obtained from:

	Administrative Assistant
	Department of Artificial Intelligence
	University of Edinburgh
	Forrest Hill
	Edinburgh  EH1 2QL
	SCOTLAND
phone
	031-667-1011 x2554

or by contacting

	RAE%EDXA%UCL-CS@ISID		(Networks permitting)

Applications should be made by March 17th, 1983.




From layer  Sat Mar  5 20:12:57 1983
Date: 5 Mar 83 20:12:57 PST (Sat)
From: layer (Kevin Layer)
Subject: process function
Message-Id: <8303060412.18927@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA18927; 5 Mar 83 20:12:57 PST (Sat)
Phone: (415) 652-2405
To: local-lisp
Status: O

The process function now looks in the environment at the SHELL variable.
If present, it will use this as the default shell to execute your command.
If not present, csh and then sh are tried (in that order).


From @udel-relay.ARPA:Pintzuk.UPenn.UPenn@UDel-Relay  Tue Mar  8 06:04:10 1983
Date:  8 Mar 1983  2:32-EST
From: Susan Pintzuk <Pintzuk.UPenn@UDel-Relay>
Subject: lisp statistical packages
Return-Path: <Pintzuk.UPenn.UPenn@UDel-Relay>
Message-Id: <8303081401.AA13004@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.322/3.14)
	id AA13004; 8 Mar 83 06:01:54 PST (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA08297; 8 Mar 83 06:04:10 PST (Tue)
To: franz-friends@BERKELEY.ARPA
Via:  UPenn; 8 Mar 83 3:49-EST
Status: O

do any franz-lisp packages exist which calculate mean, standard deviation,
%n within mean +/- 1 (or 2 or 3) standard deviation(s), etc.?  if so, how
do i obtain a copy?

From jkf  Tue Mar  8 09:10:46 1983
Date: 8 Mar 83 09:10:46 PST (Tue)
From: jkf (John Foderaro)
Subject: opus38.56
Message-Id: <8303081710.9423@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA09423; 8 Mar 83 09:10:46 PST (Tue)
To: local-lisp
Status: O

  If $gcprint is set to a non nil value, then just before a garbage
collection is begun, the message 'gc:' will be printed on the tty.
As before, after the garbage collection is finished, the statistics
message in square brackets will be printed.



From fateman  Wed Mar  9 09:54:31 1983
Date: 9 Mar 83 09:54:31 PST (Wed)
From: fateman (Richard Fateman)
Subject: need a job 
Message-Id: <8303091754.14754@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA14754; 9 Mar 83 09:54:31 PST (Wed)
To: local-lisp
Status: O

porting Lisp, C, Pascal, Fortran ... etc to a Denelcorp HEP
computer?  Wanna live in Denver?  There is a recruiter in
town from Denelcor at Marriot Inn, Jim Holly.  There is an
ad posted on 5th floor bulletin board.

From jkf  Sat Mar 19 17:44:33 1983
Date: 19 Mar 83 17:44:33 PST (Sat)
From: jkf (John Foderaro)
Subject: liszt 8.24
Message-Id: <8303200144.25091@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA25091; 19 Mar 83 17:44:33 PST (Sat)
To: local-lisp
Status: O

  The vax and 68k versions of liszt have been combined into one set of
source files.  This is mainly a textual change, but some functions
in the compiler have been modified in reduce the machine dependent code.
Be on the lookout for strange errors.



From fateman  Tue Mar 22 20:52:11 1983
Date: 22 Mar 83 20:52:11 PST (Tue)
From: fateman (Richard Fateman)
Subject: T Lisp
Message-Id: <8303230452.5935@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA05935; 22 Mar 83 20:52:11 PST (Tue)
To: local-lisp
Status: RO

I have a preliminary manual for the T dialect of Lisp, created
at Yale.  It is being offered for sale by Cognitive Systems, Inc.
for $1000/CPU (educational price).  It offers features from Lisp
and Scheme.  It runs on VAX and Apollo 68000 systems.  

From jkf  Thu Mar 24 08:29:31 1983
Date: 24 Mar 83 08:29:31 PST (Thu)
From: jkf (John Foderaro)
Subject: liszt 8.25
Message-Id: <8303241629.6735@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA06735; 24 Mar 83 08:29:31 PST (Thu)
To: local-lisp
Status: O


  If you do this:

  liszt -x a/b/c.l -o x/y/z.o

  then the cross reference file will be put in x/y/z.x 
  Before this version, it would have gone into a/b/c.x
  


From jkf  Thu Mar 24 15:00:37 1983
Date: 24 Mar 83 15:00:37 PST (Thu)
From: jkf (John Foderaro)
Subject: liszt 8.26
Message-Id: <8303242300.11144@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA11144; 24 Mar 83 15:00:37 PST (Thu)
To: local-lisp
Status: O

  liszt will now pass the assembler the -V switch.  This tells the assembler
to keep its intermediate file in core rather than putting it in /tmp.
This should make assembly slightly faster and also permit large lisp files to
be compiled on systems with small /tmp's.



From @udel-relay.ARPA:tim.unc@UDel-Relay  Sat Mar 26 03:41:05 1983
Date:     25 Mar 83 15:03:29 EST  (Fri)
From: Tim Maroney <tim.unc@UDel-Relay>
Subject:  open coding of (function (lambda ...))
Return-Path: <tim.unc@UDel-Relay>
Message-Id: <8303261137.AB02371@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.331/3.17)
	id AB02371; 26 Mar 83 03:37:13 PST (Sat)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA00854; 26 Mar 83 03:41:05 PST (Sat)
To: franz-friends@BERKELEY.ARPA
Via:  UNC; 25 Mar 83 19:43-EST
Status: O

This doesn't seem to work. I'm using Liszt version 8.10, University
of Maryland distribution. The documentation in the file "lispnews"
is sketchy, but it seems that compiling and loading the file:

(setq appsum (function (lambda (x) (apply 'sum x))))

should leave a bcd object in appsum's value, but it doesn't. It
leaves the uncompiled lambda. Am I doing something wrong? 

Tim Maroney
decvax!duke!unc!tim
tim.unc@udel-relay

From jkf@UCBKIM  Sat Mar 26 08:46:44 1983
Date: 26 Mar 83 08:46:28 PST (Sat)
From: jkf@UCBKIM (John Foderaro)
Subject: Re:  open coding of (function (lambda ...))
Message-Id: <8303261646.2453@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA02453; 26 Mar 83 08:46:28 PST (Sat)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.331/3.17)
	id AA05012; 26 Mar 83 08:42:50 PST (Sat)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA02462; 26 Mar 83 08:46:44 PST (Sat)
To: tim.unc@UDel-Relay
Cc: franz-friends@BERKELEY.ARPA
In-Reply-To: Your message of     25 Mar 83 15:03:29 EST  (Fri)
Status: O


   Liszt only compiles functions, not literals it finds in files.
To make this statement be compiled:
(setq appsum (function (lambda (x) (apply 'sum x))))

you should surround it with a function defintion:
(defun junk ()
	(setq appsum (function (lambda (x) (apply 'sum x)))))



From CARR@UTAH-20  Mon Apr  4 14:53:09 1983
Date:  4 Apr 1983 0922-MST
From: Harold Carr <CARR@UTAH-20>
Subject: Franz/Common lisp
Message-Id: <8304041711.AA07020@UCBVAX.ARPA>
Received: from UTAH-20 (utah-20.ARPA) by UCBVAX.ARPA (3.332/3.20)
	id AA07020; 4 Apr 83 09:11:40 PST (Mon)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA01683; 4 Apr 83 14:53:09 PST (Mon)
To: franz-friends@BERKELEY.ARPA
Cc: KROHNFELDT@UTAH-20
Status: O

Does anyone have any sort of Common Lisp compatibility package for Franz?
If so, how can I obtain it? Thanks in advance. Harold Carr (CARR@UTAH-20).
-------

From jeff@aids-unix  Tue Apr  5 12:42:46 1983
Date:  4 Apr 1983 11:06:49 PST (Monday)
From: Jeff Dean <jeff@aids-unix>
Subject: knowledge representation language
Message-Id: <8304052042.AA26557@UCBVAX.ARPA>
Received: from aids-unix (aids-unix.ARPA) by UCBVAX.ARPA (3.332/3.20)
	id AA26557; 5 Apr 83 12:42:11 PST (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA16443; 5 Apr 83 12:42:46 PST (Tue)
To: franz-friends@BERKELEY.ARPA
Status: O

Does anyone have a knowledge representation language (such as FRL or
KL-ONE) available under Franz Lisp?

	Jeff Dean
	arpa: jeff@aids-unix
	uucp: ...ucbvax!jeff@aids-unix


From jkf  Tue Apr  5 13:08:06 1983
Date: 5 Apr 83 13:08:06 PST (Tue)
From: jkf (John Foderaro)
Subject: lisp opus 38.57
Message-Id: <8304052108.16969@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA16969; 5 Apr 83 13:08:06 PST (Tue)
To: local-lisp
Status: RO

  This version has a number of internal changes to make it compilable
on 68k.  If you notice it acting abnormally, let me know.



From FAHLMAN@CMU-CS-C  Thu Apr  7 07:50:06 1983
Date: Thu, 7 Apr 1983  10:46 EST
From: Scott E. Fahlman <Fahlman@CMU-CS-C>
Subject: Franz/Common lisp
Message-Id: <8304071549.AA13873@UCBVAX.ARPA>
Received: ID <FAHLMAN@CMU-CS-C>; 7 Apr 83 10:46:59 EST
Received: from CMU-CS-C (cmu-cs-c.ARPA) by UCBVAX.ARPA (3.332/3.20)
	id AA13873; 7 Apr 83 07:49:42 PST (Thu)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA18082; 7 Apr 83 07:50:06 PST (Thu)
To: Harold Carr <CARR@UTAH-20>
Cc: franz-friends@BERKELEY.ARPA
In-Reply-To: Msg of 4 Apr 1983  11:22-EST from Harold Carr <CARR at UTAH-20>
Status: RO


Harold,

A couple of things make it seem unlikely that anyone would have such a
package right now.  First, we don't even have a final Common Lisp manual
yet -- Guy's next draft is due very soon, but there will be some tuning
and hassling after that.  Second, there are things in Common Lisp that
would be very tough to fake on Franz: lexical binding, generic
sequences, some of the hairy number types, character objects, etc.
Common Lisp is pretty close to being a superset of Franz, so I would
expect to see Franz compatibility packages in Common Lisp, but not vice
versa.  Third, if anyone were writing such a package, they would be
crazy not to have arranged for access to our code that implements all of
the hairy functions, and nobody has done this to my knowledge.

My standard advice is for people to continue to code in Franz with the
knowledge that they can easily convert their code to Common Lisp
whenever the DEC Common Lisp is available to them.  This should be a
one-time conversion, since moving the other way after "going native" in
Common Lisp would be very tough.

If someone does pop up with a compatibility package -- even a partial
one -- I would be interested in hearing about it.

-- Scott

From fateman@UCBKIM  Sun Apr 10 19:52:14 1983
Date: 10 Apr 83 19:50:59 PST (Sun)
From: fateman@UCBKIM (Richard Fateman)
Subject: Re:  Franz/Common lisp
Message-Id: <8304110350.6176@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA06176; 10 Apr 83 19:50:59 PST (Sun)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.332/3.21)
	id AA10019; 10 Apr 83 19:49:55 PST (Sun)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA06192; 10 Apr 83 19:52:14 PST (Sun)
To: carr@utah-20, fahlman@cmu-cs-c
Cc: franz-friends@BERKELEY.ARPA
Status: RO

I think that a common-lisp-compatibility package written
in Franz would not be as difficult as all that. 

If Common Lisp (TM of DEC?) were available on all the same
machines at the same price, (appx. $0.) and CL were
in fact a superset of Franz for all practical purposes, and
with similar or better efficiency, etc. Why would anyone bother?

Of course if CL does not meet all of the objectives (e.g. price, machines),
then a CL-to-Franz "translator" might make sense.

With that in mind,
I would like to officially request a copy of the Common Lisp
language (as implemented in CL, presumably), as soon as it
becomes available (i.e. no later than when it is a "product"
of DEC, and probably at "beta" test time).
I agree fully with Scott that trying to do this with an incomplete
language specification is unwise.

I am also not making any commitment to do anything with CL at
Berkeley, but since we are building tools for our own applications,
and CL might be useful, we might consider an efficient merge of
ideas.

From jkf@UCBKIM  Mon Apr 11 08:07:39 1983
Date: 11 Apr 83 06:42:43 PST (Mon)
From: jkf@UCBKIM (John Foderaro)
Subject: mail to this mailing list
Message-Id: <8304111442.11378@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA11378; 11 Apr 83 06:42:43 PST (Mon)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.332/3.21)
	id AA07288; 11 Apr 83 08:05:32 PST (Mon)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.310/3.5)
	id AA11949; 11 Apr 83 08:07:39 PST (Mon)
To: franz-friends@BERKELEY.ARPA
Status: RO

  I'm sorry that people who mail to this mailing list must put up with lots
 of mail errors from our local mailer.   The problem is not that we have a
 lot of illegal addresses, but that over the three day period that the
 mailer tries to deliver the mail, some of the destination sites never
 respond.  I think that this is due primarily to the fact that many sites
 are running new mail and networking software.   Hopefully this will
 improve over time.
 					john foderaro
					



From jkf  Fri Apr 22 09:59:09 1983
Date: 22 Apr 83 09:59:09 PST (Fri)
From: jkf (John Foderaro)
Subject: lisp opus 38.59
Message-Id: <8304221759.20996@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA20996; 22 Apr 83 09:59:09 PST (Fri)
To: local-lisp
Status: RO

  Input like 1.2.3 and 1..2  will now be read as single symbols rather
than two consecutive numbers.



From jkf  Sun May  8 00:02:54 1983
Date: 8 May 83 00:02:54 PDT (Sun)
From: jkf (John Foderaro)
Subject: opus 38.60
Message-Id: <8305080702.22344@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.310/3.5)
	id AA22344; 8 May 83 00:02:54 PDT (Sun)
To: local-lisp
Cc: rms
Status: RO

 Thanks to some suggestions from rms we are now one step closer to
full closures.   fclosures will now work if called recursively.
It is still true that the only way to make fclosures share variables
is to use fclosure-list.

 symeval-in-fclosure may return the wrong value if the closure is 
'active'.  This will be fixed eventually.



From mbr@nprdc  Sat May 21 07:37:23 1983
Date: 20 May 1983 14:57:55-PDT
From: mbr@NPRDC
Subject: lam9.c and curses
Message-Id: <8305211434.AA16172@UCBVAX.ARPA>
Received: from nprdc (nprdc.ARPA) by UCBVAX.ARPA (3.341/3.29)
	id AA16172; 21 May 83 07:34:43 PDT (Sat)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA08856; 21 May 83 07:37:23 PDT (Sat)
Reply-To: mbr <mbr@NPRDC>
To: franz-friends@BERKELEY.ARPA
Cc: mbr@NPRDC
Status: O

When we attempted to cfasl a file that used the curses package
of screen control routines into Franz 38.40, we got the message
_ospeed: /usr/libcurses.a (cr_tty.o) multiply defined.
The apparent cause of this cryptic remark is that in lam9.c
there is an extern variable ospeed. There are a number of
tantalizing routines in this source file dealing with termcaps that
are apparently not called by anyone. Are there plans for these
routines? Does anyone use them (heaven forbid they should be
documented!). Our current fix is to just change ospeed to ospiid
which so far has had no dire effects, but I am interested in others
experience. The curses stuff seems to work fine after this
modification.
			Mark Rosenstein


From jkf  Wed May 25 12:15:54 1983
Date: 25 May 83 12:15:54 PDT (Wed)
From: jkf (John Foderaro)
Subject: opus 38.61
Message-Id: <8305251915.1144@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA01144; 25 May 83 12:15:54 PDT (Wed)
To: local-lisp
Status: O

  symeval-in-fclosure and set-in-fclosure now work (thanks to keith).

  selectq is now a part of standard franz.  selectq is just like
 caseq except it allows 'otherwise' as well as 't' for the
 key which means 'if nothing else matches, use this clause'.
 
 


From cornwell@nrl-css  Wed May 25 12:51:17 1983
Date: Wed, 25 May 83 15:14:19 EDT
From: Mark Cornwell <cornwell@NRL-CSS>
Subject: Franz on the Sun
Message-Id: <8305251950.AA02600@UCBVAX.ARPA>
Received: from nrl-css (nrl-css.ARPA) by UCBVAX.ARPA (3.341/3.29)
	id AA02600; 25 May 83 12:50:26 PDT (Wed)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA01878; 25 May 83 12:51:17 PDT (Wed)
To: franz-friends@BERKELEY.ARPA
Cc: cornwell@NRL-CSS
Status: O


  Our group at NRL is planning to purchase Sun workstations. I
currently have a substantial amount of code written in Franz Lisp that
I want to run on the Sun. 
 
  What is the status of the Berkeley group porting Franz to the Sun?   
How do I get a copy?

  Also, I have a few concerns about configuring a Sun to run Franz well.  
The basic desktop Sun workstation provides 1 Mbyte of physical memory.   
This can be extended to 2 Mbyte or one can add an Ethernet interface
*but not both*.  Since I am unwilling to give up my Ethernet
interface I may be forced to run Franz in 1 Mbyte and contend with
the added paging overhead (using a 68010 running 4.2bsd and a local disk).

  Has anyone out there had experience running Franz Lisp on a Sun in
such a configuration?  Can I get away without the 2 Mbyte extension?
I think your answers would be of general interest. 

-- Mark (caught between a rock and a hard place?) Cornwell

 

From baden@UCBKIM  Wed May 25 13:51:39 1983
Date: 25 May 83 13:32:01 PDT (Wed)
From: baden@UCBKIM (Scott B. Baden)
Subject: Re:  Franz on the Sun
Message-Id: <8305252032.2716@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA02716; 25 May 83 13:32:01 PDT (Wed)
Received: from UCBKIM.ARPA by UCBVAX.ARPA (3.341/3.29)
	id AA03753; 25 May 83 13:50:52 PDT (Wed)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA03002; 25 May 83 13:51:39 PDT (Wed)
To: franz-friends@BERKELEY.ARPA
Cc: cornwell@NRL-CSS
Status: O

Which sun are you using?  My office mate says that
he has seen a sun configured with 2MB of memory AND
an Ethernet board.

From mike%Rice.Rice@Rand-Relay  Fri May 27 19:51:33 1983
Date:     Fri, 27 May 83 18:18:47 CDT
From: Mike.Caplinger <mike.rice@Rand-Relay>
Subject:  Re:  Franz on the Sun
Return-Path: <mike%Rice.Rice@Rand-Relay>
Message-Id:  <1983.05.27.18.18.47.150.08942@dione.rice>
Received: from rand-relay.ARPA by UCBVAX.ARPA (3.341/3.29)
	id AA19088; 27 May 83 19:50:15 PDT (Fri)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA02221; 27 May 83 19:51:33 PDT (Fri)
To: franz-friends@BERKELEY.ARPA
In-Reply-To: baden%UCBKIM's message of 25 May 83 13:32:01 PDT (Wed)
Via:  Rice; 27 May 83 19:14-PDT
Status: RO

As I type I'm bringing up the 68K version of Opus 38 (now FTPable from
UCB-VAX) on a SUN running 4.1c.  There don't seem to be any major
problems so far, but the compiler doesn't run on a system with all the
net servers on it because it runs out of memory.  I've been told this
is because there's a bug in 4.1c that forces it to only use 1/2 of the
swap partition.  I'm having to run standalone to compile the compiler;
I don't yet know whether I'll be able to compile other stuff without
this rather extreme fix.

As I use the system more I will post more info to this group.

From narain@rand-unix  Tue May 31 10:49:00 1983
Date: Tuesday, 31 May 1983 10:45-PDT
From: narain@rand-unix
Subject: Interrupt question
Message-Id: <8305311747.AA10893@UCBVAX.ARPA>
Received: from rand-unix (rand-unix.ARPA) by UCBVAX.ARPA (3.341/3.29)
	id AA10893; 31 May 83 10:47:26 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA13428; 31 May 83 10:49:00 PDT (Tue)
To: franz-friends@BERKELEY.ARPA
Cc: narain@rand-unix
Status: O


Hi, I would be grateful if you could tell me  what  is  the  equivalent  of
Interlisp's  control-h  (followed  by  OK) in Franzlisp.  In other words, I
wish to interrupt a Franzlisp program, from time to time, examine its state
and allow it to continue from the interrupted point.

-- Sanjai

From lbl-csam!steve@ssc-vax.UUCP  Tue May 31 19:31:04 1983
Date: 31 May 83 17:28:35 PDT (Tue)
From: ssc-vax!steve@lbl-csam.UUCP
Subject: packages
Message-Id: <8306010028.AA16451@LBL-CSAM.ARPA>
Received: by LBL-CSAM.ARPA (3.320/3.21)
	id AA16451; 31 May 83 17:28:35 PDT (Tue)
Received: by UCBVAX.ARPA (3.341/3.31)
	id AA02877; 31 May 83 19:30:00 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA22745; 31 May 83 19:31:04 PDT (Tue)
To: ucbvax!franz-friends@lbl-csam.UUCP
Status: O


Does a version of LispMachine ``packages'' or some similar oblist partitioning
scheme exist for franz?  Having just integrated several independently coded
modules, I think something like that would be very useful.
					-thanks
	Steve White, BAC, {uw-beaver,lbl-csam}!ssc-vax!steve


From fateman  Tue Jun 14 11:48:32 1983
Date: 14 Jun 83 11:48:32 PDT (Tue)
From: fateman (Richard Fateman)
Subject: "macsyma on a chip?"
Message-Id: <8306141848.6756@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA06756; 14 Jun 83 11:48:32 PDT (Tue)
To: macsyma-i@mit-mc
Cc: franz-friends
Status: O

Well, sort of. We now have Macsyma running on a Motorola 68000 - based
system with 6 megabytes of real memory. The operating system is a 
Unisoft UNIX system, which has been ported to some large number (>65) boxes.  
The Pixel people were kind enough to lend us a machine with enough 
real memory to make virtual memory unnecessary.

It takes a long time to load up, but once running, it is quite responsive,
and appears to be about 60% of a VAX 11/780 in terms of CPU time. 

We have not shaken down everything, but since the source code is unchanged
from the VAX, we expect the bugs to be limited to lisp compilation
glitches, or differences between versions of the UNIX system.


From jkf  Wed Jun 15 10:42:05 1983
Date: 15 Jun 83 10:42:05 PDT (Wed)
From: jkf (John Foderaro)
Subject: Opus 38.62
Message-Id: <8306151742.20591@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA20591; 15 Jun 83 10:42:05 PDT (Wed)
To: local-lisp
Status: O

  There is no longer a limit on the size of bignums, strings or
symbol names which can be read by the reader [other than the size of
virtual memory].

  The value of lisp-library-directory will determine where cfasl finds
its private version of the loader.

 (changes by sklower)


From @CMU-CS-C:UI.TYJ@CU20D  Wed Jun 15 18:22:55 1983
Date: 14 Jun 1983 1812-EDT
From: Tai Jin <UI.TYJ@CU20D>
Subject: franz mailing liszt
Message-Id: <8306142214.AA16599@UCBVAX.ARPA>
Received: from CMU-CS-C (cmu-cs-c.ARPA) by UCBVAX.ARPA (3.346/3.33)
	id AA16599; 14 Jun 83 15:14:36 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA28806; 15 Jun 83 18:22:55 PDT (Wed)
To: franz-friends%berkeley@CMCSC
Cc: ui.travis%cu20d@CMCSC, ui.tyj%cu20d@CMCSC
Status: O


Hi, we would like to be added to your mailing list.

We are currently attempting to install FRANZ Lisp on Amdahl's Unix (UTS)
running under VM/CMS on an IBM 4341 here at CUCCA (Columbia University Center
for Computing Activities).

Is anyone out there working on an UTS/IBM implementation?  Any information will
be greatly appreciated.


Thanks,

Tai Jin <UI.TYJ%CU20D@CMCSC>
Travis Winfrey <UI.TRAVIS%CU20D@CMCSC>
-------

From @CMU-CS-C:Ui.Travis@CU20D  Thu Jun 16 09:47:39 1983
Date: 16 Jun 1983 1243-EDT
From: Travis Lee Winfrey <Ui.Travis@CU20D>
Subject: Porting Franz lisp to Amdahl Unix
Message-Id: <8306161646.AA25470@UCBVAX.ARPA>
Received: from CMU-CS-C (cmu-cs-c.ARPA) by UCBVAX.ARPA (3.346/3.33)
	id AA25470; 16 Jun 83 09:46:15 PDT (Thu)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA06352; 16 Jun 83 09:47:39 PDT (Thu)
To: sklower%berkeley@CMCSC, kim.layer%berkeley@CMCSC
Cc: franz-friends%berkeley@CMCSC, ui.tyj@CU20D, Ui.Travis@CU20D,
        kim.fateman%berkeley@CMCSC
Status: O

Hi, Tai Jin and I are currently attemping to bring up Franz lisp on Amdahl's
Unix running on a IBM 4341.  We are working from a copy that runs on the VAX.

We would be very interested in seeing any versions that runs both on the VAX
and some other machine, such as the 68000.  We are also interested in seeing
any documentation on other porting efforts, regardless of what machine.

Thanks,

Tai Jin  <ui.tyj%cu20d@cmu-cs-c>
Travis Winfrey <ui.travis%cu20d@cmu-cs-c>
-------

From jkf  Sun Jun 19 15:43:34 1983
Date: 19 Jun 83 15:43:34 PDT (Sun)
From: jkf (John Foderaro)
Subject: opus 38.63
Message-Id: <8306192243.19626@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA19626; 19 Jun 83 15:43:34 PDT (Sun)
To: local-lisp
Status: O

 Added functions:
   (vputprop 'Vv_vector 'g_value 'g_indicator)
   (vget  'Vv_vector 'g_indicator)

  work just like putprop and get, but modify the vector property list.

 Also:
   you can determine which function is called by lisp to print a vector
 by placing the function to call on the vector's property list under
 indicator 'print'.  The  print function is called with two arguments:
 the vector and the port.
 
 For example:
=> (defun printv (v port)
      (patom "A vector of size " port)
      (print (vsize v) port))
printv
=> (setq xx (new-vector 10))
vector[40]
=> (vputprop xx 'printv 'print)
printv
=> xx
A vector of size 10
=>



From jkf  Sun Jun 19 22:47:42 1983
Date: 19 Jun 83 22:47:42 PDT (Sun)
From: jkf (John Foderaro)
Subject: opus 38.64
Message-Id: <8306200547.23164@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA23164; 19 Jun 83 22:47:42 PDT (Sun)
To: local-lisp
Cc: jpg@Mit-mc
Status: O


  added the function (^ 'x_a 'x_b)  which computes  x_a to the x_b
power and always returns a fixnum result (it currently wraps around
on overflow).



From JPG@MIT-MC  Sun Jun 19 22:54:00 1983
Date: 20 June 1983 01:53 EDT
From: Jeffrey P. Golden <JPG@MIT-MC>
Subject: ^
Message-Id: <8306200553.AA15160@UCBVAX.ARPA>
Received: from MIT-MC (mit-mc.ARPA) by UCBVAX.ARPA (3.346/3.33)
	id AA15160; 19 Jun 83 22:53:57 PDT (Sun)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA23228; 19 Jun 83 22:54:00 PDT (Sun)
To: jkf@UCBKIM
Cc: JPG@MIT-MC, local-lisp@UCBKIM
Status: O

   Date: 19 Jun 83 22:47:42 PDT 
   From: jkf%UCBKIM@Berkeley 
   Subject: opus 38.64
   To: local-lisp%UCBKIM@Berkeley
   Cc: jpg@Mit-mc
   added the function (^ 'x_a 'x_b)  which computes  x_a to the x_b
   power and always returns a fixnum result (it currently wraps around
   on overflow).
The Maclisp ^ errors out in this case with the message:
;RESULT LARGER THAN FIXNUM - ^


From narain@rand-unix  Mon Jun 20 22:09:31 1983
Date: Monday, 20 Jun 1983 22:00-PDT
From: narain@rand-unix
Subject: Re: Interrrupt question
Message-Id: <8306210509.AA00276@UCBVAX.ARPA>
Received: from rand-unix (rand-unix.ARPA) by UCBVAX.ARPA (3.346/3.33)
	id AA00276; 20 Jun 83 22:09:20 PDT (Mon)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA09633; 20 Jun 83 22:09:31 PDT (Mon)
To: franz-friends@BERKELEY.ARPA
Cc: narain@rand-unix
Status: O


				   TWIMC
				   -----

Here is the equivalent of Interlisp's control-H followed by OK in Franzlisp:
i.e. if you wish to interrupt a Franzlisp computation, browse around the state
and resume computation:

Hit DEL;
Browse;
(return t)

This answer was given by Liz Allen at Maryland (liz.umcp-cs@udel-relay).

-- Sanjai

From Tim%UPenn.UPenn@UDel-Relay  Tue Jun 21 14:52:53 1983
Date: Tue, 21 Jun 83 10:33 EDT
From: Tim Finin <Tim.UPenn@UDel-Relay>
Subject: interrupting Franz
Return-Path: <Tim%UPenn.UPenn@UDel-Relay>
Message-Id: <8306212152.AA12930@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.346/3.33)
	id AA12930; 21 Jun 83 14:52:36 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA21097; 21 Jun 83 14:52:53 PDT (Tue)
To: franz-friends@BERKELEY.ARPA
Via:  UPenn; 21 Jun 83 17:40-EDT
Status: O


Under VMS, one should type a ^C (control-C) rather than DEL to interrupt Franz.

From jkf  Sat Jun 25 13:49:37 1983
Date: 25 Jun 83 13:49:37 PDT (Sat)
From: jkf (John Foderaro)
Subject: opus 38.65
Message-Id: <8306252049.25527@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA25527; 25 Jun 83 13:49:37 PDT (Sat)
To: local-lisp
Status: O

  If you have automatic case conversion set (i.e. (sstatus uctolc t)),
then symbols with lower case letters will be escaped by print.



From layer  Tue Jul  5 00:26:29 1983
Date:  5 Jul 1983 0026-PDT (Tuesday)
From: layer (Kevin Layer)
Subject: lisp opus 38.67
Message-Id: <5390.30.426237985@ucbkim>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA05911; 5 Jul 83 00:26:29 PDT (Tue)
Phone: (415) 652-2405
To: local-lisp
Cc: layer
Status: O

  The function 'sortcar' has been slightly changed: if the second
arg is nil, then the ordering function 'alphalessp' is assumed
('sort' does it this way).

	Kevin

From layer  Wed Jul  6 00:02:33 1983
Date: 6 Jul 83 00:02:33 PDT (Wed)
From: layer (Kevin Layer)
Subject: liszt opus 8.30
Message-Id: <8307060702.24776@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA24776; 6 Jul 83 00:02:33 PDT (Wed)
Phone: (415) 652-2405
To: local-lisp
Cc: sklower, jkf
Status: O

  All modifications should be transparent, but if there are problems
relating to the autorun feature (-r flag), please let me know.

	Kevin



From sklower  Thu Jul  7 00:27:52 1983
Date: 7 Jul 83 00:27:52 PDT (Thu)
From: sklower (Keith Sklower)
Subject: Franz, opus38.68
Message-Id: <8307070727.10697@UCBKIM.ARPA>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA10697; 7 Jul 83 00:27:52 PDT (Thu)
To: local-lisp
Status: O

Franz now escapes UPPER case letters instead of lower case letters when
(status uctolc) is enabled, so that (read (print x)) is an identity operation
on atom printnames.  Also, we made (explode) conform to what maclisp does
with opposite-than-normal character-cases.

From Ira%UPenn.UPenn@UDel-Relay  Fri Jul  8 01:46:25 1983
Date: Thu, 7 Jul 83 22:13 EDT
From: Ira Winston <Ira.UPenn@UDel-Relay>
Subject: Eliza
Return-Path: <Ira%UPenn.UPenn@UDel-Relay>
Message-Id: <8307080845.AA16294@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.346/3.33)
	id AA16294; 8 Jul 83 01:45:43 PDT (Fri)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA01687; 8 Jul 83 01:46:25 PDT (Fri)
To: franz-friends@BERKELEY.ARPA
Via:  UPenn; 8 Jul 83 3:07-EDT
Status: O

Does anyone have a version of Eliza that runs under Franz Lisp?

From layer  Fri Jul  8 18:04:10 1983
Date:  8 Jul 1983 1804-PDT (Friday)
From: layer (Kevin Layer)
Subject: lisp opus 38.69
Message-Id: <7031.30.426560643@ucbkim>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA07142; 8 Jul 83 18:04:10 PDT (Fri)
Phone: (415) 652-2405
To: local-lisp
Cc: layer
Status: O

  'setf' now knows about 'nthelem', and there are two new functions:

	(readdir 's_direct)
		returns a list of the contents of the directory s_direct.

	(dirp 's_name)
		returns s_name if s_name is a directory.  This doesn't
		insure that you can read the directory, though (only
		uses stat(2)).

					Kevin

From layer  Fri Jul  8 20:57:13 1983
Date:  8 Jul 1983 2057-PDT (Friday)
From: layer (Kevin Layer)
Subject: new function readdir
Message-Id: <465.30.426571029@ucbkim>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA00480; 8 Jul 83 20:57:13 PDT (Fri)
Phone: (415) 652-2405
To: local-lisp
Fcc: record
Status: O

  The function 'readdir' and 'dirp' should not be relied on yet, since
they are provisional, because they are implemented with C library
functions only available on 4.1+ systems.

	Kevin

From Pwh%GaTech.GATech@UDel-Relay  Tue Jul 12 18:08:46 1983
Date:     11 Jul 83 20:36:32-EDT (Mon)
From: <pwh.gatech@UDel-Relay>
Subject:  Franz flavors?
Return-Path: <Pwh%GaTech.GATech@UDel-Relay>
Message-Id: <8307130107.AA03336@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.346/3.33)
	id AA03336; 12 Jul 83 18:07:40 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA20140; 12 Jul 83 18:08:46 PDT (Tue)
To: franz-friends@BERKELEY.ARPA
Cc: jlk.Gatech@UDel-Relay
Via:  GATech; 12 Jul 83 2:43-EDT
Status: O

We at Ga Tech (ai group working under prof Janet Kolodner) have just gotten our
long awaited Symbolics Lisp Machine up and running and are trying to establish
some measure of compatability between Franz and Zeta Lisp (as appropriate).
Janet seems to recall some mention of a flavor package for Franz. Is this
Berkley based or can anyone provide some clues as to where to check next?

Also, when is the next release of Franz scheduled and what features will it
incorporate?

If the flavor package is non-existent, we will probably be forced to develop
one here and will, of course, be glad to pass anything useful along.

phil hutto

From narain@rand-unix  Tue Jul 12 20:10:42 1983
Date: Tuesday, 12 Jul 1983 19:49-PDT
From: narain@rand-unix
Subject: Re:  Franz flavors?
Message-Id: <8307130309.AA05908@UCBVAX.ARPA>
Received: from rand-unix (rand-unix.ARPA) by UCBVAX.ARPA (3.346/3.33)
	id AA05908; 12 Jul 83 20:09:41 PDT (Tue)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA21387; 12 Jul 83 20:10:42 PDT (Tue)
To: <pwh.gatech@UDEL-RELAY>
Cc: franz-friends@BERKELEY.ARPA, jlk.Gatech@UDEL-RELAY
In-Reply-To: Your message of     11 Jul 83 20:36:32-EDT (Mon).
             <8307130107.AA03336@UCBVAX.ARPA>
Status: O


We at Rand are interested in developing a set of guidelines for writing
code that will be compatible with each of Zeta- Franz- and PSL Lisps. I
would be grateful if you could tell us of what your experiences have been with
making Franzlisp code work on the Symbolics machine. We would gladly share
our own with you if you wish; incidentally we also have an IJCAI paper on a
related issue.

-- Sanjai Narain

From liz.umcp-cs@UDel-Relay  Wed Jul 13 00:55:26 1983
Date:     13 Jul 83 03:09:39 EDT  (Wed)
From: Liz Allen <liz.umcp-cs@UDel-Relay>
Subject:  Re:  Franz flavors?
Return-Path: <liz.umcp-cs@UDel-Relay>
Message-Id: <8307130754.AA10367@UCBVAX.ARPA>
Received: from udel-relay.ARPA by UCBVAX.ARPA (3.346/3.33)
	id AA10367; 13 Jul 83 00:54:32 PDT (Wed)
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA24477; 13 Jul 83 00:55:26 PDT (Wed)
To: pwh.gatech@UDel-Relay, franz-friends@BERKELEY.ARPA
Cc: jlk.Gatech@UDel-Relay
Via:  UMCP-CS; 13 Jul 83 3:23-EDT
Status: O

Here at the Univ of Maryland, we do have an implementation of
flavors in Franz Lisp and have used it successfully in several
large systems.  It doesn't contain all the features of the Lisp
Machine Flavors, but it does implement all the major ones.  It is
also different in a few ways that are necessitated by the limitations
of Franz Lisp (shallow binding without invisible pointers or true
closures -- though closures may be in the very newest versions of
Franz -- we have opus 38.26).  The package uses a hashing scheme
for looking up methods, and the function <- which is used to send
a message to an object is written in C.  Together, this makes it
an efficient implementation.

We are currently working on a new policy for distributing flavors,
our other lisp packages and our window package.  When we have worked
it out, I will announce the details here.

				-Liz

From @MIT-MC:mdm@cmu-ri-isl  Thu Jul 14 11:07:57 1983
Date: 14 Jul 1983 14:03:01-EDT
From: Malcolm.McRoberts@CMU-RI-ISL
Subject: random numbers
Message-Id: <8307141806.AA05735@UCBVAX.ARPA>
Received: from MIT-MC (mit-mc.ARPA) by UCBVAX.ARPA (3.347/3.35)
	id AA05735; Thu, 14 Jul 83 11:06:45 PDT
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA13687; 14 Jul 83 11:07:57 PDT (Thu)
Apparently-To: <franz-friends@UCB-VAX>
Status: O

I am interested in obtaining a GOOD random number generator that is callable
from Franz.  My only real requirements are that it accept a seed (so that I
can duplicate the same series), is fairly good (try doing several (random
4)'s in Franz and see what you get), and is of intermediate speed.  If you
know of such an animal please send me mail telling me how to get it.
							thanks


From kanderso@bbn-vax  Thu Jul 14 12:49:58 1983
Date: 14 Jul 1983 15:47:19 EDT (Thursday)
From: Ken Anderson <kanderso@bbn-vax>
Subject: Random numbers
Message-Id: <8307141948.AA06936@UCBVAX.ARPA>
Received: from bbn-vax (bbn-vax.ARPA) by UCBVAX.ARPA (3.347/3.35)
	id AA06936; Thu, 14 Jul 83 12:48:49 PDT
Received: from UCBVAX.ARPA by UCBKIM.ARPA (3.340/3.5)
	id AA15607; 14 Jul 83 12:49:58 PDT (Thu)
To: franz-friends@BERKELEY.ARPA
Cc: Malcolm.McRoberts@CMU-RI-ISL
Status: O

Here is a random number generator i use.  It seems to work fairly well, but i have
not looked to closely at the statistics.  Since it will occasionally require
bignums, it is probably not the fastest either.  I was just looking for something
that was likely to be portable between LISP's.
I would be very interested in hearing your evaluation of it.

k

;;; RANDOM NUMBERS
(declare (macros t))
(include math.h)

(defvar $uniform-a 16807) ; = 7^5
(defvar $mersenne-prime 2147483647) ; = 2^31 - 1
(defvar $mersenne-prime-1 (- $mersenne-prime 1))

(defmacro with-seed (s-newseed . body)
  ; evaluates body with the seed of the random numbers set to s-newseed.
  ; the value of s-newseed is updated.  Thus this is a way of
  ; Keepining several sequences of random numbers with their own seeds
  `(let (($uniform-seed ,s-newseed))
	(prog1 (progn ,@body) 
	       (setq ,s-newseed $uniform-seed))))

(defun uniform-basic (previous-fixnum)
  ; -> a fixnum 0 < fixnum < 2^31 - 1
  ; Repeated calls will generate fixnums in the range
  ; 1 -> 2^31 - 2.

  ; The basic idea is new = A^k * old (mod p)
  ; where A is a primitive root of p, k is not a factor of  p-1
  ; and p is a large prime.

  ; This is a good random number generator but is not be the fastest!
  ; On FRANZ LISP, and LISP MACHINE it will require bignums since
  ; (* $uniform-a previous-fixnum) can have 46 bits in it. Also the remainder
  ; can be done more efficiently.
  ; See: Linus Schrage, A More Portable Fortran Random Number Generator,
  ;      ACM Trans. Math. Soft., V5, No. 2, p 132-138, 1979.
  (remainder (*$ $uniform-a previous-fixnum) $mersenne-prime))

(defvar $uniform-seed 53) ; 0 < fixnum < $mersenne-prime-1

(defun uniform ()
  ; -> the next uniform random number in the sequence
  ; To have your own sequence, rebind $uniform-seed.
  (setq $uniform-seed (uniform-basic $uniform-seed)))

(defun uniform-between (low-num high-num)
  ; -> a uniform random  number, x, low-num <= x <= high-num
  ; If low-num and high-num are fixnums, a fixnum is returned.
  (cond ((not (and (fixp low-num) (fixp high-num)))
	 (+$ low-num (*$ (//$ (uniform) (float $mersenne-prime-1))
		       (-$ high-num low-num))))
	(t (+ low-num (// (uniform)
			  (// $mersenne-prime-1 (max 1 (- high-num low-num -1))))))))

(defun gaussian-random-1 ()
  ; -> a gaussian random variable with mean 0.0 and
  ; standard deviation 1.0.
  ; Good tails.
  (*$ (sqrt (*$ -2.0 (log (uniform-between 0.0 1.0))))
     (sin (*$ $2pi (uniform-between 0.0 1.0)))))

(defun gaussian-random (mean standard-deviation)
  (+$ mean (*$ (gaussian-random-1) standard-deviation)))

;;(defun gaussian (x)
;;  (* (sqrt $2pi) 
;;     (exp (minus (// (square x) 2.0)))))

(defun random-yes-no (fraction-yes)
    (<= (uniform-between 0.0 1.0) fraction-yes))


From layer  Sat Jul 30 15:46:42 1983
Date: 30 Jul 1983 1546-PDT (Saturday)
From: layer (Kevin Layer)
Subject: liszt opus 8.33
Message-Id: <19472.30.428453197@ucbkim>
Received: by UCBKIM.ARPA (3.340/3.5)
	id AA19498; 30 Jul 83 15:46:42 PDT (Sat)
Phone: (415) 652-2405
To: local-lisp
Status: O

  Vset is now open coded.  There should be no visible change in the
behaviour of vectors, except in speed (greater, that is), and 
vsize-{byte,word} work properly now.

  Bugs to me.

	Kevin

From jkf  Mon Aug  1 14:41:28 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA03743; Mon, 1 Aug 83 14:41:28 PDT
Date: Mon, 1 Aug 83 14:41:28 PDT
From: jkf (John Foderaro)
Message-Id: <8308012141.AA03743@ucbkim.ARPA>
To: local-lisp
Subject: defstruct
Status: O

  defstruct now understands two more types of structures:
  	:vector
	:named-vector

  A named vector has the defstruct structure name on the vector property
list, thus an instance of the foo structure would print as 'foo[8]'.


  :named-vector is now the default structure type (instead of :hunk).




From jkf  Tue Aug  2 15:20:04 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA26686; Tue, 2 Aug 83 15:20:04 PDT
Date: Tue, 2 Aug 83 15:20:04 PDT
From: jkf (John Foderaro)
Message-Id: <8308022220.AA26686@ucbkim.ARPA>
To: local-lisp
Subject: lisp opus 38.70
Status: RO

  When a vector is printed, the size in square brackets will be the number
of entries (not the number of bytes).  The size printed for vectori
objects will continue to be the number of bytes.

  Also, if the property of a vector is a list with the car being a non nil
symbol, and if that list doesn't have a print property, then that
symbol will be printed rather than 'vector' or 'vectori'.



From layer  Thu Aug  4 02:10:12 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA11660; Thu, 4 Aug 83 02:10:12 PDT
From: layer (Kevin Layer)
Phone: (415) 652-2405
Date:  4 Aug 1983 0210-PDT (Thursday)
Message-Id: <11649.30.428836207@ucbkim>
To: local-lisp
Subject: liszt opus 8.34
Status: RO

  I just installed a new compiler.  For the vax, there shouldn't be
any visible changes, though a couple of vector bugs were fixed.  For
the 68000, the vector access functions are now open coded, and the
new one was installed on mike, rob, and chip in /usr/ucb.

	Kevin

From FRD@SU-AI  Fri Aug  5 15:57:17 1983
Received: from UCBVAX.ARPA by ucbkim.ARPA (4.2/4.2)
	id AA10610; Fri, 5 Aug 83 15:57:17 PDT
Received: from SU-AI.ARPA by UCBVAX.ARPA (3.347/3.35)
	id AA10357; Fri, 5 Aug 83 15:54:22 PDT
Message-Id: <8308052254.AA10357@UCBVAX.ARPA>
Date: 05 Aug 83  1353 PDT
From: Fred Lakin <FRD@SU-AI>
Subject: Franz & SUNs  
To: franz-friends@BERKELEY
Status: RO

I am interested in connectons between Franz and SUN workstations.
Like how far along is Franz on the SUN?  Is there some package
which allows Franz on a VAX to use a SUN as a display device?

Any info on this matter would be appreciated.
Thnaks, Fred Lakin


From tektronix!ogcvax!metheus!tombl  Sat Aug  6 09:49:57 1983
Received: from UCBVAX.ARPA by ucbkim.ARPA (4.2/4.2)
	id AA21229; Sat, 6 Aug 83 09:49:57 PDT
Received: by UCBVAX.ARPA (3.347/3.35)
	id AA13549; Sat, 6 Aug 83 09:40:11 PDT
Message-Id: <8308061640.AA13549@UCBVAX.ARPA>
From: ogcvax!metheus!tombl
To: ogcvax!tektronix!ucbvax!franz-friends
Cc: ogcvax!tektronix!ucbvax!sklower
Received: from ogcvax.uucp by tektronix ; 5 Aug 83 20:51:03 PDT
Subject: bug in Opus 38.66
Date: Fri Aug  5 20:46:56 1983
Status: O


A bug present in previous versions is also present in 38.66 of Franz.
cfasl fails (in most cases) to close the file it reads from.
Consequently, mysterious events occur when the maximum number of open
file descriptors is reached.

The fix is made in the file ffasl.c. "close(fildes)" should be
prepended to the two return sequences from (the Unix code for)
Lcfasl:

------------------------------------------------------------------
Old:	146c146
	< 		{Restorestack(); return(nil);}
	---
Fixed:	> 		{close(fildes); Restorestack(); return(nil);}
	149a150
	> 	close(fildes);
------------------------------------------------------------------


	Tom Blenko
	Metheus Corp.
	ucbvax!tektronix!ogcvax!metheus!tombl
	allegra!ogcvax!metheus!tombl



From FRD@SU-AI  Sun Aug  7 12:34:43 1983
Received: from UCBVAX.ARPA by ucbkim.ARPA (4.2/4.2)
	id AA10610; Fri, 5 Aug 83 15:57:17 PDT
Received: from SU-AI.ARPA by UCBVAX.ARPA (3.347/3.35)
	id AA10357; Fri, 5 Aug 83 15:54:22 PDT
Message-Id: <8308052254.AA10357@UCBVAX.ARPA>
Date: 05 Aug 83  1353 PDT
From: Fred Lakin <FRD@SU-AI>
Subject: Franz & SUNs  
To: franz-friends@BERKELEY
Status: O

I am interested in connectons between Franz and SUN workstations.
Like how far along is Franz on the SUN?  Is there some package
which allows Franz on a VAX to use a SUN as a display device?

Any info on this matter would be appreciated.
Thnaks, Fred Lakin


From jkf  Mon Aug  8 09:06:49 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA06584; Mon, 8 Aug 83 09:06:49 PDT
Date: Mon, 8 Aug 83 09:06:49 PDT
From: jkf (John Foderaro)
Message-Id: <8308081606.AA06584@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.72
Status: O

  A bug was fixed in defmacro which caused the &protect option and
displace-macros to interact poorly.



From jkf  Fri Aug 12 22:11:13 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA25610; Fri, 12 Aug 83 22:11:13 PDT
Date: Fri, 12 Aug 83 22:11:13 PDT
From: jkf (John Foderaro)
Message-Id: <8308130511.AA25610@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.73
Status: O

 'equal' will now compare all types of vectors for equality.

 'copy' will now copy all types of vectors.

 


From layer  Mon Aug 15 20:03:53 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA03597; Mon, 15 Aug 83 20:03:53 PDT
From: layer (Kevin Layer)
Phone: (415) 652-2405
Date: 15 Aug 1983 2003-PDT (Monday)
Message-Id: <3556.30.429851029@ucbkim>
To: local-lisp
Subject: liszt opus 8.35
Fcc: record
Status: RO

  Several things have changed:

1) Bugs in the open coding of vectors have been fixed.

2) Minor re-organization of the compiler source code.

3) The routine to determine whether or not tail merging is
   possible underwent major modification.

4) Lexpr's are compiled differently, or rather the way lexpr args
   are accessed has changed.  For those that want to know, here is
   the nitty gritty:

     Consider a the following lexpr: (defun test nargs ...).
     The arguments to the lexpr are stacked on the name stack
     (low to high number), and then nargs is stacked.  The user
     is allowed to change the binding of 'nargs' to anything
     he likes, so we have to have another way to access the arguments
     on the name stack (i.e., other than an offset from nargs).
     Before, a pointer to the argument base was pushed on the 
     C stack, so that indexing could be done from there.
     The addressing modes used to do this are not available
     on the MC68000 (something like *n(fp)[Rx]), so now
     nargs is pushed on the name stack twice, and the location
     of an argument can be easily calculated as an offset from nargs.

In short, lots of thing changed.  The SUN's should be updated
in the next couple of days (after I test it out).  Bugs to me...

	Kevin

From jkf  Mon Aug 15 23:11:08 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA05928; Mon, 15 Aug 83 23:11:08 PDT
Date: Mon, 15 Aug 83 23:11:08 PDT
From: jkf (John Foderaro)
Message-Id: <8308160611.AA05928@ucbkim.ARPA>
To: local-lisp
Subject:  opus 38.74
Status: O


  If a vector has a 'unique' property on it's property list, then it will
not be copied by 'copy'.

  'untrace' will now autoload /usr/lib/lisp/trace.

  A number of functions and macros were contributed by the bair group:

 






(<= 'fx_arg1 'fx_arg2 ...)
(<=& 'x_arg1 'x_arg2)

     RETURNS: t iff (> 'fx_arg1 'fx_arg2)  [or  (>&  'x_arg1
              'x_arg2)]  is nil, otherwise nil.  The general
              function, <=, can take  more  than  two  argu-
              ments.

(>= 'fx_arg1 'fx_arg2)
(>=& 'x_arg1 'x_arg2)

     RETURNS: t  iff  (<  'fx_arg1  'fx_arg2  ...)  [or  (<&
              'x_arg1 'x_arg2)] is nil, otherwise nil.

     NOTE: The general function, >=, can take more than  two
           arguments.

(litatom 'g_arg)

     RETURNS: t iff g_arg is an atom, but not a number.

(nequal 'g_x 'g_y)

     RETURNS: t iff g_x is not equal to g_y, otherwise nil.

(lineread [['p_port] ['s_flag]])

     RETURNS: a list consisting of s-expressions on  a  line
              from  the  port p_port (or piport if p_port is
              not given).  If an s-expression (e.g., a list)
              takes more than one line, or a line terminates
              in a space or  tab,  then  lineread  continues
              reading until an expression ends at the end of
              a line.

     NOTE: If s_flag is t, then if the first character on  a
           line  is  a  newline, lineread performs a tyi and
           returns nil.  If s_flag is nil  or  not  present,
           lineread  does  a  read  skipping  over any blank
           lines to make sure that an s-expression is  actu-
           ally read.

     SIDE EFFECT: lineread uses  read,  advancing  the  port
                  character pointer.








9

9










(defv g_arg1 g_arg2)

     EQUIVALENT TO: (set g_arg1 g_arg2)

(pp-form 'g_form ['p_port] ['n_lmar])

     RETURNS: nil

     SIDE EFFECT: g_form  is  pretty-printed  to  the   port
                  p_port (or poport if p_port is not given).
                  If  pp-form  is  also  supplied  with   an
                  integer  (n_lmar),  that  integer  will be
                  used as a left margin setting  (0  is  the
                  default).   This is the  function which pp
                  uses (n_lmar = 0). pp-form does  not  look
                  for  function  definitions  or  values  of
                  variables, it just prints out the form  it
                  is given.

     NOTE: This is useful as a top-level-printer, c.f.  top-
           level in Chapter 6.

(sload 's_file1 ...)

     SIDE EFFECT: The files named are opened for reading and
                  each form is read, optionally printed, and
                  evaluated.

     NOTE: What sload prints is controlled  by  the  special
           atom  $sldprint.   If  $sldprint  is t (default),
           then if a form  is  recognizable  as  a  function
           definition,  only  the  function name is printed,
           otherwise  the  whole  form   is   printed.    If
           $sldprint is eq to value, then the result of each
           form's evaluation will also be printed.  Printing
           the  forms'  values  can be controlled by setting
           sload-print equal to the name of the function  to
           be  called.   sload recognizes named functions by
           looking at  the  sloadprintarg  property  of  the
           function  name.   The  value of the sloadprintarg
           property should be the  argument  number  of  the
           function name.  For the standard Franz Lisp func-
           tions, the properties are already set.

     EXAMPLE: (defprop def 1 sloadprintarg)   ; This is  the
              default--declaring that
                                              ; the name  of
              the function definition is the
                                              ; first  argu-
              ment.


9

9










          The functions described below are  an  alternative
     to  the  gensym facility.  They generate new symbols by
     attaching counter numbers to the ends of  the  symbols'
     names.   An  example  follows  of how the functions are
     used.


    ____________________________________________________

    -> (initsym joe (john 5))       ; initializing new symbol counters
    (joe0 john5)
    -> (newsym john)                ; create a new symbol
    john6
    -> (newsym chuck)               ; symbol need not be initsym'ed
    chuck0
    -> (oldsym john)                ; get current symbol
    john6
    -> (allsym john)                ; get all symbols between 0 and counter
    (john0 john1 john2 john3 john4 john5 john6)
    -> (allsym (john 5))            ; get all symbols between 5 and counter
    (john5 john6)
    -> (remsym joe (john 4))        ; remob all interned symbols
                                    ; associated with joe and from
                                    ; john4 to the current john
                                    ; symbol--returns symbols with symbol counters
                                    ; before doing remsym
    (joe0 john6)
    -> (symstat joe john)
    ((joe nil) (john 3))
    ____________________________________________________




(initsym g_arg1 ...)

     WHERE:   g_argi is a  list  (n_counteri  s_argi)  or  a
              string  s_argi  (which  is  equivalent  to  (0
              s_argi)).

     RETURNS: a list of interned identifiers using the  sym-
              bol  counters  n_counteri, i.e., the result of
              concatenating s_argi to n_counteri.

     EXAMPLE: (initsym joe (john 5)) ==> (joe0 john5)

     NOTE: See also newsym, oldsym, allsym, remsym, and sym-
           stat functions.




9

9










(newsym s_arg)

     RETURNS: an interned identifier formed by concatenating
              the  name  s_arg  to  the  symbol  counter for
              s_arg.  The symbol counter is  stored  on  the
              property list of s_arg under symctr.  If there
              is no counter, a counter  of  0  is  used  and
              added  to  the  property list.  Thus, a symbol
              need not be initsymed.

     EXAMPLE: (initsym joe (john5)) ==> (joe0 john5)
              (newsym john) ==> john6
              (newsym joe) ==> joe1

     NOTE: See also initsym,  oldsym,  allsym,  remsym,  and
           symstat functions.

(oldsym s_arg)

     RETURNS: the  identifier  using  the   current   symbol
              counter  for s_arg, rather than creating a new
              identifier.  If no symbol counter  exists  for
              s_arg, then s_arg is returned.

     NOTE: See also initsym,  newsym,  allsym,  remsym,  and
           symstat functions.

(allsym g_arg)

     WHERE:   g_arg is a list (s_arg n_counter) or a  string
              s_arg (equivalent to (s_arg 0)).

     RETURNS: a list of all the created identifiers  between
              n_counter  and  the current symbol counter for
              s_arg.

     EXAMPLE: (allsym john) ==> (john0 john1 john2)

     NOTE: See also initsym,  newsym,  oldsym,  remsym,  and
           symstat functions.

(remsym g_arg1 ...)

     WHERE:   g_argi is a  list  (s_argi  n_counteri)  or  a
              string  s_argi (which is equivalent to (s_argi
              0)).

     RETURNS: a list of symbols s_argi with the current sym-
              bol counters.

     SIDE EFFECT: remsym remob's all the created identifiers
                  between   zero   and  the  current  symbol
                  counter for s_argi.













     NOTE: See also initsym, newsym oldsym, allsym, and sym-
           stat functions.

(symstat s_arg1 ...)

     RETURNS: a list of pairs consisting of (s_argi symctri)
              where   symctri  is  s_argi's  current  symbol
              counter.

     NOTE: See also initsym,  newsym,  oldsym,  allsym,  and
           remsym functions.









































9

9






From jkf  Thu Aug 18 19:25:45 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA09885; Thu, 18 Aug 83 19:25:45 PDT
Date: Thu, 18 Aug 83 19:25:45 PDT
From: jkf (John Foderaro)
Message-Id: <8308190225.AA09885@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.75
Status: O

  evalhook and funcallhook can now be executed without setting (*rset t)
and (sstatus evalhook t).   Although they can be executed, they won't
have any effect unless and until (*rset t) and (sstatus evalhook t) are
done.
  The reason for this change is that now one can turn off stepping
by (sstatus evalhook nil) and then continue the evaluation with
evalhook and funcallhook.

  Those who use the new top-level 'tpl' will notice a few new commands
dealing with stepping when you type '?help'.   These new commands
are ?step, ?soff, and ?sc. Details of the commands are available
using the help mechanism (e.g. '?help step').




From jkf  Fri Aug 19 13:54:26 1983
Received: by ucbkim.ARPA (4.2/4.2)
	id AA20017; Fri, 19 Aug 83 13:54:26 PDT
Date: Fri, 19 Aug 83 13:54:26 PDT
From: jkf (John Foderaro)
Message-Id: <8308192054.AA20017@ucbkim.ARPA>
To: local-lisp
Subject: liszt 8.36
Status: O

 The compiler will now compile the form
       (*no-macroexpand* <form>)
 in a special way: if <form> is a function call, e.g. (name arg1 ...),
 then any macro properties of 'name' will be ignored for this
 invocation.  This permits one to write macros which attempt
 an optimization, and if that fails, then call the standard
 function.  *no-macroexpand* is not a function that can be called,
 thus forms with *no-macroexpand* are likely to be 'cmacros'.
 Here is an example:

   (defcmacro length (x &protect (x))
       `(if (null ,x)
          then 0
	 elseif (null (cdr ,x))
	  then 1
	 else (*no-macroexpand* (length ,x))))


 [in case you are wondering, the `&protect (x)' means that
  should the actual argument to 'length' be a non atom, defcmacro
  will lambda bind the value, insuring that it is only evaluated
  once]
 
 


From layer  Wed Aug 24 22:18:34 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA12256; Wed, 24 Aug 83 22:18:34 PDT
From: layer (Kevin Layer)
Phone: (415) 652-2405
Date: 24 Aug 1983 2218-PDT (Wednesday)
Message-Id: <12219.30.430636709@ucbkim>
To: local-lisp
Subject: liszt on kim
Status: O

  The liszt that I installed on kim yesterday, compiled eq's wrong
in some rare cases.  I installed a new one this evening that fixes
this, but if you compiled any programs with the bad one, you might
consider re-compiling them...

	Kevin

From fateman  Thu Aug 25 13:58:59 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA21033; Thu, 25 Aug 83 13:58:59 PDT
Date: Thu, 25 Aug 83 13:58:59 PDT
From: fateman (Richard Fateman)
Message-Id: <8308252058.AA21033@ucbkim.ARPA>
To: local-lisp
Status: O

I have a copy of the latest Common Lisp manual... the Excelsior Edition.

From patel@UCLA-LOCUS  Tue Aug 30 21:58:38 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA29417; Tue, 30 Aug 83 21:58:38 PDT
Received: from ucla-locus (ucla-locus.ARPA) by ucbvax.ARPA (4.8/4.4)
	id AA06203; Tue, 30 Aug 83 21:50:26 PDT
Message-Id: <8308310450.AA06203@ucbvax.ARPA>
Date:           Tue, 30 Aug 83 21:44:13 PDT
From: Dorab Patel <patel@UCLA-LOCUS>
To: franz-friends@BERKELEY
Subject:        bug fix for 'insert' in opus 38.50
Status: O

The function 'insert' in Opus 38.50 does not perform as advertised in 
the manual if the last argument is non-nil (i.e. if no duplicates are allowed.
It still insists on putting the duplicate element into the list. The
fix is in /usr/lib/lisp/common2.l. Just change the default setting
of the 'comparefn' to that given below instead of 
(function alphalessp). Here is an excerpt from the modified file.


  [.....]
(def insert
     (lambda (x l comparefn nodups)
      (cond ((null l) (list x))
            ((atom l)
             (error "an atom, can't be inserted into" l))
            (t (cond
                ((null comparefn) (setq comparefn 
					(function
					 (lambda (x y) 
						 (or (alphalessp x y) 
						     (equal x y)))))))
               (prog (l1 n n1 y)
                     (setq l1 l)
                     (setq n (length l))
                a    (setq n1 (/ (add1 n) 2))
                     (setq y (Cnth l1 n1))
		     [..........]

From jkf  Sun Sep  4 09:59:01 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA03721; Sun, 4 Sep 83 09:59:01 PDT
Date: Sun, 4 Sep 83 09:59:01 PDT
From: jkf (John Foderaro)
Message-Id: <8309041659.AA03721@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.77
Status: O

  The 'error' function used to print its arguments and then call 'err' to
cause the familar 'call to err' error.  The problem with this is that
even if you wrap your compuatation with (errset ... nil), the error message
will still be printed.   In opus 38.77, this problem has been fixed.

A new function was added:
	(err-with-message 'st_message ['g_value])
 This causes an error to be signaled with the given message.   The message
will only be printed if an '(errset ... nil)' isn't being executed.
Normally nil is returned from an errset if an error occured.  If you provide
g_value, then it will be returned from the errset.
[Not surprisingly, 'error' now uses 'err-with-message']


Also, 'error' now takes any number of arguments.  In concatenates them,
separated by spaces, and this is the error message passed to
err-with-message.




From narain@rand-unix  Fri Sep  9 13:32:24 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA16481; Fri, 9 Sep 83 13:32:24 PDT
Received: from rand-unix (rand-unix.ARPA) by ucbvax.ARPA (4.12/4.7)
	id AA11010; Fri, 9 Sep 83 13:31:58 PDT
Message-Id: <8309092031.AA11010@ucbvax.ARPA>
Date: Friday,  9 Sep 1983 10:55-PDT
To: franz-friends@BERKELEY
Cc: narain@rand-unix
Subject: Franzlisp Question
From: narain@rand-unix
Status: O


Hello all:

I would be grateful if you could answer another question regarding Franzlisp.
How does one make Franzlisp continue from an error? For example when Lisp
gives an error message like "x unbound variable", is it possible to
bind x to a value and make Lisp continue from that point? Right now we have
to start over again and it is very time consuming.

-- Sanjai

From AUSTIN@DEC-MARLBORO.ARPA  Fri Sep  9 13:46:45 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA16843; Fri, 9 Sep 83 13:46:45 PDT
Received: from DEC-MARLBORO.ARPA by ucbvax.ARPA (4.12/4.7)
	id AA11248; Fri, 9 Sep 83 13:46:26 PDT
Date: 9 Sep 1983 1427-EDT
From: AUSTIN@DEC-MARLBORO
To: FRANZ-FRIENDS@BERKELEY
Subject: LIST MEMBERSHIP
Message-Id: <"MS10(2124)+GLXLIB1(1136)" 11950297972.20.647.3882 at DEC-MARLBORO>
Status: O

PLEASE ADD ME TO FRANZ-FRIENDS@BERKELEY DISTRIBUTION.

MY NAME IS TOM AUSTIN AND MY NETWORK ADDRESS IS AUSTIN@DEC-MARLBORO.

THANKS!
   --------

From jkf  Sat Sep 10 12:34:14 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA28421; Sat, 10 Sep 83 12:34:14 PDT
Date: Sat, 10 Sep 83 12:34:14 PDT
From: jkf (John Foderaro)
Message-Id: <8309101934.AA28421@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.78
Status: O

 The new functions contributed by the bair group dealing with symbol
creation have been changed from fexprs to exprs (lambdas) and lexprs.

The new documentation follows:







     The functions described below are an alternative to the
gensym  facility.   They  generate  new symbols by attaching
counter numbers to the ends of the symbols' names.  An exam-
ple follows of how the functions are used.


    ____________________________________________________

    -> (initsym 'joe '(john 5))     ; initializing new symbol counters
    (joe0 john5)
    -> (newsym 'john)               ; create a new symbol
    john6
    -> (newsym 'chuck)              ; symbol need not be initsym'ed
    chuck0
    -> (oldsym 'john)               ; get current symbol
    john6
    -> (allsym 'john)               ; get all symbols between 0 and counter
    (john0 john1 john2 john3 john4 john5 john6)
    -> (allsym '(john 5))           ; get all symbols between 5 and counter
    (john5 john6)
    -> (remsym 'joe '(john 4))      ; remob all interned symbols
                                    ; associated with joe and from
                                    ; john4 to the current john
                                    ; symbol--returns symbols with symbol counters
                                    ; before doing remsym
    (joe0 john6)
    -> (symstat 'joe 'john)
    ((joe nil) (john 3))
    ____________________________________________________




(initsym 'g_arg1 ...)

     WHERE:   g_argi is a  list  (n_counteri  s_argi)  or  a
              string  s_argi  (which  is  equivalent  to  (0
              s_argi)).

     RETURNS: a list of interned identifiers using the  sym-
              bol  counters  n_counteri, i.e., the result of
              concatenating s_argi to n_counteri.

     EXAMPLE: (initsym 'joe '(john 5)) ==> (joe0 john5)

     NOTE: See also newsym, oldsym, allsym, remsym, and sym-
           stat functions.



















(newsym 's_arg)

     RETURNS: an interned identifier formed by concatenating
              the  name  s_arg  to  the  symbol  counter for
              s_arg.  The symbol counter is  stored  on  the
              property list of s_arg under symctr.  If there
              is no counter, a counter  of  0  is  used  and
              added  to  the  property list.  Thus, a symbol
              need not be initsymed.

     EXAMPLE: (initsym 'joe '(john5)) ==> (joe0 john5)
              (newsym 'john) ==> john6
              (newsym 'joe) ==> joe1

     NOTE: See also initsym,  oldsym,  allsym,  remsym,  and
           symstat functions.

(oldsym 's_arg)

     RETURNS: the  identifier  using  the   current   symbol
              counter  for s_arg, rather than creating a new
              identifier.  If no symbol counter  exists  for
              s_arg, then s_arg is returned.

     NOTE: See also initsym,  newsym,  allsym,  remsym,  and
           symstat functions.

(allsym 'g_arg)

     WHERE:   g_arg is a list (s_arg n_counter) or a  string
              s_arg (equivalent to (s_arg 0)).

     RETURNS: a list of all the created identifiers  between
              n_counter  and  the current symbol counter for
              s_arg.

     EXAMPLE: (allsym 'john) ==> (john0 john1 john2)

     NOTE: See also initsym,  newsym,  oldsym,  remsym,  and
           symstat functions.

(remsym 'g_arg1 ...)

     WHERE:   g_argi is a  list  (s_argi  n_counteri)  or  a
              string  s_argi (which is equivalent to (s_argi
              0)).

     RETURNS: a list of symbols s_argi with the current sym-
              bol counters.

     SIDE EFFECT: remsym remob's all the created identifiers
                  between   zero   and  the  current  symbol
                  counter for s_argi.













     NOTE: See also initsym, newsym oldsym, allsym, and sym-
           stat functions.

(symstat 's_arg1 ...)

     RETURNS: a list of pairs consisting of (s_argi symctri)
              where   symctri  is  s_argi's  current  symbol
              counter.

     NOTE: See also initsym,  newsym,  oldsym,  allsym,  and
           remsym functions.



















































From jkf@ucbkim  Wed Sep 14 08:04:14 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA14801; Wed, 14 Sep 83 08:04:14 PDT
Received: from ucbkim.ARPA by ucbvax.ARPA (4.12/4.7)
	id AA04212; Wed, 14 Sep 83 08:03:58 PDT
Received: by ucbkim.ARPA (4.6/4.2)
	id AA14786; Wed, 14 Sep 83 08:03:43 PDT
Date: Wed, 14 Sep 83 08:03:43 PDT
From: jkf@ucbkim (John Foderaro)
Message-Id: <8309141503.AA14786@ucbkim.ARPA>
To: franz-friends@BERKELEY
Subject: lisp distribution
Status: O

  A number of you have noticed that ftp'ing the lisp distribution from
ucb-vax can be slow at times.    As a result, we've made 'ucb-arpa' the
primary distribution machine.  You can ftp from ucb-arpa using an anonymous
login (with your name as password).   The files are in the pub/lisp
subdirectory.
					john foderaro
					



From liz%umcp-cs@UDel-Relay  Mon Sep 26 19:41:37 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA24055; Mon, 26 Sep 83 19:41:37 PDT
Received: from udel-relay.ARPA by ucbvax.ARPA (4.12/4.7)
	id AA07367; Mon, 26 Sep 83 16:28:58 PDT
Message-Id: <8309262328.AA07367@ucbvax.ARPA>
Date:     26 Sep 83 15:22:00 EDT  (Mon)
From: Liz Allen <liz%umcp-cs@UDel-Relay>
Return-Path: <liz%umcp-cs@UDel-Relay>
Subject:  Maryland software distribution
To: franz-friends@BERKELEY
Via:  UMCP-CS; 26 Sep 83 17:46-EDT
Status: O

This is to announce the availability of the Univ of Maryland software
distribution.  This includes source code for the following:

1.  The flavors package written in Franz Lisp.  This package has
    been used successfully in a number of large systems at Maryland,
    and while it does not implement all the features of Lisp Machine
    Flavors, the features present are as close to the Lisp Machine
    version as possible within the constraints of Franz Lisp.
    (Note that Maryland flavors code *can* be compiled.)
2.  Other Maryland Franz hacks including the INTERLISP-like top
    level, the lispbreak error handling package, the for macro and
    the new loader package.
3.  The YAPS production system written in Franz Lisp.  This is
    similar to OPS5 but more flexible in the kinds of lisp expressions
    that may appear as facts and patterns (sublists are allowed
    and flavor objects are treated atomically), the variety of
    tests that may appear in the left hand sides of rules and the
    kinds of actions may appear in the right hand sides of rules.
    In addition, YAPS allows multiple data bases which are flavor
    objects and may be sent messages such as "fact" and "goal".
4.  The windows package in the form of a C loadable library.  This
    flexible package allows convenient management of multiple
    contexts on the screen and runs on ordinary character display
    terminals as well as bit-mapped displays.  Included is a Franz
    lisp interface to the window library, a window shell for
    executing shell processes in windows, and a menu package (also
    a C loadable library).

You should be aware of the fact that the lisp software is based on
Franz Opus 38.26 and that we will be switching to the newer version
of lisp that comes with Berkeley 4.2 whenever that comes out.

---------------------------------------------------------------------

To obtain the Univ of Maryland distribution tape:

1.  Fill in the form below, make a hard copy of it and sign it.
2.  Make out a check to University of Maryland Foundation for $100,
    mail it and the form to:

		Liz Allen
		Univ of Maryland
		Dept of Computer Science
		College Park MD 20742

3.  If you need an invoice, send me mail, and I will get one to you.
    Don't forget to include your US Mail address.

Upon receipt of the money, we will mail you a tape containing our
software and the technical reports describing the software.  We
will also keep you informed of bug fixes via electronic mail.

---------------------------------------------------------------------

The form to mail to us is:


In exchange for the Maryland software tape, I certify to the
following:

a.  I will not use any of the Maryland software distribution in a
    commercial product without obtaining permission from Maryland
    first.
b.  I will keep the Maryland copyright notices in the source code,
    and acknowledge the source of the software in any use I make of
    it.
c.  I will not redistribute this software to anyone without permission
    from Maryland first.
d.  I will keep Maryland informed of any bug fixes.
e.  I am the appropriate person at my site who can make guarantees a-d.

				Your signature, name, position,
				phone number, U.S. and electronic
				mail addresses.

---------------------------------------------------------------------

If you have any questions, etc, send mail to me:

				-Liz Allen, U of Maryland, College Park MD
				 Usenet:   ...!seismo!umcp-cs!liz
				 Arpanet:  liz%umcp-cs@Udel-Relay


From fateman  Thu Sep 29 14:50:17 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA10806; Thu, 29 Sep 83 14:50:17 PDT
Date: Thu, 29 Sep 83 14:50:17 PDT
From: fateman (Richard Fateman)
Message-Id: <8309292150.AA10806@ucbkim.ARPA>
To: franz-friends
Subject: survey
Cc: fateman
Status: O

I am trying to collect some statistics on usage of Franz.
I would like to get answers to these questions:
(1) Your location:
(2) The number of computers at your location (actively) running Franz:
(3) Have you produced a locally modified manual? (y/n)
(4) Are other Lisps in use there? (names?)
(5) Do you use Franz for instruction? research?
(6) Are you distributing or selling packages "on top of" Franz?

(You may also send comments you wish; I will compile results and
redistribute, so please do not respond to "franz-friends", but to me.)
Thanks.

From jkf  Thu Sep 29 23:04:29 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA04355; Thu, 29 Sep 83 23:04:29 PDT
Date: Thu, 29 Sep 83 23:04:29 PDT
From: jkf (John Foderaro)
Message-Id: <8309300604.AA04355@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.80
Status: O

  Two new functions:

    (character-index 'st_string 'xst_char)

    returns the position of the character xst_char in the string
    st_string.  The position of the first character is '1'
    (1-based indexing was chosen because substring also uses
     1-based indexing).
    If the character is not in the string, nil is returned.

     xst_char, as its prefix implies, can either be the fixnum
     value of a character (commonly written #/x), or a symbol
     or string, in which case the first character is used.


  (sleep 'x_seconds)
    sleep for x_seconds.

  


From jkf  Sat Oct  1 21:42:29 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA16280; Sat, 1 Oct 83 21:42:29 PDT
Date: Sat, 1 Oct 83 21:42:29 PDT
From: jkf (John Foderaro)
Message-Id: <8310020442.AA16280@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.81
Status: O

 new function  (sys:nice 'x_delta-priority)
this increments your nice value (decrements your process priority)
by x_delta-priority.    x_delta-priority can only be negative
if you are root, of course.




From unmvax!gatech!pwh  Tue Oct  4 08:35:04 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA23488; Tue, 4 Oct 83 08:35:04 PDT
Received: by ucbvax.ARPA (4.12/4.7)
	id AA07616; Tue, 4 Oct 83 08:05:43 PDT
From: unmvax!gatech!pwh
Message-Id: <8310041505.AA07616@ucbvax.ARPA>
Date:     1 Oct 83 19:44:56-EDT (Sat)
Original-From:      <pwh@gatech>
To: franz-friends@BERKELEY
Subject:  why a HOLE (duck) ?
Status: RO


Could someone explain to me what HOLE is all about in the vax dependent 
Franz code? I've scrutinized the code and read the preliminary Franz 
implementation manual too many times and still can't figure it...

phil hutto




From mbr@nprdc  Sat Oct  8 15:59:38 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA08262; Sat, 8 Oct 83 15:59:38 PDT
Received: from nprdc (nprdc.ARPA) by ucbvax.ARPA (4.12/4.7)
	id AA23633; Sat, 8 Oct 83 15:58:02 PDT
Message-Id: <8310082258.AA23633@ucbvax.ARPA>
Date: 8 Oct 1983 15:52:17-PDT
From: Mark Rosenstein <mbr@NPRDC>
Reply-To: mbr@NPRDC
To: franz-friends@BERKELEY
Subject: bugs in liszt 8.36
Status: RO

Problem:
   -I flag doesn't work
Solution??
   in file tlev.l change 'i to 'I in line 127
   (notice that -i flag includes files and it is imposible to get
    into uci mode)

Problem:
   while compiling get message:
     Undefined function called from compiled code   e-sub2
Solution??
   in file tlev.l change e-sub2 to e-sub in line 298
   (I don't swear by this solution--my stuff seems to compile ok
    but no promises)

From jkf  Wed Oct 12 06:11:15 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA29652; Wed, 12 Oct 83 06:11:15 PDT
Date: Wed, 12 Oct 83 06:11:15 PDT
From: John Foderaro (on an h19-u) <jkf>
Message-Id: <8310121311.AA29652@ucbkim.ARPA>
To: local-lisp
Subject: New AI language in the works
Cc: 
Status: RO


From: Skef Wholey <Wholey@CMU-CS-C.ARPA>

>From an article "Computing Women" in a shoddy little pseudo-magazine
called "Ampersand" that was stuck inside CMU's student newspaper this
week:

	Our final tip involves a different kind of research.  Is a
	breakthough in computing happening right on your own
	campus?  MIT and Carnegie-Mellon University, for example,
	are busy developing a brainchild called Lisp.  If
	successful, Lisp may become the standard language of
	``artificially intelligent'' computers that ``think''
	within a limited sphere on their own.  Imagine your
	marketability if you've worked with a poineer in this
	field.  Skip a football game some Saturday afternoon and
	see what the Prof is doing with HIS spare time.  It could
	be profitable to you.





From @MIT-MC:apm@cmu-ri-isl1  Fri Oct 14 09:27:56 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA14501; Fri, 14 Oct 83 09:27:56 PDT
Received: from MIT-MC (mit-mc.ARPA) by ucbvax.ARPA (4.12/4.7)
	id AA00195; Fri, 14 Oct 83 09:26:15 PDT
Message-Id: <8310141626.AA00195@ucbvax.ARPA>
Date: 14 Oct 1983 12:22:28-EDT
From: Andrew.Mendler@CMU-RI-ISL1
Subject: eunice version of franz
Apparently-To: <franz-friends@UCB-VAX>
Status: RO

What is the most recent version of franz lisp that is available under eunice?
In particular is opus38.55 available?

Thanks in advance.


From sklower  Fri Oct 14 09:45:15 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA14694; Fri, 14 Oct 83 09:45:15 PDT
Date: Fri, 14 Oct 83 09:45:15 PDT
From: sklower (Keith Sklower)
Message-Id: <8310141645.AA14694@ucbkim.ARPA>
To: franz-friends
Subject: eunice version of franz
Status: RO

We have opus38.79 working on David Kashtan's machine.  The source
is integrated with the vax-unix and 68000 versions, all available
by anonymous ftp, or as the regular tape distribution.  I have had
one report from a eunice user that the installation didn't get past
construction the kernel, but it could be due to insufficient quota.

From jkf  Sun Oct 16 16:39:35 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA03935; Sun, 16 Oct 83 16:39:35 PDT
Date: Sun, 16 Oct 83 16:39:35 PDT
From: John Foderaro (on an aaa-60-s) <jkf>
Message-Id: <8310162339.AA03935@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.82
Cc: 
Status: RO

  I'm working on a simple record (destruct-like) package. Consequently,
I've made 'defrecord' autoload my record package.  This will cause
problems if there are people who use the name 'defrecord' as a
non-macro function.   If this will cause you problems, please speak up.



From procter@UCBMIRO  Mon Oct 17 08:59:02 1983
Received: from UCBMIRO.ARPA by ucbkim.ARPA (4.6/4.2)
	id AA01206; Mon, 17 Oct 83 08:59:02 PDT
Date: 16 Oct 83 22:56:00 PDT (Sun)
From: procter@UCBMIRO (Steve Procter)
Subject: cfasl
Message-Id: <8310170556.AA01323@UCBMIRO.ARPA>
Received: by UCBMIRO.ARPA (3.340/3.29)
	id AA01323; 16 Oct 83 22:56:00 PDT (Sun)
To: local-lisp@ucbkim
Status: O

	How are arguements passed from lisp to the C routines?
I wrote a program which just printed the arguements passed to it, 
and when I cfasl'd it and used it, I got argc > 500000...

						steve procter
						procter@ucbmiro

From jkf  Mon Oct 17 10:08:37 1983
Received: by ucbkim.ARPA (4.6/4.2)
	id AA02418; Mon, 17 Oct 83 10:08:37 PDT
Date: Mon, 17 Oct 83 10:08:37 PDT
From: John Foderaro (on an h19-u) <jkf>
Message-Id: <8310171708.AA02418@ucbkim.ARPA>
To: procter@UCBMIRO
Subject: Re: cfasl
Cc: local-lisp
In-Reply-To: Your message of 16 Oct 83 22:56:00 PDT (Sun)
Status: O

  Arguments are passed to C functions in the normal C way (on the stack
not as strings on the command line).   There are examples in the
lisp manual (in the section on foreign functions).



From whm.Arizona@Rand-Relay  Fri Oct 28 05:44:39 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.16/4.2)
	id AA20395; Fri, 28 Oct 83 05:44:39 pdt
Received: from rand-relay.ARPA by ucbvax.ARPA (4.16/4.13)
	id AA14289; Fri, 28 Oct 83 05:43:48 pdt
Message-Id: <8310281243.AA14289@ucbvax.ARPA>
Date: 28 Oct 1983 01:12:45-PST
From: whm.arizona@Rand-Relay
Return-Path: <whm.Arizona@Rand-Relay>
Subject:  Memory management in Franz
Date-Sent: 28 Oct 83 01:12:42 MST  (Fri)
To: franz-friends@BERKELEY
Via:  Arizona; 28 Oct 83 2:37-PDT
Status: O

I've got a couple of questions about Franz Lisp storage management that
I wondering if somebody "in the know" might be able to answer.  I tried
this on net.lang.lisp, but didn't get any answers.

First, Franz seems to support non-relocatable data objects such as
external functions.  Are such objects managed by having two logical
regions in managed memory, one for relocatable objects and one for
non-relocatable objects?  Such a scheme has been used in other systems
that require garbage collection and I was wondering if Franz uses
this or some other scheme.

Second, I've heard (but not tried) that Franz allows non-relocatable
data to be allocated via brk/sbrk.  Is this true?

(Actually, I suppose I'd like information on any storage management
implementations for any languages (w/ automatic storage management)
that allow non-relocatable data to be dynamically allocated that don't
use the aforementioned scheme.)

					Thanks,
					Bill Mitchell
					whm.arizona@rand-relay
p.s.
I'm not on the Franz-Friends list, so if you would, please mail me
any replies.

From whm.Arizona@Rand-Relay  Mon Oct 31 04:55:33 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.16/4.2)
	id AA29912; Mon, 31 Oct 83 04:55:33 pst
Received: from rand-relay.ARPA by ucbvax.ARPA (4.16/4.13)
	id AA08771; Mon, 31 Oct 83 04:54:49 pst
Message-Id: <8310311254.AA08771@ucbvax.ARPA>
Date: 31 Oct 1983 00:41:38-PST
From: whm.arizona@Rand-Relay
Return-Path: <whm.Arizona@Rand-Relay>
Subject:  Memory management in Franz
Date-Sent: 31 Oct 83 00:41:36 MST  (Mon)
To: franz-friends@BERKELEY
Via:  Arizona; 31 Oct 83 1:36-PST
Status: O

[My apologies if this is a repeat; I got some very wierd messages back
from the Berkeley mailer on my first attempt to send this.]

I've got a couple of questions about Franz Lisp storage management that
I wondering if somebody "in the know" might be able to answer.  I tried
this on net.lang.lisp, but didn't get any answers.

First, Franz seems to support non-relocatable data objects such as
external functions.  Are such objects managed by having two logical
regions in managed memory, one for relocatable objects and one for
non-relocatable objects?  Such a scheme has been used in other systems
that require garbage collection and I was wondering if Franz uses
this or some other scheme.

Second, I've heard (but not tried) that Franz allows non-relocatable
data to be allocated via brk/sbrk.  Is this true?

(Actually, I suppose I'd like information on any storage management
implementations for any languages (w/ automatic storage management)
that allow non-relocatable data to be dynamically allocated that don't
use the aforementioned scheme.)

					Thanks,
					Bill Mitchell
					whm.arizona@rand-relay
p.s.
I'm not on the Franz-Friends list, so if you would, please mail me
any replies.

From pjt@brl-voc  Tue Nov  1 06:52:11 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.16/4.13)
	id AA03145; Tue, 1 Nov 83 06:52:11 pst
Received: from BRL-VOC (brl-voc.ARPA) by ucbvax.ARPA (4.16/4.13)
	id AA01150; Tue, 1 Nov 83 06:51:14 pst
Message-Id: <8311011451.AA01150@ucbvax.ARPA>
Date:     Tue, 1 Nov 83 9:44:54 EST
From: Paul Tanenbaum <pjt@brl-voc>
To: Ailist-requests@sri-ai, Franz-Friends@BERKELEY
Cc: pjt@brl-voc
Subject:  mailing list
Status: O

Please cons me onto your mailing list
     Thanks,
     paul   <pjt@brl-voc>


From norvig  Fri Nov  4 14:14:16 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA20986; Fri, 4 Nov 83 14:14:16 pst
Date: Fri, 4 Nov 83 14:14:16 pst
From: norvig (Peter Norvig)
Message-Id: <8311042214.AA20986@ucbkim.ARPA>
To: mills@ernie
Subject: Graphics on Suns
Cc: local-lisp
Status: O

I want a lisp-callable package to display trees and graphs on the suns.
This is for showing semantic nets, and it would also be useful for showing
how procedures call each other, like Interlisp's masterscope. Does anyone
know of such a package?

From kanderso@bbn-vax  Fri Nov  4 19:55:59 1983
Received: from ucbvax.ARPA by ucbkim.ARPA (4.16/4.13)
	id AA26540; Fri, 4 Nov 83 19:55:59 pst
Received: from bbn-vax (bbn-vax.ARPA) by ucbvax.ARPA (4.16/4.13)
	id AA03738; Fri, 4 Nov 83 19:55:52 pst
Message-Id: <8311050355.AA03738@ucbvax.ARPA>
Date: Fri, 4 Nov 83 22:55 EST
From: Ken Anderson <kanderso@BBN-Vax>
Subject: Why no &keywords in local functions?
To: franz-friends@BERKELEY
Status: O

With liszt version 8.29 (Opus 38.66 of Franz) I get the following message:

?Error: save.l: save-install: local functions can't use &keyword's save-install

When compiling the function (declared as a localf):

(defun save-install (thing table &aux type handler)
    ; Install thing in hash table, and recursively install its parts.
    (cond ((memq (setq type (save-type thing))
		 '(symbol number)))	; Needn't install
	  (t (cond ((zerop (save-count++ thing))
		    ; Increment access count, and install parts of thing if it
		    ; is being installe
		    (cond ((setq handler (get type 'save-install-parts))
			   (funcall handler thing table))
			  (t (ferror "Don't Know how to save ~S~%" thing))))))))

This used to work in earlier Opuses (like 38.44).  Can you explain the
change.

From norvig  Tue Nov  8 01:51:03 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA20986; Fri, 4 Nov 83 14:14:16 pst
Date: Fri, 4 Nov 83 14:14:16 pst
From: norvig (Peter Norvig)
Message-Id: <8311042214.AA20986@ucbkim.ARPA>
To: mills@ernie
Subject: Graphics on Suns
Cc: local-lisp
Status: O

I want a lisp-callable package to display trees and graphs on the suns.
This is for showing semantic nets, and it would also be useful for showing
how procedures call each other, like Interlisp's masterscope. Does anyone
know of such a package?

From norvig  Tue Nov  8 02:03:27 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA20986; Fri, 4 Nov 83 14:14:16 pst
Date: Fri, 4 Nov 83 14:14:16 pst
From: norvig (Peter Norvig)
Message-Id: <8311042214.AA20986@ucbkim.ARPA>
To: mills@ernie
Subject: Graphics on Suns
Cc: local-lisp
Status: O

I want a lisp-callable package to display trees and graphs on the suns.
This is for showing semantic nets, and it would also be useful for showing
how procedures call each other, like Interlisp's masterscope. Does anyone
know of such a package?

From sklower  Thu Nov 17 17:03:27 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA01897; Thu, 17 Nov 83 17:03:27 pst
Date: Thu, 17 Nov 83 17:03:27 pst
From: sklower (Keith Sklower)
Message-Id: <8311180103.AA01897@ucbkim.ARPA>
To: local-lisp
Subject: lisp sources
Status: O

Franz now resides in /usr/franz.

From jkf  Tue Nov 22 09:33:32 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA15675; Tue, 22 Nov 83 09:33:32 pst
Date: Tue, 22 Nov 83 09:33:32 pst
From: John Foderaro (on an h19-u) <jkf>
Message-Id: <8311221733.AA15675@ucbkim.ARPA>
To: local-lisp
Subject: liszt 8.39
Cc: 
Status: O

  The -W switch has been added to liszt.  When specified, if a compilation
causes any warning messages to given (such as a symbol declared special),
then the compiler will not perform the assembly and will return a non-zero
exit status (for 'make's benefit).   Liszt will continue to compile after it
has seen a warning, even if -W is given, to permit as many warnings as
possible to be made in each compile.




From barry%umcp-cs@CSNet-Relay  Tue Nov 22 17:14:09 1983
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA23508; Tue, 22 Nov 83 17:14:09 pst
Received: from csnet-cic.ARPA by UCB-VAX.ARPA (4.21/4.15)
	id AA06655; Tue, 22 Nov 83 17:13:29 pst
Message-Id: <8311230113.AA06655@UCB-VAX.ARPA>
Date:     22 Nov 83 12:48:01 EST  (Tue)
From: Barry Perricone <barry%umcp-cs@CSNet-Relay>
Return-Path: <barry%umcp-cs@CSNet-Relay>
Subject:  Franz for VMS
To: franz-friends@BERKELEY
Via:  UMCP-CS; 22 Nov 83 19:25-EST
Status: O


  I need to know if anybody has a version of Franz for the Vax series
under VMS which includes 'liszt'.  Also one which when a 'dumplisp'
is performed will output a file which can execute as a stand-alone
(i.e., does not need to be "restored").  I would appreciate
any information on this matter, and if one exists information
on how I could obtain a copy of it.

Thanks in advance,
Barry P.

From alfred.ct@Rand-Relay  Sat Dec  3 22:40:07 1983
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA12594; Sat, 3 Dec 83 22:40:07 pst
Received: from rand-relay.ARPA by UCB-VAX.ARPA (4.22/4.16)
	id AA06631; Sat, 3 Dec 83 21:43:27 pst
Message-Id: <8312040543.AA06631@UCB-VAX.ARPA>
Date: 3 Dec 1983 11:58:11-PST
From: alfred.ct@Rand-Relay
Return-Path: <alfred.ct@Rand-Relay>
Subject: Deficiency in Franz GC
To: franz-friends@BERKELEY
Via:  ct; 3 Dec 83 12:46-PST
Status: RO

This really isn't a bug so much as a deficiency
in the code.  We are running Opus 38.26 and recently
had need to increase the constant TTSIZE (in config.h)
above the default 10216.  It turns out that this
breaks the garbage collector which will fail
to completely clear the array bitmapi
if given a TTSIZE greater 10216 (during the
clearing out of bit maps).  The offending code
is in Talloc.c (or alloc.c, depending on your Opus).
The old code is:

	/* try the movc5 to clear the bit maps */
	/* the maximum number of bytes we can clear in one sweep is
	 * 2^16 (or 1<<16 in the C lingo)
	 */
	bytestoclear = ((((int)datalim)-((int)beginsweep)) >> 9) * 16; 
	if(bytestoclear > MAXCLEAR)
	{ 
	   blzero(((int) &bitmapi[((int)beginsweep>>7)]) + MAXCLEAR, 
			    bytestoclear - MAXCLEAR);
	   bytestoclear = MAXCLEAR;
	}
	blzero((int)&bitmapi[((int)beginsweep)>>7],bytestoclear);

and the fixed version that we have been running for several weeks
now is:

	/* try the movc5 to clear the bit maps */
	/* the maximum number of bytes we can clear in one sweep is
	 * 2^16 (or 1<<16 in the C lingo)
	 */
	bytestoclear = ((((int)datalim)-((int)beginsweep)) >> 9) * 16;
	{int count = 0; 
    	while (bytestoclear > 0) {
	    if(bytestoclear > MAXCLEAR)
	    { 
	   	blzero(((int) &bitmapi[((int)beginsweep>>7)])+count*MAXCLEAR, 
			    MAXCLEAR);
	   	++count;
	    }
	    else
	    	blzero(((int)&bitmapi[((int)beginsweep)>>7]+count*MAXCLEAR),
			bytestoclear);
   	    bytestoclear -= MAXCLEAR;
	    }
	}

The old code is still present in Opus 38.56.

Alfred Correira
Paul Robertson
...ucbvax!nbires!ctvax!alfred (UUCP)
alfred.ct@Rand-Relay (CSNET)

From fateman  Tue Dec 13 09:11:00 1983
Received: by ucbkim.ARPA (4.16/4.13)
	id AA03666; Tue, 13 Dec 83 08:31:30 pst
Date: Tue, 13 Dec 83 08:31:30 pst
From: fateman (Richard Fateman)
Message-Id: <8312131631.AA03666@ucbkim.ARPA>
To: local-lisp
Cc: pattrsn
Status: O

I have just received a copy of the new Common Lisp Reference Manual
(The Mary Poppins Edition ... Practically Perfect in Every Way)
... it is 385 pages long.

From hoey@nrl-aic  Wed Jan 11 12:58:53 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA06395; Wed, 11 Jan 84 12:58:53 pst
Received: from nrl-aic (nrl-aic.ARPA) by UCB-VAX.ARPA (4.22/4.19)
	id AA03955; Wed, 11 Jan 84 12:58:55 pst
Message-Id: <8401112058.AA03955@UCB-VAX.ARPA>
Date: 11 Jan 1984 14:43-EST
From: Dan Hoey <hoey@NRL-AIC>
Subject: Problems with arrays in Franz
Apparently-To: <FRANZ-FRIENDS@berkeley>
Status: O



From hoey@nrl-aic  Wed Jan 11 13:10:01 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA06529; Wed, 11 Jan 84 13:10:01 pst
Received: from nrl-aic (nrl-aic.ARPA) by UCB-VAX.ARPA (4.22/4.19)
	id AA04150; Wed, 11 Jan 84 13:09:46 pst
Message-Id: <8401112109.AA04150@UCB-VAX.ARPA>
Date: 11 Jan 1984 14:43-EST
From: Dan Hoey <hoey@NRL-AIC>
Subject: Problems with arrays in Franz
To: FRANZ-FRIENDS@BERKELEY
Status: O

Hard to believe but it was less than two and a half years ago that
someone was having trouble using Franz arrays...

    Date: 17 Jul 1981 17:06:22-PDT
    From: CSVAX.jkf at Berkeley
    To: FININ@WHARTON-10
    cc: franz-friends at MIT-MC
    Subject: Re: ... the maclisp-style array package.
    In-reply-to: Your message of 17 Jul 1981 1347-PDT (Friday).

        From: FININ@WHARTON-10
        Subject: ... the maclisp-style array package.

        ...
        [3] We've been having problems with the MacLisp compatable array
            package - it doesn't work!  Does anyone have a debugged version?

    Can you be more specific? We use it in Vax Macsyma without any problems.
    Personally I feel that Maclisp arrays were invented by a madman and no new
    code should be written using them.  

    -- john foderaro

Well, I used the Maclisp array package because I didn't want to waste
time writing my own.  Instead I spent hours looking for the bug in this
code:

    -> (let ((factorial (*array () () 100.)))
            (store (factorial 0) 1)
	    (do ((i 1 (1+ i)))
	        ((= i 100.))
                (store (factorial i) (times i (factorial (1- i)))))
            (factorial 10.))
    285656

To make a long story short, this lossage is because the second argument
to *array being nil tells the garbage collector not to scan the
array.  The factorial of ten gets tossed in the bit bucket, where it
unfortunately looks like a fixnum.  To fix the example, change the
first line of the example to

    -> (let ((factorial (*array () t 100.)))

To save someone else from excruciatingly wrong answers, change the
documentation in Section 2.

    (*array 's_name 's_type 'x_dim1 ... 'x_dimn)
    (array s_name s_type x_dim1 ... x_dimn)

         WHERE:   s_type may be one of t, nil,  fixnum,  flonum,
                  fixnum-block and flonum-block.
           ...
<                  In FRANZ LISP arrays of type t, nil, fix-
<          num and flonum are equivalent and the elements of
<          these  arrays  can  be  any  type of lisp object.
---
>                  In  FRANZ  LISP arrays of type t, fixnum,
>          and  flonum  are  equivalent  and the elements of
>          these arrays can  be  any  type  of  lisp object.
>          Type nil arrays may also contain any type of lisp
>          object,  but  they are not marked  by the garbage
>          collector  (see 9.2.2)  and can lose data if used
>          incorrectly.
           Fixnum-block and  flonum-block  arrays  are  res-
           tricted  to  fixnums and flonums respectively and
           are used mainly to communicate with foreign func-
           tions (see 8.4).

Dan

From hoey@nrl-aic  Wed Jan 11 16:23:56 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA06395; Wed, 11 Jan 84 12:58:53 pst
Received: from nrl-aic (nrl-aic.ARPA) by UCB-VAX.ARPA (4.22/4.19)
	id AA03955; Wed, 11 Jan 84 12:58:55 pst
Message-Id: <8401112058.AA03955@UCB-VAX.ARPA>
Date: 11 Jan 1984 14:43-EST
From: Dan Hoey <hoey@NRL-AIC>
Subject: Problems with arrays in Franz
Apparently-To: <FRANZ-FRIENDS@berkeley>
Status: O



From fateman@ucbdali  Sun Jan 15 14:58:17 1984
Received: from ucbdali.ARPA by ucbkim.ARPA (4.16/4.13)
	id AA00458; Sun, 15 Jan 84 14:58:17 pst
Received: by ucbdali.ARPA (4.22/4.18)
	id AA02865; Sun, 15 Jan 84 14:58:51 pst
Date: Sun, 15 Jan 84 14:58:51 pst
From: fateman@ucbdali (Richard Fateman)
Message-Id: <8401152258.AA02865@ucbdali.ARPA>
To: franz-friends@ucbdali
Subject: FUGUE.3
Status: O








                        FUGUE Notes

               An occasional publication of the
    Franz Lisp User Group under Unix and Eunice (FUGUE)

                  Number 3 (January, 1984)
                edited by Richard J. Fateman
                  University of California
                     Berkeley CA 94720
                            USA
                      fateman@berkeley

_1.  _W_e_l_c_o_m_e!

     It seems about time  to  publish  the  third  of  these
newsletters,  since  we  have  accumulated  a  number of new
items.  We would also like to relay to others such  informa-
tion as has been forwarded to us. The reports of projects at
Berkeley (and elsewhere) may strike sympathetic chords  with
other research.

_2.  _N_e_w _i_m_p_l_e_m_e_n_t_a_t_i_o_n_s

     Franz now runs on a number of Motorola 68000 and  68010
systems,  including  DUAL,  PIXEL,  Apple-LISA  (UNIX),  and
undoubtedly a large number of other UNISOFT Inc. UNIX ports.
(The  LISA  has  only  a 1 megabyte address space, and hence
cannot run the compiler.  It can  load  cross-compiled  pro-
grams.)  Non-UNISOFT  UNIX  systems we have Franz running on
include the 4.2BSD" Sun Microsystems operating system.

     Some work is beginning on  high-speed  VLSI  chips  for
Lisp, using the reduced instruction set technology which has
been successfully used at UCB in the past.  More information
on this will be available in the near future.

_3.  _N_e_w _p_r_o_g_r_a_m_s

_3._1.  _V_a_x_i_m_a _a_n_d _A_l_g_e_b_r_a_i_c _M_a_n_i_p_u_l_a_t_i_o_n

     Macsyma runs on the 68000 workstations with  sufficient
memory  both virtual and real.  At least 4 megabytes of vir-
tual is needed, but benchmarks suggest  that  anything  less
than  2 megabytes of real memory is painful.  We recommend 4
or more real megabytes.  The PIXEL machine with 6  megabytes
(unpaged) is our fastest real-time Macsyma system, (CPU-time
is about 25% longer than reported VAX-780 CPU time, but more
to the point, CPU-time is equal to real-time).  Distribution
____________________
9   UNIX, Eunice, Franz Lisp, may be trademarks of Bell Labs,
SRI Int'l, and Univ. of Calif.



9










of 68000 Macsyma will presumably be done by Symbolics, (con-
tact  RP@mit-mc,  with  a  cc to fateman@berkeley if you are
interested).

     Development of a new algebra system and  user  applica-
tion  modules  is  proceeding,  and  a  programming language
called Newspeak, initially implemented on top of  Franz,  is
the  principal vehicle. This is described in John Foderaro's
PhD dissertation, available from the  CS  Division  at  UCB.
(Newspeak  is  hierarchical,  object-oriented,  and strongly
typed;  is  compiler-based,  and  should  provide  efficient
access  to  machine  resources).   While the algebra code is
progressing well, we are not yet ready to set a release date
for the user-end of the system, tentatively named Xi.

_4.  _N_e_w _f_e_a_t_u_r_e_s

     As usual,  various  performance  enhancements  and  bug
fixes  have  been  incorporated in versions of Franz (now on
Opus 38.87 and the compiler, Liszt 8.39) Most  changes  made
it  into  the  recent Berkeley 4.2BSD UNIX distribution, and
reported alterations will not be repeated here.

_5.  _O_t_h_e_r _L_i_s_p_s

     We understand that a version of PSL will  be  supported
by  Hewlett  Packard,  on  its workstations, and that Common
Lisp, from DEC will  have  initial  field-test  in  January,
1984.   We  believe  PSL  should be available from Utah in a
form for running on 4.2BSD VAX UNIX; similarly for "T"  from
Cognitive  Systems.   We  believe that a Common-Lisp support
package for Franz may be constructed, but probably not at UC
under current funding. (see Business news below, though).

_6.  _W_o_r_k _i_n _P_r_o_g_r_e_s_s

_6._1.  _G_r_a_p_h_i_c_s

     Gregg Foster has  constructed  a  graphics  Franz  Lisp
which  includes  the  full Sun Microsystems Graphics package
for Sun-2 systems, and Keith Sklower has  constructed  a  C-
structure  package  in  Franz  to enable programmers to more
easily construct arbitrary C-structures in Lisp, to pass  to
C.  Various  demonstration  programs  have  been  written to
access the smooth-curve plotting capabilities, variable-size
fonts, etc.

_6._2.  _I_B_M _F_r_a_n_z

     Still more nibbles on this one, but not yet. We heard a
rumor  of  work  at  Columbia University. (also see the next
item.)
9

9










_7.  _B_u_s_i_n_e_s_s _N_e_w_s

_7._1.  _F_r_a_n_z _I_n_c

     A new software company has been formed to support Franz
and  application  programs,  and  is  seeking customers in 3
categories: (a) manufacturers of hardware wishing to  obtain
a  Lisp  system  and/or Lisp support; (b) software producers
who wish to have reliable access to experts  in  Franz,  for
enhancement,  support, training or porting of existing code.
(c) end-users who are using Franz or applications written in
Franz and need help in customizing, debugging, conversion to
or from other dialects, etc.

     The University of California will continue  to  distri-
bute  Franz  Lisp  on  its current basis, but your questions
about support in any of these categories,  or  about  future
plans,  can be directed to Franz Inc. Most of the principals
at UC will be participating in this venture.  Contact  Franz
Inc. via fkunze@berkeley, or (to avoid abuse of various net-
work privileges), Fritz Kunze, President, Franz  Inc.,  6321
Thornhill Drive, Oakland, Ca 94611 (415) 339-1481.






























9

9




From cowan@AEROSPACE  Thu Jan 19 09:56:25 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA14836; Thu, 19 Jan 84 09:56:25 pst
Received: from aerospace.ARPA by UCB-VAX.ARPA (4.22/4.19)
	id AA02684; Thu, 19 Jan 84 09:55:33 pst
Message-Id: <8401191755.AA02684@UCB-VAX.ARPA>
Date:           Thu, 19 Jan 84 09:55:01 PST
From: Ric Cowan <cowan@AEROSPACE>
To: franz-friends@BERKELEY
Subject:        Help
Status: O

Hi, 

I'm starting a new project and would like to use Franz lisp. It is a large
application that needs to:

	(1) Run on a VAX 11/780 under VMS.
	(2) Interface with INGRESS.
	(3) Support a menu driven interface with VT100 type terminals.

Is Franz lisp a viable language to use? 

Thanks in advance,

Ric Cowan

From levitt@aids-unix  Thu Jan 26 17:44:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA10074; Thu, 26 Jan 84 17:44:03 pst
Received: from aids-unix (aids-unix.ARPA) by UCB-VAX.ARPA (4.22/4.19)
	id AA02121; Thu, 26 Jan 84 17:01:25 pst
Message-Id: <8401270101.AA02121@UCB-VAX.ARPA>
Date: 26 Jan 1984 16:25:55-PST
From: Tod Levitt <levitt@aids-unix>
To: franz-friends@BERKELEY
Subject: report PAM 124, "Parlez vous Franz..." by James Larus
Cc: levitt@aids-unix
Status: O

I am trying to obtain a copy of PAM report 124 which discusses
interfacing foreign functions to Franzlisp. Can someone please
point me at a source for this document? Thanks...
                            Tod Levitt (levitt@aids-unix)

From jkf@ucbmike  Fri Jan 27 08:44:54 1984
Received: from ucbmike.ARPA by ucbkim.ARPA (4.16/4.13)
	id AA15308; Fri, 27 Jan 84 08:44:54 pst
Date: Fri, 27 Jan 84 08:44:40 pst
From: John Foderaro (on an h19-u) <jkf@ucbmike>
Message-Id: <8401271644.2469@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.17/3.5)
	id AA02469; Fri, 27 Jan 84 08:44:40 pst
To: local-lisp@kim
Subject: lisp 38.88
Cc: 
Status: O

 The 'msg' macro now accepts the special form (T 'x_column), and it
spaces over to that column (plus 1).

-> (msg "foo" (T 10) "bar" N "baz" (T 11) "bof" N)
foo       bar
baz        bof
nil
->

Note that the method used to locate the column only works if nothing
has yet been actually written on the line.  Problems will occur if you drain
the port in the middle of the line.

For example:
-> (msg "foo" D (T 10) "bar" N		<< here we drain after "foo"
        "foo"   (T 10) "bar" N)
foo          bar		<< thus column 11 turns out to be column 14
foo       bar
nil
->


From jkf@ucbmike  Tue Jan 31 10:55:51 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.16/4.13)
	id AA20759; Tue, 31 Jan 84 10:55:51 pst
Received: from ucbmike.ARPA by UCB-VAX.ARPA (4.22/4.21)
	id AA12296; Tue, 31 Jan 84 10:51:34 pst
Date: Tue, 31 Jan 84 10:51:33 pst
From: John Foderaro (on an sun-e) <jkf@ucbmike>
Message-Id: <8401311851.1218@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.17/3.5)
	id AA01218; Tue, 31 Jan 84 10:51:33 pst
To: franz-friends@BERKELEY
Subject: LISPcraft, a book on Lisp and Franz.
Cc: 
Status: O

  A new Lisp book is due out March 23rd which may be especially interesting 
to Franz Lisp users or potential Franz Lisp users.   The title
is `LISPcraft' and it was written by Robert Wilensky, a Computer Science
professor at Berkeley who teaches AI programming courses.
  The book starts at first principles and teaches Lisp programming, and then 
goes on to Franz-specific topics such as debugging, read macros, error 
handling, and compilation.   Then there are chapters on Lisp 
applications: pattern matching and databases.  Finally it contains 
a complete description of all Franz functions.

details:
LISPcraft, by Robert Wilensky    385 pages, $19.95
publisher: W. W. Norton, 500 5th Avenue, N.Y. N.Y.  10110
           800-223-2584




From jkf@ucbmike  Fri Feb  3 08:03:58 1984
Received: from ucbmike.ARPA by ucbkim.ARPA (4.16/4.13)
	id AA19272; Fri, 3 Feb 84 08:03:58 pst
Date: Fri, 3 Feb 84 08:04:17 pst
From: John Foderaro (on an h19-u) <jkf@ucbmike>
Message-Id: <8402031604.2117@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.17/3.5)
	id AA02117; Fri, 3 Feb 84 08:04:17 pst
To: local-lisp@kim
Subject: opus 38.89
Cc: 
Status: O

 In opus 38.88 the msg macro was extended to make (T n) put the cursor
on column n+1.   Others had extended the msg macro in a conflicting way,
so we decided to convert over to their extensions.  So forget what
you read in the opus38.88 message, and remember this:
	(C n)	go to column n.  The first column on the line is column 1.
	        If the cursor is beyond column n, then go to the next line
		and go to column n.
	(T m)   print m tab characters
	
	
	


From jkf  Thu Feb 16 10:32:03 1984
Received: by ucbkim.ARPA (4.16/4.22)
	id AA16308; Thu, 16 Feb 84 10:32:03 pst
Date: Thu, 16 Feb 84 10:32:03 pst
From: John Foderaro (on an sun-e) <jkf>
Message-Id: <8402161832.AA16308@ucbkim.ARPA>
To: local-lisp
Subject: opus 38.90
Cc: 
Status: O

 For those of you using the 'tpl' toplevel, the new command ?fast
will set all switches for maximum speed:
	(*rset nil)
	(sstatus translink on)
	(setq displace-macros t)
 	


From wilensky@ucbdali  Wed Feb 22 09:58:43 1984
Received: from ucbdali.ARPA by ucbkim.ARPA (4.16/4.22)
	id AA16486; Wed, 22 Feb 84 09:58:43 pst
Received: by ucbdali.ARPA (4.22/4.22)
	id AA06784; Wed, 22 Feb 84 09:57:21 pst
Date: Wed, 22 Feb 84 09:57:21 pst
From: wilensky@ucbdali (Robert Wilensky)
Message-Id: <8402221757.AA06784@ucbdali.ARPA>
To: andy@aids-unix, franz-friends@ucbdali
Subject: Re: Franz Flavors & software copyright
In-Reply-To: Your message of 21 Feb 1984 16:29-PST
Status: O


Thanks for your clarification.  Everything you said is consistent with my
understanding of the situation.  And you are correct in emphasizing the
complexity of the issue.  But I want to stress my main point.  This is
that the ``author'' holds the copyright.  It may be unclear who the author
is, but it is clearly NOT the university. 

In addition, many pieces of ``university-developed'' software have
contributions by unfunded students, and by faculty, whose salary is not paid
by the gov't (except maybe during the summer).  Furthermore, it would seem
to be unclear who the author is if it is, say, a student working as a gov't
sponsored r. a.  For example, the student's thesis is presumably his to
copyright, even if the student were paid by the gov't because it was not
part of what he was paid to do.  One could argue that a concommitant program
has the same status unless it were specifically contracted for.

Let me state that my main purpose was not to promote people selling their
code, but rather, to stop the universities from impeding its distribution.
As far as I know, the gov't hasn't tried to prevent us from giving each
other our software, but many universities have.  Therefore, we are better
off leaving them out of the picture entirely - legally this seems to be a
sound position.


From jkf@ucbmike  Wed Mar 14 09:04:55 1984
Received: from ucbmike.ARPA by ucbkim.ARPA (4.16/4.22)
	id AA00884; Wed, 14 Mar 84 09:04:55 pst
Date: Wed, 14 Mar 84 08:58:51 pst
From: John Foderaro (on an h19-u) <jkf@ucbmike>
Message-Id: <8403141658.3782@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.17/3.5)
	id AA03782; Wed, 14 Mar 84 08:58:51 pst
To: fateman@ucbdali, sklower@ucbdali, layer@ucbdali, chris@cory
Subject: lisps running wild 
Cc: local-lisp@kim
In-Reply-To: Your message of Tue, 13 Mar 84 21:45:25 pst
Status: O

re:	
	From: chris@ucbcory (Chris Guthrie)
	We are having a good deal
	of trouble with them being left running instead of dying and killing
	the load here.

The problem is that people are setting a flag in their lisp init files
which instruct lisp to ignore 'end of file' (much like the c shell).
If a connection is broken (ipc connection breaks or modem hangs up), then
lisp is sent a hangup signal (which it ignores) and then a continuous
sequence of 'end of files' which it ignores after a bit of processing.
The solution is this:
  If you have something in your init file which instructs lisp to ignore
end of files  (such as (sstatus ignoreeof t)), then you should also
have   (signal 1 'exit)   in the init file so lisp will exit upon a hangup.




From mcgeer  Wed Mar 14 09:37:45 1984
Received: by ucbkim.ARPA (4.16/4.22)
	id AA01437; Wed, 14 Mar 84 09:37:45 pst
Date: Wed, 14 Mar 84 09:37:45 pst
From: Rick McGeer (on an aaa-60-s) <mcgeer>
Message-Id: <8403141737.AA01437@ucbkim.ARPA>
To: jkf@ucbmike, chris@cory, layer@ucbdali, sklower@ucbdali, fateman@ucbdali
Subject: Re: lisps running wild 
Cc: local-lisp
In-Reply-To: Your message of Wed, 14 Mar 84 08:58:51 pst
Status: O

	John, your top level sets the ignoreeof flag.  Does it also set the
appropriate signal, or should your users do that themselves?


From jkf@ucbmike  Wed Mar 14 09:48:04 1984
Received: from ucbmike.ARPA by ucbkim.ARPA (4.16/4.22)
	id AA01603; Wed, 14 Mar 84 09:48:04 pst
Date: Wed, 14 Mar 84 09:42:15 pst
From: John Foderaro (on an h19-u) <jkf@ucbmike>
Message-Id: <8403141742.3833@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.17/3.5)
	id AA03833; Wed, 14 Mar 84 09:42:15 pst
To: mcgeer@ucbkim, fateman@ucbdali, sklower@ucbdali, layer@ucbdali, chris@cory
Subject: Re: lisps running wild 
Cc: local-lisp@ucbkim
In-Reply-To: Your message of Wed, 14 Mar 84 09:37:45 pst
Status: O

 Since ignoreeof is always set in the new top level, I'll make 'exit on
hangup' the default if you use the new top level.

  


From ROD@SU-AI.ARPA  Sat Mar 17 13:45:58 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.22)
	id AA05623; Sat, 17 Mar 84 13:45:58 pst
Received: from SU-AI.ARPA by UCB-VAX.ARPA (4.24/4.25)
	id AA12441; Sat, 17 Mar 84 13:47:35 pst
Message-Id: <8403172147.AA12441@UCB-VAX.ARPA>
Date: 17 Mar 84  1347 PST
From: Rod Brooks <ROD@SU-AI.ARPA>
Subject: Don't use Franz sortcar!
To: franz-friends@BERKELEY
Status: O


Somewhat bizzarely it seems that Franz Lisp sort and sortcar have
different time complexities. sort is good and sortcar is bad so
I suggest you convert your sortcar's to sort's until someone sorts
this out. The code and transcript below use both sort and sortcar
to sort a list of length n (the list happens to start in precisely
reverse order). A count of the number of calls to the comparison
function is kept. The results show that sort takes n*log(n)
comparisons while sortcar takes n*n. The problem should
be fixable by throwing out code as there must be two sorters lurking
in there!

;;;;;;;;;;;;;;;

(defun gen (n)
    (do ((i 0 (1+ i))
	 (l () (cons (cons i ()) l)))
	((= i n)
	 l)))

(defun compare (x y)
    (setq *count* (1+ *count*))
    (< x y))

(defun compare-cars (x y) (compare (car x) (car y)))

(defun count-sort (n)
    (let ((*count* 0))
	 (sort (gen n) #'compare-cars)
	 *count*))

(defun count-sortcar (n)
    (let ((*count* 0))
	 (sortcar (gen n) #'compare)
	 *count*))

(defun test (n)
    (let ((csort (count-sort n))
	  (csortcar (count-sortcar n)))
	 (list n
	       csort
	       csortcar
	       (/$ (float csort) (*$ (float n) (log n)))
	       (/$ (float csortcar) (float (* n n))))))

;;;;;;;;;;;;;;;

Here's the transcript. The lists of 5 elements are:
	n
	compares for sort
	compares for sortcar
	compares for sort / n*log(n)
	compares for sortcar / n*n


Franz Lisp, Opus 38
-> (load 'test)
t
-> (test 3)
(3 3 6 0.910239226626837 0.6666666666666667)
-> (test 100)
(100 460 9900 0.9988773083774791 0.99)
-> (test 200)
(200 1020 39800 0.9625697456705496 0.995)
-> (test 300)
(300 1440 89700 0.8415468193831012 0.9966666666666667)
-> (test 400)
(400 2240 159600 0.9346629619469353 0.9975)
-> 


From @MIT-MC:smh@MIT-EMS  Wed Mar 28 06:11:15 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.3)
	id AA06408; Wed, 28 Mar 84 06:11:15 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.25)
	id AA23759; Wed, 28 Mar 84 06:10:43 pst
Message-Id: <8403281410.AA23759@UCB-VAX.ARPA>
Date: 28 Mar 1984 09:09:38-EST
From: <smh@mit-ems@mit-mc>
To: franz-friends@BERKELEY
Subject: Fixes for setf return value problem
Status: O

As FranzFriends readers will know, my message several days ago
generated a number of comments.  The clear consensus was that setf
should be fixed, not the documentation.  This was obvious.  The reason
I didn't suggest the fix myself was that I felt it was far more
important to preserve compatibility between Franz and the various other
more-or-less-source-compatible Lisps (aka Common Lisps).  It was my
impression that code relying on the value returned by setf would not
be portable.

I have since learned that Common Lisp does indeed define setf to return
the new value (its second argument), and that other implementations
(i.e. MIT and Symbolics Lisp Machines) indeed work this way.  (Mind
you, I haven't checked this myself -- the information is second hand.)
The fixes to setf are quite straightforward and are brief enough that I
am including them below.  For each case that the setf macro evaluates
to a {rplaca, rplacd, rplacx} the corresponding {car, cdr, cxr} is now
wrapped around it.  The Liszt compiler seems smart enough to remove the
extra reference if the value is ignored.

The new setf functions follow.  The starting version is the Opus 38.69
common2 identified by:
;; common2.l				-[Fri Jul  8 17:46:13 1983 by layer]-
(Although only two lines of setf-check-car+d were changed, the entire
function is included because the change is difficult to locate by
context.)  I suggest these changes be made in the official sources.
Whoever wants to install them should edit common2.l and remake the
Franz interpreter.  The Liszt compiler does not need to be changed.
====================

; modified 27Mar84 SMH@MIT-EMS@MT-MC (see comment below)
;
(defun setf-check-cad+r (name)
 (if (eq (getcharn name 1) #/c)
     then (let
	   ((letters (nreverse (cdr (exploden name)))))
	   (if (eq (car letters) #/r)
	       then (do ((xx (cdr letters) (cdr xx)))
			((null xx)
			 ;; form is c{ad}+r, setf form is
			 ;; (rplac<first a or d> (c<rest of a's + d's>r x))
			 (setq letters (nreverse letters))
			 (eval
			  `(defsetf ,name (e v)
					; SMH@MIT-EMS@MIT-MC	
					; added next line and matching rparen.
				    (list ',(implode `(#/c ,(car letters) #/r))
				     (list
				      ',(concat "rplac" (ascii (car letters)))
				      (list
				       ',(implode `(#/c ,@(cdr letters)))
				       (cadr e))
				      v))))	; SMH@MIT-EMS@MIT-MC
			 t)
			(if (not (memq (car xx) '(#/a #/d)))
			    then (return nil)))))))

. . .

;--- other setf's for car's and cdr's are generated automatically
;
; modified 27Mar84 SMH@MIT-EMS@MIT-MC
; Now whenever setf macro expands to a rplac[adx], the corresponding c[adx]r
; is now wrapped around it so that setf consistently returns its second arg.
; The compiler is smart enough to remove the extra operation if the value
; is not used.
;
(defsetf car (e v) `(car (rplaca ,(cadr e) ,v)))
(defsetf caar (e v) `(car (rplaca (car ,(cadr e)) ,v)))
(defsetf cadr (e v) `(car (rplaca (cdr ,(cadr e)) ,v)))
(defsetf cdr (e v) `(cdr (rplacd ,(cadr e) ,v)))
(defsetf cdar (e v) `(cdr (rplacd (car ,(cadr e)) ,v)))
(defsetf cddr (e v) `(cdr (rplacd (cdr ,(cadr e)) ,v)))
(defsetf cxr (e v) `(cxr ,(cadr e) (rplacx ,(cadr e) ,(caddr e) ,v)))

. . .

(defsetf nth (e v) `(car (rplaca (nthcdr ,(cadr e) ,(caddr e)) ,v)))
(defsetf nthelem (e v) `(car (rplaca (nthcdr (1- ,(cadr e)) ,(caddr e)) ,v)))
(defsetf nthcdr (e v) `(cdr (rplacd (nthcdr (1- ,(cadr e)) ,(caddr e)) ,v)))

. . .

; (defsetf args (e v) `(args ,(cadr e) ,v))	; no longer implemented?

====================

Steven Haflich
MIT Experimental Music Studio
(617)253-7441
smh@mit-ems@mit-mc
decvax!genrad!mit-ems!smh


From fateman@ucbdali  Thu Mar 29 12:07:33 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.3)
	id AA20323; Thu, 29 Mar 84 12:07:33 pst
Received: from ucbdali.ARPA by UCB-VAX.ARPA (4.24/4.25)
	id AA22790; Thu, 29 Mar 84 12:07:08 pst
Received: by ucbdali.ARPA (4.24/4.22)
	id AA04139; Thu, 29 Mar 84 12:07:10 pst
Date: Thu, 29 Mar 84 12:07:10 pst
From: fateman@ucbdali (Richard Fateman)
Message-Id: <8403292007.AA04139@ucbdali.ARPA>
To: franz-friends@BERKELEY
Subject: commercialization of Franz
Status: O


Some people may have gotten the incorrect impression that 
the University of California will cease sending out 
tapes of Franz Lisp.  We intend to continue distribution
of the latest version which is the property of UCB.  This is
currently opus 38.91.  This distribution works, so far as we know,
on SUN releases (0.4, 1.0, 1.1) and Masscomp, and VAX 4.2BSD.
Such distributions will continue, and will continue to be unsupported.
Although we have made reasonable efforts to provide a useful,
portable, efficient, and complete system, we have spent too much of
our time and our sponsors' money in answering
questions about installation-dependent difficulties or 
(what USUALLY turns out to be non-existent) bugs.
I might point out that many of the questions come from commercial users.

Franz Inc. was formed to provide a mechanism for support, transportation
of Franz Lisp to new architectures, enhancements, documentation, etc.
It has the (non-exclusive) right to use, distribute, (etc) Franz Lisp,
and intends to produce enhancements that the University does not
have funding for. I expect that if enhancements of Franz Lisp at UCB 
are produced, these will next be made available on 4.3 BSD tapes. Earlier
distributions of contributed software or locally produced software
MAY occur, but cannot be promised.

I expect that there will continue to be a large number of Franz Lisp
users who are satisfied with the university distribution (on 4.2BSD)
or on the separate tapes (e.g. after opus 38.79) that UCB is sending out.
Others will want the enhanced, supported, version from Franz Inc.

The divergence of versions,
some of which has already occurred with local variants of older
systems being redistributed, seems inevitable regardless of Franz Inc.

I hope this clarifies UCB's position.



From @MIT-MC:smh@MIT-EMS  Wed Apr  4 15:44:42 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.3)
	id AA07196; Wed, 4 Apr 84 15:44:42 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.25)
	id AA01892; Wed, 4 Apr 84 15:14:05 pst
Message-Id: <8404042314.AA01892@UCB-VAX.ARPA>
Date: 4 Apr 1984 16:44:49-EST
From: <smh@mit-ems@mit-mc>
To: franz-friends@BERKELEY
Subject: Re: recent suggested fix to setf
Status: O

There was one mistake in my recent posting with fixes for the Franz
setf function.  I said that it was not necessary to remake liszt (the
compiler).  This was wrong:  code compiled with an old copy of liszt
will not use the modified setf definitions.

The fix is simply to remake liszt after the new Franz interpreter has
been generated.

Sorry about any confusion.

Steve Haflich
MIT Experimental Music Studio
decvax!genrad!mit-ems!smh
smh@mit-ems@mit-mc


From MCLINDEN@RUTGERS.ARPA  Wed Apr 18 20:37:26 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.3)
	id AA16547; Wed, 18 Apr 84 20:37:26 pst
Received: from RUTGERS.ARPA (rutgers.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.27)
	id AA29663; Wed, 18 Apr 84 20:36:21 pst
Message-Id: <8404190436.AA29663@UCB-VAX.ARPA>
Date: 18 Apr 84 23:37:14 EST
From: Sean McLinden  <MCLINDEN@RUTGERS.ARPA>
Subject: [Sean McLinden  <MCLINDEN@RUTGERS.ARPA>: Re: Franz on Suns under 4.2?]
To: franz-friends@BERKELEY
Status: O

Mail-From: MCLINDEN created at 18-Apr-84 23:33:56
Date: 18 Apr 84 23:33:56 EST
From: Sean McLinden  <MCLINDEN@RUTGERS.ARPA>
Subject: Re: Franz on Suns under 4.2?
To: allegra!jdd@UCB-VAX.ARPA
cc: MCLINDEN@RUTGERS.ARPA
In-Reply-To: Message from "allegra!jdd@Berkeley (John DeTreville)" of 18 Apr 84 13:10:10 EST



 I must be missing something with all of this discussion of Franz
 Lisp on Suns. We have had no trouble at all running the current
 (opus 38.91?) Berkeley release on Suns and have been running Sun
 Franz Lisp for nearly a year now.

 The only serious problem that I can recall happened a few sub versions
 ago and was due to a logical error in the C-coded algorithm which
 determined when to garbage collect (as things would have it, it
 never did). The result was that liszt was unable to compile some
 of the lisp coded sources due to the 2 Meg/process limit imposed
 by the Sun operating system (the bug existed in the Vax version as
 well but one would only see it if the lisp image exceeded 6 megs
 which is rare for a compiler run).

 Perhaps you could be more explicit in describing what, exactly,
 the problem is. The people at Berkeley most probably have Suns
 and I am sure that they don't release Sun versions without testing
 them.

 Sean McLinden
 Decision Systems Lab
 University of Pittsburgh
 School of Medicine
-------
-------

From varghese%colostate.csnet@csnet-relay.arpa  Fri May 25 18:47:11 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20472; Fri, 25 May 84 18:47:11 pdt
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.27)
	id AA23631; Fri, 25 May 84 18:45:35 pdt
Message-Id: <8405260145.AA23631@UCB-VAX.ARPA>
Received: From colostate.csnet by csnet-relay;  25 May 84 21:17 EDT
Date: Fri, 25 May 84 13:47:24 mdt
From: varghese%colostate.csnet@csnet-relay.arpa
Received: by csu-cs.UUCP (4.12/3.14)
	id AA11606; Fri, 25 May 84 13:47:24 mdt
To: FRANZ-FRIENDS.BERKELEY@csnet-relay.arpa
Subject: Addition to mailing list




Please add us to the mailing list. Since there will be more than one 
person at this site who wants to be on the mailing list we decided to 
get everything mailed to one central mailbox. 
The mailbox address for this mailing list is 

	frnzlist@colostate

Please note that this is a CSnet address. Thank you,

						    Joe Varghese
						    varghese@colostate


From trk@cmu-cs-g.arpa  Sun Jun  3 19:15:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA07648; Sun, 3 Jun 84 19:15:03 pdt
Received: from CMU-CS-G.ARPA (cmu-cs-g.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.27)
	id AA24832; Sun, 3 Jun 84 19:13:42 pdt
Date: 3 Jun 1984 22:02-EST
From: Todd.Kueny@CMU-CS-G.ARPA
Subject: Please add my name to the list
To: FRANZ-FRIENDS@BERKELEY
Message-Id: <455162572/trk@CMU-CS-G>

Please add my name to the FRANZ-FRIENDS list.
							-Todd K.

From Jonl.pa@Xerox.ARPA  Sun Jun  3 23:24:19 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA09575; Sun, 3 Jun 84 23:24:19 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.27)
	id AA27487; Sun, 3 Jun 84 23:22:53 pdt
Message-Id: <8406040622.AA27487@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 03 JUN 84 23:22:56 PDT
Date: 3 Jun 84 23:22 PDT
From: Jonl.pa@XEROX.ARPA
Subject: This is a test
To: Franz-Friends@BERKELEY

Sorry to bother you -- this is only a test of correct forwarding on this mailing list.


From @MIT-MC:sl@cmu-ri-isl1.arpa  Mon Jun 18 17:09:37 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA21265; Mon, 18 Jun 84 17:09:37 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA19453; Mon, 18 Jun 84 17:07:25 pdt
Message-Id: <8406190007.AA19453@UCB-VAX.ARPA>
Date: 18 Jun 1984 12:48:57-EDT
From: Simon.Lowenfeld@CMU-RI-ISL1
Subject: old messages
Apparently-To: <franz-friends@UCB-VAX>

Is there some kind of archive for old postings?
I am interested in the Franz/T argument
from earlier this year.


From wkc@Ardc.ARPA  Tue Jun 19 07:36:37 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA01983; Tue, 19 Jun 84 07:36:37 pdt
Received: from ARDC (ardc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA01762; Tue, 19 Jun 84 07:34:31 pdt
Message-Id: <8406191434.AA01762@UCB-VAX.ARPA>
Date:     Tue, 19 Jun 84 10:31:27 EDT
From: William K. Cadwallender (LCWSL) <wkc@Ardc.ARPA>
To: franz-friends@BERKELEY
Subject:  Franz for VAX730

	We are about to purchase a VAX730 with BSD4.2 UNIX. Has anyone out thereheard of a port of Franz, or ANY LISP to a 730? Please reply to the net or directly to wkc@ARDC.
			Bill Cadwallender (wkc@ARDC)

From RZ@MIT-MC  Thu Jun 21 19:26:57 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA08546; Thu, 21 Jun 84 19:26:57 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA27996; Thu, 21 Jun 84 19:24:37 pdt
Message-Id: <8406220224.AA27996@UCB-VAX.ARPA>
Date: 21 June 1984 22:28-EDT
From: Richard E. Zippel <RZ@MIT-MC>
Subject:  MIT flavors
To: franz-friends@BERKELEY
Cc: zymelman@MITRE, smh@MIT-VAX
In-Reply-To: Msg of 21 Jun 1984  9:19:16 EDT () from Ari Zymelman <m13676 at mitre>

I am happy to report than the MIT flavor system is finally available.  I
won't try to correct the numerous bits of misinformation that have been
spread about this other than to say that the MIT flavor system can now be
freely distributed, if it is not used for profit, and the MIT copyrights are
maintained in the sources.  Berkeley has a copy of the most recent version
of the code and should include it in their standard distributions shortly.


From hoey@nrl-aic  Wed Jun 27 14:24:24 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA19372; Wed, 27 Jun 84 14:24:24 pdt
Received: from nrl-aic (nrl-aic.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA13744; Wed, 27 Jun 84 14:21:16 pdt
Message-Id: <8406272121.AA13744@UCB-VAX.ARPA>
Date: 27 Jun 1984 16:42-EDT
From: Dan Hoey <hoey@NRL-AIC>
Subject: Incorrect "make fromasm" in 68k franz 38.91
To: franz-friends@BERKELEY
Cc: dejong@nrl-aic, franz-bugs@BERKELEY

Problem:
The "make fromasm" option for franz installation on a 68k does not work
as distributed.

Diagnosis:
The assembler is used to convert *.s files into *.o.  But the output of
as defaults to "a.out" and is not overridden, so no *.o files are
produced.

Fixes:
Specify the output file in the fromasm: option in lisplib/Makefile and
liszt/68k/Makefile.

In lisplib/Makefile, and (if make copylibrary has been done) in
/usr/lib/lisp/Makefile, change

<	for i in *.s; do echo $$i; ${LibDir}/as $$i; done
----
>	for i in *.s; do echo $$i; \
>	${LibDir}/as $$i -o `basename $$i .s`.o; done

In liszt/68k/Makefile, change

<	for i in *.s; do echo $$i; as $$i; done
----
>	for i in *.s; do echo $$i; \
>	as $$i -o `basename $$i .s`.o; done

Bugs:
1.  One version specifies ${LibDir}/as, the other uses vanilla as.  I
    didn't change it, but perhaps the liszt/68k/Makefile should also
    specify ${LibDir}/as.

2.  Isn't there a cleaner way of doing this?  Can a ".s.o:" rule be
    specified?

Dan

From @MIT-MC:rsw@cmu-cs-h.arpa  Mon Jul  9 22:06:26 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA17486; Mon, 9 Jul 84 22:06:26 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA24170; Mon, 9 Jul 84 22:05:52 pdt
Message-Id: <8407100505.AA24170@UCB-VAX.ARPA>
Date: 9 Jul 1984 21:10:53-EDT
From: Richard.Wallace@CMU-CS-H
Subject: Bell quote
Apparently-To: <franz-friends@UCB-VAX>

Lisp, designed about 1960 by John McCarthy, impressed me so 
much that I included the critcal data access primitives
in the architecture of the DEC System 10 in 1965 (still
about the fastest Lisp computer).

                        - C. Gordon Bell
                          IEEE Computer
                          June, 1984



From kanderso@bbn-vax  Tue Jul 10 11:41:39 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA25755; Tue, 10 Jul 84 11:41:39 pdt
Received: from bbn-vax (bbn-vax.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA06454; Tue, 10 Jul 84 11:29:28 pdt
Message-Id: <8407101829.AA06454@UCB-VAX.ARPA>
Date: Tue, 10 Jul 84 14:28 EDT
From: Ken Anderson <kanderso@bbn-vax>
Subject: Problem compiling flavors in Opus 83.79
To: franz-friends@BERKELEY
Cc: franz-composers@BERKELEY, lbagnall@bbn, jchung@bbn

When trying to make flavors from the version in pub/lib on ucbkim,
liszt complains about calling an undefined function e-sub2.  Here is
the output of my makefile.  Any suggestions?

liszt -a flavorm
Compilation begins with Liszt vax version 8.36
source: flavorm.l, result: flavorm.o
[fasl /usr/lib/lisp/machacks.o]
[autoload /usr/lib/lisp/struct]
[fasl /usr/lib/lisp/struct.o]
flavor-plist
flavor-init-keywords
flavor-initable-instance-variables
flavor-settable-instance-variables
flavor-gettable-instance-variables
flavor-default-handler
flavor-which-operations
flavor-depends-on-all
flavor-includes
flavor-depended-on-by
flavor-depends-on
flavor-method-table
flavor-all-instance-variables
flavor-local-instance-variables
flavor-name
flavor-method-hash-table
flavor-bindings
make-flavor
alter-flavor
instancep
instancep::cmacro:g00079
send
lexpr-send
send-self
lexpr-send-self
g00100::send
%Note: flavorm.l: Compilation complete
%Note: flavorm.l:  Time: Real: 0:32, CPU: 0:11.10, GC: 0:0.00 for 0 gcs
%Note: flavorm.l: Assembly begins
%Note: flavorm.l: Assembly completed successfully
liszt -a flavors
Compilation begins with Liszt vax version 8.36
source: flavors.l, result: flavors.o
[fasl /usr/lib/lisp/machacks.o]
[fasl /usr/lib/lisp/lmhacks.o]
[fasl flavorm.o]
defflavor
defun-method
[autoload /usr/lib/lisp/struct]
[fasl /usr/lib/lisp/struct.o]
instance-variable-boundp
instance-flavor
instance-flavor::cmacro:g00068
instance-function
instance-function::cmacro:g00075
get-flavor
instance-typep
flavor-additional-instance-variables
flavor-additional-instance-variables::cmacro:g00101
flavor-instance-variable-initializations
flavor-instance-variable-initializations::cmacro:g00108
flavor-remaining-default-plist
flavor-remaining-default-plist::cmacro:g00115
flavor-remaining-init-keywords
flavor-remaining-init-keywords::cmacro:g00122
flavor-all-initable-instance-variables
flavor-all-initable-instance-variables::cmacro:g00129
g00133::flavor
Undefined function called from compiled code   e-sub2
?Error: flavors.l: : Lisp error during compilation
make: *** Error code 1 ***

From jkf@ucbmike  Tue Jul 10 12:18:28 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA27111; Tue, 10 Jul 84 12:18:28 pdt
Received: from ucbmike.ARPA by UCB-VAX.ARPA (4.28/4.31)
	id AA07135; Tue, 10 Jul 84 12:06:28 pdt
Date: Tue, 10 Jul 84 12:07:07 pdt
From: John Foderaro (on an sun) <jkf@ucbmike>
Message-Id: <8407101907.3780@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.24ucb/3.5)
	id AA03780; Tue, 10 Jul 84 12:07:07 pdt
To: kanderso@bbn-vax, franz-friends@BERKELEY
Subject: Re: Problem compiling flavors in Opus 83.79
Cc: jchung@bbn, lbagnall@bbn, franz-composers@BERKELEY
In-Reply-To: Your message of Tue, 10 Jul 84 14:28 EDT

 This bug was fixed a while back, but apparently after you got your lisp
distribution.  You should get the latest lisp distribution.



From @MIT-MC:stw@cmu-cs-spice.arpa  Tue Jul 10 13:29:15 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA28822; Tue, 10 Jul 84 13:29:15 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA08350; Tue, 10 Jul 84 13:28:25 pdt
Message-Id: <8407102028.AA08350@UCB-VAX.ARPA>
Date: 10 Jul 1984 13:46:05-EDT
From: Suzanne.Woolf@CMU-CS-SPICE
Subject: pretty printer
Apparently-To: <franz-friends@UCB-VAX>

Does anyone out there know of a well-documented pretty printer for lisp?  A
friend of mine needs one that can be hacked up.  Franz Lisp would be ideal,
but anything similar is fine.

Please send replies to:
Jaffe@cmu-psy-a

Thanks.



From @MIT-MC:smh@MIT-EMS  Tue Jul 10 15:29:20 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA02481; Tue, 10 Jul 84 15:29:20 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA10890; Tue, 10 Jul 84 15:28:30 pdt
Message-Id: <8407102228.AA10890@UCB-VAX.ARPA>
Date: 10 Jul 1984 18:24:02-EDT
From: <smh@mit-ems@mit-mc>
To: franz-friends@BERKELEY, kanderso@bbnvax
Subject: Re: Problem compiling flavors in Opus 83.79

A very quick check reveals the following suspiciousness:  The function
in flavors.l being compiled when the failure occurs is apparently:

(DEFUN (FLAVOR :NAMED-STRUCTURE-INVOKE) (OPERATION &OPTIONAL SELF &REST ARGS)
  (SELECTQ OPERATION
	   (:WHICH-OPERATIONS '(:PRINT-SELF :DESCRIBE))
	   (:PRINT-SELF
	    (SI:PRINTING-RANDOM-OBJECT (SELF (CAR ARGS))
	       (FORMAT (CAR ARGS) "FLAVOR ~S" (FLAVOR-NAME SELF))))
	   (:DESCRIBE (DESCRIBE-FLAVOR SELF))
	   (OTHERWISE
	    (FERROR NIL "~S UNKNOWN OPERATION FOR FLAVOR" OPERATION))))

This is the first appearance in the file of defun with a "function
spec" instead of a symbol as the first argument.  This is a Lisp
Machine hack which basically means to squirrel the functional object
away under the :NAMED-STRUCTURE-INVOKE property of the plist of FLAVOR.
(More precisely, the first arg is the Maclisp compatability syntax for
(:PROPERTY FLAVOR :NAMED-STRUCTURE-INVOKE) ...)

Liszt could be choking as it tries to store into the
function-definition slot of something other than a symbol.  Such
abilities of defun are not documented in Franz, and it might be that
your defun macro in common0.l has not been extended for such usage.
Locally it is defined as follows:

;--- defun
; maclisp style function defintion
;
(def defun
   (macro (l)
      (prog (name type arglist body specind specnam)
	 (setq name (cadr l) l (cddr l))
	 (cond ((dtpr name)
		(cond ((memq (cadr name) '(macro expr fexpr lexpr))
		       (setq l (cons (cadr name) l)
			     name (car name)))
		      (t (setq specnam (car name)
			       specind (cadr name)
			       name (concat (gensym) "::" specnam))))))
	 (cond ((null (car l)) (setq type 'lambda))
	       ((eq 'fexpr (car l)) (setq type 'nlambda l (cdr l)))
	       ((eq 'expr (car l))  (setq type 'lambda l (cdr l)))
	       ((eq 'macro (car l)) (setq type 'macro l (cdr l)))
	       ((atom (car l))
		(setq type 'lexpr
		      l (nconc (list (list (car l)))
			       (cdr l))))
	       (t (setq type 'lambda)))
	 (setq body (list 'def name (cons type l)))
	 (cond (specnam
		  (return (list 'progn ''compile
				body
				(list 'putprop
				      (list 'quote specnam)
				      (list 'getd
					    (list 'quote name))
				      (list 'quote specind)))))
	       (t (return body))))))

You could also check by invoking liszt without arguments and then
asking it
	(testmac '(defun (foo bar) () (hello goodbye)))
and seeing if it properly generates
	(progn 'compile (defun ... ) (putprop ... ))

On another matter, I have recently been making a number of minor
bugfixes to the flavor and various other MIT compatibility packages.
These files come indirecly from Maclisp or Lisp Machines, and the ports
have generally never been exercised sufficiently to check all the
obscure features.  These fixes postdate the versions Rich Zippel
recently transmitted to Berkeley.  I will shortly distribute the
new versions to Berkeley.

Believe it or not, the flavor system really does work under Franz.
So do hash tables, defstruct, format, etc.  I use them every day.

Steve Haflich, MIT Experimental Music Studio
smh@mit-ems@mit-mc
{decvax!genrad, ihnp4}!mit-eddie!smh


From abar@ucbernie  Tue Jul 10 23:04:16 1984
Received: from ucbernie.ARPA by ucbkim.ARPA (4.28/4.27)
	id AA08764; Tue, 10 Jul 84 23:04:16 pdt
Received: by ucbernie.ARPA (4.28/4.30)
	id AA06176; Tue, 10 Jul 84 23:02:56 pdt
Date: Tue, 10 Jul 84 23:02:56 pdt
From: abar@ucbernie (Robert Abarbanel)
Message-Id: <8407110602.AA06176@ucbernie.ARPA>
To: franz-friends@ucbernie
Subject: &optional, &rest, &aux

Any way to get these &args to work without compilation... that is, when
a function is working interpreted?

From kanderso@bbn-vax  Wed Jul 11 12:25:52 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA17391; Wed, 11 Jul 84 12:25:52 pdt
Received: from bbn-vax (bbn-vax.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA19991; Wed, 11 Jul 84 12:24:54 pdt
Message-Id: <8407111924.AA19991@UCB-VAX.ARPA>
Date: Wed, 11 Jul 84 15:24 EDT
From: Ken Anderson <kanderso@bbn-vax>
Subject: bugs in hash.l and array.l
To: franz-friends@BERKELEY
Cc: lbagnall@bbn, jchung@bbn

To get Flavors working in Opus 38.91 you will need to fix a bug in
lisplib/hash.l.  Change all occurances of "getlength" to "vsize".

Although unrelated to Flavors, there are several problems with
the functions, fillarray fillarrayarray and listarray in
lisplib/array.l.  Here is an ed script produced by diff:

285,286c
	       (cond ((or (arrayp arr)		; KRA
			  (and (symbolp arr) (arrayp (setq arr (getd arr))))))
.
282,283c
    (lexpr (n)
	   (prog (arr size typ ret newv)
.
280a
; KRA 83-11-2:  Arrays need not be symbols.
.
279c
		    (replace (arrayref arrto i) (arrayref arrfrom i)))
		(return arrto))))	; KRA
.
270c
		    (cond ((cdr ls) (setq ls (cdr ls)))))
		(return arr))))		; KRA
.
244a
; KRA 83-11-2:  Fillarray  and fillarrayarray should return the array!
.

From jkf@ucbmike  Wed Jul 11 13:43:49 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA20014; Wed, 11 Jul 84 13:43:49 pdt
Received: from ucbmike.ARPA by UCB-VAX.ARPA (4.28/4.31)
	id AA21120; Wed, 11 Jul 84 13:32:32 pdt
Date: Wed, 11 Jul 84 13:32:52 pdt
From: John Foderaro (on an sun) <jkf@ucbmike>
Message-Id: <8407112032.5402@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.24ucb/3.5)
	id AA05402; Wed, 11 Jul 84 13:32:52 pdt
To: franz-friends@BERKELEY
Subject: Re: &optional, &rest, &aux
Cc: franz-composers@BERKELEY
In-Reply-To: Your message of 11 Jul 1984 15:12:07-EDT

 The problem with the &optional and &rest was due to abar using the
cmufile package, which redefines 'def' and doesn't look for those
keywords.



From uucp-5@cmu-cs-g.arpa  Wed Jul 11 20:29:28 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA25212; Wed, 11 Jul 84 20:29:28 pdt
Received: from CMU-CS-G.ARPA (cmu-cs-g.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA28089; Wed, 11 Jul 84 20:28:27 pdt
Reply-To: cadre!sm@CMU-CS-G.ARPA
Received: by cadre.UUCP (4.12/3.14)
	id AA22394; Wed, 11 Jul 84 23:22:09 edt
Date: Wed, 11 Jul 84 23:22:09 edt
From: cadre!sm (Sean McLinden)
Message-Id: <8407120322.AA22394@cadre.UUCP>
To: jkf@ucbmike.BERKELEY
Subject: redefinition of existing flavors
Cc: franz-friends@BERKELEY


 As distributed by Berkeley, the flavors package on Opus 38.89
 appears to work in all cases except when a flavor is redefined
 and perform-flavor-redefinition is invoked. The problem, I
 thought, was in copy-hunk-contents, since the default structures
 (and therefore flavors), in Opus 38.89, are VECTORS, not HUNKS.
 However, modifying copy-hunk-contents to copy VECTORS did not,
 completely, fix the problem (i.e, the first modification after
 redefinition of copy-hunk-contents caused an error, the second
 worked but then describe did not work for old instances of the
 flavor).

 Before delving into code with which I am unfamiliar are there
 any differences between Opus 38.89 and 38.91 which might explain
 this?

 Sean McLinden
 Decision Systems Lab
 University of Pittsburgh


From harrison@nrl-aic  Thu Jul 12 07:15:39 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA28967; Thu, 12 Jul 84 07:15:39 pdt
Received: from nrl-aic (nrl-aic.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA07280; Thu, 12 Jul 84 07:14:50 pdt
Date: 12 Jul 1984 10:08-EDT
From: Patrick Harrison <harrison@NRL-AIC>
Subject: Lisp for Honeywell 6060 DPS-8
To: ailist@sri-ai
Cc: franz-friends@BERKELEY
Message-Id: <84/07/12 1008.550@NRL-AIC>


     Am looking for information on current versions of LISP (FranzLisp,
MacLisp) running in a Honeywell 6060, DPS-8 environment. Would also
like to implement OPS5 on same.  Address:
   
                        Dr. Patrick Harrison
                        Computer Science Department
                        U.S. Naval Academy
                        Annapolis, Maryland 21402.
 
Responses to above address or <harrison@nrl-aic>

From @MIT-MC:mhs@MIT-HTVAX  Tue Jul 17 12:45:10 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA00659; Tue, 17 Jul 84 12:45:10 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA02214; Mon, 16 Jul 84 16:28:19 pdt
Message-Id: <8407162328.AA02214@UCB-VAX.ARPA>
Date: 16 Jul 1984 16:32:48-EDT
From: mhs@mit-htvax@mit-mc
To: franz-friends@berkeley@mit-mc
Subject: Small bug in flavors.l
Cc: mhs@mit-htvax@mit-mc

    The following test demonstrates a problem with flavors.l as it is
distributed with Release 38.91.  (The "a" after the minor number indicates a
couple of changes made locally - mostly involving preloading struct, loop and
such.  flavors.l wasn't touched.)

    The problem is that simple method combination doesn't work for trivial
reasons.  A fix is suggested below.  As the example shows, the combined method
for :PROGN combination is wrong. (:OR, :LIST ... all have the same problem).

Franz Lisp, Opus 38.91a (with Zetalisp compatability package)
-> (defflavor object
     (color)
     ()
     :gettable-instance-variables
     :settable-instance-variables
     :initable-instance-variables
     (:method-combination (:progn :base-flavor-last :test1)))
object
-> (defmethod (object :test1) ()
     (format t "~&object :test1~%"))
(:method object :test1)
-> (defflavor car
     (price)
     (object)
     :gettable-instance-variables
     :settable-instance-variables
     :initable-instance-variables)
car
-> (defmethod (car :test1) ()
     (format t "~&car :test1~%"))
(:method car :test1)
-> (setq car (make-instance 'car))
#<car 591928>
-> (send car ':test1)
|Error:| eval: Undefined function  :progn
<1>: (debug)

<------debug------>

:bk

<------debug------>   <--- you are here
(eval (debug))
(break-err-handler (|ER%undef| 0 t |eval: Undefined function | :progn))
(:progn (lexpr-funcall (function car-test1-method) .daemon-caller-args.) (lexpr-funcall (function object-test1-method) .daemon-caller-args.))
((lambda (.daemon-caller-args.) .daemon-caller-args. (:progn (lexpr-funcall (function car-test1-method) .daemon-caller-args.) (lexpr-funcall (function object-test1-method) .daemon-caller-args.))) (do ((g00005 g00004 (|1-| g00005)) (g00006 () (cons (arg g00005) g00006))) ((< g00005 1) g00006)))
,
,
,
(send car (quote :test1))
(eval (send car (quote :test1)))
<bottom of stack>

    Look at the combined method:

(:progn
     (lexpr-funcall (function car-test1-method) .daemon-caller-args.)
     (lexpr-funcall (function object-test1-method) .daemon-caller-args.))

    I think the problem is caused by the fact that in the older package system,
the keyword package inherited from the global package.  Thus :PROGN (in the
keyword package) was the same atom as PROGN (in global).  However, this isn't
true in Franz.  :PROGN isn't EQ to PROGN, and it shouldn't be.  (The same
problem occurs for all of the other simple method combination types too, e.g.
:OR, :LIST ...).  One possible fix is to add an alist
(SIMPLE-METHOD-COMBINATION-TYPE-ALIST) to store the correspondence between
:PROGN and PROGN, like so:  (I just tested this code locally and it seemed to
work.)

#+franz
(DEFCONST SIMPLE-METHOD-COMBINATION-TYPE-ALIST
        '((:PROGN . PROGN)
          (:AND . AND)
          (:OR . OR)
          (:MAX . MAX)
          (:MIN . MIN)
          (:+ . +)
          (:APPEND . APPEND)
          (:NCONC . NCONC)))

(DEFUN SIMPLE-METHOD-COMBINATION (FL MAGIC-LIST-ENTRY)
  (LET ((METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL NIL NIL NIL))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY)))
    (OR (AND (NOT WRAPPERS-P) (NULL (CDR METHODS)) (CAR METHODS))
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
           ;; In the old package system, :progn maps to progn trivially
           ;; via package inheritance (keyword inherits from global).
           ;; In Franz, we use an alist to implement the mapping.
	   (CONS #-franz (CADR MAGIC-LIST-ENTRY)
                 #+franz (CDR (ASSQ (CADR MAGIC-LIST-ENTRY) 
                                 SIMPLE-METHOD-COMBINATION-TYPE-ALIST))
		         (MAPCAR 'METHOD-CALL
			         METHODS))))))


From "Gladd Tom"@LLL-MFE.ARPA  Wed Jul 18 10:44:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA00765; Wed, 18 Jul 84 10:44:03 pdt
Received: from LLL-MFE.ARPA (lll-mfe.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.31)
	id AA01412; Wed, 18 Jul 84 10:42:20 pdt
Message-Id: <8407181742.AA01412@UCB-VAX.ARPA>
Date: Wed, 18 Jul 84 10:35 PDT
From: "Gladd Tom"@LLL-MFE.ARPA
Subject: join list 619-453-6580
To: franz-friends@BERKELEY

i would like to join your list. i am very interested in list in general
and have been trying to learn it in a near vacuum (small hi-tech company
in sandiego. i am especially interested in advanced coding techniques
(at least beyond the standard texts). my background is theoretical
plasma physics. i have used and am very interested in macsyma.
my address is "gladd tom%cma"@lll-mfe.arpa

From @MIT-MC:pmk@cmu-ri-isl2.arpa  Wed Jul 25 10:06:41 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA08698; Wed, 25 Jul 84 10:06:41 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA19747; Wed, 25 Jul 84 10:05:06 pdt
Message-Id: <8407251705.AA19747@UCB-VAX.ARPA>
Date: 25 Jul 1984 12:30:25-EDT
From: Philip.Kasprzyk@CMU-RI-ISL2
Subject: Lisp Speed Benchmarks
Apparently-To: <franz-friends@UCB-VAX>

~v
I am interested in determining the absolute speed of execution of a lisp
system. I realize that this is a complicated task that is application
and implementation dependant. Nevertheless I am seeking the following:

1) A "gibson mix" style benchmark for lisp based systems.

2) Any data that experienced users of lisp may have regarding performance.
    (I don't care what machine or dialect of lisp is reported)

3) Any method or program which translates a lisp program into another
    target high level language with execution speed as its objective.
	(I don't mean a normal lisp compiler)

Can anyone out there help me? 

If so send mail to pmk@isl2.



From mab@aids-unix  Fri Jul 27 14:35:21 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA29865; Fri, 27 Jul 84 14:35:21 pdt
Received: from aids-unix (aids-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA04068; Fri, 27 Jul 84 14:33:40 pdt
Message-Id: <8407272133.AA04068@UCB-VAX.ARPA>
Date: 27 Jul 84 14:23:47 PDT (Fri)
From: Mike Brzustowicz <mab@aids-unix>
Subject: Benchmarks
To: franz-friends@BERKELEY

Does anyone have any small LISP programs that can be abused as benchmarks?
(They need to be small is source only.)  I need some very soon.  Thanks!

-Mike
<mab@aids-unix>

From Masinter.pa@Xerox.ARPA  Fri Jul 27 15:15:06 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA01124; Fri, 27 Jul 84 15:15:06 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA04900; Fri, 27 Jul 84 15:13:09 pdt
Message-Id: <8407272213.AA04900@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 27 JUL 84 15:14:21 PDT
Date: 27 Jul 84 15:14 PDT
From: Masinter.pa@XEROX.ARPA
Subject: Re: Benchmarks
In-Reply-To: Mike Brzustowicz <mab@AIDS-UNIX.ARPA>'s message of 27 Jul
 84 14:23:47 PDT (Fri)
To: mab@AIDS-UNIX.ARPA
Cc: franz-friends@BERKELEY

Here's a good benchmark:

(defun nilret () nil)

this is a good test of how fast your lisp returns NIL.

I also like

(defun retjunk (x) (cond((junkp x)  'junk)
				 ((cdr x) (retjunk (car x)))
				 ((= (car x) 'junk) (retjunk (cons (cdr x) (cdr x))))
				 (t (retjunk (cons 'junk x))))

(defun junkp (x) (equal (reverse (explode x)) (reverse (explode
'junk))))


This benchmark measures how fast your lisp can return junk, executing
the retjunk function.

Both of the benchmarks have the adavantage that they are small and can
be abused as benchmarks.

From @USC-ECL.ARPA:BENSON@ECLD  Tue Jul 31 20:02:20 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.28/4.27)
	id AA21521; Tue, 31 Jul 84 20:02:20 pdt
Received: from USC-ECL.ARPA (usc-ecl.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA02839; Tue, 31 Jul 84 20:00:29 pdt
Message-Id: <8408010300.AA02839@UCB-VAX.ARPA>
Received: from ECLD by ECLA with ECLnet; Tue 31 Jul 84 19:56:31-PDT
Date: Tue 31 Jul 84 19:33:52-PDT
From: Eric Benson <BENSON@ECLD.#ECLnet>
Subject: Re: Lisp Speed Benchmarks
To: Philip.Kasprzyk@CMU-RI-ISL2.ARPA
Cc: BENSON@ECLD.#ECLnet, Franz-Friends@BERKELEY
In-Reply-To: Message from "Philip.Kasprzyk@CMU-RI-ISL2" of Wed 25 Jul 84 09:30:25-PDT

There is a set of benchmarks which have been run on a variety of Lisp
systems which have been compiled by Richard Gabriel at Stanford.  You
should contact Paul Wieneke (PW@SU-AI) for more information.
-------

From narain@rand-unix  Wed Aug  1 12:31:21 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00623; Wed, 1 Aug 84 12:31:21 pdt
Received: from rand-unix.ARPA (rand-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA00567; Wed, 1 Aug 84 12:29:40 pdt
Received: by rand-unix.ARPA; Wed, 1 Aug 84 11:04:30 pdt
From: Sanjai Narain <narain@rand-unix>
Message-Id: <8408011804.AA01076@rand-unix.ARPA>
Date: 01 Aug 84 11:04:25 PDT (Wed)
To: franz-friends@BERKELEY
Subject: Fast recompiling


Often we have files consisting of large numbers of functions which are
compiled. Sometimes, just one of these functions needs to be changed. It
would be nice to recompile just this function, and copy already compiled
functions to produce a fresh version of the compiled file. Is there any
quick method of doing this in Franz Lisp i.e. is there an equivalent of
Interlisp's "recompile" function.

I would be grateful for your response.

-- Sanjai Narain

From fateman@ucbdali  Wed Aug  1 13:24:30 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03438; Wed, 1 Aug 84 13:24:30 pdt
Received: from ucbdali.ARPA by UCB-VAX.ARPA (4.28/4.33)
	id AA01542; Wed, 1 Aug 84 13:06:01 pdt
Received: by ucbdali.ARPA (4.24/4.27)
	id AA00994; Wed, 1 Aug 84 13:07:35 pdt
Date: Wed, 1 Aug 84 13:07:35 pdt
From: fateman@ucbdali (Richard Fateman)
Message-Id: <8408012007.AA00994@ucbdali.ARPA>
To: franz-friends@BERKELEY, narain@rand-unix
Subject: Re:  Fast recompiling

This would be an interesting feature, but it is complicated by the
possibility that the compilation environment is built up in a typical
large Franz system, by processing the whole file.  I think that the
interlisp situation is usually simpler.  
  For example, in recompiling Macsyma, sometimes a file itself or
function definitions in it do not change at all. A "macro definition"
file which is included in the compilation environment can, however, change
the generated code, substantially.
  Something like UNIX's "make" might be needed.

Alternatively, you can use smaller files...

From jkf@ucbmike  Thu Aug  2 16:10:04 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA16097; Thu, 2 Aug 84 16:10:04 pdt
Received: from ucbmike.ARPA by UCB-VAX.ARPA (4.28/4.33)
	id AA00501; Thu, 2 Aug 84 16:08:09 pdt
Date: Thu, 2 Aug 84 16:09:45 pdt
From: John Foderaro (on an sun) <jkf@ucbmike>
Message-Id: <8408022309.1757@ucbmike.ARPA>
Received: by ucbmike.ARPA (4.24ucb/3.5)
	id AA01757; Thu, 2 Aug 84 16:09:45 pdt
To: franz-friends@BERKELEY
Subject: repeated messages
Cc: 

  I'm sorry about the repeated messages.  Our mailing machine got a bit
overloaded.  I've modified the organization of the list to try to
fix the problem.



From NET-ORIGIN@MIT-MC  Fri Aug  3 15:15:44 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA26463; Fri, 3 Aug 84 15:15:44 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA04086; Fri, 3 Aug 84 15:13:41 pdt
Received: from mit-heracles (mit-heracles.ARPA) by mit-charon (4.12/4.7)
	id AA13781; Fri, 3 Aug 84 14:32:51 edt
Received: by mit-heracles (4.12/4.7)
	id AA20045; Fri, 3 Aug 84 14:35:30 edt
From: yba@mit-heracles (Mark H Levine)
Message-Id: <8408031835.AA20045@mit-heracles>
Date:  3 Aug 1984 1435-EDT (Friday)
To: franz-friends@BERKELEY
Subject: Opus 37.79 building from source


Has anyone published a fix to the bug that causes "rawlisp" to take a
memory fault when built from vanilla 4.2bsd sources?

It seems that the routine "getatom" in franz/alloc.c calls strcmp
with "name" equal to "mod" and "aptr -> a.pname" equal to CNIL (-4).

This is presumably a side effect of some other error; it still causes
a memory fault in strcmp and prevents building from source.  The sources
have some Sept. '83 changes to the library code, but are otherwise con-
sistent with all the 4.2 code I have seen.

Got a fix handy?



From liz@maryland  Mon Aug  6 07:41:41 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA16830; Mon, 6 Aug 84 07:41:41 pdt
Received: from maryland.ARPA (maryland.ARPA.ARPA) by UCB-VAX.ARPA (4.28/4.33)
	id AA06949; Mon, 6 Aug 84 07:39:52 pdt
Received: by maryland.ARPA (4.12/4.7)
	id AA01505; Mon, 6 Aug 84 10:40:52 edt
Date: Mon, 6 Aug 84 10:40:52 edt
From: liz@maryland (Liz Allen)
Message-Id: <8408061440.AA01505@maryland.ARPA>
To: franz-friends@BERKELEY, yba%mit-heracles@csnet-relay.ARPA
Subject: Re:  Opus 37.79 building from source

That sounds like an error I ran into recently -- only it was with Opus
38.91 and it was also because I was adding more strings to rawlisp.
Anyway, the fix was easy and is probably worth trying.  Go into
franz/data.c and change the size of i_strbuf and make it bigger.  Ours
was 600, and I made it 1000.  You'll also need to change the
initialization for i_strbuf; I changed ours from "i_strbuf + 599" to
"i_strbuf + 999".

Hope this helps!

				-Liz

From smotroff@bbncct  Wed Aug  8 14:39:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA23393; Wed, 8 Aug 84 14:39:03 pdt
Received: from bbncct (bbncct.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA21105; Wed, 8 Aug 84 14:39:58 pdt
Message-Id: <8408082139.AA21105@UCB-VAX.ARPA>
Date: Wed, 8 Aug 84 17:28:58 EDT
From: Ira Smotroff <smotroff@BBNCCT.ARPA>
Subject: add me to the list
To: franz-friends@BERKELEY

please add my name to the franz-friends list


smotroff at bbn


From booker@nrl-aic  Fri Aug 10 06:18:45 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA13113; Fri, 10 Aug 84 06:18:45 pdt
Received: from nrl-aic (nrl-aic.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA14441; Fri, 10 Aug 84 06:19:43 pdt
Message-Id: <8408101319.AA14441@UCB-VAX.ARPA>
Date: 10 Aug 1984 09:09:24-PDT
From: Lashon Booker <booker@NRL-AIC>
To: franz-friends@BERKELEY
Subject: Interlisp Compatibility Package?

Has anyone written an Interlisp compatibility package
for Franz?  Thanks.

Lashon Booker
booker@nrl-aic

From @MIT-MC:smh@MIT-EMS  Fri Aug 10 13:14:44 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA01017; Fri, 10 Aug 84 13:14:44 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA21922; Fri, 10 Aug 84 13:15:43 pdt
Message-Id: <8408102015.AA21922@UCB-VAX.ARPA>
Date: 10 Aug 1984 16:06:48-EDT
From: smh@mit-ems@mit-mc
To: franz-friends@BERKELEY
Subject: (atom VECTOR): franz vs liszt

Versions: Franz 38.91, Liszt 8.39, and probably most others.

Description:
	The atom predicate operates inconsistently between compiled and
	interpreted code when passed a vector or vectori.

Repeat-by:
	Create and compile a file containing the following definition:
		(defun atum(x) (atom x))
	After loading it into the interpreter the following results can
	be obtained:
		(setq v (vector 1 2 3))
		(atom v)		===> t
		(atum v)		===> nil

Discussion:
	According to the manual, atom returns "t iff g_arg is not a list or
	hunk object."  By this definition, the interpreter is correct and the
	compiler incorrect.  However, one can make a strong argument that
	vectors, analogously to hunks, should not be considered atoms.
	Therefore, the both the documentation and interpreter should be
	changed.  (It is doubtful very much existing code depends on this.)

Suggested fix:
	Change the definition of atom section 2 of the manual to read:
		"t iff g_arg is not a list, hunk, vector, or vectori object."
	Add the following definition to franz/h/global.h, after the existing
	definition of HUNKP:
		#define HUNKORVECP(a1)	((TYPE(a1) >= 11) & (TYPE(a1) <= 19))
	Change the definition of Latom in franz/lam1.c:
		lispval
		Latom()
		{
			register struct argent *lb = lbot;
			chkarg(1,"atom");
	==>		if(TYPE(lb->val)==DTPR || (HUNKORVECP(lb->val)))
				return(nil);
			else
				return(tatom);
		}

Alternative suggested fix:
	If franz-composers really feel that atom ought to treat hunks
	and vectors differently (sigh?), then fix the compiler instead
	of the interpreter and documentation.  The most important thing
	is that interpreted and compiler do the same thing!
	In liszt/funa.l:cc-atom, add 1_18 and 1_19 to the definition
	of the mask constant.

Random (constructive) flame:
	The interpreter definition above has to lookup the type of its
	argument expensively in the typetable *three* times, to wit:
		#define ATOX(a1)	((((int)(a1)) - OFFSET) >> 9)
		#define	TYPE(a1)	((typetable+1)[ATOX(a1)])
	While compiled code is admirably streamlined, the interpreter
	could be made significantly faster here and elsewhere if TYPE
	were evaluated only once and held for examination in a
	temporary.  This would require a bunch more type predicate
	DEFINEs operating on TYPE values instead of object addresses.

Steve Haflich
smh%mit-ems@mit-mc
{decvax!genrad, ihnp4!mit-eddie}!mit-ems!smh


From JonL.pa@Xerox.ARPA  Mon Aug 13 13:25:44 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03640; Mon, 13 Aug 84 13:25:44 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA05890; Mon, 13 Aug 84 13:26:52 pdt
Message-Id: <8408132026.AA05890@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 13 AUG 84 13:24:39 PDT
Date: 13 Aug 84 13:24 PDT
From: JonL.pa@XEROX.ARPA
Subject: Re: (atom VECTOR): franz vs liszt
In-Reply-To: "smh@mit-ems"@MIT-MC.ARPA's message of 10 Aug 84 16:06:48
 EDT
To: "smh@mit-ems"@MIT-MC.ARPA
Cc: franz-friends@BERKELEY, GSB@MIT-ML.ARPA, ALAN@MIT-MC.ARPA

Perhaps this bug should be forwarded to BUG-LISP@MIT-MC, since the
original design flaw is in MacLisp.  The problem is that when Hunks were
first invented, there where some who wanted them as "annotated" list
cells (hence, they weren't ATOMs) while other wanted them as small
VECTORs (hence there should be ATOMs).  The resolution was some awful
switch setting for whether or not to treat them as ATOMs, but I don't
remember the default setting, nor the final results.

-- JonL --




From ALAN@MIT-MC  Mon Aug 13 17:15:11 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA07443; Mon, 13 Aug 84 17:15:11 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA10564; Mon, 13 Aug 84 17:16:03 pdt
Message-Id: <8408140016.AA10564@UCB-VAX.ARPA>
Date: 13 August 1984 20:08-EDT
From: Alan Bawden <ALAN@MIT-MC>
Subject:  (atom VECTOR): franz vs liszt
To: JonL.pa@XEROX
Cc: GSB@MIT-MC, franz-friends@BERKELEY, smh@MIT-EMS
In-Reply-To: Msg of 13 Aug 84 13:24 PDT from JonL.pa at XEROX.ARPA

    Date: 13 Aug 84 13:24 PDT
    From: JonL.pa at XEROX
    ...  The resolution was some awful switch setting for whether or not to
    treat them as ATOMs, but I don't remember the default setting, nor the
    final results.

There are indeed a couple of switches that control various random aspects
of hunks, but none of them have any effect on their atomic or non-atomic
nature.  Hunks are never atoms in MacLisp.  Everybody agrees that this is a
loss, but at this point it is rather deeply ingrained into things to think
about changing it.


From jmiller@csnet-relay.csnet  Tue Aug 14 01:53:12 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA13476; Tue, 14 Aug 84 01:53:12 pdt
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA23091; Tue, 14 Aug 84 01:54:22 pdt
Message-Id: <8408140854.AA23091@UCB-VAX.ARPA>
Received: From ct.csnet by csnet-relay;  14 Aug 84 4:31 EDT
Date: 13 Aug 1984 20:46:42-PST
From: jmiller%ct.csnet@csnet-relay.arpa
To: franz-friends@BERKELEY
Subject: bug in assoc

The following illustrates a rather unpleasant bug in Franz's ASSOC (as
of 38.26, anyhow).  Be forewarned....

------------------------------------------------------------------------------

8_(setq l '((a 1) (b 2) (c 3)))	       ;;set up an a-list
((a 1) (b 2) (c 3))

9_(setq foo 'l)			       ;;FOO points to the NAME of the a-list
l

10_(setq bar 'foo)		       ;;BAR points to the NAME of the NAME of
foo				       ;;the a-list

11_(assoc 'b l)			       ;;This does the right thing
(b 2)

12_(assoc 'b foo)		       ;;Gag me with a mouse -- should err
(b 2)				       ;;with "bad arg to <something>"

13_(assoc 'b bar)		       ;;Double gag me with a mouse!!
(b 2)

------------------------------------------------------------------------

For the record, ASSQ is flawed in the same way.


Jim Miller
Computer Thought, Dallas
jmiller@ctvax.csnet
...!convex!ctvax!jmiller

From @MIT-MC:smh@MIT-EMS  Tue Aug 14 07:35:27 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA14507; Tue, 14 Aug 84 07:35:27 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA26447; Tue, 14 Aug 84 07:36:36 pdt
Message-Id: <8408141436.AA26447@UCB-VAX.ARPA>
Date: 14 Aug 1984 08:40:00-EDT
From: smh@mit-ems@mit-mc
To: ALAN@mit-mc, GSB@mit-mc, JonL.pa@parc-maxc
Subject: (atom VECTOR): franz vs liszt
Cc: franz-friends@BERKELEY

Gentlemen, I think we are losing grasp on the original bug report.
This is probably my fault for including a discourse on the philosophy
of hunks (:-) in the bug report.

Maclisp ain't gonna change about hunks, and it would be a poor idea for
Franz to change.  Anyway, the bug is with vectors.  In Franz, compiled
and interpreted code disagree whether a vector is an atom.  Certainly
no one can defend this!

Maclisp doesn't *have* vectors, does it?

Steve Haflich
smh%mit-ems@mit-mc


From mcgeer  Tue Aug 14 11:03:10 1984
Received: by ucbkim.ARPA (4.24/4.27)
	id AA17397; Tue, 14 Aug 84 11:03:10 pdt
Date: Tue, 14 Aug 84 11:03:10 pdt
From: Rick McGeer (on an h19-u) <mcgeer>
Message-Id: <8408141803.AA17397@ucbkim.ARPA>
Phone: (415) 236-8262
To: ALAN@MIT-MC, JonL.pa@XEROX
Subject: Re:  (atom VECTOR): franz vs liszt
Cc: smh@MIT-EMS, franz-friends, GSB@MIT-MC
In-Reply-To: Your message of 13 August 1984 20:08-EDT

	The predicate atom in Franz appears to be:
	
(defun atom(foo)
   (if foo
      then (not (or (hunkp foo) (dtpr foo)))
      else t))

whereas a more natural implementation, it seems to me, is:

(defun atom(foo)
   (or (symbolp foo) (numberp foo)))

Since it seems to me that:

(xor (vectorp foo) (hunkp foo) (dtpr foo) (atom foo) (arrayp foo))

should always be non-nil for non-nil objects.  Or, better put, that vectors,
hunks, dtprs, atoms, and arrays should partition the data space.  No?

					Rick.



From mcgeer  Tue Aug 14 11:53:28 1984
Received: by ucbkim.ARPA (4.24/4.27)
	id AA18832; Tue, 14 Aug 84 11:53:28 pdt
Date: Tue, 14 Aug 84 11:53:28 pdt
From: Rick McGeer (on an h19-u) <mcgeer>
Message-Id: <8408141853.AA18832@ucbkim.ARPA>
Phone: (415) 236-8262
To: jmiller%ct.csnet@csnet-relay.arpa, franz-friends
Subject: Re: bug in assoc
Cc: 
In-Reply-To: Your message of 13 Aug 1984 20:46:42-PST

	"'Curiouser and curiouser', said Alice".  I dug out the source for
assoc (38.79), and here it is:

(def assoc
  (lambda (val alist)
	  (do ((al alist (cdr al)))
	      ((null al) nil)
	      (cond ((null (car al)))
		    ((not (dtpr (car al)))
		     (error "bad arg to assoc" al))
		    ((equal val (caar al)) (return (car al)))))))

So nothing particularly screwy is going on here.  However, when I do the
traces (after setting up stuff the way you did), I get:
=> (assoc 'b 'l)
1 <Enter> assoc (b l)
1 <EXIT>  assoc  (b 2)
(b 2)
=> (assoc 'b ''l)
1 <Enter> assoc (b 'l)
Error: bad arg to assoc (quote l) 
Form: (assoc 'b ''l)
{1} bar
foo
{1} (assoc 'b 'foo)
|2 <Enter> assoc (b foo)
|2 <EXIT>  assoc  (b 2)
(b 2)
{1} foo
l
{1} bar
foo
{1} (assoc 'b bar)
|2 <Enter> assoc (b foo)
|2 <EXIT>  assoc  (b 2)
(b 2)
{1} (assoc 'b ''l)
|2 <Enter> assoc (b 'l)
Error: bad arg to assoc (quote l) 
Form: (assoc 'b ''l)
{2}

Which is certainly *very* odd...


From mcgeer  Tue Aug 14 12:06:20 1984
Received: by ucbkim.ARPA (4.24/4.27)
	id AA19018; Tue, 14 Aug 84 12:06:20 pdt
Date: Tue, 14 Aug 84 12:06:20 pdt
From: Rick McGeer (on an h19-u) <mcgeer>
Message-Id: <8408141906.AA19018@ucbkim.ARPA>
Phone: (415) 236-8262
To: ALAN@MIT-MC, JonL.pa@XEROX
Subject: Re:  (atom VECTOR): franz vs liszt
Cc: smh@MIT-EMS, franz-friends, GSB@MIT-MC

	Sorry to anyone who's getting this twice: I can't figure out from
the mailer error message who got it and who didn't...


	The predicate atom in Franz appears to be:
	
(defun atom(foo)
   (if foo
      then (not (or (hunkp foo) (dtpr foo)))
      else t))

whereas a more natural implementation, it seems to me, is:

(defun atom(foo)
   (or (symbolp foo) (numberp foo)))

Since it seems to me that:

(xor (vectorp foo) (hunkp foo) (dtpr foo) (atom foo) (arrayp foo))

should always be non-nil for non-nil objects.  Or, better put, that vectors,
hunks, dtprs, atoms, and arrays should partition the data space.  No?

					Rick.






From PSZ@MIT-MC  Tue Aug 14 13:53:19 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20310; Tue, 14 Aug 84 13:53:19 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA03508; Tue, 14 Aug 84 13:54:23 pdt
Message-Id: <8408142054.AA03508@UCB-VAX.ARPA>
Date: 14 August 1984 16:37-EDT
From: Peter Szolovits <PSZ@MIT-MC>
Subject:  on the issue of the "ATOMness" of hunks
To: ALAN@MIT-MC
Cc: GSB@MIT-MC, PSZ@MIT-MC, JonL.pa@XEROX, franz-friends@BERKELEY, smh@MIT-EMS
In-Reply-To: Msg of 13 Aug 1984 20:08-EDT from Alan Bawden <ALAN>

I have a small quarrel with Alan Bawden's statement that "hunks never
being atoms in Maclisp" is a universally-agreed bug.  There are indeed
useful structures that one would like to build in Lisp that act as CONS
cells (i.e., CAR and CDR are applicable), but that can have further
structure.  I have sorely missed such objects in Lisp Machine Lisp and
NIL, where flavor-instances are always atomic, when I wanted to build
Brand X (interned "list structure" and universal property lists).  In
Maclisp, I could do this using hunks, though even that was not
completely right because I wanted to be able to disallow RPLACA and
RPLACD while allowing CAR and CDR, and this was hard, given the hunk
abstraction.  I would, however, love to have non-atomic flavor-instances 


From @MIT-MC:smh@MIT-EMS  Tue Aug 14 14:28:47 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20792; Tue, 14 Aug 84 14:28:47 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA04288; Tue, 14 Aug 84 14:29:41 pdt
Message-Id: <8408142129.AA04288@UCB-VAX.ARPA>
Date: 14 Aug 1984 17:13:29-EDT
From: smh@mit-ems@mit-mc
To: mcgeer@ucbkim@BERKELEY
Subject: Re: bug in assoc
Cc: franz-friends@BERKELEY, jmiller@ct.csnet@udel-relay@mit-mc

As McGeer@ucbkim points out, the code for assoc is (in common0.l):

(def assoc
  (lambda (val alist)
	  (do ((al alist (cdr al)))
	      ((null al) nil)
	      (cond ((null (car al)))
		    ((not (dtpr (car al)))
		     (error "bad arg to assoc" al))
		    ((equal val (caar al)) (return (car al)))))))

The reason for the reported strange behavior of assoc is as simple as
it is obscure!  First a couple hints:
 - This code is inside the executable franz interpreter and therefore
   runs compiled.
 - The same strangeness is exhibited by assq, which is C-coded inside
   the Franz kernel.
 - Both the cdr of a dtpr and the value of an atom are stored at offset
   zero within their respective structures.  The car and plist
   similarly share the same offset within their structures.
 - If you try to run the above assoc definition interpreted, it will
   properly fail to work, or rather, it will complain about a bad arg
   to car.
 - Of course, c[ad]r in the interpreter carfully check their arguments;
   In the compiler, they simple indirect through pointers for maximum
   speed.

Finally, in case by now it isn't absolutely clear to everyone what is
going on, assoc is (sort of) comparing val against the plist of bar and
subsequently foo, and then each time automagically effectively doing a
symeval on the atom to continue scanning down the "cdr" of the alist.

Moral:  Although the interpreter tries pretty hard to do the dynamic
typing and implied typechecking for which lisp is famous, type checking
in compiled code is often a myth.  Correct code only necessarily works
correctly when given corrent arguments.

Steve Haflich
MIT Experimental Music Studio
smh%mit-ems@mit-mc
{decvax!genrad, ihnp4!mit-eddie}!mit-ems!smh


From JonL.pa@Xerox.ARPA  Wed Aug 15 16:33:44 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00784; Wed, 15 Aug 84 16:33:44 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA05115; Wed, 15 Aug 84 14:20:30 pdt
Message-Id: <8408152120.AA05115@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 15 AUG 84 14:19:35 PDT
Date: 15 Aug 84 14:18 PDT
From: JonL.pa@XEROX.ARPA
Subject: Re: (atom VECTOR): franz vs liszt
In-Reply-To: Alan Bawden <ALAN@MIT-MC.ARPA>'s message of 13 Aug 84 20:08
 EDT
To: ALAN@MIT-MC.ARPA
Cc: JonL.pa@XEROX.ARPA, GSB@MIT-MC.ARPA, franz-friends@BERKELEY,
        smh@MIT-EMS.ARPA

[Ah, confusion with Interlisp here].  

I meant to say "The resolution was some awful switch setting for whether
or not to treat them as LISTs" rather than "to treat them as ATOMs".
The switch name is HUNKP.

Interlisp's ATOM predicate is defined simply as (NOT (LISTP x)), and
LISTP is true only of cons cells [thus (LISTP NIL) is false].

-- JonL --



From JonL.pa@Xerox.ARPA  Wed Aug 15 18:21:08 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA02292; Wed, 15 Aug 84 18:21:08 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA09647; Wed, 15 Aug 84 18:21:57 pdt
Message-Id: <8408160121.AA09647@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 15 AUG 84 18:18:31 PDT
Date: 15 Aug 84 18:18 PDT
From: JonL.pa@XEROX.ARPA
Subject: Re: bug in assoc
In-Reply-To: "smh@mit-ems"@MIT-MC.ARPA's message of 14 Aug 84 17:13:29
 EDT
To: "smh@mit-ems"@MIT-MC.ARPA
Cc: "mcgeer@ucbkim"@BERKELEY, franz-friends@BERKELEY,
        "jmiller@ct.csnet@udel-relay"@MIT-MC.ARPA, Common-Lisp@SU-AI.ARPA

Common Lisp also faces the possibility of inconsistent system code due
to the handling of cases marked "is an error" (see Manual, sec. 1.2.4);
that is, it is undefined as to what happens if you apply CAR to a
non-LISTP.  All portable system code should therefore certify the type
of a datum before taking car or cdr.  ASSOC (and ASSQ) from the Franz
sources clearly doesn't check the type of the arguments before carcdring
away on them.

Well, why not "all system code should certify the type before taking
car/cdr . . . " -- it certainly can't hurt to "signal an error" rather
than fall into some undefined morass.

-- JonL --


From JonL.pa@Xerox.ARPA  Wed Aug 15 19:49:22 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA02844; Wed, 15 Aug 84 19:49:22 pdt
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA10989; Wed, 15 Aug 84 19:50:13 pdt
Message-Id: <8408160250.AA10989@UCB-VAX.ARPA>
Received: from Semillon.ms by ArpaGateway.ms ; 15 AUG 84 19:48:41 PDT
Date: 15 Aug 84 15:00 PDT
From: JonL.pa@XEROX.ARPA
Subject: Re: (atom VECTOR): franz vs liszt
In-Reply-To: "smh@mit-ems"@MIT-MC.ARPA's message of 14 Aug 84 08:40:00
 EDT
To: "smh@mit-ems"@MIT-MC.ARPA
Cc: ALAN@MIT-MC.ARPA, GSB@MIT-MC.ARPA, JonL.pa@XEROX.ARPA,
        franz-friends@BERKELEY

MacLisp indeed does have VECTORs, STRINGs, CLASSes, etc. in an extended
SmallTalk-like hierarchy, but they are not in the initial system.  Some
of these used to have autoload properties, but I'm not sure about the
state of things now.  None of the extended stuff got documented in the
1983 MacLisp manual, mostly because of Pitman's personal preferences for
not using the extended stuff.

HUNKs are relevant, because the extended heirarchy uses the USRHUNK
feature in order to cause system functions to "trap out" on hunks,
thereby viewing them in an object-oriented way rather than as lists
(Glaaaag!) or as mere simple vectors.

-- JonL --



From MLY@MIT-MC  Wed Aug 15 22:49:17 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04730; Wed, 15 Aug 84 22:49:17 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA13406; Wed, 15 Aug 84 22:49:59 pdt
Message-Id: <8408160549.AA13406@UCB-VAX.ARPA>
Date: 16 August 1984 01:49-EDT
From: Richard Mlynarik <MLY@MIT-MC>
Subject:  on the issue of the "ATOMness" of hunks
To: PSZ@MIT-MC
Cc: ALAN@MIT-MC, GSB@MIT-MC, JonL.pa@XEROX, franz-friends@BERKELEY,
        smh@MIT-EMS
In-Reply-To: Msg of 14 Aug 1984 16:37-EDT from Peter Szolovits <PSZ>

    From: Peter Szolovits <PSZ>

    I have a small quarrel with Alan Bawden's statement that "hunks never
    being atoms in Maclisp" is a universally-agreed bug.  There are indeed
    useful structures that one would like to build in Lisp that act as CONS
    cells (i.e., CAR and CDR are applicable), but that can have further
    structure.  I have sorely missed such objects in Lisp Machine Lisp and
    NIL, where flavor-instances are always atomic, when I wanted to build
    Brand X (interned "list structure" and universal property lists).  In
    Maclisp, I could do this using hunks, though even that was not
    completely right because I wanted to be able to disallow RPLACA and
    RPLACD while allowing CAR and CDR, and this was hard, given the hunk
    abstraction.  I would, however, love to have non-atomic flavor-instances 

The MIT lisp machine system makes some attempt to "support" this sort
of thing, by sending :CAR, :CDR, etc messages to instances. The result
is that you get an error about an unclaimed message, rather than one
about an attempt to take the car of a non-nil atom. LISTP and CONSP
both still return NIL when applied to an instance. The way to get RPLACA
(or SETF of CAR), etc to not work is simply to not define methods for doing
these operations...

Is is not really clear to me what the value of such is, unless you get tired
of typing too many "(SEND"'s.


From goldfarb%ucf.csnet@csnet-relay.arpa  Fri Aug 17 16:44:40 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00202; Fri, 17 Aug 84 16:44:40 pdt
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA01032; Fri, 17 Aug 84 16:45:24 pdt
Received: From ucf.csnet by csnet-relay;  17 Aug 84 19:26 EDT
Received: by ucf-cs.UUCP (4.12/4.7)
	id AA00852; Fri, 17 Aug 84 15:29:05 edt
Date: Fri, 17 Aug 84 15:29:05 edt
From: Ben Goldfarb <goldfarb%ucf.csnet@csnet-relay.arpa>
Message-Id: <8408171929.AA00852@ucf-cs.UUCP>
To: franz-friends@BERKELEY
Subject: ChangeLog

The ReadMe file in /usr/src/cmd/ucb/lisp states that there are ChangeLog
files in the subdirectories franz and liszt.  We got no such files on
our distribution tape (Berkeley 4.2bsd).  I'd appreciate receiving copies
of these files, along with any other documentation of differences between
the 4.2 version and prior versions of Franz Lisp.  

Thanks,

Ben Goldfarb
University of Central Florida
uucp: {duke,decvax,princeton}!ucf-cs!goldfarb
ARPA: goldfarb.ucf-cs@csnet.relay
csnet: goldfarb@ucf

From gvax.bromley@Cornell.ARPA  Sun Aug 26 20:48:24 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA11969; Sun, 26 Aug 84 20:48:24 pdt
Received: from CORNELL.ARPA (cornell-gw.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA18166; Sun, 26 Aug 84 20:46:52 pdt
Received: from CORNELL-GVAX.ARPA (gvax) by CORNELL.ARPA (4.30/4.30)
	id AA16455; Sun, 26 Aug 84 23:48:12 edt
Date: Sun, 26 Aug 84 23:45:55 edt
From: gvax.bromley@Cornell.ARPA (Mark Bromley)
Message-Id: <8408270345.AA14288@CORNELL-GVAX.ARPA>
Received: by CORNELL-GVAX.ARPA (4.30/4.30)
	id AA14288; Sun, 26 Aug 84 23:45:55 edt
To: gvax.arpa-franz@Cornell.ARPA
Subject: Bug in open coding of vseti in Liszt 8.36


If (vseti vector index expression) gets open coded by the compiler,
the resulting value is the value of index, not the value of expression.
This also holds for vseti-byte and vseti-word.

The problem is in d_vset in vector.l.  The code which builds the return
value for immediate vectors assumes that the value of expression is in
index-reg, but it never gets put there.

One solution would be to change the lines

         (if g-loc
             then  (if (eq type 'byte)

(occuring about 3/4 of the way through d_vset) to
         (if g-loc
             then (setq temp (cadr (assq type '((byte cvtbl)
                                                (word cvtwl)
                                                (long movl)))))
                  (e-write3 temp vect-val index-reg)

                  (if (eq type 'byte)

Mark Bromley
bromley@cornell


From forwarder@UWVAX  Mon Aug 27 14:25:15 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA19881; Mon, 27 Aug 84 14:25:15 pdt
Received: from wisc-rsch.arpa (wisc-rsch.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA05251; Mon, 27 Aug 84 14:23:30 pdt
Date: Mon, 27 Aug 84 16:26:07 cdt
Message-Id: <8408272126.AA14734@wisc-rsch.arpa>
Received: by wisc-rsch.arpa; Mon, 27 Aug 84 16:26:07 cdt
To: franz-friends@BERKELEY
Subject: FRANZ to VI and back
Cc: neves@wisc-rsch.arpa
Sender: forwarder@UWVAX
From: neves@wisc-rsch.arpa

Escuse me if this is a simple question, but i am a Unix novice.
What is the best way to go between VI & Franz when debugging a
program?  The way I currently do it is to ctrl-Z out of Franz,
FG to my VI process, correct my code, FG back to FRANZ, load the
corrected code.  Is there a better way (do not tell me about
Emacs because that is not an option)?
-thanks, david

From rad@mitre-bedford  Mon Aug 27 14:52:55 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20435; Mon, 27 Aug 84 14:52:55 pdt
Received: from mitre-bedford (mitre-bedford.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA05840; Mon, 27 Aug 84 14:51:11 pdt
Message-Id: <8408272151.AA05840@UCB-VAX.ARPA>
Date: Monday, 27 Aug 1984 17:45-EDT
From: rad@Mitre-Bedford
To: neves@WISC-RSCH.ARPA
Cc: franz-friends@BERKELEY, neves@WISC-RSCH.ARPA
Subject: Re: FRANZ to VI and back
In-Reply-To: Your message of Monday, 27 Aug 1984 17:26-EDT.
             <8408272126.AA14734@wisc-rsch.arpa>


>>Escuse me if this is a simple question, but i am a Unix novice.
>>What is the best way to go between VI & Franz when debugging a
>>program?  The way I currently do it is to ctrl-Z out of Franz,
>>FG to my VI process, correct my code, FG back to FRANZ, load the
>>corrected code.  Is there a better way (do not tell me about
>>Emacs because that is not an option)?

It's undocumented in the franz opus 37 manual, but may be in the opus
38:  In franz, type (vi foo) and lisp will spin up vi.  If it can't
find the file foo, it tries for foo.l before creating a new file.  If
you invoke it as (vil foo), it will load foo back in after you exit
from vi.  There are similar functions called ex and exl.  

If you're using BSD4.2, you probably have opus 38.  A new book is out
called Lispcraft.  It is based on franz, opus 38 in particular.  You
might want to pick that up.  The old standby, Lisp, by Winston and
Horn, documented Maclisp which is close to franz.  Their new, 2nd
edition is based on Common Lisp, however, which is different, so watch 
out!

If you don't like ex or vi (say you're an ed-masochist), there are hooks
for other editors.  Put the following in the .lisprc file in your home
directory:

(def ed (nlambda (x)
		   (exvi 'ed x nil)))
(def edl (nlambda (x)
		    (exvi 'ed x t)))

These will give you the same function as ex/vi and exl/vil except
using ed.  These functions are found in /usr/lib/lisp/auxfns0.l (opus
37, anyway).

Dick Dramstad
rad@mitre-bedford


From liz@maryland  Tue Aug 28 10:17:28 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA28395; Tue, 28 Aug 84 10:17:28 pdt
Received: from maryland.ARPA (maryland.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA24861; Tue, 28 Aug 84 10:15:46 pdt
Received: by maryland.ARPA (4.12/4.7)
	id AA20274; Tue, 28 Aug 84 10:59:06 edt
Date: Tue, 28 Aug 84 10:59:06 edt
From: liz@maryland (Liz Allen)
Message-Id: <8408281459.AA20274@maryland.ARPA>
To: neves@WISC-RSCH.ARPA, rad@Mitre-Bedford
Subject: Re: FRANZ to VI and back
Cc: franz-friends@BERKELEY

One feature of our vi functions is to ask (after returning from vi)
whether or not you want to load the file.  This gives you the freedom
to decide later when you know if you modified the file.  To implement
this, you could change the last line of exvi from:

	(cond (doload (load edit_file)))

to:

	(cond ((or doload (query "Load " edit_file "? "))
	       (load edit_file)))

and define query:

	(defmacro (&rest prompt)
	  `(progn (msg ,@prompt) (yesp (read))))

(or something like that).  Exvi is defined in common1.l.

Enjoy!

				-Liz

PS  You could also send me mail asking about getting our software!


From @MIT-MC:iaeh@cmu-ri-isl2.arpa  Wed Aug 29 08:09:14 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA09035; Wed, 29 Aug 84 08:09:14 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA15198; Wed, 29 Aug 84 08:09:05 pdt
Message-Id: <8408291509.AA15198@UCB-VAX.ARPA>
Date: 29 Aug 1984 11:06:09-EDT
From: Ingemar.Hulthage@CMU-RI-ISL2
Subject: Vector algebra
Apparently-To: <franz-friends@UCB-VAX>


I am writing a package of functions for vector algebra in arbitrary (finite)
dimensions and it occured to me that I ought to post a message to find
out if something like this is alredy available. 

I am looking forward to the replies


From @MIT-MC:iaeh@cmu-ri-isl2.arpa  Fri Aug 31 10:16:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04497; Fri, 31 Aug 84 10:16:03 pdt
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA03527; Fri, 31 Aug 84 10:15:41 pdt
Message-Id: <8408311715.AA03527@UCB-VAX.ARPA>
Date: 31 Aug 1984 13:15:27-EDT
From: Ingemar.Hulthage@CMU-RI-ISL2
Subject: matrix inversion
Apparently-To: <franz-friends@UCB-VAX>


I need to numerically invert matrices of varying sizes and I would
appreciate pointers to any lisp functions that can do that.


From mccune@aids-unix  Fri Aug 31 10:42:29 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA05060; Fri, 31 Aug 84 10:42:29 pdt
Received: from aids-unix (aids-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA04133; Fri, 31 Aug 84 10:41:52 pdt
Message-Id: <8408311741.AA04133@UCB-VAX.ARPA>
Date: 31 Aug 84 10:40:13 PDT (Fri)
From: Brian McCune <mccune@aids-unix>
Subject: Mailing list
To: franz-friends@BERKELEY

Please remove my name from franz-friends.  Thanks.  

	Brian McCune
	MCCUNE@AIDS-UNIX

From ucsbcsl!dave@engrvax  Tue Sep  4 11:22:20 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA10583; Tue, 4 Sep 84 11:22:20 pdt
Received: by UCB-VAX.ARPA (4.24/4.33)
	id AA26490; Tue, 4 Sep 84 11:22:10 pdt
From: ucsbcsl!dave@engrvax
Received: from engrvax.UCSB (engrvax.ARPA) by ucsbcsl.UCSB (4.12/3.14.ucsb)
	id AA27209; Tue, 4 Sep 84 10:55:08 pdt
Date: Tue, 4 Sep 84 10:55:52 pdt
Message-Id: <8409041755.AA20764@engrvax.UCSB>
Received: by engrvax.UCSB (4.12/3.14.ucsb)
	id AA20764; Tue, 4 Sep 84 10:55:52 pdt
To: franz-friends@BERKELEY
Subject: I have moved.

Please change my mailing address to be 'ucsbcsl!chi!dave' from 'ucsbcsl!dave'.
Thanks.

From liz@maryland  Wed Sep  5 08:34:45 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA19892; Wed, 5 Sep 84 08:34:45 pdt
Received: from maryland.ARPA (maryland.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA14415; Wed, 5 Sep 84 08:34:27 pdt
Received: by maryland.ARPA (4.12/4.7)
	id AA09320; Wed, 5 Sep 84 11:33:56 edt
Date: Wed, 5 Sep 84 11:33:56 edt
From: liz@maryland (Liz Allen)
Message-Id: <8409051533.AA09320@maryland.ARPA>
To: franz-friends@BERKELEY
Subject: Maryland software

I'm mailing the announcement here again since a few things have
changed since I last sent it out here and I have had requests for
it.  Currently, we are completing the 4.2 switchover and will
(hopefully) be starting to distribute it by the end of September.

				-Liz Allen

-----------------------------------------------------------------

Greetings:


     This is to announce the availability of the Univ of Maryland
software distribution.  This includes source code for the follow-
ing packages which are currently running on a  VAX  11/780  under
Berkeley UNIX(tm) 4.1:

(1)  The flavors package written in Franz Lisp.  This package has
     been used successfully in a number of large systems at Mary-
     land, and while it does not implement all  the  features  of
     Lisp  Machine  Flavors, the features present are as close to
     the Lisp Machine version as possible within the  constraints
     of  Franz  Lisp.   (Note that Maryland flavors code *can* be
     compiled.)

(2)  Other Maryland Franz hacks including the INTERLISP-like  top
     level,  the  lispbreak error handling package, the for macro
     and the new loader package.

(3)  The YAPS production system written in Franz Lisp.   This  is
     similar  to  OPS5  but  more  flexible  in the kinds of lisp
     expressions that may appear as facts and patterns  (sublists
     are  allowed and flavor objects are treated atomically), the
     variety of tests that may appear in the left hand  sides  of
     rules  and the kinds of actions may appear in the right hand
     sides of rules.  In  addition,  YAPS  allows  multiple  data
     bases which are flavor objects and may be sent messages such
     as "fact" and "goal".

(4)  The windows package in the form of  a  C  loadable  library.
     This flexible package allows convenient management of multi-
     ple contexts on the screen and runs  on  ordinary  character
     display  terminals as well as bit-mapped displays.  Included
     is a Franz lisp interface to the window  library,  a  window
     shell  for  executing shell processes in windows, and a menu
     package (also a C loadable library).

(5)  The phone program.  This is a facility to allow two or  more
     users  to type messages to each other in separate windows on
     a tty screen.  It uses the Maryland window package and CMU's
     IPC facility.

(6)  The calend program, an appointment calendar maintainer.   It
     uses a user file of reminding messages and dates for remind-
     ing, and can notify a user by messages printed to his termi-
     nal,  sending them mail, or nagging them to get off the ter-
     minal at a certain time of day.  It  allows  one-time  only,
     weekly,  biweekly, monthly, yearly and other similar methods
     for being reminded.

(7)  The bbd program, a multiple bulletin  board  system  loosely
     based  on the 'msgs' program.  It accepts character-oriented
     commands and allows user-definable bulletin-boards.

(8)  Rzasm, a relocating Z80 cross-assembler.  Running on the vax
     it  puts  out  ld-style object files.  Its features include,
     among others: free-form input;  (very)  long  variable/label
     names;  conditional assembly; macros (in 'm4' format); digit
     labels; global, external, common and local  common  declara-
     tions; data and text segments; support of the "undocumented"
     Z80 instructions (that work on high and  low  bytes  of  the
     index registers separately); expressions using C syntax; and
     string constants.

(9)  Zrun, a z80 microprocessor simulator.   Zrun  simulates  the
     execution  of  a  z80 with 64k RAM, as directed by user com-
     mands.  In addition to the essential commands that cause  an
     rzasm  object  program  to be loaded and executed, there are
     commands to examine and set  registers,  flags,  and  memory
     locations,  to  set  a  breakpoint, to single-step through a
     program, to re-direct the  flow  of  data  through  the  z80
     ports, etc.

The distribution currently runs under Berkeley Unix 4.1,  but  we
will  be upgrading to 4.2 in early July and the upgrade should be
ready for distribution in September.  At that time, we will begin
to put both the 4.1 and 4.2 sources on the distribution tape.  If
you are running 4.2 or plan to be running 4.2 in the near future,
it  is  probably  worth  your while to wait for it.  Also at that
time, the fee for the distribution will go up from $100 to $250.

     We also include Franz Lisp in the distribution since  it  is
easier  to do that than to describe all the small changes that we
have made to the Franz sources.  For  the  4.1  distribution,  we
send  Franz  Opus 38.26.  For the 4.2 distribution, we do not yet
know which Franz we will be mailing, but it will be whichever  we
get with our 4.2 Berkeley Unix.


How to obtain a tape:

     To obtain the Univ of Maryland distribution tape:

(1)  Fill in the form below and sign it.  Please indicate whether
     you  want  just  the  4.1 distribution, both the 4.1 and 4.2
     distributions or if you will be obtaining  the  distribution
     via a third party or via the Arpanet.

(2)  Make out a check to "University of Maryland Foundation"  for
     $100  (US  dollars) or for $250 (US dollars) if you want the
     4.2 distribution.  Mail the check and form to:

                  Liz Allen
                  Univ of Maryland
                  Dept of Computer Science
                  College Park MD 20742


(3)  If you need an invoice,  send  me  mail.   Don't  forget  to
     include your non-electronic mailing address.

Upon receipt of the money, we will mail you a tape containing our
software  and  the technical reports describing the software.  We
will also keep you informed of bug fixes via electronic mail.  We
have  an  electronic  mailing address for this kind of thing.  It
is:

         Usenet:      ...!seismo!umcp-cs!um-software
         Arpanet:     um-software@maryland

Please note that bug fixes will be done  only  insofar  they  are
consistent  with the research purposes of the University of Mary-
land.

     If you have any technical questions, etc, send mail  to  the
above  mailing  list.   If you have any administrative questions,
contact Diane Miller via electronic mail:

           Usenet:      ...!seismo!umcp-cs!despina
           Arpanet:     despina@maryland

or via phone at (301) 454-4251.


                         Liz Allen

                         Usenet:      ...!seismo!umcp-cs!liz
                         Arpanet:     liz@maryland

-----------------------------------------------------------------

In exchange for the Maryland software tape, I certify to the fol-
lowing:

a.   I will not use any of the Maryland software distribution  in
     a commercial product without obtaining permission from Mary-
     land first.

b.   I will keep the Maryland copyright  notices  in  the  source
     code,  and acknowledge the source of the software in any use
     I make of it.

c.   I will not redistribute this software to anyone without per-
     mission from Maryland first.

d.   I will keep Maryland informed of any bug fixes.

e.   I understand that the software I will be receiving has  been
     developed  for  research  purposes  only and may be good for
     absolutely nothing.  The University of  Maryland  offers  no
     warranties of any kind.  Bug fixes will be done only insofar
     they are  consistent  with  the  research  purposes  of  the
     University of Maryland.

f.   I am the appropriate person at my  site  who  can  make  the
     guarantees in parts a through e.

g.   I would like the package indicated below:


     ___  4.1 distribution only.  I have  enclosed  a  check  for
          $100.


     ___  4.1 and 4.2 distribution.  I have enclosed a check  for
          $250.   I  also understand that the 4.2 distribution is
          not yet ready and that there will be a delay  until  at
          least August or September before my tape arrives.

     ___  License and technical reports only.  I have enclosed  a
          check  for $100 and will obtain the distribution from a
          site that already has the distribtution or will get  it
          from  Maryland via the Arpanet.  (Please note specifics
          at the bottom of the form.)




Signature:                  ______________________________

Name:                       ______________________________

Position:                   ______________________________

Company or Organization:    ______________________________

Address:                    ______________________________

                            ______________________________

Phone number:               ______________________________

Electronic mail address:    ______________________________


From gvax.bromley@Cornell.ARPA  Wed Sep  5 16:11:17 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA25823; Wed, 5 Sep 84 16:11:17 pdt
Received: from CORNELL.ARPA (cornell-gw.ARPA) by UCB-VAX.ARPA (4.24/4.33)
	id AA21315; Wed, 5 Sep 84 16:10:58 pdt
Received: from CORNELL-GVAX.ARPA (gvax) by CORNELL.ARPA (4.30/4.30)
	id AA15943; Wed, 5 Sep 84 19:11:13 edt
Date: Wed, 5 Sep 84 19:06:27 edt
From: gvax.bromley@Cornell.ARPA (Mark Bromley)
Message-Id: <8409052306.AA19770@CORNELL-GVAX.ARPA>
Received: by CORNELL-GVAX.ARPA (4.30/4.30)
	id AA19770; Wed, 5 Sep 84 19:06:27 edt
To: franz-friends@BERKELEY
Subject: Bug in open coding of vseti in Liszt 8.36

There is a mistake in the open coding of (vseti vector index expression).
When the generated code is executed it returns the value of the index expression
and not the value of expression.  The problem is in d_vset in liszt/vector.l.
The code in d_vset that generates the assembler code to compute the
return value assumes that code has been generated to put the value of
expression in index-reg.  This assumption is false.

I don't know the 68000 well enough to suggest a solution for it, but the
following should work for the VAX.  Change the lines

         (if g-loc
             then  (if (eq type 'byte)

(occuring about 3/4 of the way through d_vset) to

         (if g-loc
             then
	         #+for-vax
		 (progn
		      (setq temp (cadr (assq type '((byte cvtbl)
                                                   (word cvtwl)
                                                   (long movl)))))
                      (e-write3 temp vect-val index-reg)
		  )
		  
		  #+for-68k
		  (comment Do the same thing for the 68k)

                  (if (eq type 'byte)

Also, what is the current Berkeley distribution policy.  I tried ftp'ing
from ucbvax, but the pub/lisp directory there is empty.  I'd like to get my
hands on a distribution that has the flavors package in it.

Mark Bromley
bromley@cornell




From jkf@ucbmike  Tue Oct 30 12:19:45 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA02909; Tue, 30 Oct 84 12:19:45 pst
Received: from ucbmike.arpa by UCB-VAX.ARPA (4.24/4.31)
	id AA23363; Tue, 30 Oct 84 11:43:13 pst
Received: by ucbmike.arpa (4.24ucb/4.33)
	id AA04265; Tue, 30 Oct 84 12:43:39 pst
Date: Tue, 30 Oct 84 12:43:39 pst
From: John Foderaro (on a sun) <jkf@ucbmike>
Message-Id: <8410302043.AA04265@ucbmike.arpa>
To: mrose%udel-dewey.delaware@udel-relay.ARPA, franz-friends@BERKELEY
Subject: Re: Where is franz-friends-request
In-Reply-To: Your message of 28 Oct 84 10:04:05 EST (Sun)

 franz-friends-request@berkeley is valid.  occasionlly the mailer tries
 to look in the alias table while it is being updated.
 


From liz@tove  Tue Oct 30 13:18:32 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03406; Tue, 30 Oct 84 13:18:32 pst
Received: from tove.ARPA (tove.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA24224; Tue, 30 Oct 84 12:15:01 pst
Received: by tove.ARPA (4.12/4.7)
	id AA09504; Thu, 25 Oct 84 16:46:39 edt
From: Liz Allen <liz@tove>
Message-Id: <8410252046.AA09504@tove.ARPA>
Date: 25 Oct 1984 1646-EDT (Thursday)
To: Rene Bach <BACH@su-score>
Cc: franz-friends@BERKELEY
Subject: Re: A question
In-Reply-To: Your message of Thu 25 Oct 84 09:31:09-PDT.
             <8410251628.AA00848@UCB-VAX.ARPA>

	From: Rene Bach <BACH%su-score.arpa@csnet-relay.ARPA>

	I am new on this list and haven't seen any other messages.

There isn't too much mail here.

	Is there a way to find out what are all the atoms which
	have been defined in Franz (a la mapatoms of INterlisp) ??

The functions (oblist) returns a list of all the atoms.

				-Liz

From neves%wisc-ai.uwisc@wisc-crys.ARPA  Tue Oct 30 14:38:15 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04963; Tue, 30 Oct 84 14:38:15 pst
Received: from wisc-crys.arpa (wisc-crys.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA27563; Tue, 30 Oct 84 14:36:12 pst
Received: from wisc-ai.uwisc by wisc-crys.arpa; Tue, 30 Oct 84 16:35:00 cst
Date: Tue, 30 Oct 84 16:34:59 cst
From: neves%wisc-ai.uwisc@wisc-crys.ARPA (David Neves)
Message-Id: <8410302234.AA21547@wisc-ai.uwisc>
Received: by wisc-ai.uwisc; Tue, 30 Oct 84 16:34:59 cst
To: franz-friends@BERKELEY
Subject: vi/franz question

This is a vi/franz question.
I would like to use "=" in VI to indent my lisp code.  When I
type "=" in front of some lisp code I get
No alternate filename to substitute for #0
How do I indent Lisp code (besides using autoindent)?
-Thanks, David

From Johnson%udel-dewey.delaware@udel-relay.ARPA  Wed Oct 31 05:54:58 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04156; Wed, 31 Oct 84 05:54:58 pst
Received: from udel-relay (udel-gw.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA07029; Wed, 31 Oct 84 05:52:24 pst
Message-Id: <8410311352.AA07029@UCB-VAX.ARPA>
Received: From udel-dewey.ARPA by udel-relay.ARPA id a018834 ;31 Oct 84 8:55 EST
Date:     Wed, 31 Oct 84 8:47:19 EST
From: johnson <johnson%udel-dewey.delaware@udel-relay.ARPA>
To: franz-friends@BERKELEY
Cc: johnson%udel-dewey.delaware@udel-relay.ARPA
Subject:  response to lisp/vi question


in response to:

>I would like to use "=" in VI to indent my lisp code.  When I
>type "=" in front of some lisp code I get
>No alternate filename to substitute for #0
>How do I indent Lisp code (besides using autoindent)?

1. When I type "=" in vi (without :set lisp) I get no response at all.
	Is it possible that you defined a macro named "=" ?
	{
		check your ~/.exrc file for a line beginning:
		:map = <something-or-other>
	}

2. Even after:
	:set lisp

	A single "=" does not seem to cause the correct action, however,
	two successive "="s do.  

to summarize:
	1. remove any mapping of "=" from ~/.exrc
	2. :set lisp
    	3. use "==" rather than "="

- johnson@udel-ee


From raf%bostonu.csnet@csnet-relay.arpa  Wed Oct 31 11:35:57 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA07802; Wed, 31 Oct 84 11:35:57 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA13682; Wed, 31 Oct 84 11:33:13 pst
Received: from bostonu by csnet-relay.csnet id ac00303; 31 Oct 84 14:27 EST
Received: by csvaxa.ARPA (4.12/4.7)
	id AA14678; Wed, 31 Oct 84 13:53:18 est
Date: Wed, 31 Oct 84 13:53:18 est
From: Rafail Ostrovsky <raf%bostonu.csnet@csnet-relay.arpa>
Message-Id: <8410311853.AA14678@csvaxa.ARPA>
To: FRANZ-FRIENDS%ucb-vax.arpa@csnet-relay.arpa
Subject: MAILING LIST

Hello.
I would like to subscribe to your mailing list. 
I am a grad. student at Boston U. My address is:

raf%bostonu.csnet@CSNET-RELAY.CSNET

               Thank you, -Raf

From neves%wisc-ai.uwisc@wisc-crys.ARPA  Wed Oct 31 12:40:33 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA09034; Wed, 31 Oct 84 12:40:33 pst
Received: from wisc-crys.arpa (wisc-crys.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA15180; Wed, 31 Oct 84 12:37:38 pst
Received: from wisc-ai.uwisc by wisc-crys.arpa; Wed, 31 Oct 84 14:35:47 cst
Date: Wed, 31 Oct 84 14:35:55 cst
From: neves%wisc-ai.uwisc@wisc-crys.ARPA (David Neves)
Message-Id: <8410312035.AA25488@wisc-ai.uwisc>
Received: by wisc-ai.uwisc; Wed, 31 Oct 84 14:35:55 cst
To: franz-friends@BERKELEY
Subject: re: Indenting lisp code in VI

Thanks for the response on indenting for Franz.  It seems as though
our systems people do not use Lisp and so have set up everyone's
.exrc file to map = to something else.  Your site might be doing the
same thing to this or other VI/Lisp features!  Stop them now.

From @MIT-MC:iaeh@cmu-ri-isl2.arpa  Wed Oct 31 17:37:36 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA14939; Wed, 31 Oct 84 17:37:36 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA02960; Wed, 31 Oct 84 17:14:37 pst
Message-Id: <8411010114.AA02960@UCB-VAX.ARPA>
Date: 31 Oct 84 20:08:41 EST
From: Ingemar.Hulthage@CMU-RI-ISL2
Subject: Floating point division
To: BBoard.Maintainer@CMU-CS-A


Is there a pre-defined  function in Franz Lisp that never uses integer
division when it differs from floating point division ?  Obviously it is easy
to write (quotient (float a) b) or to write a function/macro with the same
effect. However, since Franz does a good job of dealing with different kinds
of numbers in other cases, it is inconvenient and inefficient if such a
function is not available in the system.


From eng20201%BOSTONU.bitnet@WISCVM.ARPA  Thu Nov  1 16:02:58 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA05698; Thu, 1 Nov 84 16:02:58 pst
Received: from WISCVM.ARPA (wiscvm.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA08850; Thu, 1 Nov 84 16:00:19 pst
Message-Id: <8411020000.AA08850@UCB-VAX.ARPA>
Received: from ENG20201@BOSTONU.BITNET by WISCVM.ARPA on 11/01/84 at
   18:00:40 CST
Date:  1-Nov-84   18:58:53 EST
From: John Sutter               <eng20201%BOSTONU.bitnet@WISCVM.ARPA>
Subject: Pretty typer
To: franz-friends@BERKELEY
Cc: eng20201%BOSTONU.bitnet@WISCVM.ARPA

-----

  Does anyone know of a pretty typer for Franz Lisp?..

  If you do, please reply to me directly.

  Thanks

  ----  John

-----

From holtz%carleton.cdn%ubc.csnet@csnet-relay.arpa  Sun Nov  4 14:39:06 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03203; Sun, 4 Nov 84 14:39:06 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA04466; Sun, 4 Nov 84 14:36:25 pst
Received: from ubc by csnet-relay.csnet id a004399; 4 Nov 84 15:43 EST
Date: Sun, 4 Nov 84 12:37:03 pst
Received: by ubc-ean.UUCP id AA17658; Sun, 4 Nov 84 12:37:03 pst
From: Neal Holtz <holtz%carleton.cdn%ubc.csnet@csnet-relay.arpa>
To: franz-friends%ucb-vax.arpa@csnet-relay.arpa
Mmdf-Warning:  Parse error in preceding line at CSNET-RELAY.ARPA
Message-Id: 133:holtz@carleton.cdn
Subject: Franz on Apollos (or, Fritz Kunze, where are you?)

Sorry to send this to the newsgroup, but if Fritz (or anyone else,
for that matter) can tell me anything about the possibility of
having Franz run on Apollo workstations (under AEGIS) in the
near future, I would be most appreciative.


From holtz%carleton.cdn%ubc.csnet@csnet-relay.arpa  Sun Nov  4 14:39:20 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03212; Sun, 4 Nov 84 14:39:20 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA04473; Sun, 4 Nov 84 14:36:37 pst
Received: from ubc by csnet-relay.csnet id a004408; 4 Nov 84 15:45 EST
Date: Sun, 4 Nov 84 12:37:03 pst
Received: by ubc-ean.UUCP id AA17658; Sun, 4 Nov 84 12:37:03 pst
From: Neal Holtz <holtz%carleton.cdn%ubc.csnet@csnet-relay.arpa>
To: franz-friends%ucb-vax.arpa@csnet-relay.arpa
Mmdf-Warning:  Parse error in preceding line at CSNET-RELAY.ARPA
Message-Id: 133:holtz@carleton.cdn
Subject: Franz on Apollos (or, Fritz Kunze, where are you?)

Sorry to send this to the newsgroup, but if Fritz (or anyone else,
for that matter) can tell me anything about the possibility of
having Franz run on Apollo workstations (under AEGIS) in the
near future, I would be most appreciative.


From fkunze%ucbopal.CC%ucb-vax.arpa@csnet-relay.arpa  Sun Nov  4 23:25:12 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03125; Sun, 4 Nov 84 23:25:12 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA04781; Sun, 4 Nov 84 23:22:27 pst
Received: from ucb-vax.arpa by csnet-relay.arpa id a006482; 5 Nov 84 2:21 EST
Received: from ucbjade.CC.Berkeley.ARPA (ucbjade.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA04236; Sun, 4 Nov 84 22:58:35 pst
Received: from ucbopal.CC.Berkeley.ARPA (ucbopal.ARPA)
	by ucbjade.CC.Berkeley.ARPA (4.17/4.27.2)
	id AA14292; Sun, 4 Nov 84 22:59:18 pst
Received: by ucbopal.CC.Berkeley.ARPA (4.17/4.28)
	id AA03601; Sun, 4 Nov 84 22:59:26 pst
Date: Sun, 4 Nov 84 22:59:26 pst
From: Fritz Kunze <fkunze%ucbopal.CC%ucb-vax.arpa@csnet-relay.arpa>
Message-Id: <8411050659.AA03601@ucbopal.CC.Berkeley.ARPA>
To: franz-friends%ucb-vax.arpa%csnet-relay.arpa@csnet-relay.arpa,
        holtz%carleton.cdn%ubc.csnet%csnet-relay.arpa@csnet-relay.arpa
Subject: Re: Franz on Apollos (or, Fritz Kunze, where are you?)

We are working on an Apollo port right now. Due to some
non-standard features in the Apollo operating system,
the port is requiring far more time than we originally
anticipated.  We are very close to a working interpreter,
but the compiler will require more time.  Are you interested
in the Interpreter first?
---Fritz Kunze
   Franz Inc.
   2920 Domingo, suite 203
   Berkeley, CA 94705
   (415) 540-1224



From abrams@mitre  Mon Nov  5 11:41:38 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08762; Mon, 5 Nov 84 11:41:38 pst
Received: from mitre (mitre.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA06184; Mon, 5 Nov 84 11:38:18 pst
Message-Id: <8411051938.AA06184@UCB-VAX.ARPA>
Date:  5 Nov 1984 14:17:36 EST (Monday)
From: Marshall Abrams <abrams@mitre>
Subject: Call for papers: Expert Systems Symposium
To: add1:@mitre
Cc: abrams@mitre

Call for Papers

Expert Systems in Government Conference

October 23-25, 1985

THE CONFERENCE objective is to allow the developers and implementers
of expert systems in goverenment agencies to exchange information and
ideas first hand for the purpose of improving the quality of
existing and future expert systems in the government sector. 
Artificial Intelligence (AI) has recently been maturing so rapidly
that interest in each of its various facets, e.g., robotics, vision,
natural language, supercomputing, and expert systems, has acquired
an increasing following and cadre of practitioners.

PAPERS are solicited which discuss the subject of the conference. 
Original research, analysis and approaches for defining  expert   
systems issues and problems such as those identified in the
anticipated session topics, methodological approaches for analyzing
the scope and nature of expert system issues, and potential
solutions are of particular interest.  Completed papers are to be no
longer than 20 pages including graphics and are due 1 May 1985.
Four copies of papers are to be sent to:

Dr. Kamal Karna, Program Chairman
MITRE Corporation W852
1820 Dolley Madison Boulevard
McLean, Virginia  22102
Phone (703) 883-5866
ARPANET:  Karna @ Mitre

Notification of acceptance and manuscript preparation instructions
will be provided by 20 May 1985.

THE CONFERENCE is sponsored by the IEEE Computer Society and The
MITRE Corporation in cooperation with The Association for Computing
Machinery, The american Association for Artificial Intelligence and
The American Institute of Aeronautics and Astronautics National
Capital Section.  This conference will offer high quality technical
exchange and published proceedings.

It will be held at Tyson's Westpark Hotel, Tysons Corner, McLean,
VA, suburban Washington, D.C.


TOPICS OF INTEREST

The topics of interest include the expert systems in the following
applications domains (but are not limited to):

 1.  Professional:           Accounting, Consulting, Engineering,
                             Finance, Instruction, Law, Marketing,
                             Management, Medicine
                             Systems, Intelligent DBMS

 2.  Office Automation:      Text Understanding, Intelligent

 3.  Command & Control:      Intelligence Analysis, Planning,
                             Targeting, Communications, Air Traffic
                             Control

 4.  Exploration:            Space, Prospecting, Mineral, Oil

                             Archeology

 5.  Weapon Systems:         Adaptive Control, Electronic Warfare,
                             Star Wars, Target Identification

 6.  System Engineering:     Requirements, Preliminary Design,
                             Critical Design, Testing, and QA

 7.  Equipment:              Design Monitoring, Control, Diagnosis,  
                             Maintenance, Repair, Instruction

 8.  Project Management:     Planning, Scheduling, Control

 9.  Flexible Automation:    Factory and Plan Automation

10.  Software:               Automatic Programming, Specifications,
                             Design, Production, Maintenance and
                             Verification and Validation

11.  Architecture:           Single, Multiple, Distributed Problem
                             Solving Tools

12.  Imagery:                Photo Interpretation, Mapping, etc.

13.  Education:              Concept Formation, Tutoring, Testing,
                             Diagnosis, Learning

14.  Entertainment and       Intelligent Games, Investment and
     Expert Advice Giving:   Finances, Retirement, Purchasing,
                             Shopping, Intelligent Information
                             Retrieval



From decvax!utzoo!dciem!nrcaero!clan.carleton!holtz  Mon Nov  5 17:32:56 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA14064; Mon, 5 Nov 84 17:32:56 pst
Received: by UCB-VAX.ARPA (4.24/4.39)
	id AA14362; Mon, 5 Nov 84 17:30:11 pst
Return-Path: <decvax!utzoo!dciem!nrcaero!clan.carleton!holtz>
Received: by decvax.UUCP (4.12/1.0)
	id AA28321; Mon, 5 Nov 84 16:46:11 est
Date: Sun, 4 Nov 84 21:23:59 est
From: Neal Holtz <decvax!carleton!clan.carleton!holtz@clan.>
Message-Id: <8411050223.AA07104@clan. UUCP>
Received: by clan. UUCP (4.12/3.14)
	id AA07104; Sun, 4 Nov 84 21:23:59 est
To: nrcaero!dciem!utzoo!decvax!ucbvax!franz-friends
Subject: Franz on Apollos (or -- Fritz Kunze, where are you?)

Sorry to send this to the newsgroup, but if Fritz (or anyone else,
for that matter) can tell me anything about the possibility of
having Franz run on Apollo workstations (under AEGIS) in the
near future, I would be most appreciative.







From asb@SCRC-STONY-BROOK.ARPA  Tue Nov  6 16:15:33 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA25403; Tue, 6 Nov 84 16:15:33 pst
Received: from SCRC-STONY-BROOK.ARPA (scrc-stony-brook.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA06061; Tue, 6 Nov 84 16:12:18 pst
Message-Id: <8411070012.AA06061@UCB-VAX.ARPA>
Received: from CHAGRIN by SCRC-STONY-BROOK via CHAOS with CHAOS-MAIL id 122057; Tue 6-Nov-84 19:13:41-EST
Date: Tue, 6 Nov 84 19:11 EST
From: Richard Brenner <asb@SCRC-CUPID.ARPA>
Subject: Job Opportunities
To: maple-sys@BERKELEY, symalg%rand-unix.arpa%csnet-relay.arpa@SCRC-CUPID.ARPA,
        franz-friends@BERKELEY
In-Reply-To: The message of 6 Nov 84 15:51-EST from Richard Pavelle <RP at SCRC-TENEX>


Symbolics, Inc. of Cambridge is the acknowledged leader in the field of
Symbolic Processing, offering the premier LISP-based Symbolic Processor
for advanced problem-solving applications.  We are a fast-growing,
high-tech company with new, modern facilities right in Cambridge. Recent
expansion has created opportunities for the following experienced
professionals:


Member of Technical Staff

You will assist with maintenance and enhancement of MACSYMA, a large
Computer Algebra System written in LISP and used by engineers and
scientists for performing symbolic computations.  Immediate projects
could include design and implementation of tools for conversion to
Common LISP, improving modularity, modernizing the user interface,
improving performance, and design and implementation of new mathematical
packages based on the latest available algorithms.  Work will be
performed on all versions of MACSYMA using Symbolics 3600 Family Lisp
Machines.  A strong background in mathematics and Lisp programming is
preferred.  Experience with MACSYMA is desirable.


Technical Sales Support Engineer

You will provide technical support to our internal sales staff, to
customers and to prospective customers.  Responsibilities include
assistance at demonstration sites, installations on several kinds of
machines, and a full range of customer support activities.  This could
include design, development and delivery of a trainging course for
MACSYMA users.  Qualified applicants will have experience with a
high-level language, preferably MACSYMA.  Good written and verbal
communication skills and prior software project involvement are desired.
B.S. degree or equivalent and 2 years experience preferred.


Qualified candidates should send their resume,in strict confidence,
including salary history, to Gina Setteducati, Personnel Supervisor,
Symbolics, Inc., 11 Cambridge Center, Cambridge, MA 02142.  An equal
opportunity employer.


From ssc-vax!steve@uw-beaver.arpa  Wed Nov  7 19:52:19 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08630; Wed, 7 Nov 84 19:52:19 pst
Received: from uw-beaver.arpa (uw-beaver.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA05368; Wed, 7 Nov 84 18:51:47 pst
Received: by uw-beaver.arpa (4.12/2.2)
	id AA00936; Wed, 7 Nov 84 17:50:03 pst
Return-Path: <ssc-vax!steve>
Received: by ssc-vax (4.12/4.7)
	id AA06915; Wed, 7 Nov 84 17:24:40 pst
Date: Wed, 7 Nov 84 17:24:40 pst
From: ssc-vax!steve@uw-beaver.arpa (Steve White)
Message-Id: <8411080124.AA06915@ssc-vax>
To: uw-beaver!franz-friends@BERKELEY
Subject: readtable within fasl


In "fasl.c" before the literals are read back out of the object file,
the readtable is rebound to the 'standard-readtable'. This short-circuits
any type of character macro expansion. Does anyone known a workaround
for this? In NIL you can specify the readtable associated with the object
code, I guess I'm wondering how to mimic this behavior in franz?
			thanks
					steve white
				(ssc-vax!steve@uw-beaver)

From @MIT-MC:smh@MIT-EDDIE  Thu Nov  8 07:49:13 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA12925; Thu, 8 Nov 84 07:49:13 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA17112; Thu, 8 Nov 84 07:46:31 pst
Message-Id: <8411081546.AA17112@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA20888; Thu, 8 Nov 84 10:33:41 est
Date: Thu, 8 Nov 84 10:33:41 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: Re: readtable within fasl

I too was bothered by fasl's insistence on using the standard readtable
to process literals in liszt-compiled files until I realized the reason
for this limitation:

All source input to liszt is processed by `read' -- that is, the
compiler reads only forms, never ascii strings.  In order to place a
literal form in an object file, liszt must essentially convert the form
back into ASCII via `print'.  (Actually, a somewhat modified version
which knows how to wrap an assembler `.asciz' directive around the
printed representation of the form, etc.)  Unfortunately, liszt can make
no easy assumption about what strange readtable is likely to be active
at load time, so the only sane choice is to use the standard readtable.

In other words, you shouldn't think of literal forms stored in a fasl
object file as external (ASCII) representation of lisp data.  Rather,
liszt/fasl use ASCII as a convenient "position-independent" encoding of
a form which has already been processed by read at compile time.  This
is entirely analogous to what traditional compilers and assemblers do
with numeric constants represented in ASCII inside a program, except
their compiler-to-loader data format uses the native binary number
representation of the object machine.

One could argue that this isn't really a limitation provided one is
willing and able to provide the desired readtable at compile time.
Usually this isn't a problem, although I once I had a macro which wanted
to insert into a form a particular uninterned symbol which (obviously)
couldn't even exist until execution time.  I was forced to wrap the form
inside another function which would accomplish the substitution at load
time.

There is no reason liszt could not be made to copy ASCII forms into the
fasl file without read->print translation, but this would require
changes to the compiler and to fasl format, things not to be done
lightly.  If you *really* need the facility, and don't need to read huge
volumes of data, you could include ASCII forms inside a fasl file by
encoding them as lisp strings, and seeing that they get processed by an
appropriate function at load time, something like:

	(defun strange-read (str)
	       (let ((readtable strange-readtable))
		    (readlist (explodec str))))

Then you can do things like:
	(setq foo (strange-read ") a b )c d( e (")

[What?  You don't like my readtable with the parens reversed?]  The
invocation of `strange-read' can, of course, be conveniently macrofied.
If appropriate, automatic printing of literal strings can also be
performed by compile time macros.  You will have to deal with the
problem of escaping quotes inside these forms, and you might want to
enable string garbage collection if you do a lot of this sort of thing.

I know it's ugly, but...

Steve Haflich


From @MIT-MC:smh@MIT-EDDIE  Thu Nov  8 12:17:02 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA15294; Thu, 8 Nov 84 12:17:02 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA22393; Thu, 8 Nov 84 11:59:13 pst
Message-Id: <8411081959.AA22393@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA21531; Thu, 8 Nov 84 12:51:14 est
Date: Thu, 8 Nov 84 12:51:14 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: Re: Re: readtable within fasl

There was a typo in my previous mailing.  The function "explodec"
should have been "exploden".


From BACH@SU-SCORE.ARPA  Thu Nov  8 14:24:38 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA16474; Thu, 8 Nov 84 14:24:38 pst
Received: from SU-SCORE.ARPA (su-score.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA25584; Thu, 8 Nov 84 14:22:00 pst
Message-Id: <8411082222.AA25584@UCB-VAX.ARPA>
Date: Thu 8 Nov 84 14:21:16-PST
From: Rene Bach <BACH@SU-SCORE.ARPA>
Subject: printing delayed in Eunice
To: franz-friends@BERKELEY
Cc: bach@SU-SCORE.ARPA

It appears that printing gets delayed in Eunice. What I mean by that
is that I have a print statement which should indicate that the system
is progressing. However, the system is chugging along, nothing shows
for a long while and then the printing happens ALL at ONCE ! As if the
output was buffered and go printed when something else needed to be
printed.

As anyone run across this before ? Is there a flag one needs to set ?

Has it to do with Eunice ?  What I am printing is just an atom and a ", ".
When I print longer stuff, no buffering is noticed.

Thanks
Rene
-------

From JonL.pa@Xerox.ARPA  Thu Nov  8 16:34:36 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA17894; Thu, 8 Nov 84 16:34:36 pst
Received: from Xerox.ARPA (xerox.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.31)
	id AA27172; Thu, 8 Nov 84 15:30:06 pst
Message-Id: <8411082330.AA27172@UCB-VAX.ARPA>
Received: from Burger.ms by ArpaGateway.ms ; 08 NOV 84 15:29:24 PST
Date: 8 Nov 84 15:22 PST
From: JonL.pa@XEROX.ARPA
Subject: Re: readtable within fasl
In-Reply-To: Steven M. Haflich <smh@mit-eddie.ARPA>'s message of Thu, 8
 Nov 84 10:33:41 est
To: smh@mit-eddie.ARPA
Cc: franz-friends@BERKELEY

The problems with a user-tailorable READ is one of the reasons why, over
12 years ago, we chose a format for MacLisp's FASL files that is
somewhat akin to a position-independent list encoding.  (But in fact, it
was primarily for speed that the READ-oriented option was abandoned).

However, there was still the need to introduce load-time evaluation, in
order to create structures that can't be known even faintly at compile
time; there is an "internal" marker, accessible to the MacLisp user as a
global variable (named SQUID, I believe), so that the portions of a
structure that need to be eval'd at load time could be marked.  E.g.
    (FOO 3 '(SOME (DEEPLY NESTING (LIST IN #,LISPSYSTEMDATE))))
and the #, signals a spot for load-time evaluation, even though the
overall structure is essentally a QUOTE form.  

One needn't imagine that #, is the only client of this "internal" marker
-- it provides the way to get all but the trivial datatypes into
quotified structures; for example, I may have an input syntax for
arrays, but still PRINT won't put them out (MacLisp PRINT won't, at
least), and certainly not every conceivable datatype needs a special
encoding for the FASL file format; merely a LIST, which is viewed as a
general program by EVAL, is satisfactory to create any createable
datatype instance.

Interlisp too has a loadtime evaluation construct, but it may only
replace a QUOTE -- not some sub-piece of data underneath a QUOTE, such
as indicated by the #, above.  A primary reason for this limitation is
the similarity of Interlisp's and Franz's compiler output formats --
basically an ascii string to which READ is applied.   MacLisp's loader
is indeed quite more complex, but it results in a space savings for the
FASL files and a considerable time savings when loading them.

-- Jon L White --



From @MIT-MC:nss@cmu-ri-isl3.arpa  Fri Nov  9 12:09:40 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA26238; Fri, 9 Nov 84 12:09:40 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA04311; Fri, 9 Nov 84 12:06:51 pst
Message-Id: <8411092006.AA04311@UCB-VAX.ARPA>
Date: 9 Nov 84 14:02:29 EST
From: Nancy.Skooglund@CMU-RI-ISL3
Subject: opening file for output, append
To: BBoard.Maintainer@CMU-CS-A

Does anyone know how to open a file for output in Franz lisp and
@i(append) to that file?  The function "outfile" always deletes the old
version first.

Thanks,
Nancy Skooglund


From @MIT-MC:day@cmu-cs-h.arpa  Sun Nov 11 11:57:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA16052; Sun, 11 Nov 84 11:57:03 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA15747; Sun, 11 Nov 84 11:54:17 pst
Message-Id: <8411111954.AA15747@UCB-VAX.ARPA>
Date: 11 Nov 84 00:15:49 EST
From: David.Yaskin@CMU-CS-H
Subject: Franz Question
To: BBoard.Maintainer@CMU-CS-A


How does one change the depth and length of list returned from functions.
While using CMULisp it keeps returning & instead of my list.

		David Yaskin   ( day@h)


From Johnson%udel-dewey.delaware@udel-relay.ARPA  Sun Nov 11 19:11:37 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA19376; Sun, 11 Nov 84 19:11:37 pst
Received: from udel-relay (udel-gw.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA21463; Sun, 11 Nov 84 19:08:46 pst
Message-Id: <8411120308.AA21463@UCB-VAX.ARPA>
Received: From udel-dewey.ARPA by udel-relay.ARPA id a010044
          ;11 Nov 84 22:09 EST
Date:     Sun, 11 Nov 84 22:07:41 EST
From: johnson <johnson%udel-dewey.delaware@udel-relay.ARPA>
To: David.Yaskin@cmu-cs-h.ARPA
Cc: franz-friends@BERKELEY, johnson%udel-eecis1.delaware@udel-relay.ARPA
Subject:  Re:  Franz Question

--------------------  for franz -----------------------------
In franz lisp, 'prinlevel' is a variable controlling the
depth to which the top-level is to print lists, 'prinlength'
controls how many elements of a list are printed by the
top-level. For either variable, a value of 'nil' represents
infinite depth or length.

If franz is printing expressions as '&' then 
prinlevel has a value of 0.

you should
(setq prinlevel nil)
to print lists of arbitrary depth.
(see Appendix B of the Franz manual)

----------------  for CMU --------------------

In CMULisp, tlprint does the top-level printing, and this is
defined, (in, at least the 2 systems that I use) as:

	'(lambda (x) (printlev x 4))

if your functions always return &, then perhaps someone has defined
it as '(lambda (x) (printlev x 0))

if you want to change it you may either:
1.  (sstatus translink nil)
    (defun tlprint (x) (printlev x <some-large-number>))

OR,  the solution  I prefer:

2.  (load 'toplevel)  ; unnecessary in some installations.
    (defun tlprint (x) (top-print x))
  
causing 'prinlevel' and 'prinlength' to have
the effect described above for the franz system.
 
 NB: the tempting solution:
 (defun tlprint (x) (printlev x prinlevel))
 FAILS in the case that prinlevel is nil


-johnson@udel-ee

From Johnson%udel-dewey.delaware@udel-relay.ARPA  Sun Nov 11 19:31:52 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA19491; Sun, 11 Nov 84 19:31:52 pst
Received: from udel-relay (udel-gw.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA21770; Sun, 11 Nov 84 19:29:03 pst
Message-Id: <8411120329.AA21770@UCB-VAX.ARPA>
Received: From udel-dewey.ARPA by udel-relay.ARPA id a010257
          ;11 Nov 84 22:29 EST
Date:     Sun, 11 Nov 84 22:21:49 EST
From: johnson <johnson%udel-dewey.delaware@udel-relay.ARPA>
To: Nancy.Skooglund@cmu-ri-isl3.ARPA
Cc: franz-friends@BERKELEY, johnson%udel-eecis1.delaware@udel-relay.ARPA
Subject:  Re:  opening file for output, append

In later versions of franz, 'outfile' takes a second argument;
to open a file for appending:

    (setq portname (outfile '<filename> 'a))

{try:
    (help outfile)
for a full description.}

If this does not work on your version, I have a hack that associates a port
with ANY open file descriptor, but it uses 4.x system calls, - so don't
request it unless the you can't use the new 'outfile' function.

-johnson@udel-ee


From @MIT-MC:nss@cmu-ri-isl1.arpa  Mon Nov 12 06:45:39 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22731; Mon, 12 Nov 84 06:45:39 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA01316; Mon, 12 Nov 84 06:42:54 pst
Message-Id: <8411121442.AA01316@UCB-VAX.ARPA>
Date: 12 Nov 84 09:34:14 EST
From: Nancy.Skooglund@CMU-RI-ISL1
Subject: append to file answer found
To: BBoard.Maintainer@CMU-CS-A

Thanks to all who responded to my Franz lisp question about opening a
file for output and appending to it.  Here's how it works:

	(outfile '<filename> 'a)

'a may be replaced by any symbol or string whose name begins with a.

Nancy


From JAAKOV@WISDOM.BITNET  Tue Nov 13 04:26:24 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04324; Tue, 13 Nov 84 04:26:24 pst
Received: from ucbjade.CC.Berkeley.ARPA (ucbjade.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA20746; Tue, 13 Nov 84 04:25:59 pst
Received: from wisdom.BITNET
	by ucbjade.CC.Berkeley.ARPA (4.17/4.27.5)
	id AA10274; Tue, 13 Nov 84 04:24:53 pst
Received: by wisdom.BITNET (4.12/4.7)
        id AA01997; Tue, 13 Nov 84 11:29:45 -0200
Date: Tue, 13 Nov 84 11:29:45 -0200
From: jaakov@wisdom.BitNet (Jacob Levy)
Message-Id: <8411130929.AA01997@wisdom.BITNET>
To: franz-list@wisdom.BitNet
Subject: Announcement of new Lisp for UN*X 4.x VAXen

I don't know if this is the appropriate place for this announcement, but
here goes anyway :-


        YLISP, a Coroutine-based Lisp System for VAXen.
        -=============================================-

        A friend of  mine, Yitzhak  Dimitrovski, and  myself, wrote a Lisp
system for UN*X 4.x systems on VAXen. It has the following features :-

        o - Coroutines and  closures. The  system uses  these to implement
            the user-interface, single-stepping and  error-handling.  It's
            easy to write a scheduler and time-share YLISP between  two or
            more user programs.
        o - Multiple-dimension arrays.
        o - Multiple name  spaces (oblists) arranged  in a tree hierarchy.
            This is similar to the Lisp Machine facility.
        o - Defstruct structure definition package.
        o - Flavors object-oriented programming tools.
        o - User-extensible  evaluator (it is  possible to (re)define  the
            actions of 'eval', 'apply' and 'print'  relative to all  user-
            and pre-defined types).
        o - Integer arithmetic. No floating-point, sorry. don't think that
            that's  really  necessary, but *could*  be hacked. No  BIGNUMs
            either.
        o - Good user-interface with history, sophisticated error handling
            and function-call and variable-assignment tracing facilities.
        o - Extensive library of ported and user-contributed programs,such
            as a variant of the Interlisp  structure editor, 'loop' macro,
            'mlisp' Pascal-like embedded language, etc.
        o - Compiler  that  generates efficient native  assembler code for
            the VAXen. The  compiler is provided as a separate program,due
            to size  considerations. The compiler is  written entirely  in
            Lisp, of course.
        o - Extensive online documentation, as well as  a 400-page  manual
            describing the whole system from a programmer's point of view.

        The system is named  'YLISP', and was written for 4.1 when we were
students at the Hebrew University  at Jerusalem. Since  then, Yitzhak  has
left  for the  US and  is  currently a  Ph.D. student in  Prof. Schwartz's
Supercomputer group at Courant. I have continued to  develop the system on
my own, and have ported it to UN*X 4.2.

        I am looking for a site that is willing to handle the distribution
of this software from the US, by letting  one FTP it  from their computer.
Alternatively, I am also willing to supply people  with magtapes of YLISP,
for the cost of the tape and handling charges (about 70$ a piece).  If you
are interested, please respond by electronic mail to one of  the addresses
given below. I will be  ready  to  start distributing  the  system in  two
weeks' time.

        Rusty Red (AKA Jacob Levy)

        BITNET:                         jaakov@wisdom
        CSNET and ARPA:                 jaakov%wisdom.bitnet@wiscvm.ARPA
        UUCP: (if all else fails..)     ..!decvax!humus!wisdom!jaakov




From ssc-vax!steve@uw-beaver.arpa  Tue Nov 13 06:20:04 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04848; Tue, 13 Nov 84 06:20:04 pst
Received: from uw-beaver.arpa (uw-beaver.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA05430; Mon, 12 Nov 84 15:45:22 pst
Received: by uw-beaver.arpa (4.12/2.2)
	id AA28549; Mon, 12 Nov 84 15:43:15 pst
Return-Path: <ssc-vax!steve@uw-beaver.arpa>
Received: by ssc-vax (4.12/4.7)
	id AA03520; Mon, 12 Nov 84 09:58:10 pst
Date: Mon, 12 Nov 84 09:58:10 pst
From: ssc-vax!steve@uw-beaver.arpa (Steve White)
Message-Id: <8411121758.AA03520@ssc-vax>
To: uw-beaver!JonL.pa@XEROX, uw-beaver!smh@mit-eddie
Subject: Re: readtable within fasl
Cc: uw-beaver!franz-friends@BERKELEY

My problem was a bit simplier then the general case you mention. In MRS
a 'variable' is really a reader-macro ($) that at read time assigns a special
value to each variable-base-name. Basically it does a
	(set (implode `(|$| . ,(explodec name))) 'bl).
for side-effects of marking the symbol as a variable.  When compiling files
containing MRS code the compiler would execute the call inside its environment,
placing the *unbound* literals (as .asciz) in the object file to be READ
in at load time... so MRS would get the symbols and treat them as symbols
not variables.

The only reason i mention this is that the workaround used might be useful
for others seeking side effects within macros etc.
My workaround (h.a.c.k) was to use a special variable
	liszt-eof-forms
as a queue of the above SET forms and to provide a different macro expansion
for compile-time.  So

(setsyntax '|$| 'macro
  #'(lambda nil (let ((varname (implode `(|$| ,@(explodec (read))))))
		     (addq `(setq ,varname 'bl) liszt-eof-forms)
		     varname)))		;; return variable name to liszt!

[where ADDQ does the correct thing if the variable has already been seen],
adds the following to the object file
	.asciz "$xyz"
	.asciz "(setq $xyz 'bl)"
which basically works (don't gag!)
					steve white

YAP -- (yet another problem) : does anyone at MIT have a list of fixes
to franz 38.91 to make the zeta-lisp environment work :-) I started fixing
a few things but it looks like something that might MIT may have already
done. ((or any plans to put NIL under UNIX? 8-) ))

From ucscc!pravda@ucscd.ucscc.UUCP  Thu Nov 15 18:09:13 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA12102; Thu, 15 Nov 84 18:09:13 pst
Received: by UCB-VAX.ARPA (4.24/4.39)
	id AA11658; Thu, 15 Nov 84 18:09:11 pst
Received: from ucscd.UCSC (ucscd.ARPA) by ucscc.UCSC (4.12/4.7)
	id AA23553; Thu, 15 Nov 84 10:48:02 pst
Received: by ucscd.UCSC (4.12/4.7)
	id AA04900; Thu, 15 Nov 84 10:45:19 pst
Date: Thu, 15 Nov 84 10:45:19 pst
From: ucscc!pravda@ucscd.ucscc.UUCP (05550000)
Message-Id: <8411151845.AA04900@ucscd.UCSC>
To: ucbvax!franz-friends@c.CC
Subject: mailing list name change

		
	Please stop sending to
		ucscc!figgy
	
	instead add
		ucbvax!ucscc!lispers
	
	Thank you.

From weeks@ucbruby.CC  Thu Nov 15 20:51:49 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA13810; Thu, 15 Nov 84 20:51:49 pst
Received: from ucbjade.CC.Berkeley.ARPA (ucbjade.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA14507; Thu, 15 Nov 84 20:51:52 pst
Received: from ucbruby.CC.Berkeley.ARPA (ucbruby.ARPA)
	by ucbjade.CC.Berkeley.ARPA (4.18/4.27.5)
	id AA01653; Thu, 15 Nov 84 20:51:05 pst
Received: by ucbruby.CC.Berkeley.ARPA (4.18/4.27.6)
	id AA02961; Thu, 15 Nov 84 20:50:39 pst
Date: Thu, 15 Nov 84 20:50:39 pst
From: weeks@ucbruby.CC (Harry Weeks)
Message-Id: <8411160450.AA02961@ucbruby.CC.Berkeley.ARPA>
To: franz-friends@BERKELEY
Subject: Lisp implementation details.

Are there any technical reports or memoranda available which
describe the internal workings of Franz?
						-- Harry

From @MIT-MC:tg@cmu-cs-cad.arpa  Wed Nov 28 11:32:50 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA15208; Wed, 28 Nov 84 11:32:50 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA14658; Wed, 28 Nov 84 11:32:04 pst
Message-Id: <8411281932.AA14658@UCB-VAX.ARPA>
Date: 28 Nov 84 14:24:42 EST
From: Timothy.Glavin@CMU-CS-CAD
Subject: cmulisp docs
To: BBoard.Maintainer@CMU-CS-A

Does anyone know the location of on-line documentation for
cmulisp.  If not, is there a source for hard copy documentation?
I have the Foderaro Franz Lisp Manual, I only looking for info
on the CMU ideosyncracies.
					-- Tim (tg@cad)


From smith@nrl-aic  Fri Nov 30 09:17:53 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA15087; Fri, 30 Nov 84 09:17:53 pst
Received: from nrl-aic (nrl-aic.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA24282; Fri, 30 Nov 84 09:15:33 pst
Date: 30 Nov 1984 11:50-EST
From: Russ Smith <smith@nrl-aic.ARPA>
Subject: bugs using flavors (and more)
To: franz-friends@BERKELEY
Message-Id: <470681409/smith@nrl-aic>

I recently installed opus 38.91 on our VAX780 under 4.2BSD. The
installation went smoothly. The files used for the installation appear
to be the most recent available from ucbkim. This includes the flavors
stuff with appropriate modifications (for example, fixing hash.l to use
"vsize" instead of "getlength" on a vector). The flavors stuff I scarfed
TODAY was dated October 2nd I believe. Anyway, I tried out some things
with flavors and, in particular, with "describe"...with the
following result (done with "script"):
=============================================================================
% lisp
Franz Lisp, Opus 38.91
-> (defflavor ob () () :settable-instance-variables)
[autoload /usr/lib/lisp/flavors]
[fasl /usr/lib/lisp/flavors.o]
[fasl /usr/lib/lisp/machacks.o]
[fasl /usr/lib/lisp/lmhacks.o]
[fasl /usr/lib/lisp/flavorm.o]
[fasl /usr/lib/lisp/vanilla.o]
ob
-> (describe 'ob)
[autoload /usr/lib/lisp/describe]
[fasl /usr/lib/lisp/describe.o]

ob has property flavor: flavor[17]
Error: Undefined function called from compiled code  defstruct-description-name
<1>: (exit)
=============================================================================
[Well, "defstruct-description-name" is used all over the
"/usr/lib/lisp/struct.l" set of functions...apparently mostly with no
arguments...which, I think, is wrong. One fix made by SMH to "describe.l" 
replaced a call on this macro with one with an argument. But that's NOT this
problem anyway.]

(1) Is there a known fix to get the "describe", or anything else that
	 uses the "defstruct-description-name" macro, working correctly?

(2) Could it be that some sort of extended "defflavor" would load in an
	 appropriate file which on-the-fly defines this macro? That is,
	 did I do TOO simple a "defflavor"? [For example, doing:

		(load '/usr/pub/lisp/struct.l)

	 allows one to "(pp defstruct-description-name)" showing that
	 it requires an argument...without the "load" it is undefined.]

(3) Could the copy of the ftpable (???) opus38.91 files we have be out
	 of date (seem to be from around June 84)?

Any help would be much appreciated. We are attempting to develop
some stuff for use on both an LMI Lisp Machine and the VAX. This has
thrown the proverbial wrench into the work(s)...

Russ <Smith@nrl-aic>
Navy Center for Applied Research in Artificial Intelligence (whew!)

From MCLINDEN@RUTGERS.ARPA  Sat Dec  1 15:40:10 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04698; Sat, 1 Dec 84 15:40:10 pst
Received: from RUTGERS.ARPA (rutgers-gw.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA03439; Sat, 1 Dec 84 14:28:56 pst
Message-Id: <8412012228.AA03439@UCB-VAX.ARPA>
Date: 30 Nov 84 22:45:59 EST
From: Sean McLinden  <MCLINDEN@RUTGERS.ARPA>
Subject: Re: bugs using flavors (and more)
To: smith@NRL-AIC.ARPA, franz-friends@BERKELEY
Cc: MCLINDEN@RUTGERS.ARPA
In-Reply-To: Message from "Russ Smith <smith@nrl-aic.ARPA>" of 30 Nov 84 11:50:00 EST


  There is a bug in the way that describe is compiled according to the
  makefile. Basically the problem is that defstruct-description-name
  is a macro which is NOT compiled so that when you fasl the compiled
  version of struct (as you are compiling describe), you don't get
  the proper definition for defstruct-description-name.

  You can either 1). load struct.l when compiling describe.l or
		 2). (declare (macros t)) in struct.l and recompile.

  Sean McLinden
  Decision Systems Laboratory
-------

From sridhar%wsu.csnet@csnet-relay.arpa  Sat Dec  1 17:03:50 1984
Received: from ucbernie.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA06036; Sat, 1 Dec 84 16:55:15 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by ucbernie.ARPA (4.24/4.38)
	id AA08322; Sat, 1 Dec 84 16:50:50 pst
Message-Id: <8412020050.AA08322@ucbernie.ARPA>
Received: from wsu by csnet-relay.csnet id a012949; 1 Dec 84 19:41 EST
Date:     Sat, 1 Dec 84 12:47 PST
From: "S. Sridhar" <sridhar%wsu.csnet@csnet-relay.arpa>
To: franz-friends@UCBERNIE.ARPA
Cc: sridhar%wsu.csnet@csnet-relay.arpa
Subject:  Documentation pblms.

Hi,
  I am an ardent Franz hack here at Wash. St. Univ, Pullman.
  I need some specific info on Franz Lisp.

 There is no documentation on 'Structures' in the Franz Lisp manual, that
we have here. (This is dated June 1983. The version we have is Opus 38.69,
June 1983). Specifically I need documentaion on all the macros related to
the use of structures like defstruct. I know for sure that these macros
are available on our system, but I am having problems on their usage. The
on-line documentation does not give any help either. Maybe you have an 
updated version of the Franz Lisp manual. Can you help around, please ?

As another instance, functions relating to hashtables are available here
but there is no documentation for it. 

Thanks.

Sridhar
------

From smith@nrl-aic  Mon Dec  3 12:17:10 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04104; Mon, 3 Dec 84 12:17:10 pst
Received: from nrl-aic (nrl-aic.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA16806; Mon, 3 Dec 84 12:14:27 pst
Date: 3 Dec 1984 06:36-EST
From: Russ Smith <smith@nrl-aic.ARPA>
Subject: followup to "flavors bugs (and more)"
To: franz-friends@BERKELEY
Message-Id: <470921820/smith@nrl-aic>

This is a followup to a previous note I sent requesting help with fixing
Opus 38.91 of Franz and Flavors running on a Vax780 under 4.2BSD.

First, I want to thank the many people who had helpful suggestions on
what may have been going wrong. Given the small amount of information I
provided on the problem, some of them were remarkably relevant.

The problem had to do with certain functions such as "describe" going
south when invoked on a FLAVOR object. The solution was (at least) two
fold. One, which I alluded to in the previous note, had to do with the
distributed file "hash.l" containing invalid calls on the intrinsic
"getlength" function with a vector argument. These calls had to be
changed to "vsize" instead (actually "getlength" could probably have
been redefined to allow vectors...). Whatever, that solved that part.

The second solution had to do with how WE at NCARAI were installing
Franz. We have a set of directories for "local" software into which
we wanted to put the "new" Franz. As such, I went through all the
"Makefile"s and changed default directories for such things as the
libraries and objects, etc. While doing this, it was noted that certain
files in the "lisplib" directory had hard-coded the default names for, for
example, the library. Since our library was not in the same place as
this default, these lines were "commented out" (with an "exit")...with
the result that the Franz and Liszt installations did not go as smoothly
as I thought. It turns out that these lines also should be changed to
reflect the appropriate directory. They are in the files "buildlisp.l",
"common1.l", and "fix.l" in the lisplib directory (possibly others exist as
well). The pertinent lines read something like:

	(or (boundp 'default-library-directory)
	    (setq default-library-directory '/usr/lib/lisp))

During the installation (done on a CRT) I was doing something else. Thus
when the mods made (namely changing the "setq" call above into an "exit")
were invoked, I didn't notice later that a number of things which SHOULD have
happened didn't (they'd gone off the screen...). Needless to say, this
caused all sorts of bizarre inconsistencies (especially since our last
installation DID use the default directories...).

Anyway, notes for the future:

	(1) If ftp'ing Franz from ucbkim be sure to get the stuff in the
	    "flavors" directory as well. This contains a new "hash.l"
	    modified by SMH to use "vsize" rather than "getlength".

	(2) If not using the default directories for the installation,
	    change the names in the above files as well to reflect the
	    appropriate place(s)...sigh.

Yours (with an apparently working Franz+flavors),

Russ <Smith@nrl-aic>
Navy Center for Applied Research in Artificial Intelligence (whew!)

From @MIT-MC:smh@MIT-EDDIE  Tue Dec  4 12:49:49 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20917; Tue, 4 Dec 84 12:49:49 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA24636; Tue, 4 Dec 84 12:13:23 pst
Message-Id: <8412042013.AA24636@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA19371; Tue, 4 Dec 84 14:50:26 est
Date: Tue, 4 Dec 84 14:50:26 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: the *real* flavor sources (etc.)

For some time I have been using and maintaining enhanced versions of the
several Franz lisplib modules which implement various Lisp Machine
compatibilities, most notably, the FLAVOR system and FORMAT output.
jkf@berkeley has authorized me to announce public availability of these
files via anonymous ftp from UCBKIM.  These seven files are compatible
with Opus 38.91, but supersede the versions in the 39.91 distribution.
There are a number of bugfixes and new features.

UCBKIM supports FTP with login "anonymous" and any password.  The
files are:
	 ~anonymous/pub/flavors/Makefile
				flavors.l
				flavorm.l
				vanilla.l
				hash.l
				describe.l
				format.l

The changes are too many to describe in detail.  Many of the FLAVOR
system changes are for compatibility with changes to Franz, although a
few non-working or missing features (but not all) have been bludgeoned
into functionality.  In particular, wrappers work.  The FORMAT module
fixes a number of format directives which apparently never worked.
However, some of the hairier ones are known still to be defective.

This "completely unsupported" software is graciously being made
available to all takers without any promises whatever:  there is no
promise of correctness, and no promise of support.  Also, the sources
total 160K and unsuitable for uucp distribution, and I don't have time
to deal with tape requests [sorry].

The above notwithstanding, I am as eager as anyone for additional
improvements to the code.  Anyone with additional bugfixes is encouraged
to communicate to me, and I will try to integrate the code.  I will try
to respond to bug reports, but it may be a rather low priority business.

Steve Haflich
MIT Experimental Music Studio
ARPA: smh@mit-eddie@mit-mc
UUCP: {ihnp4, decvax!genrad}!mit-eddie!smh


From @MIT-MC:smh@MIT-EDDIE  Tue Dec  4 19:32:49 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA26327; Tue, 4 Dec 84 19:32:49 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA26237; Tue, 4 Dec 84 13:26:17 pst
Message-Id: <8412042126.AA26237@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA20260; Tue, 4 Dec 84 15:44:20 est
Date: Tue, 4 Dec 84 15:44:20 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: fix for describe.l
Cc: MCLINDEN@RUTGERS@MIT-MC, smith@nrl-aic@mit-mc

Previous postings have correctly identified the problem (which was fixed
long ago in the versions announced today).  The best fix is to change
the (environment-lmlisp) invocation near the beginning of describe.l to
read as follows, then recompile it:

	(environment-lmlisp (compile eval) (files struct flavorm))

The struct and flavorm modules do not need to be around when the
compiled describe code is executed, so omitting load from the eval-when
saves some unnecessary fasl's.  Describe, by the way, is useful even
when flavors and defstructs are not being used.  For instance, it will
report the source module in which a compiled function lives.

Steve Haflich
smh@mit-eddie@mit-mc
{ihnp4, decvax!genrad}!mit-eddie!smh


From @MIT-MC:smh@MIT-EDDIE  Tue Dec  4 22:49:05 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA29026; Tue, 4 Dec 84 22:49:05 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA05974; Tue, 4 Dec 84 20:50:44 pst
Message-Id: <8412050450.AA05974@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA24308; Tue, 4 Dec 84 23:50:01 est
Date: Tue, 4 Dec 84 23:50:01 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: Franz documentation for MIT LM code
Cc: sridhar%wsu.csnet@csnet-relay

Sorry to report that there really is no official documentation for the
several Franz lisplib modules which implement a measure of compatibility
with Zetalisp, the dialect running on MIT Lisp Machines (and, more or
less, on Symbolics and LMI machines).  The Franz source code was adapted
from the MIT Lisp machine code several years ago; there is still
approximate compatibility, although new features and certain semantic
subtleties have diverged.  Driven partially by natural evolution and
partially by the standardization efforts of Common Lisp, Lisp Machine
compatibility is something of a moving target.

But do not despair; there are two standardly available sources for
documentation.  Reading them will give a very usable idea about the
packages.  Unfortunately, a few unimplemented features and semantic
differences will have to be discovered by experimentation or examination
of the source code.  (What do you want for free? :-)

(1) If you have available a MIT Lisp Machine Manual, the sections on
defstruct, flavors, format, hash, and loop output are still reasonable
approximations of documentation for the Franz versions.  Incidentally,
the `Blue' MIT Lisp Machine Manual circa 1981 corresponds most closely
with the Franz inplementation, although a few more recent features have
been retrofitted.  If available, Symbolics documentation is probably
only very slightly less good -- the older, the better.

(2) For defstruct, hash, and format the Guy Steele <Common Lisp: The
Language>, published by Digital Press (a branch of DEC), is usefully
close to the existing Franz code.  Again, experimentation and
examination of the source code will resolve the details.  Unfortunately,
Flavors and the loop macro are not (yet) part of the Common Lisp
specification, and may well be very different when they are.

Unofficially, there is another even better hope.  The MIT Athena project
will be `releasing' these packages into their standard Franz system this
in another month or two.  They are commencing a quick effort to edit
Lisp Machine documentation into proper format for inclusion as
appendixes in the Franz manual.  If at all possible, I will attempt to
get the results publically distributed.  (Translation:  My assistance is
essential to this documentation, so I am in position to insist they be
`reasonable' about it...)  But no promises just yet.

Steve Haflich
MIT


From MAILER@CUNYVM.BITNET  Thu Dec  6 13:53:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03880; Thu, 6 Dec 84 13:53:03 pst
Received: from ucbjade.CC.Berkeley.ARPA (ucbjade.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA27039; Thu, 6 Dec 84 11:43:13 pst
Received: from CUNYVM.BITNET
	by ucbjade.CC.Berkeley.ARPA (4.19/4.30)
	id AA27252; Thu, 6 Dec 84 11:44:10 pst
Message-Id: <8412061944.AA27252@ucbjade.CC.Berkeley.ARPA>
Received: by CUNYVM     id 8508; Thu, 06 Dec 84 14:41:26 EST
Date:         Thu, 6 Dec 84 14:39 EST
From: Henry Nussbacher <HJNCU@CUNYVM.BitNet>
To: <sf-lovers-request@rutgers.arpa>, <franz-friends@BERKELEY>,
        <ailist-request@sri-ai>, <works@rutgers.arpa>,
        <info-graphics@utexas-20.arpa>, <prolog-request@su-score.arpa>

Can you please register the following user to your lists:
arpalist%cunyvm.BITNET

Thank you,
Henry Nussbacher
BITNET Network Information Center

From mike@rice.ARPA  Thu Dec  6 18:20:03 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA07782; Thu, 6 Dec 84 18:20:03 pst
Received: from rice.ARPA (rice.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA05141; Thu, 6 Dec 84 17:55:14 pst
Received: from thule by rice.ARPA (AA02673); Thu, 6 Dec 84 19:41:33 CST
Received: by thule (AA02845); Thu, 6 Dec 84 19:38:53 cst
Date: Thu, 6 Dec 84 19:38:53 cst
From: Mike Caplinger <mike@rice.ARPA>
Message-Id: <8412070138.AA02845@thule>
To: franz-friends@BERKELEY
Subject: bug in 68k Opus 38.91 arrays

In 68k Opus 38.91, the expression
(array foo flonum-block 4 4)
generates an "Error: IMPROPER USE OF SET".

On the VAX, in Opus 38.79, this worked fine.  What's happening?

(I am on a Sun, compiled with sun_4_2.)

	- Mike

From @MIT-MULTICS.ARPA:POSTMASTER@VANDERBILT.MAILNET  Sat Dec  8 05:42:09 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA25844; Sat, 8 Dec 84 05:42:09 pst
Received: from MIT-MULTICS.ARPA (mit-multics.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA22892; Sat, 8 Dec 84 05:39:47 pst
Received: from VANDERBILT.MAILNET by MIT-MULTICS.ARPA with Mailnet id <2648813816713007@MIT-MULTICS.ARPA>; 08 Dec 1984 08:36:56 est
Date:        06 Dec 84 15:26 CDT
From: David_Linn%VANDERBILT.MAILNET@MIT-MULTICS.ARPA
Reply-To:    David_Linn%VANDERBILT.MAILNET@MIT-MULTICS.ARPA
To: "franz-friends"@BERKELEY
Subject:     FranzLISP on the S9000
Message-Id:  <30788@VUCCG1COM>
In-Reply-To: <30731@VUCCG1COM>

The AI Group at Vanderbilt would like to join the franz-friends
mailing list. We have version 38.87 running on the IBM Inruments
S9000 under CSOS 1.1, a very non-UNIX opsys. Both interpreter
and compiler are working and a farily large general-purpose
expert system tool set written on a VAX is up and running.



From MOHAN@USC-ECLC.ARPA  Mon Dec 10 12:06:53 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA18655; Mon, 10 Dec 84 12:06:53 pst
Received: from USC-ECLC.ARPA (usc-eclc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA04397; Mon, 10 Dec 84 12:04:27 pst
Message-Id: <8412102004.AA04397@UCB-VAX.ARPA>
Date: Mon 10 Dec 84 12:03:06-PST
From: MOHAN@USC-ECLC.ARPA
Subject: array  - space
To: franz-friends@BERKELEY
Cc: mohan@USC-ECLC.ARPA


I am working with images stored as fixnum arrays (with delta =1 i.e. four
pixels packed into a word)  aux as unmarked arrays. (I am on a VAX under
Eunice). How do I deallocate the array-space once I am done with it?
(I use small-segment to allocate space for the array).

Also I would appreciate any pointers of how to speed up programs with 
nested do loops (order of 512x512 x(5 x 5) itterations).

Thanks,

-Rakesh Mohan.
-------

From mike@rice.ARPA  Mon Dec 10 15:37:50 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20942; Mon, 10 Dec 84 15:37:50 pst
Received: from rice.ARPA (rice.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA08450; Mon, 10 Dec 84 15:35:12 pst
Received: from iapetus by rice.ARPA (AA26746); Mon, 10 Dec 84 17:28:43 CST
Received: by iapetus (AA16942); Mon, 10 Dec 84 17:29:45 CST
Date: Mon, 10 Dec 84 17:29:45 CST
From: Mike Caplinger <mike@rice.ARPA>
Message-Id: <8412102329.AA16942@iapetus>
To: franz-friends@BERKELEY
Subject: gensym and the compiler

How does one get code like the following:

; construct an identity transformation matrix.
(defun tm-new ()
    (let ((name (gensym)))
	(*array name 'flonum-block 4 4)
	(do i 0 (1+ i) (= i 4) (store (name i i) 1.0))
	name)
)

to work under the compiler?  Compiled, this refuses to believe
in the existence of name.

Do I need to declare it as a lambda?  Is there a way to declare arrays?

	- Mike

From jkf@ucbmike  Mon Dec 10 16:03:40 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA21396; Mon, 10 Dec 84 16:03:40 pst
Received: from ucbmike.arpa by UCB-VAX.ARPA (4.24/4.39)
	id AA08955; Mon, 10 Dec 84 16:01:22 pst
Received: by ucbmike.arpa (4.24ucb/4.33)
	id AA06150; Mon, 10 Dec 84 16:04:09 pst
Date: Mon, 10 Dec 84 16:04:09 pst
From: John Foderaro (on a sun) <jkf@ucbmike>
Message-Id: <8412110004.AA06150@ucbmike.arpa>
To: MOHAN@USC-ECLC.ARPA, franz-friends@BERKELEY
Subject: Re: array  - space
Cc: mohan@USC-ECLC.ARPA
In-Reply-To: Your message of Mon 10 Dec 84 12:03:06-PST

 You would be better off using immediate vectors (vectori) which
are garbage collected.    Items allocated with small-segment aren't
gc'ed.




From jkf@ucbmike  Mon Dec 10 17:08:13 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22000; Mon, 10 Dec 84 17:08:13 pst
Received: from ucbmike.arpa by UCB-VAX.ARPA (4.24/4.39)
	id AA10131; Mon, 10 Dec 84 17:05:36 pst
Received: by ucbmike.arpa (4.24ucb/4.33)
	id AA06315; Mon, 10 Dec 84 17:08:19 pst
Date: Mon, 10 Dec 84 17:08:19 pst
From: John Foderaro (on a sun) <jkf@ucbmike>
Message-Id: <8412110108.AA06315@ucbmike.arpa>
To: MOHAN@USC-ECLC.ARPA, franz-friends@BERKELEY
Subject: Re: array  - space
Cc: mohan@USC-ECLC.ARPA
In-Reply-To: Your message of Mon 10 Dec 84 12:03:06-PST

 One small correction: small-segment space is garbage collected and
reclaimed, but only as individual elements: adjacent free elements are
not combined.   Vectors are different: adjacent free vectors are combined
into larger vectors.



From @MIT-MC:smh@MIT-EDDIE  Mon Dec 10 19:02:52 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA23540; Mon, 10 Dec 84 19:02:52 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.39)
	id AA11754; Mon, 10 Dec 84 18:21:17 pst
Message-Id: <8412110221.AA11754@UCB-VAX.ARPA>
Received: by mit-eddie.Mit-chaos.Arpa id AA03264; Mon, 10 Dec 84 21:20:04 est
Date: Mon, 10 Dec 84 21:20:04 est
From: Steven M. Haflich <smh@mit-eddie>
To: franz-friends@BERKELEY
Subject: re: gensym and the compiler

<Mike@rice> wants to know how to make this function work:

	; construct an identity transformation matrix.
	(defun tm-new ()
	    (let ((name (gensym)))
		(*array name 'flonum-block 4 4)
		(do i 0 (1+ i) (= i 4) (store (name i i) 1.0))
		name)
	)

The problem is that send is a macro (see lisplib/array.l), and at
compile time it is impossible for it to determine exactly the "data
type" of name.  Therefore, it expands the function to:

	(defun tm-new ()
	    (let ((name (gensym)))
		(*array name 'flonum-block 4 4)
		(do i 0 (1+ i) (= i 4) (name 1.0 i i))
		name)
	)

Essentially, it just assumes 'name is a symbol which has an array in its
function binding, or else which symevals (possibly recursively) to
something that is either an array, or a symbol with an array in its
function binding.  When the compiler compiles the expansion, it assumes
that it wants to call the function-binding of name, not the
function-binding of symeval of name.  In the interpreter it happens to
work because eval of a list in the interpreter (but not the compiler) is
defined to repetitively evaluate the car of the list until it finds a
recognizable function or array.  (See chapter 4.)  But note!!  If 'name
also has a function binding, the interpreter will find it instead of the
array!

What you really want to do, then, is this:

	(defun tm-new ()
	    (let ((name (gensym)))
		(*array name 'flonum-block 4 4)
		(do i 0 (1+ i) (= i 4) (funcall name 1.0 i i))
		name)
	)

This guarantees that name gets symevaled once before the interpreter
checks for function bindings, which also does the right thing in
compiled code.  Unfortunately, you will have to write this out by hand.
I don't see any way that the send macro can be fixed.  If it always
returned the extra funcall, then this simple case wouldn't work
compiled:

	(array foo ...)
	(store foo ...)

Did anyone follow any of this?


From BACH@SUMEX-AIM.ARPA  Tue Dec 11 20:05:09 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA06334; Tue, 11 Dec 84 20:05:09 pst
Received: from SUMEX-AIM.ARPA (sumex-aim.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA15218; Tue, 11 Dec 84 20:03:46 pst
Message-Id: <8412120403.AA15218@UCB-VAX.ARPA>
Date: Tue 11 Dec 84 20:04:16-PST
From: Rene Bach <BACH@SUMEX-AIM.ARPA>
Subject: Porting FRANZ to other OS running C ?
To: franz-friends@BERKELEY

I am interested in finding out if someone has ported FRANZ to some
other OS than UNIX. A friend of mine is interested in running a LISP
under VMS at no cost. He has C on his machine.
Is this feasible, how much work is involved ?

What about porting FRANZ to some UNIX look alike ?  How much work is
involved ?

Thanks for any leads
Rene
-------

From MCLINDEN@RUTGERS.ARPA  Tue Dec 11 20:44:19 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA06672; Tue, 11 Dec 84 20:44:19 pst
Received: from RUTGERS.ARPA (rutgers-gw.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA16044; Tue, 11 Dec 84 20:42:36 pst
Message-Id: <8412120442.AA16044@UCB-VAX.ARPA>
Date: 11 Dec 84 23:41:49 EST
From: Sean McLinden  <MCLINDEN@RUTGERS.ARPA>
Subject: Re: Franz documentation for MIT LM code
To: smh%MIT-EDDIE@MIT-MC.ARPA, franz-friends@BERKELEY
Cc: sridhar%wsu.csnet@CSNET-RELAY.ARPA, MCLINDEN@RUTGERS.ARPA
In-Reply-To: Message from "Steven M. Haflich <smh@mit-eddie>" of 4 Dec 84 23:50:01 EST



 Regarding the documentation for Franz Lisp and the MIT/Lisp Machine
 compatibility packages:

 Another option exists for those who might be interested. We at Decision
 Systems Lab have been using a modified version of Opus 38.89 which in-
 cludes the  defstruct and flavors code already described. It also in-
 cludes an Interlisp compatibility package which allows Interlisp
 records as well as most of the CLISP forms (these are actually very
 easily simulated with LOOP but we chose a strategy which is more
 in keeping with the Interlisp implementation of CLISP involving
 hashed definitions for CLISP forms.

 The modified Lisp has all of the up-to-date flavors code and an
 edited version of the manual which describes the format, defstruct,
 and CLISP packages (borrowing heavily from the Laser edition of
 the Common Lisp manual by Guy Steele). It also includes a re-organization
 of much of the older manual into a more coherent form, and a number
 of examples of more difficult concepts.

 If there is any interest I can make this publicly available. It would
 be of little value to simply have the additional chapter since it
 refers, heavily, to material in other sections. Also, flavors is not,
 yet included, since the status of flavors in Franz was uncertain up
 to a few months ago.

 For those interested, I will not be prepared to answer requests before
 Christmas but after that I'll be around and can handle almost anything.

 Sean McLinden
 Decision Systems Laboratory
 University of Pittsburgh

-------

From @MIT-MC:ZZZ.RLK@MIT-OZ  Wed Dec 12 21:51:39 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08208; Wed, 12 Dec 84 21:51:39 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA07258; Wed, 12 Dec 84 21:03:56 pst
Message-Id: <8412130503.AA07258@UCB-VAX.ARPA>
Date: Wednesday, 12 December 1984, 19:53-EST
From: Robert L. Krawitz <ZZZ.RLK@MIT-OZ>
Reply-To: rlk%mit-eecs at mit-mc.arpa
To: franz-friends@BERKELEY

Hi.

I'm writing a term paper on the procedure call in various languages,
perhaps on various languages on the VAX, perhaps just on the procedure
call in various dialects of Lisp on the Vax.

Could someone mail me some info on this subject (i. e. the calling
conventions, how/if the Vax procedure call instructions are used, etc.)
quickly, as this is the last week of classes and I don't want to take
too long on this paper.  Thanks.

Robert^Z

From psm@mitre-bedford  Mon Dec 17 09:05:35 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20993; Mon, 17 Dec 84 09:05:35 pst
Received: from mitre-bedford (mitre-bedford.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA19421; Mon, 17 Dec 84 09:04:32 pst
Message-Id: <8412171704.AA19421@UCB-VAX.ARPA>
Date: 17 Dec 1984 11:56:37-EST
From: psm@Mitre-Bedford
To: franz-friends@BERKELEY
Subject: Please add me to your  mailing list.
Cc: psm@Mitre-Bedford

Hi,

Would you please add me to your mailing list/ user's group.
(I hope this is the right place to make the request & it's not
franz-friends-request or something like that.  Sorry for the
inconvenience if it is.)

Peter Mager
(psm@mitre-bedford)

From jkf@ucbmike  Mon Dec 17 13:01:48 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00901; Mon, 17 Dec 84 13:01:48 pst
Received: from ucbmike.arpa by UCB-VAX.ARPA (4.24/4.40)
	id AA24456; Mon, 17 Dec 84 13:00:55 pst
Received: by ucbmike.arpa (4.24ucb/4.33)
	id AA15009; Mon, 17 Dec 84 13:03:16 pst
Date: Mon, 17 Dec 84 13:03:16 pst
From: John Foderaro (on a sun) <jkf@ucbmike>
Message-Id: <8412172103.AA15009@ucbmike.arpa>
To: psm@Mitre-Bedford, franz-friends@BERKELEY
Subject: Re: Please add me to your  mailing list.
Cc: psm@Mitre-Bedford
In-Reply-To: Your message of 17 Dec 1984 11:56:37-EST

 I've added you to franz-friends.
 


From jkf@ucbmike  Mon Dec 17 13:06:53 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA01005; Mon, 17 Dec 84 13:06:53 pst
Received: from ucbmike.arpa by UCB-VAX.ARPA (4.24/4.40)
	id AA24568; Mon, 17 Dec 84 13:05:59 pst
Received: by ucbmike.arpa (4.24ucb/4.33)
	id AA15044; Mon, 17 Dec 84 13:08:10 pst
Date: Mon, 17 Dec 84 13:08:10 pst
From: John Foderaro (on a sun) <jkf@ucbmike>
Message-Id: <8412172108.AA15044@ucbmike.arpa>
To: franz-friends@BERKELEY
Subject: I'll be away
Cc: 


  For the new few weeks I'll be unable to handle franz-friends requests.

  Happy Holidays to all of you.

  					john foderaro
					
  


From @MIT-MC:wah@cmu-cs-ius.arpa  Mon Dec 17 13:08:08 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA01035; Mon, 17 Dec 84 13:08:08 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA24610; Mon, 17 Dec 84 13:07:10 pst
Message-Id: <8412172107.AA24610@UCB-VAX.ARPA>
Date: 17 Dec 84 16:02:13 EST
From: Wilson.Harvey@CMU-CS-IUS
Subject: appending to files in lisp?
To: BBoard.Maintainer@CMU-CS-A


Does anyone have a function that will allow them to append to a file?  I
need to open a file and write some data to it then, at a later time, reopen
the same file and add some more data to it.  The only things that I could
find in Franz were "infile" and "outfile", and "outfile" truncates the file
when called.  It would be nice if the function would create the file if it
didn't already exist, but that is not necessary.

Thanks. --Wilson

P.S. I tried writing a C-function to handle this, but I didn't have any luck
passing the FILE pointer back into Franz.  It didn't recognize the pointer
as a port, and I don't know how to set it straight.


From cadwall@Ardc.ARPA  Mon Dec 17 13:31:59 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA01357; Mon, 17 Dec 84 13:31:59 pst
Received: from ARDC (ardc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA25405; Mon, 17 Dec 84 13:30:56 pst
Message-Id: <8412172130.AA25405@UCB-VAX.ARPA>
Date:     Mon, 17 Dec 84 16:23:16 EST
From: William K. Cadwallender (LCWSL) <cadwall@Ardc.ARPA>
To: franz-friends@BERKELEY
Subject:  Please change my ID

The computer people here at ARDC have changed my ID: I was wkc@ARDC, I am
now cadwall@ARDC. Please update the franz-friends mailer accordingly.
				Thanks,
				Bill Cadwallender
				(now cadwall@ARDC)

From liz@tove  Tue Dec 18 12:19:24 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00302; Tue, 18 Dec 84 12:19:24 pst
Received: from tove.ARPA (tove.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA04349; Tue, 18 Dec 84 11:54:53 pst
Received: by tove.ARPA (4.12/4.7)
	id AA26165; Tue, 18 Dec 84 14:54:41 est
From: Liz Allen <liz@tove>
Message-Id: <8412181954.AA26165@tove.ARPA>
Date: 18 Dec 1984 1454-EST (Tuesday)
To: Wilson.Harvey@CMU-CS-IUS
Cc: franz-friends@BERKELEY
Subject: Re: appending to files in lisp?
In-Reply-To: Your message of 17 Dec 84 16:02:13 EST.
             <8412172107.AA24610@UCB-VAX.ARPA>

To append to a file, use the outfile function's second argument:

	(setq oport (outfile '<filename> 'append))

This is discussed in the documentation for outfile in the Franz Lisp
Manual.

				-Liz

From @MIT-MC:wah@cmu-cs-ius.arpa  Tue Dec 18 16:46:44 1984
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA02563; Tue, 18 Dec 84 16:46:44 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA10079; Tue, 18 Dec 84 16:15:50 pst
Message-Id: <8412190015.AA10079@UCB-VAX.ARPA>
Date: 17 Dec 84 23:04:24 EST
From: Wilson.Harvey@CMU-CS-IUS
Subject: appendfile question answered
To: BBoard.Maintainer@CMU-CS-A


Wow, was that an easy question.  All the responces were equally simple (use
"fileopen" with mode = a, or use "outfile" with the extra argument
"append").

I must have an outdated copy of the manual because I could find none of
these "features" documented.  A hearty "Thank you" to all who responded.

Wilson


From johnson@UDEL-EECIS2.DELAWARE  Wed Jan  2 03:00:04 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08140; Wed, 2 Jan 85 03:00:04 pst
Received: from udel-dewey (udel-dewey.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.40)
	id AA01144; Wed, 2 Jan 85 02:51:04 pst
Message-Id: <8501021051.AA01144@UCB-VAX.ARPA>
Received: From localhost.DELAWARE by udel-dewey.DELAWARE id a029713
          ;2 Jan 85 5:57 EST
To: franz-friends@BERKELEY
Cc: johnson@udel-dewey
Subject: franz on 68k-based systems? (esp NCR tower)
Date: 02 Jan 85 05:57:37 EST (Wed)
From: johnson <johnson@udel-dewey>


Has anyone out there had experience using franz (or similar lisps)
on an NCR tower or tower XP? (or any other 68k-based unix system ?)

I am interested in answers to these questions:

 1. What version of (franz) lisp are you using.

 2. Are there any special problems you've discovered in this system?

 3. How does this system perform? (compared to franz on a VAX 11/70,
	assuming you have had experience with both)

 4. Where did you obtain your version of (franz) lisp and how?
    (what media, what cost, under what terms or license?)

 thanks in advance,
 johnson@udel-ee

From sridhar%wsu.csnet@csnet-relay.arpa  Thu Jan 24 00:31:15 1985
Received: from ucbernie.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA12825; Thu, 24 Jan 85 00:31:15 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by ucbernie.ARPA (4.24/4.40)
	id AA15268; Thu, 24 Jan 85 00:31:03 pst
Message-Id: <8501240831.AA15268@ucbernie.ARPA>
Received: from wsu by csnet-relay.csnet id a006053; 24 Jan 85 3:16 EST
Date:     Wed, 23 Jan 85 21:50 PST
From: "S. Sridhar" <sridhar%wsu.csnet@csnet-relay.arpa>
To: cross%lsu.csnet@csnet-relay.arpa
Cc: franz-friends@UCBERNIE.ARPA
Subject:  pretty printing

Is there any way I can pretty-print Franz lisp function (or files) with all
the comments in tact. Right now when I use the built in pp, it pretty prints
and strips off all comments. I mean is there any built-in function that does
this. Thanks.

Sridhar (sridhar@wsu)

From fsbrn@BRL-VOC.ARPA  Thu Jan 24 05:33:59 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA14557; Thu, 24 Jan 85 05:33:59 pst
Received: from BRL-VOC (brl-voc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA00666; Thu, 24 Jan 85 05:16:27 pst
Message-Id: <8501241316.AA00666@UCB-VAX.ARPA>
Date:     Thu, 24 Jan 85 7:59:46 EST
From: "Ferd Brundick (VLD/LTTB)" <fsbrn@BRL-VOC.ARPA>
To: "S. Sridhar" <sridhar%wsu.csnet@CSNET-RELAY.ARPA>
Cc: Franz-Friends@BERKELEY
Subject:  Re:  pretty printing

Haah,

Franz's (read) function trashes all comments on input. [Which means
you can document your data files.]  You have to pretty-print the
original code before Franz gets it.  I don't know of any stand-alone
programs to do this (surely someone has written one).  I use
Berkeley's "vi" editor because it has a lisp mode; all input is
automatically pretty-printed if you say
  :set ai lisp
(ai stands for autoindent)
Another way is to execute the vi "=" command while in lisp mode.  All
of this is documented in the vi manual.  Hope this helps.

                                        dsw, fferd
                                        Fred S. Brundick
                                        USABRL, APG, MD.
                                        <fsbrn@brl-voc>

From @MIT-MC:smh@MIT-EMS  Thu Jan 24 06:01:33 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA14651; Thu, 24 Jan 85 06:01:33 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA00458; Thu, 24 Jan 85 06:00:41 pst
Message-Id: <8501241400.AA00458@UCB-VAX.ARPA>
Received: by mit-ems.Mit-chaos.Arpa id AA25956; Thu, 24 Jan 85 08:59:42 est
Date: Thu, 24 Jan 85 08:59:42 est
From: Steven Haflich <smh@mit-ems>
To: franz-friends@BERKELEY, sridhar%wsu.csnet@csnet-relay
Subject: Re: pretty printing

Since comments are not part of a Lisp form returned by `read', clearly
no pretty-print function can do what you want.  Certainly a far more
complicated pretty-printer could be written which would be passed an
ascii file to read and which would somehow preserve comments inside the
form in order to regurgitate them during formatting.  The problem has
several complications, however, such as how to handle ascii Lisp text
with conditionalized inclusions (`#+' constructions)...

Instead, what you want is probably provided the Lisp-mode `grind'
facilities available in several popular text editors -- in particular,
EMACS.  (I know CCA EMACS works, and believe Gosling EMACS does also.)
In these editors a couple keystrokes will specify a region of text and
apply one of several Lisp-indentation algorithms to it.  They almost
always indent in reasonable ways, and attempt to do reasonable things
with comments, at least.  The ones with which I am familiar will *not*,
however, adjust line length length by moving either comment or Lisp
text from line to line.  This is not a great problem for normal
human-typed text, such as programs, since one tends not to type
absurdly long lines.


From peck@sri-spam  Wed Feb  6 12:01:17 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA28782; Wed, 6 Feb 85 12:01:17 pst
Received: from sri-spam.ARPA (sri-spam.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA04441; Wed, 6 Feb 85 12:00:09 pst
Received: from localhost.ARPA by sri-spam.ARPA (4.22/4.16)
	id AA08198; Wed, 6 Feb 85 12:00:05 pst
Message-Id: <8502062000.AA08198@sri-spam.ARPA>
Date: 06 Feb 85 11:59:58 PST (Wed)
To: ailist-request@sri-ai, franz-friends@BERKELEY
Subject: AI, Lisp, Graphics on SUN computers?
From: peck@sri-spam

I would like to here from anyone using SUN computers 
who can supply answers or comments on any of these issues:
 Is Franz the only (best) lisp available?
 Has anyone used the Maryland Flavors to create useful tools/extensions?
 Any support for sun graphics (windows, menus,etc) a la Interlisp-D?
 Any differential reports of Prolog (Quintus) vs Lisp ?
 Any obvious alternative to SUN? (vendor in same class (Tektronix?))
 Worst or hidden problems, pitfalls, gotcha's, etc.
> Can real AI development (even applications) be supported on SUN's? <

From kessler%utah-orion@utah-cs  Wed Feb  6 15:58:12 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03031; Wed, 6 Feb 85 15:58:12 pst
Received: from utah-cs.ARPA (utah-gateway.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA06871; Wed, 6 Feb 85 13:46:19 pst
Received: from utah-orion.ARPA by utah-cs.ARPA (4.42/4.40.1)
	id AA03096; Wed, 6 Feb 85 14:37:05 MST
Received: by utah-orion.ARPA (4.42/4.40.1)
	id AA10406; Wed, 6 Feb 85 14:36:22 MST
Date: Wed, 6 Feb 85 14:36:22 MST
From: kessler%utah-orion@utah-cs (Robert Kessler)
Message-Id: <8502062136.AA10406@utah-orion.ARPA>
To: peck@sri-spam.ARPA
Cc: ailist-request@sri-ai.ARPA, franz-friends@BERKELEY
Subject: Re: AI, Lisp, Graphics on SUN computers? (Long Message)
In-Reply-To: Your message of 06 Feb 85 11:59:58 PST (Wed).
	     <8502062000.AA08198@sri-spam.ARPA>


 > I would like to here from anyone using SUN computers 
 > who can supply answers or comments on any of these issues:
 >  Is Franz the only (best) lisp available?
We have finally finished porting Portable Standard LISP (PSL) to yet
another machine.  This time it is now running on the SUN.  Initial
timing measurements indicate that its speed is somewhere between a 
Vax 750 and 780 (all running PSL), and about twice as fast as Franz running
the REDUCE algebra system test on Suns.  We are now running the Gabriel
benchmarks to discover where it fits in the set.  For more details
see the announcement at the end of this message.
 >  Has anyone used the Maryland Flavors to create useful tools/extensions?
PSL provides support for a simple flavors package that seems quite
useful.  However, the current version has no inheritance.
 >  Any support for sun graphics (windows, menus,etc) a la Interlisp-D?
We have oload working which allows you to call externally compiled
routines (like other c sources).  So the interface should be easy to
add (but we haven't done it).
 >  Any differential reports of Prolog (Quintus) vs Lisp ?
None that I know of.
 >  Any obvious alternative to SUN? (vendor in same class (Tektronix?))
PSL also runs on Apollo's and HP Series 200 (both 68K based machines).
We have also ported a simple "educational" version to the 128K
Macintosh which is used in a beginning programming class.  We plan on
moving at least the Standard LISP subset and compiler to the 512K mac
(so if you want to go really cheap...... :-) )
 >  Worst or hidden problems, pitfalls, gotcha's, etc.
We had a lot of problems with the Sun port.  Some were hardware
related, others were differences between Unix 4.2 on the Sun and on the
Vax.  After we get some more experience using PSL on the machine, maybe
we could report more.
 > > Can real AI development (even applications) be supported on SUN's? <
I think so, as long as you can get one with enough memory.  Some of our
applications running on HP 9836's (which doesn't have virtual memory)
really fly (better than a 780 in speed).  So, memory is really a key to
a fast machine.
 > 
Bob.

		   PSL 3.2 for the SUN Workstation

We are pleased to announce that Portable Standard LISP (PSL) version
3.2 is now available for the Sun workstation.  PSL is about the power,
speed and flavor  of Franz LISP or  MACLISP, with growing  influence
from Common  LISP.  It  is recognized  as an  efficient and  portable
LISP implementation with  many  more capabilities  than  described in
the  1979 Standard LISP Report.  PSL's main  strength is its
portability across  many different  systems,   including:   Vax  BSD
Unix, Vax VMS,  Extended   Addressing DecSystem-20 Tops-20, Apollo
DOMAIN  Aegis, and HP  Series 200.  A  version for the IBM-370 is in
beta test and two Cray versions are being used on an experimental
basis.  Since PSL generates very efficient code, it is an ideal
delivery vehicle for LISP based applications (we can  also provide  PSL
reseller  licenses for  binary only  and  source distributions).

PSL is distributed for the  various systems with executables, all
sources, an approximately  500 page  manual and  release notes.   The
release  notes describe how to install the system and how to rebuild
the various  modules.  We are charging  $750 for the  Sun version of
PSL for Commercial  Site licenses.  Non-profit institutions and all
other versions of PSL will  not be charged a license fee.  We are also
charging a $250 tape distribution fee for each system.

PSL is in heavy use at Utah, and by collaborators at Hewlett-Packard,
Rand, Stanford, Columbia and over  250 other sites.   Many existing
programs  and applications have been  adapted to  PSL including
Hearn's REDUCE  computer algebra system and GLISP, Novak's object
oriented LISP dialect.  These  are available from Hearn and Novak.

To obtain a copy of the license  and order form, please send a NET
message or letter with your US MAIL address to:

Utah Symbolic Computation Group Secretary
University of Utah - Dept. of Computer Science
3160 Merrill Engineering Building
Salt Lake City, Utah 84112

ARPANET: CRUSE@UTAH-20
USENET:  utah-cs!cruse

From cas@cvl  Thu Feb 21 11:40:59 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA17380; Thu, 21 Feb 85 11:40:59 pst
Received: from cvl.ARPA (cvl.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA23930; Thu, 21 Feb 85 11:33:27 pst
Received: by cvl.ARPA (4.12/4.7)
	id AA09421; Thu, 21 Feb 85 14:38:26 est
Date: Thu, 21 Feb 85 14:38:26 est
From: cas@cvl (Cliff Shaffer)
Message-Id: <8502211938.AA09421@cvl.ARPA>
To: franz-friends@BERKELEY
Subject: database system request


Does anybody know of a database system written in FRANZ or easily
compatible with FRANZ?  We have written a lot of software for a
geographic information system, and may want to redo the section which
handles random bits of information associated with polygons or points
stored in a map.  Right now we store this information as a property
list on an atom associated with the polygon or point in question.  This
becomes very inefficient when we want to find all such atoms with
a particular value for some arbitrary property.  Equally importantly,
there is very little relationship between the set of properties associated
with each polygon or point, so a system storing a fixed length record
for each polygon, with fields for each piece of information, would not work.
Any suggestions?
		Cliff Shaffer
		cas@cvl

From layer@ucbdali  Thu Feb 21 12:54:14 1985
Received: from ucbdali.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA18356; Thu, 21 Feb 85 12:54:14 pst
Received: by ucbdali.ARPA (4.24/4.40)
	id AA16858; Thu, 21 Feb 85 12:53:47 pst
Date: Thu, 21 Feb 85 12:53:47 pst
From: layer@ucbdali (Kevin Layer)
Message-Id: <8502212053.AA16858@ucbdali.ARPA>
Phone: (415) 652-2405
To: cas@cvl, franz-friends@kim
Subject: Re:  database system request

You could use the dbm library, as supplied by UNIX (/usr/lib/libdbm.a),
via cfasl and getaddress.

	Kevin


From freemant%rpi.csnet@csnet-relay.arpa  Mon Feb 25 04:50:50 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20175; Mon, 25 Feb 85 04:50:50 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.41)
	id AA24603; Mon, 25 Feb 85 04:43:20 pst
Date: Mon, 25 Feb 85 04:43:17 pst
Message-Id: <8502251243.AA24603@UCB-VAX.ARPA>
Received: from rpi by csnet-relay.csnet id a012112; 25 Feb 85 7:24 EST
From: freemant%rpi.csnet@csnet-relay.arpa
To: franz-friends@BERKELEY

Hello!  Our version of lxref didn't work right when it was passed the -a
option, so I fixed it.  Someone may want to use the -a option on lxref one
of these days, so I am mailing you my fixes in hopes that you will
distribute them.  

Things are kind of chaotic around here, so I am not sure that I was working
with the most current version of lxref.  Make sure that your current version
of lxref matches the code that I changed before you edit in my changes.

The origional definition of the function process-annotate-file left files
open.  Because the lisp interpreter can only have a finite number of files
open at once, this caused lxref to bomb when it was given a large job to do.
To fix this, I changed the definition of process-annotate-file from:

(defun process-annotate-file (filename)
   (let (sourcep outp)
      ; make sure file exists and write annotate file as a
      ; file with the prefix #,
      (if (null (errset (setq sourcep (infile filename))))
	 then (msg "will ignore that file " N)
	 else ; will write to file.A (erasing the final l)
	      (let ((filen (concat "#," filename)))
		 (setq outp (outfile filen))
		 (anno-it sourcep outp)
		 (close outp)
		 ; now mv the original filename to #dfilename
		 ; and the annotated file to the original file
		 (let ((oldcopy (concat "#." filename)))
		    (if (null (errset
				 (progn (if (probef oldcopy)
					   then (sys:unlink oldcopy))
					(sys:link filename oldcopy)
					(sys:unlink filename)
					(sys:link filen filename)
					(sys:unlink filen))))
		       then (msg "An error occured while mving files around "
				 N
				 "files possibly affected "
				 filename oldcopy filen)))))))

to:

(defun process-annotate-file (filename)
   (let (sourcep outp)
      ; make sure file exists and write annotate file as a
      ; file with the prefix #,
      (if (null (errset (setq sourcep (infile filename))))
	 then (msg "will ignore that file " N)
	 else ; will write to file.A (erasing the final l)
	      (let ((filen (concat "#," filename)))
		 (setq outp (outfile filen))
		 (anno-it sourcep outp)
		 (close outp)
		 (close sourcep)
		 ; now mv the original filename to #dfilename
		 ; and the annotated file to the original file
		 (let ((oldcopy (concat "#." filename)))
		    (if (null (errset
				 (progn (if (probef oldcopy)
					   then (sys:unlink oldcopy))
					(sys:link filename oldcopy)
					(sys:unlink filename)
					(sys:link filen filename)
					(sys:unlink filen))))
		       then (msg "An error occured while mving files around "
				 N
				 "files possibly affected "
				 filename oldcopy filen)))))))

Note that the only change is the insertion of one close statement.

The other bug I found was that find-func miserably failed to do its job
right.  The origional version of the function looked like this:

(defun find-func (buf)
   ; first locate first space or tab
   (do ((i 1 (1+ i))
	(max (cxr 0 buf))
	(die))
       ((or (setq die (not (<& i max)))
	    (memq (cxr i buf) '(#\space #\tab)))
	(if die
	   then nil	; can find it, so give up
	   else ; find first non blank
		(do ((ii i (1+ ii)))
		    ((or (setq die (not (<& ii max)))
			 (not (memq (cxr ii buf) '(#\space #\tab))))
		     (if (or die (eq (cxr ii buf) #\lpar))
			then nil
			else ; fid first sep or left paren
			     (do ((iii (1+ ii) (1+ iii)))
				 ((or (not (<& iii max))
				      (memq (cxr iii buf)
					    '(#\space #\tab #\lpar)))
				  (implode-fun buf ii (1- iii)))))))))))

Not unsurprisingly, this code didn't work.  I discarded it and rewrote the
function in a much simpler fashion:

(defun find-func (buf)
    (let ((i 1)
	  (max (cxr 0 buf))
	  (result nil))
	 (loop until (or (greaterp i max) (memq (cxr i buf) '(#\space #\tab)))
	       do (setq i (+ i 1)))
	 (loop while (and (not (greaterp i max))
			  (memq (cxr i buf) '(#\space #\tab))) do
	       (setq i (+ i 1)))
	 (loop until (or (greaterp i max)
			 (memq (cxr i buf) 
			       '(#\space #\tab #.(getcharn '|(| 1)))) do
	       (setq result (cons (cxr i buf) result))
	       (setq i (+ i 1)))
	 (if result then (implode (reverse result)) else nil)))

The error in the origional definition of find-func caused the -a option to
always do nothing.  It is surprising that no one caught the fact that the -a
option was useless earlier.  (However, I am not sure that the source that I
was looking at came from your tape, so perhaps it isn't your fault.)  In any
case, my version works.

Bye!
					Tim Freeman
					freemant@rpi

From bane@gymble  Wed Feb 27 12:20:08 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA19926; Wed, 27 Feb 85 12:20:08 pst
Received: from gymble.ARPA (gymble.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA13078; Wed, 27 Feb 85 12:12:21 pst
Received: by gymble.ARPA (4.12/4.7)
	id AA25775; Wed, 27 Feb 85 15:17:32 est
Date: Wed, 27 Feb 85 15:17:32 est
From: John R. Bane <bane@gymble>
Message-Id: <8502272017.AA25775@gymble.ARPA>
To: franz-friends@BERKELEY
Subject: symeval 'feature'

	I've just finished a half-hour "It works interpreted but not compiled"
debugging session with a user who was new to compiling Franz, and I have a
complaint. The function 'symeval' works misleadingly differently interpreted
and compiled.

	Compiled symeval open-codes into a symbol value-cell reference. This
is fine. Interpreted symeval is implemented as a pointer to 'eval'.  This
loses because something like (symeval '(+ 1 2)) is not an error interpreted,
and it should be because it turns into the worst kind of bug when compiled,
since it'll return some random pointer from cons node space.

	This 'feature' was observed in Opus 38.91.

From neves@wisc-ai.arpa  Thu Feb 28 11:37:06 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA04105; Thu, 28 Feb 85 11:37:06 pst
Received: from wisc-ai.arpa (wisc-ai.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA08982; Thu, 28 Feb 85 11:29:20 pst
Date: Thu, 28 Feb 85 13:34:20 cst
From: neves@wisc-ai.arpa (David Neves)
Message-Id: <8502281934.AA26546@wisc-ai.arpa>
Received: by wisc-ai.arpa; Thu, 28 Feb 85 13:34:20 cst
To: franz-friends@BERKELEY
Subject: franz to vi & back

We have a heavily loaded vax on which we run our Lisp classes.  It
seems to me that we could lessen the load by not having VI start
up anew every time the student does a VIL in Franz.  

It would be nice to have two processes, one Lisp and the other VI.
There would be a function (like VIL) in Franz that would start up
a VI process if there wasn't one and if there was a VI process just
goto it.  When the student is finished editing the file he/she would
hit a key that would save out the file and return to Lisp (without
killing the VI process).  I believe that Gosling Emacs had something
like this, only more sophisticated.

My questions.  Has anyone done this for Franz & VI?  Would this help
the load average on a VAX?  If no one has done it, would it be difficult
to do?
-Thanks, David

From moore.losangel%ibm-sj.csnet@csnet-relay.arpa  Thu Feb 28 16:20:09 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08882; Thu, 28 Feb 85 16:20:09 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA05586; Thu, 28 Feb 85 16:12:12 pst
Message-Id: <8503010012.AA05586@UCB-VAX.ARPA>
Received: from ibm-sj by csnet-relay.csnet id ac15203; 28 Feb 85 19:11 EST
Date: Thu, 28 Feb 85 15:34:11 PST
From: Jim moore <moore.losangel%ibm-sj.csnet@csnet-relay.arpa>
To: info-ibmpc@usc-isi.ARPA, franz-friends@BERKELEY
Subject: Can/does Franz exist on PC/IX or VM/IX?

I am looking for a high quality LISP to run under PC(VM)/IX.
 
Is Franzlisp the one?  Who & How?
 
If not, which?
 
Thanks in advance -- Jim Moore
 
(MOORE.LOSANGEL@IBM)
 
p.s. pls reply directly since I'm not on this list.
 

From johnson@udel-dewey.ARPA  Fri Mar  1 04:29:27 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA17511; Fri, 1 Mar 85 04:29:27 pst
Received: from udel-dewey (udel-dewey.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA18449; Fri, 1 Mar 85 04:21:31 pst
Message-Id: <8503011221.AA18449@UCB-VAX.ARPA>
Received: From localhost.DELAWARE by udel-dewey.DELAWARE id a009017
          ;1 Mar 85 7:18 EST
To: David Neves <neves@wisc-ai.arpa>
Cc: franz-friends@BERKELEY, johnson@udel-dewey
Subject: Re: franz to vi & back
In-Reply-To: Your message of Thu, 28 Feb 85 13:34:20 cst.
	     <8502281934.AA26546@wisc-ai.arpa>
Date: 01 Mar 85 07:18:11 EST (Fri)
From: johnson@udel-dewey


Subject: franz to vi & back

> We have a heavily loaded vax on which we run our Lisp classes.  It
> seems to me that we could lessen the load by not having VI start
> up anew every time the student does a VIL in Franz.  
> 
> It would be nice to have two processes, one Lisp and the other VI.
> There would be a function (like VIL) in Franz that would start up
> a VI process if there wasn't one and if there was a VI process just
> goto it.  When the student is finished editing the file he/she would
> hit a key that would save out the file and return to Lisp (without
> killing the VI process).  I believe that Gosling Emacs had something
> like this, only more sophisticated.
> 
> My questions.  Has anyone done this for Franz & VI?  Would this help
> the load average on a VAX?  If no one has done it, would it be difficult
> to do?
> 

I have developed something similar to what you describe, for franz
running under bsd4.2

It was moderately difficult at the time, but I was just learning to
exploit job control.

in this system, the user invokes: 
(vif  foo)
to edit the function foo.

when he is finished editing, he saves the current buffer by:
:w
then exits the editor by pressing:
^Z  [NOT wq!!]

(getting users o use ^Z rather than wq is the biggest difficulty)

the function is the read from a temporary file which is created
by vif.

if the user later wishes to modify the SAME function [often the case]
he simply invokes:
(vif)
- and is returned to the [stopped] editing session EXACTLY where
he left it.  
[ providing some motivation for putting up with ^Z ]


The system people around here aren't too adventurous, so the only people
who use this system are my friends and myself, so I can't say what effect
it has on the load, [but it can only help]

one problem:  files in /tmp may accumulate, as there is no way to force
a user to clean up all editing sessions before exiting lisp.
[but that is what /tmp is for!]  you might warn your system people
to remove all VIF files that are over 2days old, or something like that.


note: this package knows about changes made by [cmu]edit, and may
be simplified if you are using a system where cmuedit is unavailable.


NOTE!!!!!!
Neither the University of Delaware
nor Apperson H. Johnson
relinquishes any rightts toi this software.

Please do NOT transfer the software without written permission
from both The University of Delaware and Apperson H. Johnson.


**********************************************************
setting up the system:

Script started on Fri Mar  1 06:49:30 1985
% make jced
cc  -c jced.c
cc  -c eroar.c
ld -o jcedmod.o -r  jced.o eroar.o
% lisp
Franz Lisp, Opus 38.79
-> [load 'vif]
[load vif.l]
/usr/lib/lisp/nld -N -x -A /usr/ucb/lisp -T 95800 jcedmod.o -e _jced_ -o /tmp/Li8788.0  -lc
t
-> [dumplisp newlisp]
nil
-> (exit)
script done on Fri Mar  1 06:51:45 1985
*******************************************************************

"newlisp" is now the lisp to use - you can put it in some directory
in youtr student's path
----------  here is vif.l  --------------------------------
(setq sccid "#(@)vif.l	V1.1	johnson@udel	10/13/84")
(eval-when (compile)
	(msg "vif doen't work compiled!!!\\ "N) (exit))
(declare (localf sccid))
;
;  uses job-control to allow ^Z from 'vi' to return to inside of
;  Lisp function
;


; ::vif::
;
;  Usage: (vif [<function-name>])
;  returns: t if function is loaded without errors, nil otherwise
;  side-effect: starts vi with temporary file,
;
;  does NOT REMOVE FILE UNLESS SUCCESSFUL LOAD HAS BEEN MADE
;  AND user has "quit" the editor
;
;  - allows ~instantaneous return to file being edited if
;    vi has been exited by ^Z (or whatever the susp character is, [see stty.1])
;   
;  NOTE: file and vi session may stay "LIVE" even between invocations!!!
; eg:
;
;  (def jnk '(lambda (x) "i am jnk"))
;
;  (vif jnk)
;    --> vi session, followed by :w, and then ^Z
;  t
;  followed by  :
;     (vif jnk ) 
;  or:
;     (vif)
;   --> INSTANTLY returns to former vi session !!
;
;
;
(declare (special *jced_lastf* *jced_lastc*  %changes))

(def vif
  (nlambda (fn)
    (prog (res tf er ppflag)
          (cond
           (fn
            (cond
             ((or (not (boundp '*jced_lastf*))
                  (neq *jced_lastf* (car fn)))
              (setq ppflag t)
              (setq *jced_lastf* (car fn))))))
          (cond ((boundp '*jced_lastf*)
                 (setq tf
                       (substring (concat '/tmp/VF
                                          (concat (syscall 20)
                                                  (concat '_
                                                          *jced_lastf*)))
                                  1))
                 (cond
                  ((and (boundp '%changes)
                        (memq *jced_lastf* %changes)
                        (or (not (boundp '*jced_lastc*))
                            (neq *jced_lastc* (memq *jced_lastf* %changes))))
                   (setq ppflag t)))
                 (cond
                  (ppflag
                   (eval (list 'pp (list 'F tf) *jced_lastf*)))))
                (t (msg "vif: edit what ??" N) (return nil)))
     lp   (setq res (jced_ tf ""))
          (setq er nil)
          (setq ER%all '(lambda (x)
                                (setq er t))
                        )
          (cond
           ((not (probef tf))
            (msg "vif: cannot find " tf)
            (cond
             ((eq res 1)
              (msg " want to return to the editor? {y/n} ")
              (cond ((eq (read) 'y) (go lp)))
			  (return nil)))
            (msg " sorry." N)
            (makunbound '*jced_lastf*)
            (return t)))
          (errset (load tf))
          (cond
           ((boundp '%changes)
            (setq *jced_lastc* (memq *jced_lastf* %changes))))
          (cond
           (er (msg "vif: want to fix " *jced_lastf* "? {y/n} ")
               (cond ((eq (read) 'y) (go lp)))))
          (cond ((eq res 0)
                 (makunbound '*jced_lastf*)
                 (syscall 10 tf)
                 (return t))
                (t (return nil))))))


;
; include modules written in C
(cfasl 'jcedmod.o '_jced_ 'jced_ "integer-function")

;  initialization string for jced
(jced_ ":se lisp
" "edinit")

;  editor to use
(jced_ "/usr/ucb/vi" "editor")

--------------- -------     jced.c             ---------------
static char sccid[] = "@(#)jced.c	1.1	johnson@udel 11/2/84";

#include  <signal.h>
#include  <sgtty.h>
#include  <errno.h>
#include  <sys/wait.h>
#include  <sys/types.h>
#include  <sys/stat.h>
#include  <sys/file.h>
#include  <stdio.h>

#define streq(s1,s2)	(0 == strcmp(s1,s2))
#define file_exist(FN)  (0 == access(FN,F_OK))
static int chpgrp, pgrp;   
static union wait status;
static struct stat st0,st1;
static struct sigvec sv1 = { SIG_IGN, 0, 0};
static struct sigvec sv0;

static char curname[128];
static char ed_buf[] = "/usr/ucb/vi";
static char init_buf[] = "";
static char myname_buf[] = "jced_";
static char *editor = ed_buf;
static char *edinit = init_buf;
static char *myname = myname_buf;

/*	::jced_::
 *	
 *	Usage: (jced_ "filename" "")
 *	
 *			jced_ is a job-control editor
 *
 *	- starts an editor session with "filename"
 *	  (or resumes it if there is a 'living' session with that file)
 *	- returns 1 if the session remains alive, 0 if the session is over
 *	
 * 	NOTE: if the SECOND argument is not the EMPTY string, 
 *	then the following special calls may apply:
 *	
 *		 (jced_ "/usr/ucb/vi" "editor") 
 *	- causes jced to use /usr/ucb/vi as the editor (this is the default)
 *	
 *		: (jced_ ":se bla" "edinit") 
 *	- causes jced cause the editor to pretend that the user typed ":se bla"
 *	every time the editor is invoked (the default is "")
 *
 *		: (jced_ "jced_" "myname") 
 *	- causes jced to use the name "jced_" in its prompts and messages
 *	(this is the default)
 *
 */
int
jced_(fname,cmd)
char *fname, *cmd;
{
union wait  status;
char resp[2];


	if (*cmd) {
		if (streq(cmd,"editor")) newstring(&editor,fname);
		else if (streq(cmd,"edinit")) newstring(&edinit,fname);
		else if (streq(cmd,"myname")) newstring(&myname,fname);
		else fprintf(stderr,"%s: %s is an unknown command",myname,cmd);
		return(0);
	}

	if (*curname) {
		if (*fname &&  !streq(fname,curname)) {
				if (file_exist(curname))
					eroar(unlink(curname),0,"unlink %",curname);
				kvil_();
				strcpy(curname,fname);
				begin_vi(); resume_vi();
		} else {
 			/*
			 * if file has been modified elsewhere,
			 * new editing session is needed
			 */ 
			if (file_exist(curname)) { 
				eroar(stat(curname,&st1),0,"stat");
				if(st0.st_mtime != st1.st_mtime) {
					kvil_(); strcpy(curname,fname); begin_vi();
				}
			}
			resume_vi();
		}
	} else if (*fname) {
			strcpy(curname,fname);
			begin_vi(); resume_vi();
    } else
		return(0);
		
	return((*curname) ? 1 : 0);
}

/*  to be called when a function is modified elsewhwre */
kvil_()
{
	eroar(killpg(chpgrp,SIGKILL),0,"killpg %d",chpgrp);
	wait3(&status,WUNTRACED,0);
	curname[0] = '\0';
}

static
begin_vi()
{
	if (chpgrp = fork()) {
		pgrp = getpgrp(0);
		eroar(setpgrp(chpgrp,chpgrp),0,"setpgrp");
	} else {
		fakeinput(edinit);
		execlp(editor,editor,curname,0);
		fprintf(stderr,"%s: exec of %s failed\n",myname,editor);
    }
}


static
resume_vi()
{
char dum[2];

	for (;;) {
		eroar(sigvec(SIGTTOU,&sv1,&sv0),0,"sigvec -IGN TTOU");
		eroar(ioctl(0,TIOCSPGRP,&chpgrp),0,"SPGRP chpgrp");
		if (file_exist(curname))
			eroar(stat(curname,&st1),0,"stat");
		else
			st1.st_mtime = 0;
		killpg(chpgrp,SIGCONT);
		wait3(&status,WUNTRACED,0);
		eroar(ioctl(0,TIOCSPGRP,&pgrp),0,"ioctl SPGRP pid");
		eroar(sigvec(SIGTTOU,&sv0,0),0,"sigvec -DFL TTOU");
		if (file_exist(curname))
			eroar(stat(curname,&st0),0,"stat");
		else
			st0.st_mtime = st1.st_mtime;

		if(!status.w_status) {
		 	curname[0] = '\0'; break;
		}
		if(st0.st_mtime == st1.st_mtime) {
			fprintf(stderr,"%s: %s was not modified, try again? {y/n} ",
				myname, curname);
			if (1 == scanf("%1s",dum) && dum[0] == 'n')  break;
		} else 
			break;
	}
}

static
fakeinput(s)
char *s;
{
int i;
	/* pretend s was typed at the terminal */
	for(i=0;s[i]; ++i)
		ioctl(0,TIOCSTI,s+i);
}

static
newstring(sptr,s)
char **sptr, *s;
{
char *s2, *malloc();

	if (NULL == (s2 = malloc(1 + strlen(s)))) {
		fprintf(stderr,"%s: malloc failed\n",myname);
	} else {
		strcpy(s2,s);
		*sptr = s2;
	}
}

---------------------------  eroar.c  --------------------

static char sccid[] = "@(#)eroar.c	1.0	johnson@udel 10/13/84";

/*	::eroar.c::
 *	
 *	error reporter-handler for faulty system function calls
 *	
 *	Usage: eroar( <system-call>, <exit-code>, <printf-pattern>, 
 *						<printf-arg>, <printf-arg>,  ...... );
 *	
 *	behavior:
 *		if the system call is successful, returns (1) immediately
 *		else
 *			prints out the error message (from the printf pattern)
 *			  and prints an error explanation
 * 			if exit-code is non-zero, exits with that code
 *			else returns (0)
 */


#include <errno.h>
#include <stdio.h>
#define ERR_BUFMAX 128

extern int sys_nerr, errno;
extern char *sys_errlist[];

eroar(expr,code,s,p1,p2,p3,p4,p5,p6,p7,p8,p9)
int expr,code; char *s;
{
	static char errbuf[ERR_BUFMAX];
	if (-1 != expr) return(1);
	fprintf(stderr,s,p1,p2,p3,p4,p5,p6,p7,p8,p9);
	fprintf(stderr,": %s\n",
		(0 < errno && errno < sys_nerr) ?
				sys_errlist[errno] : "UNKNOWN ERROR");
	if (code) exit(code);
	return(0);
}

-----------------    makefile -----------------------

jced : jcedmod.o

jcedmod.o : jced.o eroar.o
	ld -o jcedmod.o -r  jced.o eroar.o
-------------------------------------------------------

... (share a little joke with the world) ...

net:		johnson@udel-ee
usmail: 	Apperson H. Johnson
			618 Lehigh Rd. apt S11
			Newark, De. 19711
--------------------------------------------------------

From jshaver@apg-3  Fri Mar  1 13:37:57 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22358; Fri, 1 Mar 85 13:21:35 pst
Received: from apg-3 (apg-3.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA28355; Fri, 1 Mar 85 13:13:39 pst
Message-Id: <8503012113.AA28355@UCB-VAX.ARPA>
Date:  1 Mar 1985 16:15:48 EST (Friday)
From: John Shaver STEEP-TM-AC 879-7602 <jshaver@apg-3>
Subject: Vax availability
To: franz-friends@BERKELEY
Cc: jshaver@apg-3

Is Franz Lisp available for the VAX?   Please respond directly to me, as I am
not on the list.  Please add me to the list.

Thank you.
This is an Otrona Attache 1200 bps

 
John


From jshaver@apg-3  Mon Mar  4 06:10:51 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA11236; Mon, 4 Mar 85 06:10:51 pst
Received: from apg-3 (apg-3.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA03832; Mon, 4 Mar 85 06:05:00 pst
Message-Id: <8503041405.AA03832@UCB-VAX.ARPA>
Date:  4 Mar 1985  9:09:27 EST (Monday)
From: John Shaver STEEP-TM-AC 879-7602 <jshaver@apg-3>
Subject: Returned mail: User unknown
To: franz-friends@BERKELEY
Cc: jshaver@apg-3


----BEGINNING OF FORWARDED MESSAGES----
Received: from ucbkim.ARPA by UCB-VAX.ARPA (4.24/4.42)
	id AA28859; Fri, 1 Mar 85 13:34:56 pst
Received: by ucbkim.ARPA (4.24/4.27)
	id AA00121; Fri, 1 Mar 85 13:37:57 pst
Date:  1 Mar 1985 16:15:48 EST (Friday)
From: MAILER-DAEMON%ucbkim@Berkeley (Mail Delivery Subsystem)
Subject: Returned mail: User unknown
Message-Id: <8503012137.AA00121@ucbkim.ARPA>
To: <jshaver@apg-3>

   ----- Transcript of session follows -----
>>> RCPT To:<franz-friends-3@ucbmike.BERKELEY>
<<< 550 <franz-friends-3@ucbmike.BERKELEY>... User unknown
550 franz-friends-3@ucbmike... User unknown
>>> RCPT To:<franz-friends-score@ucbmike.BERKELEY>
<<< 550 <franz-friends-score@ucbmike.BERKELEY>... User unknown
550 franz-friends-score@ucbmike... User unknown

   ----- Unsent message follows -----
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22358; Fri, 1 Mar 85 13:21:35 pst
Received: from apg-3 (apg-3.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA28355; Fri, 1 Mar 85 13:13:39 pst
Message-Id: <8503012113.AA28355@UCB-VAX.ARPA>
Date:  1 Mar 1985 16:15:48 EST (Friday)
From: John Shaver STEEP-TM-AC 879-7602 <jshaver@apg-3>
Subject: Vax availability
To: franz-friends@BERKELEY
Cc: jshaver@apg-3

Is Franz Lisp available for the VAX?   Please respond directly to me, as I am
not on the list.  Please add me to the list.

Thank you.
This is an Otrona Attache 1200 bps

 
John


----END OF FORWARDED MESSAGES----
Is it something I'm doing?


From jshaver@apg-3  Mon Mar  4 06:16:15 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA11275; Mon, 4 Mar 85 06:16:15 pst
Received: from apg-3 (apg-3.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA03880; Mon, 4 Mar 85 06:10:25 pst
Message-Id: <8503041410.AA03880@UCB-VAX.ARPA>
Date:  4 Mar 1985  9:10:31 EST (Monday)
From: John Shaver STEEP-TM-AC 879-7602 <jshaver@apg-3>
Subject: mail request failure
To: franz-friends@BERKELEY
Cc: jshaver@apg-3


----BEGINNING OF FORWARDED MESSAGES----
Received: from CMU-CS-A.ARPA (cmu-cs-a.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA29648; Fri, 1 Mar 85 14:05:23 pst
Message-Id: <8503012205.AA29648@UCB-VAX.ARPA>
Date: 1 Mar 85 17:8:8 EST
From: Mailer <Gripe@CMU-CS-A.ARPA>
To: <@BERKELEY:jshaver@apg-3>
Reply-To: Gripe <Gripe@CMU-CS-A.ARPA>
Subject: mail request failure

   ----- Transcript of session follows -----

Mail being sent from disk area [N900AR0M]
*NMail 1 Mar 85 17:06:02 EST;@UCB-VAX.ARPA:jshaver@apg-3;927920.QED[n900ar0m];mark.stevenson@cmua
1 Mar 85 17:8:8 EST
?%No such person as 'mark.stevenson' at CMU-CS-A.


   ----- Unsent message follows -----
Received: from UCB-VAX.ARPA by CMU-CS-A.ARPA; 1 Mar 85 17:05:57 EST
Received: from ucbkim.ARPA by UCB-VAX.ARPA (4.24/4.42)
	id AA28701; Fri, 1 Mar 85 13:30:28 pst
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22358; Fri, 1 Mar 85 13:21:35 pst
Received: from apg-3 (apg-3.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA28355; Fri, 1 Mar 85 13:13:39 pst
Message-Id: <8503012113.AA28355@UCB-VAX.ARPA>
Date:  1 Mar 1985 16:15:48 EST (Friday)
From: John Shaver STEEP-TM-AC 879-7602 <jshaver@apg-3>
Subject: Vax availability
To: franz-friends@Berkeley
Cc: jshaver@apg-3

Is Franz Lisp available for the VAX?   Please respond directly to me, as I am
not on the list.  Please add me to the list.

Thank you.
This is an Otrona Attache 1200 bps

 
John



----END OF FORWARDED MESSAGES----
Try a return address of RREINER@Simtel20.  They forward everything to me.


From fsbrn@BRL-VOC.ARPA  Tue Mar  5 08:17:28 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00161; Tue, 5 Mar 85 08:17:28 pst
Received: from BRL-VOC (brl-voc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA09879; Tue, 5 Mar 85 08:11:28 pst
Message-Id: <8503051611.AA09879@UCB-VAX.ARPA>
Date:     Tue, 5 Mar 85 11:13:21 EST
From: "Ferd Brundick (VLD/LTTB)" <fsbrn@BRL-VOC.ARPA>
To: Franz-Friends@BERKELEY
Cc: Meself <fsbrn@BRL-VOC.ARPA>
Subject:  Trace bug

Haah,

We recently installed some revisions to our 4.2 BSD system, and the
Joseph Lister package is apparently broken.  Since our system
administrators don't use Franz, I poked around in the file trace.l.
An error run is shown below:

-> (getsyntax '\;)
vsplicing-macro
-> (trace intersect)
[autoload /usr/lib/lisp/trace]
[load /usr/lib/lisp/trace.l]
[load /usr/lib/lisp/charmac.l]
Error: Unbound Variable: ;;
<1>: (getsyntax '\;)
vcharacter

The trace code that is executing is:

(eval-when (eval)
  (setq old-read-table-trace readtable)
  (setq readtable (makereadtable t))
  (setq old-uctolc-value (status uctolc))
  (sstatus uctolc nil)		; turn off case conversion
  (load 'charmac)
  (setsyntax '\; 'macro 'zapline)
  )

What I think is happening is that the readtable is being clobbered by
the (makereadtable t) line.  The file charmac.l starts off with a
comment line, but the definition of ';' has changed in the readtable.
I copied trace.l and reversed the last 2 lines so ';' is macro'd to
zapline BEFORE charmac.l is loaded.  I can then load trace.l and
(trace) functions with no trouble.

My question is: Why did I have to reverse those lines ??  (trace) used
to work fine.  Is there a problem with (makereadtable) that I need to
fix ??  We are running Opus 38.79.

                                        dsw, fferd
                                        Fred S. Brundick
                                        USABRL, APG, MD.
                                        <fsbrn@brl-voc>

"Me ears are on the wrong side of me 'ead."

From fsbrn@BRL-VOC.ARPA  Tue Mar  5 14:55:27 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00189; Tue, 5 Mar 85 14:55:27 pst
Received: from BRL-VOC (brl-voc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA16643; Tue, 5 Mar 85 13:15:11 pst
Message-Id: <8503052115.AA16643@UCB-VAX.ARPA>
Date:     Tue, 5 Mar 85 16:14:14 EST
From: "Ferd Brundick (VLD/LTTB)" <fsbrn@BRL-VOC.ARPA>
To: Franz-Friends@BERKELEY
Cc: Ferd Brundick <fsbrn@BRL-VOC.ARPA>, kanderso@bbn-vax.ARPA
Subject:  Re:  Trace bug

Haah,

  >>Why aren't you loading the compiled version of trace?
  >>Would that help?

That was the what the person who stumbled onto the bug said.  (I don't
use the trace package myself because everything works the first time
:-).  I don't see how that would matter because compiled code is just
as wrong; it just bombs faster.  Besides, my slightly obsolete Franz
manual says "the trace package ... usually in the file
/usr/lib/lisp/trace.l".  I'm just wondering why the file doesn't work
any more when it used to.  I'd rather fix the problem permanently
instead of patching around it.

                                        dsw, fferd
                                        Fred S. Brundick
                                        USABRL, APG, MD.
                                        <fsbrn@brl-voc>

"I think I pulled a muscle in me ear."

From hamscher@MIT-HTVAX.ARPA  Tue Mar 19 16:50:09 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22357; Tue, 19 Mar 85 16:50:09 pst
Received: from MIT-HTVAX.ARPA (mit-htvax.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA05308; Tue, 19 Mar 85 11:49:40 pst
Received: by MIT-HTVAX.ARPA (4.12/4.7) 
	id AA21434; Tue, 19 Mar 85 14:50:20 est
Date: Tue, 19 Mar 85 14:50:20 est
From: Walter Hamscher <hamscher@MIT-HTVAX.ARPA>
Message-Id: <8503191950.AA21434@MIT-HTVAX.ARPA>
To: Franz-Friends@BERKELEY
Subject: Franz -> Common Lisp ?

Reply-to: hamscher@mit-htvax.arpa

Is there a common lisp that runs on 4.2 BSD?  Seems to
me this is  a vacuum that many folks must be trying to fill.

I am wondering:

(1) Who's working on one?

    <<None of the following answers win brownie points:
	(a) DEC.  Their Unix common lisp is only for in-house use.
	(b) CCA.  Ain't ready yet.
	(c) David Betz (XLISP 1.4).  Currently only a small subset.
	(d) NIL.  No Unix implementation planned.>>

(2) Is there a common lisp compatability package for franz?

	<<Unlikely, I know.  Still, how much of common
	lisp already exists in compatability packages,
	e.g. Lexical scoping :-), Packages, Keyword
	arguments, Pathnames, Bit-arrays?>>

(3) Are folks at UCB thinking of spinning off a common
    lisp from the existing franz implementation?

	<<Also unlikely but surely the thought has occurred.>>

All answers and pointers appreciated.

	Thanks,
	Walter Hamscher

From shebs@utah-cs  Wed Mar 20 17:27:57 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08685; Wed, 20 Mar 85 17:27:57 pst
Received: from utah-cs.ARPA (utah-gateway.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA11992; Wed, 20 Mar 85 16:51:20 pst
Received: by utah-cs.ARPA (4.42/4.40.2)
	id AA01825; Wed, 20 Mar 85 17:48:26 MST
Date: Wed, 20 Mar 85 17:48:26 MST
From: shebs@utah-cs (Stanley Shebs)
Message-Id: <8503210048.AA01825@utah-cs.ARPA>
To: Franz-Friends@BERKELEY, hamscher@mit-htvax.arpa
Subject: Re:  Franz -> Common Lisp ?

We have several versions of compatibility stuff for PSL (and it
would work under Franz without much change).  We're trying to
get CL while retaining the speed of PSL, so we haven't yet
embarked on a full standalone CL...

						stan shebs

From ingrid@UCLA-LOCUS.ARPA  Thu Mar 21 11:05:39 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA18463; Thu, 21 Mar 85 11:05:39 pst
Received: from ucla-locus.arpa (ucla-locus.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA12504; Thu, 21 Mar 85 10:37:45 pst
Date:           Thu, 21 Mar 85 10:35:28 PST
From: Ingrid Zukerman <ingrid@UCLA-LOCUS.ARPA>
To: franz-friends@BERKELEY
Subject:        setq command changes code
Message-Id:     <480278128-16289-ingrid@UCLA-LOCUS.ARPA>

I have the following problems:
1. After performing the command (setq x (list ... )), I noticed that
   the code in the function that initializes x was also changed to the
   new value. After consulting with my guru, he pointed out that this
   might be due to a sharing pattern I am not aware of, or to the way
   in which assignments are performed (e.g., by passing a pointer).
   I wasn't able to find this information, so my question is were I
   could find it in order to avoid such occurrences in the future. Of
   course, if somebody up there is terribly curious and wants to look
   at a transcript of the session, I'll be very appreciative.
2. The most updated copy we have of Franz is Opus 38.5. I hear that it
   is now Opus 38.91. What should I do in order to get an updated copy?
   Please don't advise me to contact the person in charge, because this
   person (who no longer wishes to be in charge) told me to contact you.
Thanks very much.
--Ingrid

From franz!schlafly  Mon Mar 25 18:03:33 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA20019; Mon, 25 Mar 85 18:03:33 pst
Received: from ucbkim.ARPA by UCB-VAX.ARPA (4.24/4.42)
	id AA21825; Mon, 25 Mar 85 17:57:20 pst
Received: by ucbkim.ARPA (4.24/4.27)
	id AA20010; Mon, 25 Mar 85 18:03:19 pst
Received: by franz.uucp (1.2/3.14)
	id AA00961; Mon, 25 Mar 85 17:36:52 pst
Date: Mon, 25 Mar 85 17:36:52 pst
From: franz!schlafly (Roger Schlafly)
Message-Id: <8503260136.AA00961@franz.uucp>
To: franz-friends@BERKELEY
Subject: programs written in Franz Lisp


I am compiling a list of expert systems and expert
system building tools which are written in Franz Lisp.

I would appreciate it if people would send me:
(1) The name of each such program.
(2) A brief description of what it does.
(3) Whether it is available to the public.
(4) An electronic address for obtaining more information.

I will then make this list available to anyone who requests it.

	Roger Schlafly
	ucbvax!franz!schlafly


From franz!schlafly  Mon Mar 25 20:02:47 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA21162; Mon, 25 Mar 85 20:02:47 pst
Received: from ucbkim.ARPA by UCB-VAX.ARPA (4.24/4.42)
	id AA23786; Mon, 25 Mar 85 19:56:37 pst
Received: by ucbkim.ARPA (4.24/4.27)
	id AA21150; Mon, 25 Mar 85 20:02:36 pst
Received: by franz.uucp (1.2/3.14)
	id AA01276; Mon, 25 Mar 85 19:37:31 pst
Date: Mon, 25 Mar 85 19:37:31 pst
From: franz!schlafly (Roger Schlafly)
Message-Id: <8503260337.AA01276@franz.uucp>
To: franz-friends@BERKELEY
Subject: programs written in Franz Lisp


I am compiling a list of expert systems and expert
system building tools which are written in Franz Lisp.

I would appreciate it if people would send me:
(1) The name of each such program.
(2) A brief description of what it does.
(3) Whether it is available to the public.
(4) An electronic address for obtaining more information.

I will then make this list available to anyone who requests it.

	Roger Schlafly
	ucbvax!franz!schlafly


From carter%ubc.csnet@csnet-relay.arpa  Tue Mar 26 12:52:24 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00886; Tue, 26 Mar 85 12:52:24 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA11893; Tue, 26 Mar 85 12:46:01 pst
Received: from ubc by csnet-relay.csnet id a017378; 26 Mar 85 15:03 EST
Received: from ubc-vision.UUCP by ubc.csnet id AA04906; Tue, 26 Mar 85 12:01:03 pst
Date: Tue, 26 Mar 85 12:00:43 pst
From: Alan Carter <carter%ubc.csnet@csnet-relay.arpa>
Message-Id: <8503262000.AA09422@ubc-vision.UUCP>
Received: by ubc-vision.UUCP id AA09422; Tue, 26 Mar 85 12:00:43 pst
To: franz-friends@BERKELEY
Subject: Lisp interface to C functions



Does anyone know if there is a problem with calling malloc and free from
C functions which are called by Franz ?


					Alan Carter
					carter@ubc-vision.UUCP

From mcgeer  Tue Mar 26 16:06:57 1985
Received: by ucbkim.ARPA (4.24/4.27)
	id AA03620; Tue, 26 Mar 85 16:06:57 pst
Date: Tue, 26 Mar 85 16:06:57 pst
From: Rick McGeer (on an aaa-60-s) <mcgeer>
Message-Id: <8503270006.AA03620@ucbkim.ARPA>
To: prolog@ernie, franz-friends
Subject: Lisp is faster than Prolog?
Cc: 

	A number of articles in recent IEEE Spectra have discussed Silicon
Compilation in Prolog, and concluded with a statement to the effect: for
performance reasons, we will go to Lisp for a production version.

	Is Lisp really faster than Prolog?  I used to think so.  Some time
ago, I wrote a Prolog interpreter in Lisp: after several versions, I gave
up, because I couldn't make my Prolog fast.  Its best speed was 100 LIPS
through the append loop on a 780, or about 7% of the speed of C-Prolog (1500
LIPS, according to the literature.

	Then it occured to me that I could not expect my Prolog to run
faster than an equivalent function coded in Lisp.  I coded the function, and
the result was the following:

(def my-append
   (lambda (x y)
      (cond (x (cons (car x) (my-append (cdr x) y)))
	    (t y))))

it can be seen that the time of the computation is invariant with respect to
the second argument.  Hence, for all the tests to be mentioned, the second
argument is '(1 2 3 4 5).

	I ran the program on the lists consisting of the first 100, 250, and
300 integers.  The results were the following:

list length	ticks (60/sec)	LIPS equivalent
  100		  14		  429
  250		  29		  517
  300		  34		  529

Or about one-third the published speed of of the same function in CProlog on
a 780.  I then wondered how the native Franz append would do.  This function
is compiled, and is optimized for tail recursion, so the experiment is not
really fair to CProlog.  In any case:

list length	ticks		LIPS equivalent
  100		  3		  2000
  250		  8		  1875
  300		 10		  1800

I don't know what this proves, but I know what it doesn't prove.  The Lisp
used, by the way, was Franz version 38.96 on a Vax 11/780 at the University
of California at Berkeley.  Despite numerous queries to Edinburgh, we still
don't have a version of C-Prolog for comparative measurement here, so I
can't personally vouch for the 1500 LIPS claim.

							Rick.


From chris@maryland  Tue Mar 26 16:18:52 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA03876; Tue, 26 Mar 85 16:18:52 pst
Received: from maryland.ARPA (maryland.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA16580; Tue, 26 Mar 85 16:12:34 pst
Received: by maryland.ARPA (4.12/4.7)
	id AA23203; Tue, 26 Mar 85 19:17:28 est
Date: Tue, 26 Mar 85 19:17:28 est
From: Chris Torek <chris@maryland>
Message-Id: <8503270017.AA23203@maryland.ARPA>
To: carter%ubc.csnet@csnet-relay.ARPA
Subject: Re:  Lisp interface to C functions
Cc: franz-friends@BERKELEY

I believe that there were.  In U of M Franz, we stuck in a version of
malloc and free that uses the Lisp allocator to get unGCable memory,
and a host of problems with the window library went away ... (the
window library uses malloc & free quite, er, freely :-) ).

Chris

From narain@rand-unix  Tue Mar 26 18:17:38 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA06939; Tue, 26 Mar 85 18:17:38 pst
Received: from rand-unix.ARPA (rand-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA18369; Tue, 26 Mar 85 17:39:36 pst
Received: by rand-unix.ARPA; Tue, 26 Mar 85 17:33:48 pst
From: Sanjai Narain <narain@rand-unix>
Message-Id: <8503270133.AA16864@rand-unix.ARPA>
Date: 26 Mar 85 17:33:41 PST (Tue)
To: Rick McGeer <mcgeer@ucbkim>
Cc: prolog@ernie, franz-friends@ucbkim, narain@rand-unix
Subject: Re: Lisp is faster than Prolog?
In-Reply-To: Your message of Tue, 26 Mar 85 16:06:57 pst.
	     <8503270006.AA03620@ucbkim.ARPA>


Your first comparison of Prolog and Lisp is not very meaningful. You are
comparing a Prolog implemented in Lisp with a Lisp implemented in C.
Perhaps you could try to compare Lisp in Lisp with Prolog in Lisp.

In a certain sense, your comparison of Franzlisp and C-Prolog infact
indicates the superiority of C-Prolog. C-Prolog can be used to do append
and all other functional programming at almost the speed of FranzLisp.
However, in C-Prolog, you can do also do deduction, searching, pattern
matching and a lot of other AI-stuff at the same speed. To do these in
Franzlisp you must write Lisp functions and suffer the loss in speed
associated with simulating functionality in a high-level language.

-- Sanjai

From mcgeer  Tue Mar 26 18:30:58 1985
Received: by ucbkim.ARPA (4.24/4.27)
	id AA07153; Tue, 26 Mar 85 18:30:58 pst
Date: Tue, 26 Mar 85 18:30:58 pst
From: Rick McGeer (on an aaa-60-s) <mcgeer>
Message-Id: <8503270230.AA07153@ucbkim.ARPA>
To: narain@rand-unix
Subject: Re: Lisp is faster than Prolog?
Cc: narain@rand-unix, franz-friends, prolog@ernie
In-Reply-To: Your message of 26 Mar 85 17:33:41 PST (Tue)


	You misunderstood my message.  Prolog-in-Lisp really isn't under
examination: the only reason I brought it up was that it provided the
original motivation for the experiment (I wanted to determine a limit on the
speed I could expect out of my Prolog, reasoning that it could not possibly
be faster than native-coded Lisp.)

	The rest of your letter is essentially correct: the figures imply
that CProlog is at least as fast as Franz, since the relevant test is
interpreted code in each language (i.e., the first set of figures).
However, this should not imply that I believe that Prolog is a "better"
language than Lisp (I don't want to get into *that* debate), or imply
that Lisp has no advantages over Prolog.  Lisp may have real advantages over
Prolog, but there is no reason to believe that speed is one of them.

					Rick.


From hilfingr@ucbrenoir  Wed Mar 27 01:06:00 1985
Received: from ucbrenoir.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA11390; Wed, 27 Mar 85 01:06:00 pst
Received: by ucbrenoir.ARPA (4.24/4.42)
	id AA03594; Wed, 27 Mar 85 01:07:16 pst
Date: Wed, 27 Mar 85 01:07:16 pst
From: hilfingr@ucbrenoir (Paul Hilfinger)
Message-Id: <8503270907.AA03594@ucbrenoir.ARPA>
To: mcgeer@ucbkim, narain@rand-unix
Subject: Re: Lisp is faster than Prolog? A personal plea
Cc: prolog@ernie, franz-friends@ucbkim
In-Reply-To: Your message of 26 Mar 85 17:33:41PST


Please, please, please stop trying to compare the performance of Lisp and
Prolog by considering micro-benchmarks!  Even in languages that are
essentially "the same" (from my perspective as a semanticist/language
designer or from the perspective of a Prolog programmer, FORTRAN, Pascal,
Modula 2, and Ada are all the same); such benchmarks are imperfect guides.
When comparing Lisp and Prolog, where the programs one might write to do a
particular problem might be radically different in strategy, anything that
compares the performance of tiny programs conveys almost no useful
information.

Please, please, please, PLEASE don't try to compare Prolog with Lisp (etc.)
using LIPS as a part of the measure! In comparing Prolog implementations, I
suppose LIPS might be of some interest, but when comparing Lisp with Prolog,
they don't help at all. The reason is simple: if Lisp is not suited for
doing logical inferences (in the Prolog sense) quickly, then the good Lisp
programmer simply does not formulate his solution using logical inferences.
(Patient: Doctor! Doctor! It hurts when I do this. Doctor: Well, then don't
do that.) It's like saying that my APL implementation, which uses lazy
evaluation and a bit of cleverness to compute

	+/ ,((iota n) o.= iota n) x A +.x B

(the trace of the matrix product of nxn matrices A and B, I think) in time
O(n^2) instead of O(n^3), is "faster" than my FORTRAN implementation, which
requires time O(n^3) to do a direct transcription of this algorithm
(actually forming the full matrix product).  

I think it wrong to say

   "To do [deduction, searching, pattern matching and other AI-stuff] in
    Franzlisp you must write Lisp functions and suffer the loss in speed
    associated with simulating functionality in a high-level language."

because one DOESN'T use simulation if one wants speed, but instead goes
after an entirely different kind of solution (I won't argue that this
solution is "just as easy" as the Prolog solution; there are certainly many
instances in which Prolog solutions are simpler, and I haven't the foggiest
notion what the story is for large systems.)  

	* * *

Finally, a question.  I was struck by Sanjai Narain's  comment:

    "However, in C-Prolog, you can do also do deduction, searching, 
     pattern matching and a lot of other AI-stuff at the same speed."

I notice that the Prolog digest is full of interesting puzzles whose
solution involves search. But are these representative? I think pattern
matching is certainly a big part of any Prolog program, but do deduction and
searching really form a big part of actual Prolog applications in practice?

I recall an article by Drew McDermott called the "The Prolog Phenonmenon"
that appeared (I think) in SIGArt at some point, maybe July '82. He asked
why it was that Prolog had not died out, as had PLANNER, which also
purported to support searching et al. He said some things on what he liked
and disliked about Prolog, and then made the following comment (emphasis
mine):

	"The Europeans went in a different direction [from the Americans
	 in reaction to the problems of PLANNER-like languages].  What
	 they liked best about logic was its variable-binding machinery.
	 Their attitude towards backtracking has been simply that it is a
	 programmer's duty to remember that his program will be executed
	 backward as well as forward, that his programs must correct bad
	 guesses as well as exploit good ones.  If the backwards
	 execution blows up, he must debug his program, not rewrite the
	 interpreter [the American approach], just as with more prosaic
	 kinds of infinite loops.  Once this burden was shifted away
	 from the language implementer and onto the programmer, the
	 logical [!] next step was to freeze the interpreter design
	 and make it as efficient as possible.  THE RESULT IS A 
	 PROGRAMMING LANGUAGE, NOT A PROBLEM SOLVER OR THEOREM PROVER;
	 it doesn't compete with NOAH, but with Lisp.  And it's my
	 impression that it competes pretty well.
	 
	     "The effect is to reverse the usual images of the American 
	 and European computer scientists.  In this case, the Americans
	 have pursued impractical theoretical studies, while the
	 Europeans have bummed the hell out of a hack."

(By "backward execution," he is referring to backtracking, I believe). To
put this another way, one doesn't use Prolog's backtracking to do AI-style
(i.e., very large) search, but rather to do very local and carefully-
controlled "search," in the sense of "search this list (tree, ....) for an
element equal to this one" or "try all permutations of this tiny set for one
that satisfies P." Likewise, one doesn't use it to do what an AI
investigator would call "deduction." One CAN convince the Prolog machinery
to do more general AI-style searching efficiently, but only at the expense
of vastly obscuring the original clear, simple, declarative form of the
program.

Not being a real Prolog hacker (yet) I don't really know how accurate this
view is, and would appreciate some reaction (preferably semi-quantitative).



From franz!jkf  Wed Mar 27 08:03:25 1985
Received: by ucbkim.ARPA (4.24/4.27)
	id AA13270; Wed, 27 Mar 85 08:03:25 pst
Received: by franz.uucp (1.2/3.14)
	id AA06162; Wed, 27 Mar 85 07:59:36 pst
Date: Wed, 27 Mar 85 07:59:36 pst
From: franz!jkf (John Foderaro)
Message-Id: <8503271559.AA06162@franz.uucp>
To: hilfingr@ucbrenoir.BERKELEY, narain@rand-unix.ARPA, mcgeer@ucbkim.BERKELEY
Subject: Re: Lisp is faster than Prolog? A personal plea
Cc: franz-friends@ucbkim.BERKELEY, prolog@ernie
In-Reply-To: Your message of Wed, 27 Mar 85 01:07:16 pst

 While I find the discussion of Prolog vrs Lisp interesting, please do don't
include franz-friends in on the discussion.  When the mailing list has
strayed off the topic of Franz Lisp in the past,  I've gotten inundated with
complaints.	Thanks.
					John Foderaro
					



From mcgeer  Wed Mar 27 10:22:15 1985
Received: by ucbkim.ARPA (4.24/4.27)
	id AA15354; Wed, 27 Mar 85 10:22:15 pst
Date: Wed, 27 Mar 85 10:22:15 pst
From: Rick McGeer (on an aaa-60-s) <mcgeer>
Message-Id: <8503271822.AA15354@ucbkim.ARPA>
To: hilfingr@ucbrenoir, narain@rand-unix
Subject: Re: Lisp is faster than Prolog? A personal plea
Cc: franz-friends, prolog@ernie
In-Reply-To: Your message of Wed, 27 Mar 85 01:07:16 pst

	Good point, Paul, but I think you're missing something.  First you
plead with us not to use micro-benchmarks, then you point out (correctly)
that the strategy that one would use to write a program in Lisp instead of
Prolog can often differ.  I would think that the implication from the latter
observation is that large programs are fundamentally incomparable, and I
think that that is probably correct.

	So if you deny us micro-benchmarks, then we can not measure the
relative performance of these languages at all (or, more precisely, the
standard implementations of these languages on the 11/780).  Hence we might
as well accept the statements "Prolog is faster than Lisp" or "Lisp is faster
than Prolog" or "Lisp is faster than assembler" as essentially meaningless
statements, since we can't quantify any of them.

	Let me sputter out making one final point.  LIPS is not all that
bad a measure.  Perhaps if we called it "cycles through the append loop" or
"function calls per second" (essentially identical statements) I think most
people would agree that this is a fair measure of the performance of any
Lisp.  After all, Lisp does nothing other than call functions and manipulate
lists.

	I'm certainly not going to take issue with the rest of your letter,
which is really more directed at Sanjai's claims than mine, and walks rather
closer to debates on programming style than any sane man should dare to go.


	I remain, sir,

					Y'r obedient servant,

						Rick McGeer.


From jeffr@sri-spam  Fri Mar 29 16:22:50 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA09984; Fri, 29 Mar 85 16:22:50 pst
Received: from sri-spam.ARPA (sri-spam.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA04718; Fri, 29 Mar 85 16:16:10 pst
Received: from localhost.ARPA by sri-spam.ARPA (4.22/4.16)
	id AA29100; Fri, 29 Mar 85 16:22:32 pst
Message-Id: <8503300022.AA29100@sri-spam.ARPA>
Date: 29 Mar 85 16:22:30 PST (Fri)
To: franz-friends@BERKELEY
Subject: Problems Forking Around
From: jeffr@sri-spam

I am having problems getting child processes forked from Franz to exit
cleanly.  If I execute a simple forking function, such as

	(defun fork_test ()
       		(prog (pid)
	     	(cond ((setq pid (fork)) (return pid)))
	     	(exit)
	]

from the Franz interpreter, a zombie process is created which doesn't exit
until I exit the interpreter.  The same result holds when fork_test is
called from a compiled Franz daemon which is not associated with a tty.

It's Friday and I'm out of ideas; any you have, even if only speculation,
would be greatly appreciated.

					- Jeff Rininger
					  SRI International	

From larus@ucbdali  Fri Mar 29 16:50:22 1985
Received: from ucbdali.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA10643; Fri, 29 Mar 85 16:50:22 pst
Received: by ucbdali.ARPA (4.24/4.42)
	id AA04603; Fri, 29 Mar 85 16:50:11 pst
Message-Id: <8503300050.AA04603@ucbdali.ARPA>
To: jeffr@sri-spam.ARPA
Cc: franz-friends@ucbdali
Subject: Re: Problems Forking Around
In-Reply-To: Your message of 29 Mar 85 16:22:30 PST (Fri).
	     <8503300022.AA29100@sri-spam.ARPA>
Date: 29 Mar 85 16:50:02 PST (Fri)
From: larus@ucbdali

This is a not-very-well-known bug/feature of Franz/Unix.  Try adding a
(wait) call in the main routine and the zombies will go away.

/Jim

From weeks@ucbruby.CC  Fri Mar 29 18:23:00 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA11898; Fri, 29 Mar 85 18:23:00 pst
Received: from ucbjade.CC.Berkeley.ARPA (ucbjade.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA07034; Fri, 29 Mar 85 18:16:19 pst
Received: from ucbruby.CC.Berkeley.ARPA (ucbruby.ARPA)
	by ucbjade.CC.Berkeley.ARPA (4.19/4.34.1)
	id AA11566; Fri, 29 Mar 85 18:22:39 pst
Received: by ucbruby.CC.Berkeley.ARPA (4.19/4.34.1)
	id AA10320; Fri, 29 Mar 85 18:21:53 pst
Date: Fri, 29 Mar 85 18:21:53 pst
From: weeks@ucbruby.CC (Harry Weeks)
Message-Id: <8503300221.AA10320@ucbruby.CC.Berkeley.ARPA>
To: jeffr@sri-spam
Subject: Re: Problems Forking Around
Cc: franz-friends@BERKELEY

It is a characteristic of Unix that processes do not really die
until they are waited for.  Your `zombie' process will not die
until you (wait) for it.  The (wait) function returns the dotted
pair (pid . status).  Thus the following examples will spawn
children that immediately die.
						--Harry

In simplest terms:

    (def beget
      (lambda nil
	(cond ((fork) (wait))
	      (t (exit 0)))))

In more realistic terms:

    (def beget
      (lambda nil
	(prog (child)
	      (setq child (fork))
	      (cond ((null child)
		     ; child branch: (fork) evaluated to nil
		     (exit 0))
		    ((> child 0)
		     ; parent branch: (fork) evaluated to pid
		     (princ "Begot ")
		     (princ child)
		     (princ ".")
		     (terpri)
		     (return (beget:wait child)))
		    ((< child 0)
		     ; error branch
		     (princ "Birth pain.")
		     (terpri)
		     (return child))
		    (t
		     ; impossible branch
		     (princ "Impossible pain.")
		     (terpri)
		     (return -1))))))
    (def beget:wait
      (lambda (child)
	(prog (pvec)
	      (setq pvec (wait))
	      (cond ((= (car pvec) child)
		     ; child we are waiting for died
		     (return (cdr pvec)))
		    ((< (car pvec) 0)
		     ; error
		     (princ "Wait error.")
		     (terpri)
		     (return (car pvec)))
		    (t
		     ; another child died, keep waiting for ours
		     (return (beget:wait child)))))))

From carter%ubc.csnet@csnet-relay.arpa  Tue Apr  2 16:48:37 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA15047; Tue, 2 Apr 85 16:48:37 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA26876; Tue, 2 Apr 85 16:48:19 pst
Received: from ubc by csnet-relay.csnet id a008974; 2 Apr 85 19:35 EST
Received: from ubc-vision.UUCP by ubc.csnet id AA06552; Tue, 2 Apr 85 16:28:06 pst
Date: Tue, 2 Apr 85 16:27:59 pst
From: Alan Carter <carter%ubc.csnet@csnet-relay.arpa>
Message-Id: <8504030027.AA14795@ubc-vision.UUCP>
Received: by ubc-vision.UUCP id AA14795; Tue, 2 Apr 85 16:27:59 pst
To: franz-friends@BERKELEY
Subject: C interface

Does anyone know if it is OK to call malloc and free from C functions
called by lisp?
				-- Alan Carter
				   carter@ubc-vision.UUCP

From dennis%boulder.csnet@csnet-relay.arpa  Wed Apr  3 19:05:09 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA09023; Wed, 3 Apr 85 19:05:09 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA24595; Wed, 3 Apr 85 19:04:50 pst
Message-Id: <8504040304.AA24595@UCB-VAX.ARPA>
Received: from boulder by csnet-relay.csnet id af16243; 3 Apr 85 21:51 EST
Received: by boulder.UCBOULDER (4.30/4.7)
	id AA10745; Wed, 3 Apr 85 09:58:09 mst
Date: Wed, 3 Apr 85 09:58:09 mst
From: Dennis Heimbigner <dennis%boulder.csnet@csnet-relay.arpa>
To: carter%ubc.csnet@csnet-relay.arpa, franz-friends@BERKELEY
Subject: Re:  C interface

If I recall correctly, the pre-4.2 malloc did not appear to work
with franz because it assumed that it had control
of all of free memory.  The malloc for 4.2 uses a buddy
system and should not care if, for example, franz
has pre-empted pieces of virtual memory for its own use.
On the other side, franz only looks at the memory
it gets from sbrk, so it doesn't care about malloc'd
areas of virtual memory.
.lp
More to the point, I have been using malloc inside
cfasl'd code and have not yet seen a problem.

Dennis Heimbigner
dennis.boulder@csnet-relay.


From @seismo.ARPA:prlb2!vauclair@seismo.ARPA  Fri Apr  5 01:13:08 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA27833; Fri, 5 Apr 85 01:13:08 pst
Received: from seismo.ARPA (css-ring-gw.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA25779; Fri, 5 Apr 85 01:12:50 pst
Return-Path: <prlb2!vauclair@seismo.ARPA>
Received: from prlb2.UUCP by seismo.ARPA with UUCP; Fri, 5 Apr 85 04:12:31 EST
Received: by prlb2.UUCP (4.12/4.7)
	id AA01128; Fri, 5 Apr 85 10:36:51 -0200
Date: Fri, 5 Apr 85 10:36:51 -0200
From: prlb2!vauclair@seismo.ARPA (Marc Vauclair)
Message-Id: <8504050836.AA01128@prlb2.UUCP>
To: franz-friends@BERKELEY
Subject: Profiling options in Franz Lisp. Opus 38.91. UoM Var. 3.5.

Does anyone know how to set up profiling in Franz Lisp ?
We have Franz Lisp of University of Maryland : Opus 38.91, UoM Variation 3.5.

I have already made the following modifications :

1) as stated in the makefile : ../franz/vax/Makefile I have removed the #
   in :
------------------------------------------------------------------------------
ProfFlag = # -XP
ProfFlag2 = # -DPROF
------------------------------------------------------------------------------

giving :

------------------------------------------------------------------------------
ProfFlag =  -XP
ProfFlag2 =  -DPROF
------------------------------------------------------------------------------

2) I've changed in ../franz/vax/Makefile the line :

------------------------------------------------------------------------------
	/lib/cpp $< -I../h |\
------------------------------------------------------------------------------

to :

------------------------------------------------------------------------------
	/lib/cpp ${ProfFlag2} $< -I../h |\
------------------------------------------------------------------------------

3) I've changed in ../franz/vax/Makefile/qfuncl.c the lines :

------------------------------------------------------------------------------
#ifdef PROF
	.set	indx,0
#define Profile \
	movab	prbuf+indx,r0  \
	.set 	indx,indx+4 \
	jsb 	mcount
#define Profile2 \
	movl   r0,r5 \
	Profile	\
	movl   r5,r0 
#else
#define Profile
#define Profile2
#endif
------------------------------------------------------------------------------

to :

------------------------------------------------------------------------------
#ifdef PROF
	.set	indx,0
#define Profile \
	movab	prbuf+indx,r0 ; \
	.set 	indx,indx+4 ; \
	jsb 	mcount
#define Profile2 \
	movl   r0,r5 ; \
	Profile	; \
	movl   r5,r0 
#else
#define Profile
#define Profile2
#endif
------------------------------------------------------------------------------

After all these modifications, we have the following error message when
making it slow :

------------------------------------------------------------------------------
ld -x -o rawlisp -e start ../low.o ../lowaux.o crt0.o ../alloc.o ../data.o  bigmath.o qfuncl.o vax.o ../lisp.o ../eval.o ../eval2.o ../inits.o ../io.o ../error.o  ../sysat.o ../lam1.o ../lam2.o ../lam3.o ../lam4.o ../lam5.o ../lam6.o  ../lam7.o ../lam8.o 


../lam9.o ../lamr.o ../lamp.o  ../fex1.o ../fex2.o ../fex3.o ../fex4.o ../fexr.o ../fpipe.o  ../subbig.o ../pbignum.o ../divbig.o  ../ffasl.o ../fasl.o  ../trace.o ../evalf.o ../frame.o ../lamgc.o  ../lamuom.o ../hash.o  -lm -lc -ltermlib
mcount: ld:/lib/libc.a(mon.o): multiply defined
*** Error code 2

Stop.
*** Error code 1

Stop.
------------------------------------------------------------------------------

From franz!schlafly  Fri Apr  5 11:19:37 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA02221; Fri, 5 Apr 85 11:19:37 pst
Received: from ucbkim.ARPA by UCB-VAX.ARPA (4.24/4.42)
	id AA04091; Fri, 5 Apr 85 11:18:48 pst
Received: by ucbkim.ARPA (4.24/4.27)
	id AA02177; Fri, 5 Apr 85 11:18:45 pst
Received: by franz.uucp (1.2/3.14)
	id AA00261; Fri, 5 Apr 85 10:37:18 pst
Date: Fri, 5 Apr 85 10:37:18 pst
From: franz!schlafly (Roger Schlafly)
Message-Id: <8504051837.AA00261@franz.uucp>
To: franz-friends@BERKELEY
Subject: Franz Lisp applications



Here is my list of Franz Lisp applications. Enough people
requested copies that I am sending it to all franz-friends.
If anyone sees any notable omissions, please send me a
message and I will augment the list.

	Roger Schlafly
	ucbvax!franz!schlafly

============================================================



        AI and Expert System Tools and Applications
           Developed or Running under Franz Lisp



+ OPS-5
A rule based  environment  for  developing  expert  systems.
Available  from  Franz Inc. with Franz LISP at no charge, or
at no charge from Carnegie Mellon University.

Computer Science  Department,  Carnegie  Mellon  University,
Schenley Park, Pittsburgh PA 15213.  (412) 578-2592

+ Flavors
An object oriented extension of Lisp, developed at  MIT  and
the  University  of  Maryland.   Used  on the Symbolics Lisp
machines.  Available from Franz Inc. at no  charge  to  pur-
chasers of Franz Lisp.

+ DUCK
DUCK is an expert systems development environment.

Available  from  Smart  Systems  Technology,  6870  Elm  St.
McLean, VA.  22101 (703) 448-8562.

+ Boyer-Moore Theorem Prover
Available from Prof. Robert Boyer, University of Texas, Aus-
tin.    Computer  Science  Department,  3-28  Painter  Hall,
University of Texas, Austin, Texas 78712.  (512) 471-7316

+ GLISP
GLISP is a high-level language which is based on Lisp and is
compiled  into  Lisp.  It was developed at the University of
Texas at Austin by Prof. Gordon Novak.  Object-centered pro-
gramming  is  supported.   Message  interpretations  can  be
looked up at compile time  to  produce  efficient  code.   A
window-based  editor,  GEV, is available to inspect and edit
data according to its data structure description.  GLISP  is
available  from  Franz  Inc.  at  no charge to purchasers of
Franz Lisp, or from the University of Texas at Austin, Prof.
Gordon  Novak,  Computer  Science  Department,  3-28 Painter
Hall, University of Texas, Austin, Texas 78712.  (512)  471-
7316

+ FRL
A frame representation language for AI development.

Available from Steven Rosenberg, Hewlett Packard  (415)  857
5902

+ MRS
A logic based knowledge  representation  system.   Available
from Stanford University.

Attention: Pattie McCabe SUMEX Computing Facility,  Stanford
University  Medical Center, Room TB105, Stanford, California
94305, (415) 497-5141

+ Macsyma
Developed at MIT, Macsyma is a program that carries out sym-
bolic  computation.   It  will solve all those integrals you
learned about in your calculus class, as well as systems  of
differential equations and other mathematical problems.

+ Reduce
Reduce is similar to  Macsyma.   It  was  developed  at  the
University  of Utah.  Computer Science Department, 3160 Mer-
rill Engineering Bldg.  Salt Lake City, Utah  84112.   (801)
484-7651 Ext 205

+  XCON
Digital Equipment's famous expert system, written in  OPS-5,
originally  ran  on top of Franz Lisp.  XCON configures com-
puters before shipment.

+ ACE
Automatic Cable Expertise : A knowledge based expert  system
that  provides  trouble-shooting  and diagnostic reports for
telephone company managers.   Developed by Stolfo,  Vesonder
and  others  at  AT&T  Bell Labs. For details see "The Fifth
Generation Challenge" Proceedings ACM '84 Annual Conference.

+ Slang
A circuit design and analysis tool.  It  has  been  used  to
design  several  integrated  circuits  at  U.C. Berkeley.  A
detailed description is in the masters thesis of Korbin  Van
Dyke at U.C. Berkeley.

Available from: Industrial Liason Program, EECS  Department,
University of California, Berkeley CA 94720   (415) 642-0253

+ Lyra
A VLSI design rule checker.  A description is in the masters
thesis of Michael Arnold  at U.C. Berkeley.

+ Pearl
A database and AI representation language written  in  Franz
Lisp.   Available from Franz Inc. at no charge to purchasers
of Franz Lisp.

+ YAPS
Yet Another Production System.  Developed by  Liz  Allen  at
the  University  of  Maryland.   A forward driven production
rule system similar to OPS-5, but  with  added  flexibility.
YAPS  supports  objects in facts, and defines an object that
is a complete production system, so you can have  more  than
one expert around at a time.  See "YAPS: A Production System
Meets Object" by Liz Allen in AAAI-83 for more  information.
YAPS  is  available  at  nominal cost from the Universtiy of
Maryland.  The license fee is $100 for  BSD  4.1,  $250  for
4.2.   It's  also  Arpanet FTP'able for $100 for either ver-
sion.  Contact Bob Bane on Arpanet at  bane@maryland  or  on
Usenet  at  ...seismo!umcp-cs!bane  or  contact Liz Allen at
liz@tove.arpa or seismo!umcp-cs!liz .

+ GENIE
GENeric Inference  Engine.   An  expert  system  development
tool.   Written by John Dumer, Tim Hanratty, Paul Tanenbaum,
and Fred S. Brundick.  For more information contact: Fred S.
Brundick,

+ The Berkeley UNIX Consultant
An expert System incorporating a natural language  interface
which  answers  questions  about UNIX.  Under development at
U.C. Berkeley.  USABRL, APG, MD.  <fsbrn@brl-voc>

+ ROSS and SWIRL
ROSS is an object-oriented language developed  for  building
knowledge  based simulations.  SWIRL is a program written in
ROSS that embeds knowledge about defensive and offensive air
battle  strategies.  Developed by Narain, McArthur and Klahr
at The Rand Corporation, 1700 Main Street, Santa  Monica  CA
90406.    These  systems  were  implemented  in various LISP
environments including Franz  LISP.   A  comparison  of  hte
various  environments in terms of CPU usage, real-time usage
and user aids can be found in an article by the above in the
proceedings  of  the  1983 International Joint Conference on
Artificial Intelligence, Karlsruhe, W. Germany.

From liz@tove  Sat Apr  6 09:35:22 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA13697; Sat, 6 Apr 85 09:35:22 pst
Received: from tove.ARPA (tove.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.42)
	id AA24792; Sat, 6 Apr 85 09:35:09 pst
Received: by tove.ARPA (4.12/4.7)
	id AA10092; Sat, 6 Apr 85 12:36:17 est
Message-Id: <8504061736.AA10092@tove.ARPA>
To: franz!schlafly@BERKELEY (Roger Schlafly)
Cc: franz-friends@BERKELEY
Subject: Re: Franz Lisp applications
In-Reply-To: Your message of Fri, 5 Apr 85 10:37:18 pst.
	     <8504051837.AA00261@franz.uucp>
Date: 06 Apr 85 12:36:04 EST (Sat)
From: Liz Allen <liz@tove>

A correction to one of the entries.

	From: franz!schlafly@Berkeley (Roger Schlafly)

	+ Flavors
	An object oriented extension of Lisp, developed at  MIT  and
	the  University  of  Maryland.   Used  on the Symbolics Lisp
	machines.  Available from Franz Inc. at no  charge  to  pur-
	chasers of Franz Lisp.

Actually, there are two implmentations of flavors available for
Franz; one written at MIT and the other at Univ of Maryland.  Franz
Inc distributes the one from MIT and we (at UofM) distribute our
version as part of the Maryland software distribution (which includes
Franz 38.91).  For more information about getting our distribution,
contact Bob Bane bane@gymble.arpa or seismo!umcp-cs!bane.

				-Liz


From wfi%ucsc.csnet@csnet-relay.arpa  Tue Apr  9 02:28:37 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA07208; Tue, 9 Apr 85 02:28:37 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA14376; Tue, 9 Apr 85 02:27:14 pst
Message-Id: <8504091027.AA14376@UCB-VAX.ARPA>
Received: from ucsc by csnet-relay.csnet id ad14837; 9 Apr 85 5:28 EST
Received: by vger.UCSC (4.12/4.7)
	id AA27515; Mon, 8 Apr 85 14:09:04 pst
Date: Mon, 8 Apr 85 14:09:04 pst
From: wfi <@csnet-relay.arpa,@ucsc.CSNET:wfi@ucsc.CSNET (Wayne F. Iba)>
To: franz-friends@BERKELEY
Subject: franz profiling
Cc: wfi@ucsc.CSNET


There is a short note in the documentation of liszt that "if the lisp
system is built with profiling", then using the -p option will allow
use of the UNIX prof command etc.

Can someone explain how to rebuild (if necessary) our lisp system
accordingly?

Thanks
--wayne (wfi%ucsc.csnet)


From klahr@rand-unix  Tue Apr  9 10:03:37 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA09758; Tue, 9 Apr 85 10:03:37 pst
Received: from rand-unix.ARPA (rand-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA20618; Tue, 9 Apr 85 10:02:11 pst
Received: by rand-unix.ARPA; Tue, 9 Apr 85 09:41:46 pst
From: Phil Klahr <klahr@rand-unix>
Message-Id: <8504091741.AA17861@rand-unix.ARPA>
Date: 09 Apr 85 09:41:40 PST (Tue)
To: FRANZ-FRIENDS@BERKELEY
Cc: randvax!klahr
Subject: IJCAI-85 Registration -- Please post


The International Joint Conference on Artificial Intelligence will be
meeting in Los Angeles (at UCLA) August 18-23, 1985.  Conference
brochures (including registration information) have already been mailed
out.  If you have not received one, or would like extras, contact

	IJCAI-85
	c/o AAAI
	445 Burgess Drive
	Menlo Park, CA 94025
	415-328-3123 or 415-321-1118

Registration will be limited to 5,000 people.  Based on early projections,
up to 7,000 people may wish to attend, so early registration is highly
encouraged (if not necessary).

As a bonus, early registrants will receive a substantial reduction in
registration costs.  Through June 28, registration fees are $175 ($80 for
students); for registrations received after June 28 but prior to July 26,
fees will be $225 ($100 for students); and for on-site registration (if
available), fees will be $275 ($125 for students).  Substantial reductions
for early tutorial registrations are also in effect.

Further information on the technical conference, the tutorials, the
exhibition, and housing can be found in the conference brochure.

From jeffr@sri-spam  Tue Apr  9 16:38:17 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA00472; Tue, 9 Apr 85 16:38:17 pst
Received: from sri-spam.ARPA (sri-spam.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA29765; Tue, 9 Apr 85 16:36:41 pst
Received: by sri-spam.ARPA (4.22/4.16)
	id AA05175; Tue, 9 Apr 85 16:37:20 pst
Date: Tue, 9 Apr 85 16:37:20 pst
From: jeffr@sri-spam (Jeff Rininger)
Message-Id: <8504100037.AA05175@sri-spam.ARPA>
To: franz-friends@BERKELEY

Does anyone know of (or have) a Franz function that returns a character
corresponding to a given fixnum representation, but without the pesky
symbol delimiters that `ascii' returns ?

From g_keaton%scarolina.csnet@csnet-relay.arpa  Sat Apr 13 23:33:19 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA22504; Sat, 13 Apr 85 23:33:19 pst
Received: from csnet-relay (csnet-pdn-gw.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA13927; Sat, 13 Apr 85 23:32:05 pst
Message-Id: <8504140732.AA13927@UCB-VAX.ARPA>
Received: from scarolina by csnet-relay.csnet id a013785; 14 Apr 85 2:36 EST
Date:     Fri, 12 Apr 85 13:01 EST
From: Bonnell <g_keaton%scarolina.csnet@csnet-relay.arpa>
To: FRANZ-FRIENDS@BERKELEY
Subject:  Problems with *process.

I am attempting to have a Lisp process talk to a C process using
Lisp's *process function. This function works fine with system commands
such as 'ls' but fails when the C process is a typical user program.
I hope someone has run into similar difficulties and can provide some
enlightenment. We are using a set Sun workstations running Berkley Unix.
The same problem also occurs on our VAX. 

			Thanks,
				Gar Keaton

From narain@rand-unix  Mon Apr 15 11:33:17 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA08082; Mon, 15 Apr 85 11:33:17 pst
Received: from rand-unix.ARPA (rand-unix.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA08871; Mon, 15 Apr 85 11:31:51 pst
Received: by rand-unix.ARPA; Mon, 15 Apr 85 11:29:44 pst
From: Sanjai Narain <narain@rand-unix>
Message-Id: <8504151929.AA12668@rand-unix.ARPA>
Date: 15 Apr 85 11:29:40 PST (Mon)
To: Bonnell <g_keaton%scarolina.csnet@csnet-relay.ARPA>
Cc: FRANZ-FRIENDS@BERKELEY, narain@rand-unix
Subject: Re: Problems with *process.
In-Reply-To: Your message of Fri, 12 Apr 85 13:01 EST.
	     <8504140732.AA13927@UCB-VAX.ARPA>


I once set up a link between Franzlisp and C-Prolog using process instead of
*process and it worked fine. It was on Vax 11/780, but it was most probably
on an earlier version of Unix, rather than 4.2bsd.

-- Sanjai Narain

From chin@ucbdali  Sat Apr 20 11:50:19 1985
Received: from ucbdali.ARPA by ucbkim.ARPA (4.24/4.27)
	id AA03799; Sat, 20 Apr 85 11:50:19 pst
Received: by ucbdali.ARPA (4.24/4.45)
	id AA08585; Sat, 20 Apr 85 11:50:12 pst
Date: Sat, 20 Apr 85 11:50:12 pst
From: chin@ucbdali (David N. Chin)
Message-Id: <8504201950.AA08585@ucbdali.ARPA>
To: franz-friends@ucbdali
Subject: profiling

Does anyone have a profiling package for FRANZ that provides execution
time statistics?  The prof.l package in the lisplib only provides call
frequency statistics, and the liszt -p option only works if lisp was
created with profiling (not to mention that you would have to recompile
all your code to use it).

				Thanks in advance,
				David Chin
				chin@BERKELEY
				ucbvax!chin

From smh@mit-eddie.ARPA  Sun Apr 21 14:13:02 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.27)
	id AA17063; Sun, 21 Apr 85 14:13:02 pst
Received: from mit-eddie.ARPA (mit-eddie.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.45)
	id AA03920; Sun, 21 Apr 85 14:11:39 pst
Received: by mit-eddie.ARPA (4.12/4.8)  id AA03273; Sun, 21 Apr 85 17:11:05 est
Date: Sun, 21 Apr 85 17:11:05 est
From: Steven M. Haflich <smh@mit-eddie.ARPA>
Message-Id: <8504212211.AA03273@mit-eddie.ARPA>
To: franz-friends@BERKELEY
Subject: Gnu EMACS customization for Lisp

Lisp hackers who use Gnu EMACS might want to try this useful
customization.  It emulates the standard keybinding of CCA EMACS
that makes C-Z (i.e. control-Z) a prefix which both CONTROL- and
META-izes to the following keystroke.  This is particularly useful
for Lisp because most of the special Lisp editing commands are bound
to ESC CONTROL characters.

This text can be placed in the personal .emacs file in your home
directory.  The suspend-emacs function previously run by C-Z is
still available as either C-X C-Z or C-Z C-Z .

But first: The two "^Z" strings in the text below have been sanitized
to pass through mailers and, as mailed, contain a two character
sequence representing CONTROL-Z to humans.  You will have to edit
them to contain the single literal character C-Z, which can be typed
in EMACS via the two-keystroke sequence: C-Q C-Z .

======================================
(defun c-m-prefix ()
 "Apply both META and CONTROL to the next command character"
 (interactive)
 (command-execute
  (lookup-key esc-map (char-to-string (logand 31 (read-char))))))

(define-key global-map "^Z" 'c-m-prefix)
(define-key esc-map "^Z" 'suspend-emacs)

From @MIT-MC:wah@cmu-cs-ius.arpa  Tue Apr 23 17:48:24 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.46)
	id AA18909; Tue, 23 Apr 85 17:48:24 pst
Received: from MIT-MC (mit-mc.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.46)
	id AA10636; Tue, 23 Apr 85 17:46:11 pst
Message-Id: <8504240146.AA10636@UCB-VAX.ARPA>
Received: from CMU-CS-IUS.ARPA by MIT-MC.ARPA; 22 APR 85 12:13:41 EST
Date: 22 Apr 85 12:05:53 EST
From: Wilson.Harvey@CMU-CS-IUS
Subject: #ifdef for liszt?
To: BBoard.Maintainer@CMU-CS-A


Is there anything for the lisp compiler akin to the "#ifdef" statement
for the C compiler?  Can anyone point me to something similar?
Thanks.  -- Wilson



From liz@tove  Wed Apr 24 12:02:32 1985
Received: from UCB-VAX.ARPA (ucbvax.ARPA) by ucbkim.ARPA (4.24/4.46)
	id AA01778; Wed, 24 Apr 85 12:02:32 pst
Received: from tove.ARPA (tove.ARPA.ARPA) by UCB-VAX.ARPA (4.24/4.46)
	id AA02711; Wed, 24 Apr 85 12:00:04 pst
Received: by tove.ARPA (4.12/4.7)
	id AA15012; Wed, 24 Apr 85 15:00:27 est
Message-Id: <8504242000.AA15012@tove.ARPA>
To: Wilson.Harvey@cmu-cs-ius
Cc: franz-friends@BERKELEY
Subject: Re: #ifdef for liszt?
In-Reply-To: Your message of 22 Apr 85 12:05:53 EST.
	     <8504240146.AA10636@UCB-VAX.ARPA>
Date: 24 Apr 85 15:00:16 EST (Wed)
From: Liz Allen <liz@tove>

	From: Wilson.Harvey@CMU-CS-IUS

	Is there anything for the lisp compiler akin to the "#ifdef" statement
	for the C compiler?  Can anyone point me to something similar?
	Thanks.  -- Wilson

The reader has built into it a switch that works in both liszt and
lisp.  You can tell lisp whether or not to read an expression by
putting before that expression something like:

	#+feature	
	#-feature
	#+(or feature ...)
	#+(and feature ...)

where feature is on iff it is on the "(status features)" list (which
can be modified).  Thus you can do something like this:

	#-uomlisp (defun morerecent (file1 file2) ...)

since uomlisp is turned only in Franz's that contain all our hacks and
morerecent happens to already be defined in our stuff.  If you look at
the liszt code, you'll see lots of "#+vax"'s and "#+68k"'s where the
code needs to be different, eg:

	(defun cc-foo (x y z)
	   (bar #+vax vax-arg
		#+68k 68k-arg)
	    ...)

It can be quite convenient especially when you have two lisps that are
almost the same, you can maintain just one source containing these
things whenever the sources for the different lisps must be different.

I know this stuff is documented in the code in charmac.l; I can't
remember right now if it is documented in the Franz reference manual
and I don't have it with me right now to check.


Hope this helps.

				-Liz

EndOfFile
cat >  ./scriptcat  << 'EndOfFile'
#!/bin/csh 
# shell script which is given arguments
#	sourcedir  destdir  file1 file2 ... filen
# it generates a shell command to create those files based on
# the text that follows the command.
#  the code will come from sourcedir/filei, it will go to 
#  destdir/filei when extracted
#
set sourcedir=$argv[1]
shift argv
set destdir=$argv[1]
unset time
while ($#argv > 1)
  shift argv
  echo "cat > " $destdir/$argv[1] " << 'EndOfFile'"
  cat $sourcedir/$argv[1]
  echo EndOfFile
end
EndOfFile
cat >  ./Notice  << 'EndOfFile'
  Franz Lisp is distributed as a large shell script which, when run, will
create all necessary directories and place files in those directories.
Only source files are distributed thus this shell script should be able
to pass through any networks unaltered.

 The shell script is broken up in to a set of files named: opusVV.SS
where VV is the version number and SS is a sequence number (aa, ab, ...).
Each file is less than 200,000 bytes.  You can determine what the current
names are by using the FTP 'list directory' command after you log in.

 After you retrieve all the files you should type
	cat opus* | sh
and the distribution will be extracted in the current directory.
You may then remove the opus* files.  
 
  The file ReadMe in the current directory will then describe how to make
the lisp system.

  The files are stored on the arpanet host ucb-c70.  Log in as 'lispuser'
with password 'xxxxx'. Please do not ftp an files other than the opus*  files.



EndOfFile
cat >  ./cvt.awk  << 'EndOfFile'

{ if(begin != 1)
  { if($1 != "") flags[$1] = "on"
    if($2 != "") flags[$2] = "on"
    if($3 != "") flags[$3] = "on"
    if($4 != "") flags[$4] = "on"
    if($5 != "") flags[$5] = "on"
    skip = 0
    begin = 1
    next } }
/#ifdef/||/#elseif/ { if (flags[$2] != "") skip = -1; else skip = 1
	   	      print $0
	   	      next }
/#ifndef/ { if (flags[$2] != "") skip = 1; else skip = -1
	   	      print $0
	   	      next }
/#else/ { skip = -skip; print $0; next}
/#endif/ { skip = 0 ; print $0; next}
{ if(skip > 0)
    { if(substr($0,1,1) != "#") print "#" $0; else print $0;
      next }}
{ if(skip < 0)
    { if(substr($0,1,1) == "#") 
          print substr($0,2,length($0)-1) 
	  else print $0
      next }}
{ print $0 }


EndOfFile
chmod 775 lispconf
cat >  franz/Makefile  << 'EndOfFile'
# 
# $Header: Makefile 1.10 83/07/06 02:24:04 layer Exp $
#
#  Franz Lisp C coded kernel, Machine independent part.
#
#  The directions for modifying this file are found in the machine
# dependent Makefiles (subdirectories vax/ or 68k/)


Includes = h/config.h 	h/global.h 	h/aout.h 	h/vaxframe.h \
	h/catchfram.h 	h/dfuncs.h 	h/gtabs.h 	h/sigtab.h \
	h/chars.h 	h/frame.h 	h/lfuncs.h 	h/structs.h \
	h/chkrtab.h 	h/gc.h 		h/lispo.h 	h/types.h \
	h/lconf.h	h/ltypes.h	h/68kframe.h	h/hpagsiz.h\
	h/duallispo.h	h/dualaout.h

AllSrc = Makefile ${Includes}

clean:
	rm *.o

#--- copysource : copy source files to another directory
#  called via   make CopyTo=/xx/yyy/zz copysource
# 
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@(cd .. ; scriptcat franz franz ${AllSrc})
EndOfFile
cat >  franz/h/config.h  << 'EndOfFile'
/*					-[Thu Mar  3 15:57:51 1983 by jkf]-
 * 	config.h			$Locker:  $
 * configuration dependent info
 *
 * $Header: config.h,v 1.15 85/03/24 11:06:27 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
/* 
 * this file contains parameters which each site is likely to modify
 * in order to personalize the configuration of Lisp at their site.
 * The typical things to modifiy are:
 *    [optionally] turn on GCSTRINGS
 *    [optionally] provide a value for SITE 
 */

/*
 * The type of machine and os this is to run on will come from
 * the file lconf.h.  The lconf.h file is created by the shell script
 * 'lispconf' in the directory ../..
 * lconf.h will define exactly one of these symbols:
 *  vax_4_2 vax_4_1c vax_4_1a vax_4_1 vax_unix_ts vax_eunice_vms
 *  sun_4_2 sun_4_1c sun_unisoft dual_unisoft pixel_unisoft lisa_unisys3
 *  mc500_2_0
 */
#include "lconf.h"


/* GCSTRINGS - define this if you want the garbage collector to reclaim
 *  strings.  It is not normally set because in typical applications the
 *  expense of collecting strings is not worth the amount of space
 *  retrieved
 */
 
/* #define GCSTRINGS */

/*
 * set up the global defines based on the choice above
 * the global names are
 * operating system:
 *		  os_unix
 *		     os_4_1, os_4_1a, os_4_1c, os_4_2, os_unix_ts
 *		  os_vms
 */

/* OFFSET -  this is the offset to the users address space. */
/* NB: this is not necessarily tied to the hardware.  Pixel
   informs us that when they put up 4.1 the offsetis likely
   to change */

#if vax_4_1 || vax_4_1a || vax_4_1c || vax_4_2 || vax_4_3 || vax_unix_ts || vax_eunice_vms
#define m_vax 1
#endif

#if sun_4_2beta || sun_4_2 || sun_4_1c
#define m_68k		1
#define OFFSET		0x8000
#endif

#if sun_unisoft
#define m_68k		1
#define	OFFSET		0x40000
#endif

#if dual_unisoft
#define m_68k		1
#define m_68k_dual	1
#define OFFSET		0x800000
#endif

#if pixel_unisoft
#define m_68k		1
#define OFFSET		0x20000
#endif

#if lisa_unisys3
#define m_68k		1
#define OFFSET		0x20000
#define unisys3botch	1
#define os_unix_ts	1
#endif

#if mc500_2_0
#define OFFSET 0
#define m_68k 1
#define os_masscomp 1
#endif

/* next the operating system */
#if vax_4_1 || vax_4_1a || vax_4_1c || vax_4_2 || vax_4_3 || vax_unix_ts || m_68k
#define os_unix		1
#endif

#if vax_4_1
#define os_4_1		1
#endif
#if vax_4_1a
#define os_4_1a		1
#endif
#if vax_4_1c || sun_4_1c
#define os_4_1c 	1
#endif
#if vax_4_2 || sun_4_2 || sun_4_2beta
#define os_4_2	 	1
#endif
#if vax_4_3
#define os_4_3		1
#endif
#if vax_unix_ts
#define os_unix_ts 	1
#endif
#if vax_eunice_vms
#define os_vms		1
#endif

#if sun_unisoft || dual_unisoft || pixel_unisoft
#define os_unisoft 1
#endif

/* MACHINE -  this is put on the (status features) list */
#if m_68k
#define MACHINE "68k"
#define PORTABLE
#endif

/* RTPORTS -- this O.S. allocates FILE *'s at run-time */
#if os_4_3
#define RTPORTS 1
#endif

#if m_vax
#define MACHINE "vax"
#define NILIS0	1
#endif

/*
** NILIS0 -- for any UNIX implementation in which the users
**	address space starts at 0 (like m_vax, above). 
**
** NPINREG -- for the verison if lisp that keeps np and lbot in global
**	registers.  On the 68000, there is a special `hacked' version
**	of the C compiler that is needed to do this.
**
** #define NILIS0		1
** #define NPINREG		1
*/

/*
 * SPISFP -- this is to indicate that the stack and frame pointer
 * are the same, or at least that you can't pull the same shenanigans
 * as on the vax or sun by pushing error frames at the end of C
 * frames and using alloca.  This should make life easier for
 * a native VMS version or IBM or RIDGE or Bellmac-32.
 * #define SPISFP 1
 */

#if sun_4_2beta
#define SPISFP 1
#endif

#if m_vax
#define OFFSET		0x0
#define NPINREG		1
#endif




/* OS -  this is put on the (status features) list */
#if os_unix
#define OS      "unix"
#endif
#if os_vms
#define OS 	"vms"
#endif

/* DOMAIN - this is put on the (status features) list and
 * 	is the value of (status domain)
 */
#define DOMAIN  "ucb"

/* SITE - the name of the particular machine this lisp is running on
 *    this value is available via (sys:gethostname).
 *    On 4.1a systems it is possible to determine this dynamically cheaply
 */
#if ! (os_4_1a || os_4_1c || os_4_2 || os_4_3)
#define SITE    "unknown-site"
#endif


/*  TTSIZ is the absolute limit, in pages (both text and data), of the
 * size to which the lisp system may grow.
 * If you change this, you must recompile alloc.c and data.c.
 */
#if (sun_4_2 || sun_4_2beta || HOLE)
#define TTSIZE 10216
#else
#define TTSIZE 6120
#endif

#if m_vms 
#undef TTSIZE
#define TTSIZE 10216
#define FREESIZE 512 * 10000
#endif 
EndOfFile
cat >  franz/h/global.h  << 'EndOfFile'
/*					-[Sun Jun 19 14:42:59 1983 by jkf]-
 * 	global.h			$Locker:  $
 * main include file 
 *
 * $Header: global.h,v 1.11 85/03/24 11:06:11 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include <stdio.h>
#include "config.h"
#include "ltypes.h"
#ifdef UNIXTS
#include "tsfix.h"
#endif

#define AD 0

#define	peekc(p)	(p->_cnt>0? *(p)->_ptr&0377:_filbuf(p)==-1?-1:((p)->_cnt++,*--(p)->_ptr&0377))

#define FALSE	0
#define	TRUE	1
#define EVER	;;
#define STRBLEN 512
#define LBPG	512


#define	NULL_CHAR	0
#define	LF	'\n'
#define	WILDCHR	'\0177'


/* the numbers per page of the different data objects *******************/

#define NUMSPACES (VECTORI+1)

#define ATOMSPP 25
#define STRSPP 1
#define INTSPP 128
#define DTPRSPP 64
#define DOUBSPP 64
#define ARRAYSPP 25
#define SDOTSPP 64
#define VALSPP 128
#define BCDSPP 64


#define HUNK2SPP 64		 /* hunk page sizes */
#define HUNK4SPP 32
#define HUNK8SPP 16
#define HUNK16SPP 8
#define HUNK32SPP 4
#define HUNK64SPP 2
#define HUNK128SPP 1
#define VECTORSPP 512

/* offset of size info from beginning of vector,  in longwords */
/* these values are not valid when a vector is stored in the free */
/* list, in which case the chaining is done through the propery field */
#define VSizeOff -2
#define VPropOff -1

/* VecTotSize: the total number of longwords for the data segment of
 * the vector. Takes a byte count and rounds up to nearest long.
 */

#define VecTotSize(x)  (((x)+3) >> 2)
#define VecTotToByte(x) ((x) * sizeof(long))

/* these vector size macros determine the number of complete objects
   in the vector
 */
#define VecSize(x) 	((x) >> 2)
#define VecWordSize(x)	((x) >> 1)
#define VecByteSize(x)	(x)

/* maximum and minimum fixnums */
#define MaxINT 0x3fffffff
#define MinINT (- 0x4000000)
/* 
 * macros for saving state and restoring state
 *
 * Savestack and Restorestack are required at the beginning and end of
 * functions which modify the stack pointers np and lbot.
 * The Savestack(n) should appear at the end of the variable declarations
 * The n refers to the number of register variables declared in this routine.
 * The information is required for the Vax version only.
 */
#ifdef PORTABLE
extern struct atom nilatom, eofatom;
#define nil	((lispval) &nilatom)
#define eofa	((lispval) &eofatom)
#define Savestack(n) struct argent *OLDlbot = lbot, *OLDnp = np
#define Restorestack() (lbot = OLDlbot), np = OLDnp
#else
#define nil	((lispval) 0)
#define eofa	((lispval) 20)
#define Savestack(n) snpand(n)
#define Restorestack() 
#endif

#ifdef SIXONLY
#define errorh1 errh1
#define errorh2 errh2
#endif

#define	CNIL	((lispval) (OFFSET-4))
#define NOTNIL(a)	(nil!=a)
#define ISNIL(a)	(nil==a)

#ifdef SPISFP
extern long *xsp, xstack[];
#define sp() xsp
#define stack(z) (xsp > xstack ? (*--xsp = z): xserr())
#define unstack() (*xsp++)
#define Keepxs() long *oxsp = xsp;
#define Freexs() xsp = oxsp;
#else
extern long *sp(), stack(), unstack();
#define Keepxs() /* */
#define Freexs() /* */
#endif

extern char typetable[];  /*  the table with types for each page  */
#define ATOX(a1)	((((int)(a1)) - OFFSET) >> 9)
#define	TYPE(a1)	((typetable+1)[ATOX(a1)])
#define	TYPL(a1)	((typetable+1)[ATOX(a1)])
#define SETTYPE(a1,b,c)   {if((itemp = ATOX(a1)) >= fakettsize) \
			 { if(fakettsize >= TTSIZE) \
			   {\
			      printf(" all space exausted, goodbye\n");\
			      exit(1);\
			   }\
			   fakettsize++;  badmem(c);\
			 }\
			(typetable + 1)[itemp] = (b); }

#define	HUNKP(a1)	((TYPE(a1) >= 11) & (TYPE(a1) <= 17))
#define	HUNKSIZE(a1)	((TYPE(a1)+5) & 15)

#define UPTR(x)	((unsigned)(((long)(x))-(long)CNIL))
#define VALID(a)	(UPTR(a) <= UPTR(datalim))

#define Popframe() (errp->olderrp)


/* some types ***********************************************************/
#define lispint long
#define MAX10LNG 200000000		/* max long divided by 10	*/


typedef union lispobj *lispval ;

struct dtpr {
	lispval	cdr, car;
};

struct sdot {
	int 	I;
	lispval	CDR;
};


struct	atom	{
	lispval		clb;		/* current level binding*/
	lispval 	plist;		/* pointer to prop list	*/
#ifndef WILD
	lispval		fnbnd;		/* function binding	*/
#endif
	struct	atom	*hshlnk;	/* hash link to next	*/
	char		*pname;		/* print name	*/
	};
#ifdef WILD
#define fnbnd clb
#endif

struct array {
	lispval accfun,		/*  access function--may be anything  */
		aux;		/*  slot for dimensions or auxilliary data  */
	char *data;		/*  pointer to first byte of array    */
	lispval length, delta;	/* length in items and length of one item */
};

struct bfun {
	lispval (*start)();	/*  entry point to routine  */
	lispval	discipline,	/*  argument-passing discipline  */
		language,	/*  language coded in	*/
		params,		/*  parameter list if relevant  */
		loctab;		/*  local table  */
};

struct Hunk {
	lispval hunk[1];
};

struct Vector {
        lispval vector[1];
};

/* the vectori types */
struct Vectorb {
    	char vectorb[1];
};

struct Vectorw {
       short  vectorw[1];
};

struct Vectorl {
    long vectorl[1];
};

union lispobj {
	struct atom a;
	FILE *p;
	struct dtpr d;
	long int i;
	long int *j;
	double r;
	lispval (*f)();
	struct array ar;
	struct sdot s;
	char c;
	lispval l;
	struct bfun bcd;
	struct Hunk h;
	struct Vector v;
	struct Vectorb vb;
	struct Vectorw vw;
	struct Vectorl vl;
};

#ifdef lint
extern lispval Inewint();
#define inewint(p) Inewint((long)(p))
#else
extern lispval inewint();
#endif


#include "sigtab.h"   /* table of all pointers to lisp data */

/* Port definitions *****************************************************/
extern FILE	*piport,		/* standard input port		*/
	*poport,		/* standard output port		*/
	*errport,		/* port for error messages	*/
	*rdrport;		/* temporary port for readr	*/

#ifndef RTPORTS
extern FILE *xports[];		/* page of file *'s for lisp	*/
#define P(p)		((lispval) (xports +((p)-_iob)))
#define PN(p)		((int) ((p)-_iob))
#else
extern lispval P();
extern FILE **xports;
#define PN(p) (((FILE **)P(p))-xports)
#endif

extern int lineleng ;		/* line length desired		*/
extern char rbktf;		/* logical flag: ] mode		*/
extern unsigned char *ctable;		/* Character table in current use */
#define Xdqc ctable[131]
#define Xesc ctable[130]
#define Xsdc ctable[129]

/* name stack ***********************************************************/

#define NAMESIZE 3072

/* the name stack limit is raised by NAMINC every namestack overflow to allow
   a user function to handle the error
*/
#define NAMINC 25

extern struct nament {
	lispval	val,
		atm;
}	*bnp,			/* first free bind entry*/
	*bnplim;		/* limit of bindstack   */

struct argent {
	lispval	val;
};
extern struct argent *lbot, *np, *namptr;
extern struct nament	*bnp;			/* first free bind entry*/
extern struct argent *nplim;	 	/* don't have this = np	*/
extern struct argent *orgnp;	/* used by top level to reset to start  */
extern struct nament *orgbnp;	/* used by top level to reset to start  */
extern struct nament *bnplim;		/* limit of bindstack   */
extern struct argent	*np,			/* top entry on stack	*/
		*lbot,			/* bottom of cur frame	*/
		*namptr;		/* temporary pointer	*/
extern lispval sigacts[16];
extern lispval hunk_pages[7], hunk_items[7], hunk_name[7];

extern lispval Vprintsym;

#define TNP	if(np >= nplim) namerr();

#define TNP	if(np >= nplim) namerr();
#define INRNP	if (np++ >= nplim) namerr();
#define protect(p) (np++->val = (p))
#define chkarg(p,x); if((p)!=np-lbot) argerr(x);


/** status codes **********************************************/
/*							      */
/* these define how status and sstatus should service probes  */
/* into the lisp data base				      */

/* common status codes */
#define ST_NO 0

/* status codes */
#define ST_READ 1
#define ST_FEATR 2
#define ST_SYNT 3
#define ST_RINTB 4
#define ST_NFETR 5
#define ST_DMPR  6
#define ST_CTIM  7
#define ST_LOCT  8
#define ST_ISTTY 9
#define ST_UNDEF 10

/* sstatus codes */
#define ST_SET 1
#define ST_FEATW 2
#define ST_TOLC 3
#define ST_CORE 4
#define ST_INTB 5
#define ST_NFETW 6
#define ST_DMPW  7
#define ST_AUTR 8
#define ST_TRAN 9
#define ST_BCDTR 10
#define ST_GCSTR 11


/* number of counters for fasl to use in a profiling lisp  */
#define NMCOUNT 5000

/* hashing things *******************************************************/
#define	HASHTOP	1024	/*  we handle 8-bit characters by dropping top bit  */
extern struct	atom	*hasht[HASHTOP];
extern int	hash;		/* set by ratom		*/
extern int	atmlen;		/* length of atom including final null	*/


/** exception handling ***********************************************/
extern int exception;	/* if TRUE then an exception is pending, one of */
			/* the below 				        */
extern int sigintcnt;   /* if > 0 then there is a SIGINT pending	*/

/* big string buffer for whomever needs it ******************************/
extern char	*strbuf;
extern char	*endstrb;

/* break and error declarations *****************************************/
#define	SAVSIZE	44		/* number of bytes saved by setexit	*/
#define	BRRETB	1
#define BRCONT	2
#define	BRGOTO	3
#define	BRRETN	4
#define INTERRUPT 5
#define THROW	6
extern int	depth;		/* depth of nested breaks		*/
extern lispval	contval;	/* the value being returned up		*/
extern int	retval;		/* used by each error/prog call		*/
extern lispval  lispretval;	/* used by non-local go			*/
extern int	rsetsw;		/* used by *rset mode			*/
extern int	evalhcallsw;	/* used by evalhook			*/
extern int	funhcallsw;	/* used by evalhook			*/


/* other stuff **********************************************************/
extern lispval	ftemp,vtemp,argptr,ttemp;	/* temporaries: use briefly  */
extern int itemp;
					/* for pointer type conversion  */
#include	"dfuncs.h"

#define	NUMBERP	2
#define	BCDP	5
#define	PORTP	6
#define ARRAYP	7

#define	ABSVAL	0
#define	MINUS	1
#define	ADD1	2
#define	SUB1	3
#define	NOT	4
#define	LNILL	5
#define	ZEROP	6
#define	ONEP	7
#define	PLUS	8
#define	TIMES	9
#define	DIFFERENCE	10
#define	QUOTIENT	11
#define	MOD	12
#define	LESSP	13
#define	GREATERP	14
#define	SUM	15
#define	PRODUCT	16
#define	AND	17
#define	OR	18
#define	XOR	19

interpt();
handler();  extern sigdelay, sigstruck;

/* limit of valid data area **************************************/

extern lispval datalim;

/** macros to push and pop the value of an atom on the stack ******/

#define PUSHDOWN(atom,value)\
	{bnp->atm=(atom);bnp++->val=(atom)->a.clb;(atom)->a.clb=value;\
	if(bnp>bnplim) binderr();}

#define POP\
	{--bnp;bnp->atm->a.clb=bnp->val;}

/* PUSHVAL  is used to store a specific atom and value on the
 * bindstack.   Currently only used by closure code
 */  
#define PUSHVAL(atom,value)\
	{bnp->atm=(atom);bnp++->val=value;\
	if(bnp>bnplim) binderr();}

/** macro for evaluating atoms in eval and interpreter  ***********/

#define EVALATOM(x)	vtemp = x->a.clb;\
			if( vtemp == CNIL ) {\
				printf("%s: ",(x)->a.pname);\
				vtemp = error("UNBOUND VARIABLE",TRUE);}

/*  having to do with small integers					*/
extern long Fixzero[];
#define SMALL(i)	((lispval)(Fixzero + i))
#define okport(arg,default) (vtemp = arg,((TYPE((vtemp))!=PORT)?default:(vtemp)->p))

extern lispval ioname[];	/* names of open files */
/*  interpreter globals   */

extern int lctrace;

/* register lisp macros for registers */

#define saveonly(n)	asm("#save	n")
#define snpand(n)	asm("#protect	n")
EndOfFile
cat >  franz/h/aout.h  << 'EndOfFile'
/*
 * Header prepended to each a.out file.
 */
struct exec {
	long	a_magic;	/* magic number */
unsigned long	a_text;		/* size of text segment */
unsigned long	a_data;		/* size of initialized data */
unsigned long	a_bss;		/* size of uninitialized data */
unsigned long	a_syms;		/* size of symbol table */
unsigned long	a_entry;	/* entry point */
unsigned long	a_trsize;	/* size of text relocation */
unsigned long	a_drsize;	/* size of data relocation */
};

#define	OMAGIC	0407		/* old impure format */
#define	NMAGIC	0410		/* read-only text */
#define	ZMAGIC	0413		/* demand load format */

/*
 * Macros which take exec structures as arguments and tell whether
 * the file has a reasonable magic number or offsets to text|symbols|strings.
 */
#define	N_BADMAG(x) \
    (((x).a_magic)!=OMAGIC && ((x).a_magic)!=NMAGIC && ((x).a_magic)!=ZMAGIC)

#define	N_TXTOFF(x) \
	((x).a_magic==ZMAGIC ? 1024 : sizeof (struct exec))
#define N_SYMOFF(x) \
	(N_TXTOFF(x) + (x).a_text+(x).a_data + (x).a_trsize+(x).a_drsize)
#define	N_STROFF(x) \
	(N_SYMOFF(x) + (x).a_syms)

/*
 * Format of a relocation datum.
 */
struct relocation_info {
	int	r_address;	/* address which is relocated */
unsigned int	r_symbolnum:24,	/* local symbol ordinal */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long */
		r_extern:1,	/* does not include value of sym referenced */
		:4;		/* nothing, yet */
};

/*
 * Format of a symbol table entry; this file is included by <a.out.h>
 * and should be used if you aren't interested the a.out header
 * or relocation information.
 */
struct	nlist {
	union {
		char	*n_name;	/* for use when in-core */
		long	n_strx;		/* index into file string table */
	} n_un;
unsigned char	n_type;		/* type flag, i.e. N_TEXT etc; see below */
	char	n_other;	/* unused */
	short	n_desc;		/* see <stab.h> */
unsigned long	n_value;	/* value of this symbol (or sdb offset) */
};
#define	n_hash	n_desc		/* used internally by ld */

/*
 * Simple values for n_type.
 */
#define	N_UNDF	0x0		/* undefined */
#define	N_ABS	0x2		/* absolute */
#define	N_TEXT	0x4		/* text */
#define	N_DATA	0x6		/* data */
#define	N_BSS	0x8		/* bss */
#define	N_COMM	0x12		/* common (internal to ld) */
#define	N_FN	0x1f		/* file name symbol */

#define	N_EXT	01		/* external bit, or'ed in */
#define	N_TYPE	0x1e		/* mask for all the type bits */

/*
 * Sdb entries have some of the N_STAB bits set.
 * These are given in <stab.h>
 */
#define	N_STAB	0xe0		/* if any of these bits set, a SDB entry */

/*
 * Format for namelist values.
 */
#define	N_FORMAT	"%08x"
EndOfFile
cat >  franz/h/vaxframe.h  << 'EndOfFile'
/*					-[Sat Jan 29 14:02:34 1983 by jkf]-
 * 	vaxframe.h			$Locker:  $
 * vax calling frame definition
 *
 * $Header: vaxframe.h,v 1.3 84/02/29 15:06:57 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

struct machframe {
	lispval	(*handler)();
	long	mask;
	lispval	*ap;
struct 	machframe	*fp;
	lispval	(*pc)();
	lispval	*r6;
	lispval *r7;
};
EndOfFile
cat >  franz/h/catchfram.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:56:53 1983 by jkf]-
 * 	catchfram.h			$Locker:  $
 * catch frame definition
 *
 * $Header: /na/franz/franz/h/catchfram.h,v 1.1 83/01/29 14:02:54 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

struct catchfr {		/* catch and errset frame */
    struct catchfr *link;	/* link to next catchframe */
	   lispval flag;		/* Do we print ?  */
	   lispval labl;	/* label caught at this point  */
    struct nament *svbnp;	/* saved bnp */
	   lispval retenv[11];  /* reset environment - actually a savblock */
	   lispval rs[4];	/* regis 6-11 and 13 */
       lispval (*retadr)();	/* address to continue execution */
};

struct savblock {
	lispval envir[10];
	struct savblock *savlnk;
};
EndOfFile
cat >  franz/h/dfuncs.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:54:30 1983 by jkf]-
 * 	dfuncs.h			$Locker:  $
 * external function declaration
 *
 * $Header: dfuncs.h,v 1.2 84/02/29 17:09:10 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
char *brk();
char *getsp();
char *pinewstr();
char *inewstr();
char *mkmsg();
char *newstr();
char *rstore();
char *sbrk();
char *xsbrk();
char *ysbrk();
int csizeof();
int finterp();
lispval Iget();
lispval Imkrtab();
lispval Iputprop();
lispval Lfuncal();
lispval Lnegp();
lispval Lsub();
lispval alloc();
lispval copval();
lispval csegment();
lispval error();
lispval errorh();
lispval errorh1();
lispval errorh2();
lispval eval();
lispval gc();
lispval getatom();
lispval inewval();
lispval linterp();
lispval matom();
lispval mfun();
lispval mstr();
lispval newarray();
lispval newdot();
lispval newdoub();
lispval newfunct();
lispval newint();
lispval newsdot();
lispval newval();
lispval newhunk();
lispval pnewdot();
lispval pnewdb();
lispval pnewhunk();
lispval pnewint();
lispval pnewsdot();
lispval pnewval();
lispval popnames();
lispval r();
lispval ratomr();
lispval readr();
lispval readrx();
lispval readry();
lispval typred();
lispval unprot();
lispval verify();
struct atom * newatom();
EndOfFile
cat >  franz/h/gtabs.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:57:36 1983 by jkf]-
 * 	gtabs.h				$Locker:  $
 * global lispval table
 *
 * $Header: /na/franz/franz/h/gtabs.h,v 1.1 83/01/29 14:06:37 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

/*  these are the tables of global lispvals known to the interpreter	*/
/*  and compiler.  They are not used by the garbage collector.		*/
#define GFTABLEN 200
#define GCTABLEN 8
extern lispval gftab[GFTABLEN];
extern lispval gctab[GCTABLEN];
EndOfFile
cat >  franz/h/sigtab.h  << 'EndOfFile'
/*					-[Sat May  7 20:46:54 1983 by jkf]-
 * 	sigtab.h			$Locker:  $
 * table of lispvals needed by C 
 *
 * $Header: sigtab.h 1.4 83/06/09 01:15:47 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

/*
 *  lispvals in use by the program should be in this table.
 *  Otherwise they may get garbage-collected.
 */

#define SIGNIF 139

extern lispval lispsys[SIGNIF];

#define tatom (lispsys[1])
#define lambda (lispsys[2])
#define nlambda (lispsys[3])
#define perda (lispsys[4])
#define lpara (lispsys[5])
#define rpara (lispsys[6])
#define lbkta (lispsys[7])
#define rbkta (lispsys[8])
#define Eofa (lispsys[9])
#define snqta (lispsys[10])
#define exclpa (lispsys[11])
#define quota (lispsys[12])
#define xatom (lispsys[13])
#define cara (lispsys[14])
#define cdra (lispsys[15])
#define gcafter (lispsys[16])
#define noptop (lispsys[17])
#define gcthresh (lispsys[18])
#define int_name (lispsys[19])
#define str_name (lispsys[20])
#define atom_name (lispsys[21])
#define doub_name (lispsys[22])
#define dtpr_name (lispsys[23])
#define int_items (lispsys[24])
#define int_pages (lispsys[25])
#define str_items (lispsys[26])
#define str_pages (lispsys[27])
#define dtpr_items (lispsys[28])
#define dtpr_pages (lispsys[29])
#define doub_items (lispsys[30])
#define doub_pages (lispsys[31])
#define atom_items (lispsys[32])
#define atom_pages (lispsys[33])
#define gccall1 (lispsys[34])
#define gccall2 (lispsys[35])
#define sysa (lispsys[36])
#define plima (lispsys[37])
#define macro (lispsys[38])
#define startup (lispsys[39])
#define rcomms (lispsys[40])
#define commta (lispsys[41])
#define plimit (lispsys[44])
#define array_items (lispsys[45])
#define array_pages (lispsys[46])
#define array_name  (lispsys[47])
#define sdot_items (lispsys[48])
#define sdot_pages (lispsys[49])
#define sdot_name (lispsys[50])
#define val_items (lispsys[51])
#define val_pages (lispsys[52])
#define val_name  (lispsys[53])
#define splice	(lispsys[54])
#define rdrsdot (lispsys[55])
#define funct_items (lispsys[56])
#define funct_pages (lispsys[57])
#define funct_name (lispsys[58])
#define nstack (lispsys[59])
#define rdrint (lispsys[63])
#define nilplist (lispsys[64])
#define badst (lispsys[65])
#define gccheck (lispsys[66])
#define gcport (lispsys[67])
#define gcdis (lispsys[68])
#define gcload (lispsys[69])
#define loading (lispsys[70])
#define noautot (lispsys[71])
#define lcode (lispsys[72])
#define ccode (lispsys[73])
#define odform (lispsys[74])
#define bcdst (lispsys[75])
#define listst (lispsys[76])
#define macrost (lispsys[77])
#define protst (lispsys[78])
#define argst (lispsys[79])
#define arrayst (lispsys[80])
#define proga (lispsys[81])
#define progma (lispsys[82])
#define bstack (lispsys[83])
#define lexpr_atom (lispsys[84])
#define lexpr (lispsys[85])
#define ibase (lispsys[86])
#define Vpiport (lispsys[87])
#define Vpoport (lispsys[88])
#define Veval (lispsys[89])
#define Vererr (lispsys[90])
#define Vertpl (lispsys[91])
#define Verall (lispsys[92])
#define Vermisc (lispsys[93])
#define Vlerall (lispsys[94])
#define stlist (lispsys[95])
#define Vreadtable (lispsys[96])
#define strtab (lispsys[97])
#define Verbrk (lispsys[98])
#define Vnogbar (lispsys[99])
#define rdrsdot2 (lispsys[100])
#define Veruwpt (lispsys[101])

#define hunkfree (lispsys[102])
#define port_name (lispsys[103])
#define reseta (lispsys[104])
#define rsetatom (lispsys[105])
#define bptr_atom (lispsys[106])
#define evalhatom (lispsys[107])
#define funhatom (lispsys[108])
#define Vptport (lispsys[109])
#define Vcntlw  (lispsys[110])
#define Verrset (lispsys[111])
#define Verundef (lispsys[112])
#define Vsubrou (lispsys[113])
#define Vprinlevel (lispsys[114])
#define Vprinlength (lispsys[115])
#define Vfloatformat (lispsys[116])
#define Vldprt  (lispsys[117])
#define Verdepth  (lispsys[118])
#define mrtabspace (lispsys[119])
#define pnameprot (lispsys[120])
#define other_name (lispsys[121])
#define Vevalframe (lispsys[122])
#define Vpurcopylits (lispsys[123])
#define vect_name (lispsys[124])
#define vecti_name (lispsys[125])
#define vect_items (lispsys[126])
#define vecti_items (lispsys[127])
#define vect_pages (lispsys[128])
#define vecti_pages (lispsys[129])
#define Vdisplacemacros (lispsys[130])
#define other_pages (lispsys[131])
#define other_items (lispsys[132])
#define fclosure (lispsys[133])
#define Vgcprint (lispsys[134])
#define clos_marker (lispsys[135])
#define Vpbv (lispsys[136])
#define atom_buffer (lispsys[137])
#define Vlibdir (lispsys[138])

/* various status switches */

extern lispval stattab[16] ;
#define Schainp (stattab[0])
#define Sautor (stattab[1])
#define Strans (stattab[2])
#define evalhsw (stattab[3])
EndOfFile
cat >  franz/h/chars.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:52:05 1983 by jkf]-
 * 	chars.h				$Locker:  $
 * lexical table 
 *
 * $Header: /na/franz/franz/h/chars.h,v 1.1 83/01/29 14:03:08 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

/* the format of the entries are:       ab..xxxx			*/
/*									*/
/* where a is set iff the atom containing the symbol must be quoted	*/
/* where b is set iff the character separates atoms normally		*/
/* where xxxx is a number unique to the class of symbol			*/

#define	CNUM	0000
#define CSIGN   0001
#define CCHAR	0002
#define	CLPARA	0003
#define CRPARA	0004
#define CPERD	0005
#define	CLBRCK	0006
#define	CRBRCK	0007
#define	CSQ	0011
#define	CDQ	0012
#define	CERR	0013
#define	CSEP	0014
#define CSPL	0015
#define CMAC	0016
#define CESC	0017
#define CSCA	0020
#define CSD	0021
#define CSMAC	0022
#define CSSPL	0023
#define CINF	0024
#define CSINF	0025

#define	VNUM	0000
#define VMINUS	0001
#define VSIGN   0001
#define VCHAR	0002
#define	VLPARA	(CLPARA|QALWAYS|SEPMASK)
#define VRPARA	(CRPARA|QALWAYS|SEPMASK)
#define VPERD	(CPERD|QWNUNIQ)
#define	VLBRCK	(CLBRCK|QALWAYS|SEPMASK)
#define	VRBRCK	(CRBRCK|QALWAYS|SEPMASK)
#define	VSQ	(CSQ|QALWAYS|SEPMASK)
#define	VDQ	(CDQ|QALWAYS)
#define	VERR	(CERR|QALWAYS|SEPMASK)
#define	VSEP	(CSEP|QALWAYS|SEPMASK)
#define VSPL	(CSPL|QALWAYS|SEPMASK)
#define VMAC	(CMAC|QALWAYS|SEPMASK)
#define VESC	(CESC|QALWAYS)
#define VSCA	(CSCA|SEPMASK)
#define VSD	(CSD|QALWAYS)
#define VSMAC	(CSMAC|QWNUNIQ)
#define VSSPL	(CSSPL|QWNUNIQ)
#define VINF	0024
#define VSINF	(CSINF|QWNUNIQ)


#define QUTMASK	0300
#define	SEPMASK	0040
#define QALWAYS 0300
#define QWNUNIQ 0100
#define QWNFRST 0200

#define synclass(p) (p & 037)

#define TSCA	1
#define TLPARA	2
#define TRPARA	3
#define TPERD	4
#define TEOF	5
#define TSPL	6
#define TMAC	7
#define TSQ	8
#define TLBKT	9
#define TINF	10
EndOfFile
cat >  franz/h/frame.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:55:13 1983 by jkf]-
 * 	frame.h				$Locker:  $
 * non local goto frame definition
 *
 * $Header: frame.h,v 1.3 83/09/12 15:29:08 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
/* classes of frames: */
#define F_PROG  	1
#define F_CATCH 	2
#define F_RESET 	3
#define F_EVAL		4
#define F_FUNCALL	5
#define F_TO_FORT	6
#define F_TO_LISP	7

/* classes of things thrown up */
#define C_INITIAL	0
#define C_GO    	1
#define C_RET   	2
#define C_THROW 	3
#define C_RESET 	4
#define C_FRETURN	5


/* the evaluation frame sits on the C runtime stack.  the global variable errp
   points to the newest frame. The base of the frame points in the middle
   of the frame, but in such a way that above the frame base the contents
   are the same for all implementation, and below it there are different
   saved registers for each machine. 
*/

struct frame 
{
    struct argent *svlbot, *svnp;
    struct nament *svbnp;
    struct frame *olderrp;
    lispval retaddr;
    long class;
    lispval larg1;	/* optional */
    lispval larg2;	/* optional */
};

extern struct frame *errp, *Pushframe(), *Ipushf();

/* stuff for IBM, RIDGE, DEC-VMS CC, maybe Bellmac-32
 *
 * The non obvious requirement is that any new function
 * requiring a Pushframe must declare 
 *
 * 	pbuf pb;
 *
 * as well.
 */

#ifdef SPISFP
#define Pushframe(a,b,c) Ipushf(a,b,c,&pb)
#endif


typedef struct pframe
{
	long regs[16];
	struct frame f;
} pbuf;
EndOfFile
cat >  franz/h/lfuncs.h  << 'EndOfFile'
/*					-[Sat Feb 11 14:47:50 1984 by layer]-
 * 	lfuncs.h			$Locker:  $
 * lisp external function definitons
 *
 * $Header: lfuncs.h,v 1.6 84/02/29 17:08:03 sklower Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

/* these functions never return values.  The declarations
   are merely to shut lint up. */
lispval Lcont();
lispval Lexit();
lispval Lreturn();
lispval Ngo();
lispval Nreset();
lispval Nthrow();
lispval Ntpl();

/* Begin functions which return values */

lispval Lstacktrace();
lispval Lunstacktrace();

lispval	Lalfalp();
lispval	Lfseek();
lispval LDivide();
lispval LIfss();
lispval LEmuldiv();
lispval LIvref();
lispval LIvset();
lispval LIvsize();
lispval LMakhunk();
lispval Lsprintf();
lispval Labsval();
lispval Lacos();
lispval Ladd();
lispval Ladd1();
lispval Lalloc();
lispval Lallpackages();
lispval Lapply();
lispval Larayref();
lispval Larg();
lispval Largv();
lispval Larrayp();
lispval Lascii();
lispval Lasin();
lispval Lassq();
lispval Latan();
lispval Latom();
lispval Lbaktrace();
lispval Lbcdad();
lispval Lbcdp();
lispval Lbigtol();
lispval Lbiglsh();
lispval Lbind();
lispval Lboole();
lispval Lboundp();
lispval Lc02r();
lispval Lc03r();		/* cdddr */
lispval Lc04r();		/* cddddr */
lispval Lc12r();		/* caddr */
lispval Lc13r();		/* cadddr */
lispval Lc14r();		/* caddddr */
lispval Lcaar();
lispval Lcadr();
lispval Lcar();
lispval Lcdr();
lispval Lcfasl();
lispval Lcharindex();
lispval Lchdir();
lispval Lclose();
lispval Lconcat();
lispval Lcons();
lispval Lcopyint();		/* actually copyint* */
lispval Lcos();
lispval Lcprintf();
lispval Lcpy1();
lispval Lctcherr();	/* function def of ER%unwind-protect */
lispval Lcxr();
lispval Ldbtofl();
lispval Lderef();
lispval Ldiff();
lispval Ldrain();
lispval Ldtpr();
lispval Leq();
lispval Lequal();
lispval Lerr();
lispval Leval();
lispval Leval1();
lispval Levalf();
lispval Levalhook();
lispval Lexece();
lispval Lexp();
lispval Lfact();
lispval Lfadd1();
lispval Lfake();
lispval Lfasl();
lispval Lfexpt();
lispval Lfileopen();
lispval Lfilestat();
lispval Lfix();
lispval Lfm();
lispval Lfp();
lispval Lfd();
lispval Lft();
lispval Lflatsi();
lispval Lfltodb();
lispval Lflessp();
lispval Lfloat();
lispval Lfork();
lispval Lforget();
lispval Lfrexp();
lispval Lfsub1();
lispval Lfuncal();
lispval Lfunhook();
lispval Lgethash();
lispval Lgetsyntax();
lispval Lgcstat();
lispval Lgcpar();
lispval Lgetaddress();
lispval Lfretn();
lispval Lgensym();
lispval Lget();
lispval Lgeta();
lispval Lgetaux();
lispval Lgetd();
lispval Lgetdata();
lispval Lgetdel();
lispval Lgetdim();
lispval Lgetdisc();
lispval Lgetenv();
lispval Lgetl();
lispval Lgetlang();
lispval Lgetloc();
lispval Lgetparams();
lispval Lgreaterp();
lispval Lgtentry();
lispval Lhaipar();
lispval Lhashst();
lispval Lhau();
lispval Lhtol();
lispval Lhunkp();
lispval Lhunksize();
lispval LIfranzcall();
lispval Limplode();
lispval Linfile();
lispval Lkilcopy();
lispval Llctrace();
lispval Llessp();
lispval Llexfun();
lispval Llist();
lispval Lload();
lispval Llog();
lispval Llsh();
lispval Lmakertbl();
lispval Lmaknam();
lispval Lmaknum();
lispval Lmakunb();
lispval Lmap();
lispval Lmapc();
lispval Lmapcan();
lispval Lmapcon();
lispval Lmaplist();
lispval Lmarray();
lispval Lmfunction();
lispval Lminus();
lispval Lmkcth();
lispval Lmod();
lispval Lmonitor();
lispval Lmpcar();
lispval Lntern();
lispval Lnvec();
lispval Lnvecb();
lispval Lnvecw();
lispval Lnvecl();
lispval Lncons();
lispval Lnegp();
lispval Lfasl();
lispval Lnthelem();
lispval Lnull();
lispval Lnumberp();
lispval Lnwritn();
lispval Loblist();
lispval Lod();
lispval Lonep();
lispval Lopval();
lispval Loutfile();
lispval Lpatom();
lispval Lplist();
lispval Lprocess();
lispval Lpurcopy();
lispval Lpurep();
lispval Lpname();
lispval Lpntlen();
lispval Lpolyev();
lispval Lportp();
lispval Lprint();
lispval Lprname();
lispval Lprobef();
lispval Lptime();
lispval Lptr();
lispval Lputa();
lispval Lputaux();
lispval Lputd();
lispval Lputdata();
lispval Lputdel();
lispval Lputdim();
lispval Lputdisc();
lispval Lputl();
lispval Lputlang();
lispval Lputloc();
lispval Lputparams();
lispval Lputprop();
lispval Lquo();
lispval Lrandom();
lispval Lratom();
lispval Lread();
lispval Lreadc();
lispval Lreadli();
lispval Lrematom();
lispval Lremprop();
lispval Lreplace();
#ifdef VMS
lispval Lrestlsp();
#endif
lispval Lretbrk();
lispval Lrfasl();
lispval Lrmadd();
lispval Lrot();
lispval Lrplca();
lispval Lrplcd();
lispval Lrplci();
lispval Lrplcx();
lispval Lrset();
#ifdef VMS
lispval Lsavelsp();
#endif
lispval Lsbiglsh();
lispval Lscons();
lispval Lsegment();
lispval Lset();
lispval Lsetarg();
lispval Lsetpli();
lispval Lsetsyn();
lispval Lshostk();
lispval LIshowstack();
lispval Lsignal();
lispval Lsimpld();
lispval Lsin();
lispval Lsizeof();
lispval Lslevel();
lispval Lsqrt();
lispval Lstarinvmod();
lispval LstarMod();
lispval Lstarrpx();
lispval Lstringp();
lispval Lsub();
lispval Lsub1();
lispval Lsubstring();
lispval Lsstrn();
lispval Lsymbolp();
lispval Lsyscall();
lispval Ltci();
lispval Ltcx();
lispval Lterpr();
lispval Ltimes();
lispval Ltymestr();
lispval Ltruename();
lispval Ltyi();
lispval Ltyipeek();
lispval Ltyo();
lispval Ltype();
lispval Luconcat();
lispval Luntyi();
lispval Lvaluep();
lispval Lvbind();
lispval Lvectorp();
lispval Lpvp();
lispval Lvprop();
lispval Lvsp();
lispval Lwait();
lispval Lxplda();
lispval Lxpldc();
lispval Lxpldn();
lispval Lzapline();
lispval Lzerop();
lispval LImemory();

lispval Nand();
lispval Nbreak();
lispval Ncatch();
lispval Ncond();
lispval Ndef();
lispval Ndo();
lispval Ndumplisp();
lispval Nndumplisp();
lispval Nerrset();
lispval Nevwhen();
lispval Nfunction();
lispval Ngc();
lispval Ngcafter();
lispval Nlist();
lispval Nopval();
lispval Nor();
lispval Nprocess();
lispval Nprod();
lispval Nprog();
lispval Nprog2();
lispval Nprogn();
lispval Nprogv();
lispval Nquote();
lispval Nioreset();
lispval Nsetq();
lispval Nsstatus();
lispval Nstatus();
lispval Zequal();
EndOfFile
cat >  franz/h/structs.h  << 'EndOfFile'
/*					-[Sat Jan 29 14:00:31 1983 by jkf]-
 * 	structs.h			$Locker:  $
 * random structure definitions 
 *
 * $Header: /na/franz/franz/h/structs.h,v 1.1 83/01/29 14:07:48 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

/* 
 * this file contains auxiliary structure definitions which are used by
 * just a few files.
 */

/* transfer table structures. */

#define TRENTS 510

struct trent
{
    lispval (*fcn)();		/* function to call 			*/
    lispval name;	/* symbol which is the function to call */
};

struct trtab
{
    struct trtab *nxtt;			/* pointer to next transfer table */
    struct trent trentrs[TRENTS];	/* entries			  */
    int	sentinal;			/* must be zero			  */
};



struct heads {
	struct heads *link;
	char *pntr;
};


struct types
{
	char	*next_free;
	int	space_left,
		space,
		type,
		type_len;		/*  note type_len is in units of int */
	lispval *items,
		*pages,
		*type_name;
	struct heads
		*first;
	char 	*next_pure_free;

};

struct str_x
{
	char	*next_free;
	int	space_left;
};
EndOfFile
cat >  franz/h/chkrtab.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:53:19 1983 by jkf]-
 * 	chkrtab.h			$Locker:  $
 * check if read table valid 
 *
 * $Header: /na/franz/franz/h/chkrtab.h,v 1.1 83/01/29 14:05:24 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
#define chkrtab(p);	\
	if(p!=lastrtab){ if(TYPE(p)!=ARRAY && TYPE(p->ar.data)!=INT) rtaberr();\
			else {lastrtab=p;ctable=(unsigned char*)p->ar.data;}}
extern lispval lastrtab;
EndOfFile
cat >  franz/h/gc.h  << 'EndOfFile'
/*					-[Sat Jan 29 13:56:06 1983 by jkf]-
 * 	gc.h			$Locker:  $
 * garbage collector metering definitions
 *
 * $Header: gc.h,v 1.1 83/01/29 14:06:15 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
struct gchead
	{  int version;	/* version number of this dump file */
	   int lowdata;	/* low address of sharable lisp data */
	   int dummy,dummy2,dummy3; 	/* to be used later	*/
	};

EndOfFile
cat >  franz/h/lispo.h  << 'EndOfFile'
/*
 * Header prepended to each a.out file.
 */
struct exec {
	long	a_magic;	/* magic number */
unsigned long	a_text;		/* size of text segment */
unsigned long	a_data;		/* size of initialized data */
unsigned long	a_bss;		/* size of uninitialized data */
unsigned long	a_syms;		/* size of symbol table */
unsigned long	a_entry;	/* entry point */
unsigned long	a_trsize;	/* size of text relocation */
unsigned long	a_drsize;	/* size of data relocation */
};

#define	OMAGIC	0407		/* old impure format */
#define	NMAGIC	0410		/* read-only text */
#define	ZMAGIC	0413		/* demand load format */

/*
 * Macros which take exec structures as arguments and tell whether
 * the file has a reasonable magic number or offsets to text|symbols|strings.
 */
#define	N_BADMAG(x) \
    (((x).a_magic)!=OMAGIC && ((x).a_magic)!=NMAGIC && ((x).a_magic)!=ZMAGIC)

#define	N_TXTOFF(x) \
	((x).a_magic==ZMAGIC ? 1024 : sizeof (struct exec))
#define N_SYMOFF(x) \
	(N_TXTOFF(x) + (x).a_text+(x).a_data + (x).a_trsize+(x).a_drsize)
#define	N_STROFF(x) \
	(N_SYMOFF(x) + (x).a_syms)

/*
 * Format of a relocation datum.
 */
struct relocation_info {
	int	r_address;	/* address which is relocated */
unsigned int	r_symbolnum:24,	/* local symbol ordinal */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long */
		r_extern:1,	/* does not include value of sym referenced */
		:4;		/* nothing, yet */
};

/*
 * Format of a symbol table entry; this file is included by <a.out.h>
 * and should be used if you aren't interested the a.out header
 * or relocation information.
 */
struct	nlist {
	union {
		char	*n_name;	/* for use when in-core */
		long	n_strx;		/* index into file string table */
	} n_un;
unsigned char	n_type;		/* type flag, i.e. N_TEXT etc; see below */
	char	n_other;	/* unused */
	short	n_desc;		/* see <stab.h> */
unsigned long	n_value;	/* value of this symbol (or sdb offset) */
};
#define	n_hash	n_desc		/* used internally by ld */

/*
 * Simple values for n_type.
 */
#define	N_UNDF	0x0		/* undefined */
#define	N_ABS	0x2		/* absolute */
#define	N_TEXT	0x4		/* text */
#define	N_DATA	0x6		/* data */
#define	N_BSS	0x8		/* bss */
#define	N_COMM	0x12		/* common (internal to ld) */
#define	N_FN	0x1f		/* file name symbol */

#define	N_EXT	01		/* external bit, or'ed in */
#define	N_TYPE	0x1e		/* mask for all the type bits */

/*
 * Sdb entries have some of the N_STAB bits set.
 * These are given in <stab.h>
 */
#define	N_STAB	0xe0		/* if any of these bits set, a SDB entry */

/*
 * Format for namelist values.
 */
#define	N_FORMAT	"%08x"
EndOfFile
cat >  franz/h/types.h  << 'EndOfFile'
/*					-[Sat Jan 29 14:01:58 1983 by jkf]-
 * 	types.h				$Locker:  $
 * Unix standard type definitions
 *
 * $Header: /na/franz/franz/h/types.h,v 1.1 83/01/29 14:07:57 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */

typedef	struct { int rrr[1]; } *	physadr;
typedef	long		daddr_t;
typedef char *		caddr_t;
typedef	unsigned short	ino_t;
typedef	long		time_t;
typedef	int		label_t[10];
typedef	short		dev_t;
typedef	long		off_t;
# ifdef UNIXTS
typedef unsigned short ushort;
# endif
/* major part of a device */
#define	major(x)	(int)(((unsigned)x>>8)&0377)

/* minor part of a device */
#define	minor(x)	(int)(x&0377)

/* make a device number */
#define	makedev(x,y)	(dev_t)(((x)<<8) | (y))
EndOfFile
cat >  franz/h/lconf.h  << 'EndOfFile'
/* this file created by ../../lispconf */
#define vax_4_3 1
EndOfFile
cat >  franz/h/ltypes.h  << 'EndOfFile'
/*					-[Fri Mar  4 12:11:36 1983 by jkf]-
 * 	ltypes.h			$Locker:  $
 * lisp data type defs
 *
 * $Header: ltypes.h,v 1.2 83/03/04 12:30:22 jkf Exp $
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
/* type flags */

#define	UNBO	-1
#define	STRNG	0
#define	ATOM	1
#define	INT	2
#define	DTPR	3
#define DOUB	4
#define	BCD	5
#define	PORT	6
#define	ARRAY	7
#define OTHER   8
#define SDOT	9
#define VALUE	10

#define HUNK2	11		/* The hunks */
#define HUNK4	12
#define HUNK8	13
#define HUNK16	14
#define HUNK32	15
#define HUNK64	16
#define HUNK128	17

#define VECTOR  18
#define VECTORI 19

EndOfFile
cat >  franz/h/68kframe.h  << 'EndOfFile'
/*
 * $Header: 68kframe.h,v 1.3 84/02/29 12:43:22 sklower Exp $
 * $Locker:  $
 * machine stack frame
 */
struct machframe {
struct 	machframe	*fp;
	lispval	(*pc)();
	lispval ap[1];
};
EndOfFile
cat >  franz/h/hpagsiz.h  << 'EndOfFile'
#define	NBPG	512
#define	PGOFSET	511
#define	CLSIZE	2
#define	CLOFSET	1023
#define	PAGSIZ	512
#define	PAGRND	((PAGSIZ)-1)
EndOfFile
cat >  franz/h/duallispo.h  << 'EndOfFile'
		/*	a.out.h	1.1	82/08/26	*/
/*
 * Header prepended to each a.out file.
 */
struct exec {
	long	a_magic;	/* magic number */
unsigned long	a_text;		/* size of text segment */
unsigned long	a_data;		/* size of initialized data */
unsigned long	a_bss;		/* size of uninitialized data */
unsigned long	a_syms;		/* size of symbol table */
unsigned long	a_entry;	/* entry point (WRONG) */
unsigned long	a_trsize;	/* size of text relocation */
unsigned long	a_drsize;	/* size of data relocation */
};

#define	OMAGIC	0407		/* old impure format */
#define	NMAGIC	0410		/* read-only text */
#define	ZMAGIC	0413		/* demand load format */

/*
 * Macros which take exec structures as arguments and tell whether
 * the file has a reasonable magic number or offsets to text|symbols|strings.
 */
#define	N_BADMAG(x) \
    (((x).a_magic)!=OMAGIC && ((x).a_magic)!=NMAGIC && ((x).a_magic)!=ZMAGIC)

#define	N_TXTOFF(x) \
	((x).a_magic==ZMAGIC ? 1024 : sizeof (struct exec))
#define N_SYMOFF(x) \
	(N_TXTOFF(x) + (x).a_text+(x).a_data + (x).a_trsize+(x).a_drsize)
#define	N_STROFF(x) \
	(N_SYMOFF(x) + (x).a_syms)

/*
 * Format of a relocation datum.
 */
struct relocation_info {
	int	r_address;	/* address which is relocated */
unsigned int	r_symbolnum:24,	/* local symbol ordinal */
		r_pcrel:1, 	/* was relocated pc relative already */
		r_length:2,	/* 0=byte, 1=word, 2=long */
		r_extern:1,	/* does not include value of sym referenced */
		:4;		/* nothing, yet */
};

/*
 * Format of a symbol table entry; this file is included by <a.out.h>
 * and should be used if you aren't interested the a.out header
 * or relocation information.
 */
struct	nlist {
	union {
		char	*n_name;	/* for use when in-core */
		long	n_strx;		/* index into file string table */
	} n_un;
unsigned char	n_type;		/* type flag, i.e. N_TEXT etc; see below */
	char	n_other;	/* unused */
	short	n_desc;		/* see <stab.h> */
unsigned long	n_value;	/* value of this symbol (or sdb offset) */
};
#define	n_hash	n_desc		/* used internally by ld */

/*
 * Simple values for n_type.
 */
#define	N_UNDF	0x0		/* undefined */
#define	N_ABS	0x2		/* absolute */
#define	N_TEXT	0x4		/* text */
#define	N_DATA	0x6		/* data */
#define	N_BSS	0x8		/* bss */
#define	N_COMM	0x12		/* common (internal to ld) */
#define	N_FN	0x1f		/* file name symbol */

#define	N_EXT	01		/* external bit, or'ed in */
#define	N_TYPE	0x1e		/* mask for all the type bits */

/*
 * Sdb entries have some of the N_STAB bits set.
 * These are given in <stab.h>
 */
#define	N_STAB	0xe0		/* if any of these bits set, a SDB entry */

/*
 * Format for namelist values.
 */
#define	N_FORMAT	"%08x"
EndOfFile
cat >  franz/h/dualaout.h  << 'EndOfFile'
		/*	%M%	%I%	%E%	*/
/*
 * Header prepended to each a.out file.
 */
struct exec {
	long	a_magic;	/* magic number */
unsigned long	a_text;		/* size of text segment */
unsigned long	a_data;		/* size of initialized data */
unsigned long	a_bss;		/* size of uninitialized data */
unsigned long	a_syms;		/* size of symbol table */
unsigned long	a_trsize;	/* size of text relocation */
unsigned long	a_drsize;	/* size of data relocation */
unsigned long	a_entry;	/* entry point */
};

#define	OMAGIC	0407		/* old impure format */
#define	NMAGIC	0410		/* read-only text */
#define	ZMAGIC	0413		/* demand load format */

/*
 * Macros which take exec structures as arguments and tell whether
 * the file has a reasonable magic number or offsets to text|symbols|strings.
 */
#define	N_BADMAG(x) \
    (((x).a_magic)!=OMAGIC && ((x).a_magic)!=NMAGIC && ((x).a_magic)!=ZMAGIC)

#define	N_TXTOFF(x) \
	((x).a_magic==ZMAGIC ? 1024 : sizeof (struct exec))
#define N_SYMOFF(x) \
	(N_TXTOFF(x) + (x).a_text+(x).a_data + (x).a_trsize+(x).a_drsize)
#include <a.out.h>
EndOfFile
cat >  franz/vax/Makefile  << 'EndOfFile'
# 
# $Header: Makefile,v 1.15 85/05/06 18:12:34 sklower Exp $
#
# $Locker:  $
#
#  Franz Lisp C coded kernel 
#
#-- Default Paths:
#  see ../../ReadMe for a explaination of what LibDir and CopyTo mean
#  D is the directory used for holding intermediate files during 
#    compilation
#-- Options:
#  there is one compile time options which can be set in this file
#  * do profiling (ala the unix prof(1) command)
#
#  The selection of this options is made below
#  Other options can be selected by editing ../h/config.h or via
#  ../../lispconf
#
LibDir = /usr/lib/lisp
ObjDir = /usr/ucb
CopyTo = /dev/null
Liszt = liszt
Lisp = lisp
# if you change this you must recompile rlc.c 
# (and change the value in ../Makefile)
#
HOLE=	2097152 

.DEFAULT: nlisp

MipSrc1= ../low.c ../lowaux.s
MipSrc2= ../alloc.c ../data.c
MipSrc3= ../rlc.c
MipSrc4= ../lisp.c ../eval.c ../eval2.c ../inits.c ../io.c ../error.c \
	 ../sysat.c ../lam1.c ../lam2.c ../lam3.c ../lam4.c ../lam5.c\
	 ../lam6.c  ../lam7.c ../lam8.c ../lam9.c ../lamr.c ../lamp.c \
	 ../fex1.c ../fex2.c ../fex3.c ../fex4.c ../fexr.c\
	 ../fpipe.c \
	 ../subbig.c ../pbignum.c ../divbig.c \
	 ../ffasl.c ../fasl.c \
	 ../trace.c ../evalf.c ../frame.c ../lamgc.c

MipSrc = ${MipSrc1} ${MipSrc2} ${MipSrc3} ${MipSrc4}

MipObj1= ../low.o ../lowaux.o
MipObj2= ../alloc.o ../data.o
HoleMipObj2 = ../Salloc.o ../Sdata.o
HoleMipObj3 = ../rlc.o
MipObj4= ../lisp.o ../eval.o ../eval2.o ../inits.o ../io.o ../error.o \
	 ../sysat.o ../lam1.o ../lam2.o ../lam3.o ../lam4.o ../lam5.o\
	 ../lam6.o  ../lam7.o ../lam8.o ../lam9.o ../lamr.o ../lamp.o \
	 ../fex1.o ../fex2.o ../fex3.o ../fex4.o ../fexr.o\
	 ../fpipe.o \
	 ../subbig.o ../pbignum.o ../divbig.o \
	 ../ffasl.o ../fasl.o \
	 ../trace.o ../evalf.o ../frame.o ../lamgc.o

#------ Options

#--- profiling selection
# If the lisp system is to run with profiling, this must be done:
#  1) remove the # (comment character) from the ProfFlag and
#     ProfFlag2 definitions below (also do it in ../Makefile)
#  2) remove all .o files and do a make.
#
ProfFlag = # -XP
ProfFlag2 = # -DPROF


# The order of loading of certain files is important.
# low.o must be first and lowaux second.
# 
BottomObj = ${MipObj1}

# Different objects are required depending on whether there is to be
# a hole between text and data space.
#
NoHoleObj = crt0.o ${MipObj2}
HoleObj   = hcrt0.o ${HoleMipObj2} ${HoleMipObj3}

VaxObj = bigmath.o qfuncl.o vax.o malloc.o

VaxCSrc = vax.c malloc.c
VaxASrc = bigmath.c qfuncl.c crt0.s hcrt0.s
VaxSrc = ${VaxASrc} ${VaxCSrc}

Eunice = Make.vms Make.uobj rawlisp.unx rawhlisp.unx hole.unx totxtfile.c

AllSrc = Makefile fixmask.c fixpbig.e ${VaxSrc} ${Eunice} ${MipSrc}


.SUFFIXES : .c.l
# on non-ucb systems it might be more
# polite to use temporary files rather than pipes
#
.c.o :
	@csh -cfe "echo cc -c  $*.c;\
	rm -f $*.o;\
	/lib/cpp $< -I../h |\
	/lib/ccom ${ProfFlag}  | fixmask  |\
	sed -f fixpbig.e |\
	/lib/c2 |\
	as -o $*.o 

.l.o :
	liszt $< > #resc
	@echo liszt $< done

# one special case:
#  add -DPROF if you want to profile the assembler code

qfuncl.o: qfuncl.c
	cc -I../h -E ${ProfFlag2} qfuncl.c | as -o qfuncl.o

bigmath.o: bigmath.c
	cc -I../h -E ${ProfFlag2} bigmath.c | as -o bigmath.o

../rlc.o: ../rlc.c 
	cc -c -O -DHOLE=${HOLE} ../rlc.c 
	mv rlc.o .. < /dev/null

../low.o: ../low.c
	cc -I../h -R -c ../low.c  
	mv low.o .. < /dev/null

../Salloc.o: ../alloc.c
	(echo "# define HOLE ${HOLE}"; cat ../alloc.c) > Salloc.c;\
	make Salloc.o; mv Salloc.o .. < /dev/null ; rm Salloc.c
	
../Sdata.o: ../data.c
	(echo "# define HOLE ${HOLE}"; cat ../data.c) > Sdata.c;\
	make Sdata.o; mv Sdata.o .. < /dev/null  ; rm Sdata.c

fixmask: fixmask.c
	cc -O -o fixmask fixmask.c

# rawlisp is the standard raw lisp system.

rawlisp: fixmask fixpbig.e ${BottomObj} ${NoHoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawlisp
	ld -x -o rawlisp -e start ${BottomObj} ${NoHoleObj} \
				${VaxObj} ${MipObj4}  -lm -lc -ltermlib
	ls -l rawlisp


# hlisp is a raw lisp system with a hole between text and data

rawhlisp: fixmask fixpbig.e ${BottomObj} ${HoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawhlisp
	ld -x -H ${HOLE} -o rawhlisp -e hstart ${BottomObj}  ${HoleObj} \
				${VaxObj}  ${MipObj4} -lm -lc -ltermlib
	ls -l rawhlisp


clean:
	rm -f *.o rawlisp nlisp rawhlisp

lint:
	lint ../h/*.h *.c

tags:	tags ${VaxSrc} ${MipSrc}
	ctags ../h/*.h ${VaxCSrc} ${MipSrc}

install: nlisp 
	-rm -f ${ObjDir}/lisp
	mv nlisp ${ObjDir}/lisp
	@echo lisp installed

nlisp: rawlisp ${LibDir}
	-rm -f nlisp
	(cd ${LibDir} ; make Liszt=${Liszt} required)
	echo "(progn (setq build:map 'map \
			   build:lisp-type 'franz \
		           lisp-library-directory '${LibDir} \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}) \
		     (load '${LibDir}/buildlisp)\
	             (dumplisp nlisp))" | rawlisp
	${LibDir}/tackon map nlisp
	@echo nlisp built


donlisp:
	-rm -f nlisp
	make LibDir=${LibDir} Liszt=${Liszt} ObjDir=${ObjDir} nlisp

#--- snlisp: create a totally interpreted lisp.
#	dump as snlisp
snlisp: rawlisp
	echo "(progn (setq build:load t		\
			   build:lisp-type 'franz \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}\
			   lisp-library-directory '${LibDir})\
		     (load '${LibDir}/buildlisp)\
		     (dumplisp snlisp))" | rawlisp

#--- copysource : copy source files to another directory
#  called via   make CopyTo=/xx/yyy/zz copysource
# 
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@../../scriptcat . franz/vax ${AllSrc} tags
EndOfFile
cat >  franz/vax/fixmask.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: fixmask.c,v 1.2 83/04/10 21:34:40 sklower Exp $";
#endif

/*					-[Sat Jan 29 12:42:54 1983 by jkf]-
 * 	fixmask.c				$Locker:  $
 * complete program to change register save masks on the vax
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include <stdio.h>
char mybuf[BUFSIZ];
extern unsigned short mask[];
main(){
	register savesize = 0; char *cp;
	while(fgets(mybuf,BUFSIZ,stdin)!=NULL) {
		if(*mybuf=='#') {
			if(strcmpn(mybuf,"#save	",6)==0){
				savesize = mybuf[6]-'0';
			} else if (strcmpn(mybuf,"#protect	",9)==0){
				savesize = '0'-1-mybuf[9];
			}
		}
		if(savesize && strcmpn(mybuf,"	.set	L",7)==0) {
			for(cp=mybuf;*cp++!=',';);
			sprintf(cp,"0x%X\n",mask[savesize + 10]);
			savesize = 0;
		}
		fputs(mybuf,stdout);
	}
}
unsigned short mask[] = {
	0,0,0,0xfc0,0xfc0,0xfc0,0xec0,0xcc0,0x8c0,0x0c0,0,
	0x800,0xc00,0xe00,0xf00,0xf80,0xfc0,0,0,0,0};
EndOfFile
cat >  franz/vax/fixpbig.e  << 'EndOfFile'
/calls	$[0-9]*,_stack/d
/calls	$0,_unstack/s//movl	(sp)+,r0/
/calls	$0,_sp/s//movl	sp,r0/
/calls	$1,_inewint/s//movl (sp)+,r5\
	jsb	_qnewint/
/calls	$0,_newdot/s//jsb	_qnewdot/
/calls	$0,_nargs/s//movl	(ap),r0/
/calls	$1,_popname/s//jsb	_qpopname/
/calls	$5,_exarith/s//jsb	_qexarith/
/calls	$1,_prunei/s//jsb	_qprunei/
/calls	$1,_pruneb/s//jsb	_qpruneb/
/calls	$0,_qretfromfr/s//jsb	_qretfromfr/
/calls	$[123],_Pushframe/s//jsb	_qpushframe/
/\*_np\([	, ]\)/s//(r6)\1/g
/\*_lbot\([	, ]\)/s//(r7)\1/g
/_np\([	, ]\)/s//r6\1/g
/_lbot\([	, ]\)/s//r7\1/g
/\*_np$/s//(r6)/g
/\*_lbot$/s//(r7)/g
/_np$/s//r6/g
/_lbot$/s//r7/g
EndOfFile
cat >  franz/vax/bigmath.c  << 'EndOfFile'
/* $Header: bigmath.c 1.4 83/06/09 00:50:06 sklower Exp $ */

#include "config.h"

	.globl	_dmlad
/*
	routine for destructive multiplication and addition to a bignum by
	two fixnums.

	from C, the invocation is dmlad(sdot,mul,add);
	where sdot is the address of the first special cell of the bignum
	mul is the multiplier, add is the fixnum to be added (The latter
	being passed by value, as is the usual case.


	Register assignments:

	r11 = current sdot
	r10 = carry
	r9  = previous sdot, for relinking.
*/
_dmlad:	.word	0x0e00
	movl	4(ap),r11		#initialize cell pointer
	movl	12(ap),r10		#initialize carry
loop:	emul	8(ap),(r11),r10,r0	#r0 gets cell->car times mul + carry
/*	ediv	$0x40000000,r0,r10,(r11)#cell->car gets prod % 2**30
					#carry gets quotient
*/
	extzv	$0,$30,r0,(r11)
	extv	$30,$32,r0,r10
	movl	r11,r9			#save last cell for fixup at end.
	movl	4(r11),r11		#move to next cell
	bneq	loop			#done indicated by 0 for next sdot
	tstl	r10			#if carry zero no need to allocate
	beql	done			#new bigit
	mcoml	r10,r3			#test to see if neg 1.
	bneq	alloc			#if not must allocate new cell.
	tstl	(r9)			#make sure product isn't -2**30
	beql	alloc
	movl	r0,(r9)			#save old lower half of product.
	brb	done
alloc:	jsb	_qnewdot			#otherwise allocate new bigit
	movl	r10,(r0)		#store carry
	movl	r0,4(r9)		#save new link cell
done:	movl	4(ap),r0
	ret
	.globl _dodiv
/*
	routine to destructively divide array representation of a bignum by 
	1000000000

	invocation:
		remainder = dodiv(top,bottom)
		int *top, *bottom;
	where *bottom is the address of the biggning of the array, *top is
	the top of the array.

	register assignments:
	r0 = carry
	r1 & r2 = 64bit temporary
	r3 = pointer
*/
_dodiv:	.word	0
	clrl		r0		#no carry to begin.
	movl		8(ap),r3	#get pointer to array.
loop2:	emul		$0x40000000,r0,(r3),r1
	ediv		$1000000000,r1,(r3),r0
	acbl		4(ap),$4,r3,loop2
	ret
	.globl	_dsneg
/*
	dsneg(top, bot);
	int *top, *bot;

	routine to destructively negate a bignum stored in array format
	lower order stuff at higher addresses. It is assume that the
	result will be positive.
*/
_dsneg:	.word	0
	movl	4(ap),r1	#load up address.
	clrl	r2		#set carry
loop3:	mnegl	(r1),r0		#negate and take carry into account.
	addl2	r2,r0
	extzv	$0,$30,r0,(r1)
	extv	$30,$2,r0,r2
	acbl	8(ap),$-4,r1,loop3
				#decrease r1, and branch back if appropriate.
	ret

/*
	bignum add routine
	basic data representation is each bigit is a positive number
	less than 2^30, except for the leading bigit, which is in
	the range -2^30 < x < 2^30.
*/

	.globl	_adbig
	.globl	Bexport
	.globl	backfr
/*
	Initialization section
*/
_adbig:	.word	0x0fc0		#save registers 6-11
	movl	4(ap),r1	#arg1 = addr of 1st bignum
	movl	8(ap),r2	#arg2 = addr of 2nd bignum
	clrl	r5		#r5   = carry
	movl	$0xC0000000,r4	#r4   = clear constant.
	movl	sp,r10		#save start address of bignum on stack.
				#note well that this is 4 above the actual
				#low order word.
/*
	first loop is to waltz through both bignums adding
	bigits, pushing them onto stack. 
*/
loop4:	addl3	(r1),(r2),r0	#add bigits
	addl2	r5,r0		#add carry
	bicl3	r4,r0,-(sp)	#save sum, no overflow possible
	extv	$30,$2,r0,r5	#sign extend two high order bits
				#to be next carry.
	movl	4(r1),r1	#get cdr
	bleq	out1		#negative indicates end of list.
	movl	4(r2),r2	#get cdr of second bignum
	bgtr	loop4		#if neither list at end, do it again
/*
	second loop propagates carries through higher order words.
	It assumes remaining list in r1.
*/
loop5:	addl3	(r1),r5,r0	#add bigits and carry
	bicl3	r4,r0,-(sp)	#save sum, no overflow possible
	extv	$30,$2,r0,r5	#sign extend two high order bits
				#to be next carry.
	movl	4(r1),r1	#get cdr
out2:	bgtr	loop5		#negative indicates end of list.
out2a:	pushl	r5
/*
	suppress unnecessary leading zeroes and -1's

	WARNING:  this code is duplicated in C in divbig.c
*/
iexport:movl	sp,r11		#more set up for output routine
ckloop:	
Bexport:tstl	(r11)		#look at leading bigit
	bgtr	copyit		#if positive, can allocate storage etc.
	blss	negchk		#if neg, still a chance we can get by
	cmpl	r11,r10		#check to see that
	bgeq	copyit		#we don't pop everything off of stack
	tstl	(r11)+		#incr r11
	brb	ckloop		#examine next
negchk:
	mcoml	(r11),r3		#r3 is junk register
	bneq	copyit		#short test for -1
	tstl	4(r11)		#examine next bigit
	beql	copyit		#if zero must must leave as is.
	cmpl	r11,r10		#check to see that
	bgeq	copyit		#we don't pop everything off of stack
	tstl	(r11)+		#incr r11
	bisl2	r4,(r11)	#set high order two bits
	brb	negchk		#try to supress more leading -1's
/*
	The following code is an error exit from the first loop
 	and is out of place to avoid a jump around a jump.
*/
out1:	movl	4(r2),r1	#get next addr of list to continue.
	brb	out2		#if second list simult. exhausted, do
				#right thing.
/*
	loop6 is a faster version of loop5 when carries are no
	longer necessary.
*/
loop6a: pushl	(r1)		#get datum
loop6:	movl	4(r1),r1	#get cdr
	bgtr	loop6a		#if not at end get next cell
	brb	out2a

/*
	create linked list representation of bignum
*/
copyit:	subl3	r11,r10,r2	#see if we can get away with allocating an int
	bneq	on1		#test for having popped everything
	subl3	$4,r10,r11	#if so, fix up pointer to bottom
	brb	intout		#and allocate int.
on1:	cmpl	r2,$4		#if = 4, then can do
	beql	intout
	calls	$0,_newsdot	#get new cell for new bignum
backfr:
#ifdef PORTABLE
	movl	r0,*_np
	addl2	$4,_np
#else
	movl	r0,(r6)+	#push address of cell on
				#arg stack to save from garbage collection.
				#There is guaranteed to be slop for a least 1
				#push without checking.
#endif
loop7:	movl	-(r10),(r0)	#save bigit
	movl	r0,r9		#r9 = old cell, to link
	cmpl	r10,r11		#have we copy'ed all the bigits?
	bleq	Edone
	jsb	_qnewdot	#get new cell for new bignum
	movl	r0,4(r9)	#link new cell to old
	brb	loop7
Edone:	
	clrl	4(r9)		#indicate end of list with 0
#ifdef PORTABLE
	subl2	$4,_np
	movl	*_np,r0
#else
	movl	-(r6),r0	#give resultant address.
#endif
	ret
/*
	export integer
*/
intout: pushl	(r11)
	calls	$1,_inewint
	ret
	.globl	_mulbig
/*
	bignum multiplication routine

	Initialization section
*/
_mulbig:.word	0x0fc0		#save regs 6-11
	movl	4(ap),r1	#get address of first bignum
	movl	sp,r11		#save top of 1st bignum
mloop1:	pushl	(r1)		#get bigit
	movl	4(r1),r1	#get cdr
	bgtr	mloop1		#repeat if not done
	movl	sp,r10		#save bottom of 1st bignum, top of 2nd bignum
	
	movl	8(ap),r1	#get address of 2nd bignum
mloop2:	pushl	(r1)		#get bigit
	movl	4(r1),r1	#get cdr
	bgtr	mloop2		#repeat if not done
	movl	sp,r9		#save bottom of 2nd bignum
	subl3	r9,r11,r6	#r6 contains sum of lengths of bignums
	subl2	r6,sp
	movl	sp,r8		#save bottom of product bignum
/*
	Actual multiplication
*/
m1:	movc5	$0,(r8),$0,r6,(r8)#zap out stack space
	movl	r9,r7		#r7 = &w[j +n] (+4 for a.d.) through calculation
	subl3	$4,r10,r4	#r4 = &v[j]

m3:	movl	r7,r5		#r7 = &w[j+n]
	subl3	$4,r11,r3	#r3 = &u[i]
	clrl	r2		#clear carry.

m4:	addl2	-(r5),r2	#add w[i + j] to carry (no ofl poss)
	emul	(r3),(r4),r2,r0 #r0 = u[i] * v[j] + sext(carry)
	extzv	$0,$30,r0,(r5)	#get new bigit
	extv	$30,$32,r0,r2	#get new carry

m5:	acbl	r10,$-4,r3,m4	#r3 =- 4; if(r3 >= r10) goto m4; r10 = &[u1];
	movl	r2,-(r5)	#save w[j] = carry

m6:	subl2	$4,r7		#add just &w[j+n] (+4 for autodec)
	acbl	r9,$-4,r4,m3	#r4 =- 4; if(r4>=r9) goto m5; r9 = &v[1]

	movl	r9,r10		#set up for output routine
	movl	$0xC0000000,r4	#r4   = clear constant.
	movq	20(fp),r6	#restor _np and _lbot !
	brw	iexport		#do it!
/*
 The remainder of this file are routines used in bignum division.
 Interested parties should consult Knuth, Vol 2, and divbig.c.
 These files are here only due to an optimizer bug.
*/
	.align	1
	.globl	_calqhat
_calqhat:
	.word	0xf00
	movl	4(ap),r11		# &u[j] into r11
	movl	8(ap),r10		# &v[1] into r10
	cmpl	(r10),(r11)		# v[1] == u[j] ??
	beql	L102			
	# calculate qhat and rhat simultaneously,
	#  qhat in r0
	#  rhat in r1
	emul	(r11),$0x40000000,4(r11),r4 # u[j]b+u[j+1] into r4,r5
	ediv	(r10),r4,r0,r1		# qhat = ((u[j]b+u[j+1])/v[1]) into r0
					# (u[j]b+u[j+1] -qhat*v[1]) into r1
					# called rhat
L101:
	# check if v[2]*qhat > rhat*b+u[j+2]
	emul	r0,4(r10),$0,r2		# qhat*v[2] into r3,r2
	emul	r1,$0x40000000,8(r11),r8 #rhat*b + u[j+2] into r9,r8
	# give up if r3,r2 <= r9,r8, otherwise iterate
	subl2	r8,r2			# perform r3,r2 - r9,r8
	sbwc	r9,r3
	bleq	L103			# give up if negative or equal
	decl	r0			# otherwise, qhat = qhat - 1
	addl2	(r10),r1		# since dec'ed qhat, inc rhat by v[1]
	jbr	L101
L102:	
	# get here if v[1]==u[j]
	# set qhat to b-1
	# rhat is easily calculated since if we substitute b-1 for qhat in
	# the formula, then it simplifies to (u[j+1] + v[1])
	# 
	addl3	4(r11),(r10),r1		# rhat = u[j+1] + v[1]
	movl	$0x3fffffff,r0		# qhat = b-1
	jbr	L101
	
L103:
	ret

	.align	1
	.globl	_mlsb
_mlsb:
	.word	.R2
	movl	4(ap),r11
	movl	8(ap),r10
	movl	12(ap),r9
	movl	16(ap),r8
	clrl	r0
loop8:	addl2	(r11),r0
	emul	r8,-(r9),r0,r2
	extzv	$0,$30,r2,(r11)
	extv	$30,$32,r2,r0
	acbl	r10,$-4,r11,loop8
	ret
	.set	.R2,0xf00
	.align	1
	.globl	_adback
_adback:
	.word	.R3
	movl	4(ap),r11
	movl	8(ap),r10
	movl	12(ap),r9
	clrl	r0
loop9:	addl2	-(r9),r0
	addl2	(r11),r0
	extzv	$0,$30,r0,(r11)
	extv	$30,$2,r0,r0
	acbl	r10,$-4,r11,loop9
	ret
	.set	.R3,0xe00
	.align	1
	.globl	_dsdiv
_dsdiv:
	.word	.R4
	movl	8(ap),r11
	clrl	r0
loopa:	emul	r0,$0x40000000,(r11),r1
	ediv	12(ap),r1,(r11),r0
	acbl	4(ap),$4,r11,loopa
	ret
	.set	.R4,0x800
	.align	1
	.globl	_dsmult
_dsmult:
	.word	.R5
	movl	4(ap),r11
	clrl	r0
loopb:	emul	12(ap),(r11),r0,r1
	extzv	$0,$30,r1,(r11)
	extv	$30,$32,r1,r0
	acbl	8(ap),$-4,r11,loopb
	movl	r1,4(r11)
	ret
	.set	.R5,0x800
	.align	1
	.globl	_dsrsh
_dsrsh:
	.word	.R7
	movl	8(ap),r11	# bot
	movl	16(ap),r5	# mask
	movl	12(ap),r4	# shift count
	clrl	r0
L201:	emul	r0,$0x40000000,(r11),r1
	bicl3	r5,r1,r0
	ashq	r4,r1,r1
	movl	r1,(r11)
	acbl	4(ap),$4,r11,L201
	ret
	.set	.R7,0x800
	.align	1
	.globl	_dsadd1
_dsadd1:
	.word	.R8
	movl	4(ap),r11
	movl	$1,r0
L501:	emul	$1,(r11),r0,r1
	extzv	$0,$30,r1,(r11)
	extv	$30,$32,r1,r0
	acbl	8(ap),$-4,r11,L501
	movl	r1,4(r11)
	ret
	.set	.R8,0x800
/*
	myfrexp (value, exp, hi, lo)
		double value;
		int *exp, *hi, *lo;

	myfrexp returns three values, exp, hi, lo,
	Such that value = 2**exp*tmp, where tmp = (hi*2**-23+lo*2**-53)
	is uniquely determined subect to .5< abs(tmp) <= 1.0
	

	Entry point
*/
	.text
	.globl	_myfrexp
_myfrexp:
	.word	0x0000		# We use r2, but do not save it

	clrl	*12(ap)		# Make for easy exit later
	clrl	*16(ap)		# 
	clrl	*20(ap)		# 
	movd	4(ap),r0	# Fetch "value"
	bneq	L301		# if zero return zero exponent + mantissa
	ret
L301:
	extzv	$7,$8,r0,r2	# r2 := biased exponent
	movab	-129(r2),*12(ap)# subtract bias, store exp
	insv	$154,$7,$8,r0	# lie about exponent to get out
				# high 24 bits easily with emodd.
/*
	This instruction does the following:

		Extend the long floating value in r0 with 0, and
		multiply it by 1.0.  Store the integer part of the result
		in hi, and the fractional part of the result in r0-r1.
*/
	emodd	r0,$0,$0f1.0,*16(ap),r0	# How did you like
					# THAT, sports fans? [jfr's comment]

	tstd	r0		# if zero, exit;
	bneq	L401
	ret
L401:
	insv	$158,$7,$8,r0	# lie about exponent to get out
				# next 30 bits easily with emodd.
				# (2^29 takes 30 bits).
	emodd	r0,$0,$0f1.0,*20(ap),r0	# Get last bits out likewise!
	ret				# (r0 should be zero by now!)
	.globl	_inewint
_inewint:.word	0
	movl	4(ap),r0
	cmpl	r0,$1024
	jgeq	Ialloc
	cmpl	r0,$-1024
	jlss	Ialloc
	moval	_Fixzero[r0],r0
	ret
Ialloc:
	calls	$0,_newint
	movl	4(ap),0(r0)
	ret
	.globl	_blzero
_blzero:				# blzero(where,howmuch)
					# char *where;
					# zeroes a block of length howmuch
					# beginning at where.
	.word	0
	movc5	$0,*4(ap),$0,8(ap),*4(ap)
	ret
EndOfFile
cat >  franz/vax/qfuncl.c  << 'EndOfFile'
  .asciz "$Header: qfuncl.c,v 1.10 84/02/29 16:44:30 sklower Exp $"

/*					-[Mon Mar 21 17:04:58 1983 by jkf]-
 * 	qfuncl.c				$Locker:  $
 * lisp to C interface
 *
 * (c) copyright 1982, Regents of the University of California
 */

/* 
 * This is written in assembler but must be passed through the C preprocessor
 * before being assembled.
 */

#include "ltypes.h"
#include "config.h"

/* important offsets within data types for atoms */
#define Atomfnbnd 8

/*  for arrays */
#define Arrayaccfun 0

#ifdef PROF
	.set	indx,0
#define Profile \
	movab	prbuf+indx,r0 \
	.set 	indx,indx+4 \
	jsb 	mcount
#define Profile2 \
	movl   r0,r5 \
	Profile	\
	movl   r5,r0 
#else
#define Profile
#define Profile2
#endif

#ifdef PORTABLE
#define NIL	_nilatom
#define NP	_np
#define LBOT	_lbot
#else
#define NIL	0
#define NP	r6
#define LBOT	r7
#endif


/*   transfer  table linkage routine  */

	.globl	_qlinker
_qlinker:
	.word 	0xfc0			# save all possible registers
	Profile
	tstl	_exception	        # any pending exceptions
	jeql	noexc
	tstl	_sigintcnt		# is it because of SIGINT
	jeql	noexc			# if not, just leave
	pushl	$2			# else push SIGINT
	calls	$1,_sigcall
noexc:
	movl	16(fp),r0		# get return pc
	addl2	-4(r0),r0		# get pointer to table
	movl	4(r0),r1		# get atom pointer
retry:					# come here after undef func error
	movl	Atomfnbnd(r1),r2	# get function binding
	jleq	nonex			# if none, leave
	tstl	_stattab+2*4		# see if linking possible (Strans)
	jeql	nolink			# no, it isn't
	ashl	$-9,r2,r3		# check type of function
	cmpb	$/**/BCD,_typetable+1[r3]	
	jeql	linkin			# bcd, link it in!
	cmpb	$/**/ARRAY,_typetable+1[r3] # how about array?
	jeql	doarray			# yep


nolink:
	pushl	r1			# non, bcd, call interpreter
	calls	$1,_Ifuncal
	ret

/*
 * handle arrays by pushing the array descriptor on the table and checking
 * for a bcd array handler
 */
doarray:
	ashl	$-9,Arrayaccfun(r2),r3	# get access function addr shifted
	cmpb	$/**/BCD,_typetable+1[r3]	# bcd??
	jneq	nolink			# no, let funcal handle it
#ifdef PORTABLE
	movl	NP,r4
	movl	r2,(r4)+		# store array header on stack
	movl	r4,NP
#else
	movl	r2,(r6)+		# store array header on stack
#endif
	movl	*(r2),r2		# get in func addr
	jmp	2(r2)			# jump in beyond calls header
	
	
linkin:	
	ashl	$-9,4(r2),r3		# check type of function discipline
	cmpb	$0,_typetable+1[r3]	# is it string?
	jeql	nolink			# yes, it is a c call, so dont link in
	movl	(r2),r2			# get function addr
	movl	r2,(r0)			# put fcn addr in table
	jmp	2(r2)			# enter fcn after mask

nonex:	pushl	r0			# preserve table address
	pushl	r1			# non existant fcn
	calls	$1,_Undeff		# call processor
	movl	r0,r1			# back in r1
	movl	(sp)+,r0		# restore table address
	jbr	retry			# for the retry.


	.globl	__erthrow		# errmessage for uncaught throws
__erthrow: 
	.asciz	"Uncaught throw from compiled code"

	.globl _tynames
_tynames:
	.long	NIL				# nothing here
	.long	_lispsys+20*4			# str_name
	.long	_lispsys+21*4			# atom_name
	.long	_lispsys+19*4			# int_name
	.long	_lispsys+23*4			# dtpr_name
	.long	_lispsys+22*4			# doub_name
	.long	_lispsys+58*4			# funct_name
	.long	_lispsys+103*4			# port_name
	.long	_lispsys+47*4			# array_name
	.long	NIL				# nothing here
	.long	_lispsys+50*4			# sdot_name
	.long	_lispsys+53*4			# val_nam
	.long	NIL				# hunk2_nam
	.long	NIL				# hunk4_nam
	.long	NIL				# hunk8_nam
	.long	NIL				# hunk16_nam
	.long	NIL				# hunk32_nam
	.long	NIL				# hunk64_nam
	.long	NIL				# hunk128_nam
	.long	_lispsys+124*4			# vector_nam
	.long	_lispsys+125*4			# vectori_nam

/*	Quickly allocate small fixnums  */

	.globl	_qnewint
_qnewint:
	Profile
	cmpl	r5,$1024
	jgeq	alloc
	cmpl	r5,$-1024
	jlss	alloc
	moval	_Fixzero[r5],r0
	rsb
alloc:
	movl	_int_str,r0			# move next cell addr to r0
	jlss	callnewi			# if no space, allocate
	incl	*_lispsys+24*4			# inc count of ints
	movl	(r0),_int_str			# advance free list
	movl	r5,(r0)				# put baby to bed.
	rsb
callnewi:
	pushl	r5
	calls	$0,_newint
	movl	(sp)+,(r0)
	rsb


/*  _qoneplus adds one to the boxed fixnum in r0
 * and returns a boxed fixnum.
 */

	.globl	_qoneplus
_qoneplus:
	Profile2
	addl3	(r0),$1,r5
#ifdef PORTABLE
	movl	r6,NP
	movl	r6,LBOT
#endif
	jmp	_qnewint

/* _qoneminus  subtracts one from the boxes fixnum in r0 and returns a
 * boxed fixnum
 */
	.globl	_qoneminus
_qoneminus:
	Profile2
	subl3	$1,(r0),r5
#ifdef PORTABLE
	movl	r6,NP
	movl	r6,LBOT
#endif
	jmp	_qnewint

/*
 *	_qnewdoub quick allocation of a initialized double (float) cell.
 *	This entry point is required by the compiler for symmetry reasons.
 *	Passed to _qnewdoub in r4,r5 is a double precision floating point
 *	number.  This routine allocates a new cell, initializes it with
 *	the given value and then returns the cell.
 */

	.globl	_qnewdoub
_qnewdoub:
	Profile
	movl	_doub_str,r0			# move next cell addr to r0
	jlss	callnewd			# if no space, allocate
	incl	*_lispsys+30*4			# inc count of doubs
	movl	(r0),_doub_str			# advance free list
	movq	r4,(r0)				# put baby to bed.
	rsb

callnewd:
	movq	r4,-(sp)			# stack initial value
	calls	$0,_newdoub
	movq	(sp)+,(r0)			# restore initial value
	rsb

	.globl	_qcons

/*
 * quick cons call, the car and cdr are stacked on the namestack
 * and this function is jsb'ed to.
 */

_qcons:
	Profile
	movl	_dtpr_str,r0			# move next cell addr to r0
	jlss	getnew				# if ran out of space jump
	incl	*_lispsys+28*4			# inc count of dtprs
	movl	(r0),_dtpr_str			# advance free list
storit:
	movl	-(r6),(r0)			# store in cdr
	movl	-(r6),4(r0)			# store in car
	rsb

getnew:
#ifdef PORTABLE
	movl	r6,NP
	movab	-8(r6),LBOT
#endif
	calls	$0,_newdot			# must gc to get one
	jbr	storit				# now initialize it.

/*
 * Fast equivalent of newdot, entered by jsb
 */

	.globl	_qnewdot
_qnewdot:
	Profile
	movl	_dtpr_str,r0			# mov next cell addr t0 r0
	jlss	mustallo			# if ran out of space
	incl	*_lispsys+28*4			# inc count of dtprs
	movl	(r0),_dtpr_str			# advance free list
	clrq	(r0)
	rsb
mustallo:
	calls	$0,_newdot
	rsb

/*  prunel  - return a list of dtpr cells to the free list
 * this is called by the pruneb after it has discarded the top bignum 
 * the dtpr cells are linked through their cars not their cdrs.
 * this returns with an rsb
 *
 * method of operation: the dtpr list we get is linked by car's so we
 * go through the list and link it by cdr's, then have the last dtpr
 * point to the free list and then make the free list begin at the
 * first dtpr.
 */
qprunel:
	movl	r0,r2				# remember first dtpr location
rep:	decl	*_lispsys+28*4			# decrement used dtpr count
	movl	4(r0),r1			# put link value into r1
	jeql	endoflist			# if nil, then end of list
	movl	r1,(r0)				# repl cdr w/ save val as car
	movl	r1,r0				# advance to next dtpr
	jbr	rep				# and loop around
endoflist:
	movl	_dtpr_str,(r0)			# make last 1 pnt to free list
	movl	r2,_dtpr_str			# & free list begin at 1st 1
	rsb

/*
 * qpruneb - called by the arithmetic routines to free an sdot and the dtprs
 * which hang on it.
 * called by
 *	pushl	sdotaddr
 *	jsb	_qpruneb
 */
	.globl	_qpruneb
_qpruneb:
	Profile
	movl	4(sp),r0				# get address
	decl	*_lispsys+48*4		# decr count of used sdots
	movl	_sdot_str,(r0)		# have new sdot point to free list
	movl	r0,_sdot_str		# start free list at new sdot
	movl	4(r0),r0		# get address of first dtpr
	jneq	qprunel			# if exists, prune it
	rsb				# else return.


/*
 * _qprunei 	 
 *	called by the arithmetic routines to free a fixnum cell
 * calling sequence
 *	pushl	fixnumaddr
 *	jsb	_qprunei
 */

	.globl	_qprunei
_qprunei:
	Profile
	movl	4(sp),r0		# get address of fixnum
	cmpl	r0,$_Lastfix		# is it a small fixnum
	jleq	skipit			# if so, leave
	decl	*_lispsys+24*4		# decr count of used ints
	movl	_int_str,(r0)		# link the fixnum into the free list
	movl	r0,_int_str
skipit:
	rsb


	.globl	_qpopnames
_qpopnames:			# equivalent of C-code popnames, entered by jsb.
	movl	(sp)+,r0	# return address
	movl	(sp)+,r1	# Lower limit
	movl	_bnp,r2		# pointer to bind stack entry
qploop:
	subl2	$8,r2		# for(; (--r2) > r1;) {
	cmpl	r2,r1		# test for done
	jlss	qpdone		
	movl	(r2),*4(r2)	# r2->atm->a.clb = r2 -> val;
	brb	qploop		# }
qpdone:
	movl	r1,_bnp		# restore bnp
	jmp	(r0)		# return

/*
 * _qget : fast get subroutine
 *  (get 'atom 'ind)
 * called with -8(r6) equal to the atom
 *	      -4(r6) equal to the indicator
 * no assumption is made about LBOT
 * unfortunately, the atom may not in fact be an atom, it may
 * be a list or nil, which are special cases.
 * For nil, we grab the nil property list (stored in a special place)
 * and for lists we punt and call the C routine since it is  most likely
 * and error and we havent put in error checks yet.
 */

	.globl	_qget
_qget:
	Profile
	movl	-4(r6),r1	# put indicator in r1
	movl	-8(r6),r0	# and atom into r0
	jeql	nilpli		# jump if atom is nil
	ashl	$-9,r0,r2	# check type
	cmpb	_typetable+1[r2],$1 # is it a symbol??
	jneq	notsymb		# nope
	movl	4(r0),r0	# yes, put prop list in r1 to begin scan
	jeql	fail		# if no prop list, we lose right away
lp:	cmpl	r1,4(r0)	# is car of list eq to indicator?
	jeql	good		# jump if so
	movl	*(r0),r0	# else cddr down list
	jneq	lp		# and jump if more list to go.

fail:	subl2	$8,NP		# unstack args
	rsb			# return with r0 eq to nil

good:	movl	(r0),r0		# return cadr of list
	movl	4(r0),r0
	subl2	$8,NP		#unstack args
	rsb

nilpli:	movl	_lispsys+64*4,r0 # want nil prop list, get it specially
	jneq	lp		# and process if anything there
	subl2	$8,NP		#unstack args
	rsb			# else fail
	
notsymb:
#ifdef PORTABLE
	movl	r6,NP
	movab	-8(r6),LBOT	# must set up LBOT before calling
#else
	movab	-8(r6),LBOT	# must set up LBOT before calling
#endif
	calls	$0,_Lget	# not a symbol, call C routine to error check
	subl2	$8,NP		#unstack args
	rsb			# and return what it returned.

/*
 * _qexarith 	exact arithmetic
 * calculates x=a*b+c  where a,b and c are 32 bit 2's complement integers
 * whose top two bits must be the same (i.e. the are members of the set
 * of valid fixnum values for Franz Lisp).  The result, x, will be 64 bits
 * long but since each of a, b and c had only 31 bits of precision, the
 * result x only has 62 bits of precision.  The lower 30 bits are returned
 * in *plo and the high 32 bits are returned in *phi.  If *phi is 0 or -1 then
 * x doesn't need any more than 31 bits plus sign to describe, so we
 * place the sign in the high two bits of *plo and return 0 from this
 * routine.  A non zero return indicates that x requires more than 31 bits
 * to describe.
 */

	.globl	_qexarith
/* qexarith(a,b,c,phi,plo)
 * int *phi, *plo;
 */
_qexarith:
	emul	4(sp),8(sp),12(sp),r2   #r2 = a*b + c to 64 bits
	extzv	$0,$30,r2,*20(sp)	#get new lo
	extv	$30,$32,r2,r0		#get new carry
	beql	out			# hi = 0, no work necessary
	movl	r0,*16(sp)		# save hi
	mcoml	r0,r0			# Is hi = -1 (it'll fit in one word)
	bneq	out			# it doesn't
	bisl2	$0xc0000000,*20(sp)	# alter low so that it is ok.
out:	rsb



/*
 * pushframe : stack a frame 
 * When this is called, the optional arguments and class have already been
 * pushed on the stack as well as the return address (by virtue of the jsb)
 * , we push on the rest of the stuff (see h/frame.h)
 * for a picture of the save frame
 */
	.globl	_qpushframe

_qpushframe:
	Profile
	movl	_errp,-(sp)
	movl	_bnp,-(sp)
	movl	NP,-(sp)
	movl	LBOT,-(sp)
	pushr	$0x3f00		# save r13(fp), r12(ap),r11,r10,r9,r8
	movab	6*4(sp),r0	# return addr of lbot on stack
	clrl	_retval		# set retval to C_INITIAL
#ifndef SPISFP
	jmp	*40(sp)		# return through return address
#else
	movab	-4(sp),sp
	movl	sp,(sp)
	movl	_xsp,-(sp)
	jmp	*48(sp)
#endif

/*
 * Ipushf : stack a frame, where space is preallocated on the stack. 
 * this is like pushframe, except that it doesn't alter the stack pointer
 * and will save more registers.
 * This might be written a little more quickly by having a bigger register
 * save mask, but this is only supposed to be an example for the
 * IBM and RIDGE people.
 */

#ifdef SPISFP
	.globl	_Ipushf
_Ipushf:
	.word	0
	addl3	$96,16(ap),r1
	movl	12(ap),-(r1)
	movl	8(ap),-(r1)
	movl	4(ap),-(r1)
	movl	16(fp),-(r1)
	movl	_errp,-(r1)
	movl	_bnp,-(r1)
	movl	NP,-(r1)
	movl	LBOT,-(r1)
	movl	r1,r0
	movq	8(fp),-(r1) /* save stuff in the same order unix saves them
			 (r13,r12,r11,r10,r9,r8) and then add extra
			 for vms (sp,r7,r6,r5,r4,r3,r2) */
	movq	r10,-(r1)
	movq	r8,-(r1)
	movab	20(ap),-(r1) /* assumes Ipushf allways called by calls, with
				the stack alligned */
	movl	_xsp,-(r1)
	movq	r6,-(r1)
	movq	r4,-(r1)
	movq	r2,-(r1)
	clrl	_retval
	ret
#endif
/*
 * qretfromfr
 * called with frame to ret to in r11.  The popnames has already been done.
 * we must restore all registers, and jump to the ret addr. the popping
 * must be done without reducing the stack pointer since an interrupt
 * could come in at any time and this frame must remain on the stack.
 * thus we can't use popr.
 */

	.globl	_qretfromfr

_qretfromfr:
	Profile
	movl	r11,r0		# return error frame location
	subl3	$24,r11,sp	# set up sp at bottom of frame
	movl	sp,r1		# prepare to pop off
	movq	(r1)+,r8	# r8,r9
	movq	(r1)+,r10	# r10,r11
	movq	(r1)+,r12	# r12,r13
	movl	(r1)+,LBOT	# LBOT (lbot)
	movl	(r1)+,NP	# NP (np)
	jmp	*40(sp)		# jump out of frame

#ifdef SPISFP

/*
 * this is equivalent to qretfro for a native VMS system
 *
 */
	.globl	_Iretfrm
_Iretfrm:
	.word	0
	movl	4(ap),r0	# return error frame location
	movl	r0,r1
	movq	-(r1),ap
	movq	-(r1),r10
	movq	-(r1),r8
	movl	-(r1),sp
	movl	-(r1),_xsp
	movq	-(r1),r6
	movq	-(r1),r4
	movq	-(r1),r2
	movl	r0,r1
	movl	(r1)+,LBOT
	movl	(r1)+,NP
	jmp	*16(r0)
#endif

/*
 * this routine finishes setting things up for dothunk
 * it is code shared to keep the size of c-callable thunks
 * for lisp functions, small.
 */
	.globl	_thcpy
_thcpy:
	movl	(sp),r0
	pushl	ap
	pushl	(r0)+
	pushl	(r0)+
	calls	$4,_dothunk
	ret
/*
 * This routine gets the name of the inital entry point
 * It is here so it can be under ifdef control.
 */
	.globl	_gstart
_gstart:
	.word	0
#if os_vms
	moval	_$$$start,r0
#else
	moval	start,r0
#endif
	ret
	.globl	_proflush
_proflush:
	.word	0
	ret

/*
 * The definition of mcount must be present even when the C code
 * isn't being profiled, since lisp code may reference it.
 */

#ifndef os_vms
.globl	mcount
mcount:
#endif

.globl _mcount
_mcount:

#ifdef PROF
	movl	(r0),r1
	bneq	incr
	movl	_countbase,r1
	beql	return
	addl2	$8,_countbase
	movl	(sp),(r1)+
	movl	r1,(r0)
incr:
	incl	(r1)
return:
#endif
	rsb

	
/* This must be at the end of the file.  If we are profiling, allocate
 * space for the profile buffer
 */
#ifdef PROF
	.data
	.comm	_countbase,4
	.lcomm	prbuf,indx+4
	.text
#endif
EndOfFile
cat >  franz/vax/crt0.s  << 'EndOfFile'
# C runtime startoff
# $Header: /na/franz/franz/vax/RCS/crt0.s,v 1.1 83/03/27 18:39:57 jkf Exp $

	.set	exit,1
.globl	_exit
.globl	start
.globl	_main
.globl	_environ

start:
	.word	0x0000
	subl2	$8,sp
	movl	8(sp),(sp)  #  argc
	movab	12(sp),r0
	movl	r0,4(sp)  #  argv
L1:
	tstl	(r0)+  #  null args term ?
	bneq	L1
	cmpl	r0,*4(sp)  #  end of 'env' or 'argv' ?
	blss	L2
	tstl	-(r0)  # envp's are in list
L2:
	movl	r0,8(sp)  #  env
#	movl	r0,_environ  #  indir is 0 if no env ; not 0 if env
	calls	$3,_main
	pushl	r0
	calls	$1,_exit
	chmk	$exit
	.data
_environ:	.space	4
EndOfFile
cat >  franz/vax/hcrt0.s  << 'EndOfFile'
# C runtime startoff
# $Header: /na/franz/franz/vax/RCS/hcrt0.s,v 1.1 83/03/27 18:40:07 jkf Exp $

	.set	exit,1
.globl	_exit
.globl	start
.globl	hstart
.globl	_main
.globl	_environ

#
#	C language startup routine

hstart:	
	.word	0x0000
	movl	$1,r1
	jbr	L0
start:
	.word	0x0000
	clrl	r1
L0:
	subl2	$8,sp
	movl	8(sp),(sp)  #  argc
	movab	12(sp),r0
	movl	r0,4(sp)  #  argv
L1:
	tstl	(r0)+  #  null args term ?
	bneq	L1
	cmpl	r0,*4(sp)  #  end of 'env' or 'argv' ?
	blss	L2
	tstl	-(r0)  # envp's are in list
L2:
	movl	r0,8(sp)  #  env
	movl	r0,r10  #  indir is 0 if no env ; not 0 if env
	tstl	r1
	beql	L3
	calls	$0,_rlc
L3:
	movl	r10,_environ
	calls	$3,_main
	pushl	r0
	calls	$1,_exit
	chmk	$exit
#
	.data
_environ:	.space	4
EndOfFile
cat >  franz/vax/vax.c  << 'EndOfFile'

#ifndef lint
static char *rcsid =
   "$Header: vax.c,v 1.6 84/02/29 16:45:23 sklower Exp $";
#endif

/*					-[Mon Mar 21 19:35:50 1983 by jkf]-
 * 	vax.c				$Locker:  $
 * vax specific functions
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
#include "global.h"
#include <signal.h>
#include "vaxframe.h"

/* exarith(a,b,c,lo,hi)
 * int a,b,c;
 * int *lo, *hi;
 * Exact arithmetic.
 * a,b and c are 32 bit 2's complement integers
 * calculates x=a*b+c to twice the precision of an int.
 * In the vax version, the 30 low bits only are returned
 * in *lo,and the next 32 bits of precision are returned in * hi.
 * this works since exarith is used either for calculating the sum of
 * two 32 bit numbers, (which is at most 33 bits), or
 * multiplying a 30 bit number by a 32 bit numbers,
 * which has a maximum precision of 62 bits.
 * If *phi is 0 or -1 then
 * x doesn't need any more than 31 bits plus sign to describe, so we
 * place the sign in the high two bits of *lo and return 0 from this
 * routine.  A non zero return indicates that x requires more than 31 bits
 * to describe.
 */
exarith(a,b,c,phi,plo)
int *phi, *plo;
{
asm("	emul	4(ap),8(ap),12(ap),r2	#r2 = a*b + c to 64 bits");
asm("	extzv	$0,$30,r2,*20(ap)	#get new lo");
asm("	extv	$30,$32,r2,r0		#get new carry");
asm("	beql	out			# hi = 0, no work necessary");
asm("	movl	r0,*16(ap)		# save hi");
asm("	mcoml	r0,r0			# Is hi = -1 (it'll fit in one word)");
asm("	bneq	out			# it doesn't");
asm("	bisl2	$0xc0000000,*20(ap)	# alter low so that it is ok.");
asm("out:	ret");
}

mmuladd (a, b, c, m) 
int a, b, c, m;
{
	asm ("emul	4(ap),8(ap),12(ap),r0");
	asm ("ediv	16(ap),r0,r2,r0");
}

Imuldiv() {
asm("	emul	4(ap),8(ap),12(ap),r0");
asm("	ediv	16(ap),r0,*20(ap),*24(ap)");
}

callg_(funct,arglist)
lispval (*funct)();
int *arglist;
{
	asm("	callg	*8(ap),*4(ap)");
}

#include <errno.h>
#define WRITE 4
#define READ 3

#ifdef os_vms
#define _read _$real_read
#define _write _$real_write
#else
#define _read(a,b,c) syscall(READ,a,b,c)
#define _write(a,b,c) syscall(WRITE,a,b,c)
#endif

/*C library -- write
  nwritten = write(file, buffer, count);
  nwritten == -1 means error
*/
write(file, buffer, count)
char *buffer;
{
	register lispval handy;
	int retval;
	if((file != 1) || (Vcntlw->a.clb == nil)) goto top;
	/* since ^w is non nil, we do not want to print to the terminal,
	   but we must be sure to return a correct value from the write
	   in case there is no write to ptport
	*/
	retval = count;
	goto skipit;
top:
	retval = _write(file,buffer,count);

skipit:
    if(file==1) {
	handy = Vptport->a.clb;
	if(handy!=nil && TYPE(handy)==PORT && handy->p->_file!=1) {
		fflush(handy->p);
		file = handy->p->_file;
		goto top;
	}
    }
    return(retval);
}

/*
 *
 *nread = read(file, buffer, count);
 *nread ==0 means eof; nread == -1 means error
 *
 */

read(file,buffer,count)
{
	extern int errno;
	register int Size;
again:
	Size = _read(file,buffer,count);
	if ((Size >= 0) || (errno != EINTR)) return(Size);
	if(sigintcnt > 0) sigcall(SIGINT);
	goto again;
}

lispval
Lpolyev()
{
	register int count; 
	register double *handy, *base;
	register struct argent *argp;
	lispval result; int type;
	char *alloca();
	Keepxs();

	count = 2 * (((int) np) - (int) lbot);
	if(count == 0) 
		return(inewint(0));
	if(count == 8)
		return(lbot->val);
	base = handy = (double *) alloca(count);
	for(argp = lbot; argp < np; argp++) {
		while((type = TYPE(argp->val))!=DOUB && type!=INT)
			argp->val = (lispval) errorh2(Vermisc,"%%machine-polyev:non-real arg",nil,TRUE,73,lbot,argp->val);
		if(TYPE(argp->val)==INT) {
			*handy++ = argp->val->i;
		} else
			*handy++ = argp->val->r;
	}
	count = count/sizeof(double) - 2;
	asm("polyd	(r9),r11,8(r9)");
	asm("movd	r0,(r9)");
	result = newdoub();
	result->r = *base;
	Freexs();
	return(result);
}

lispval
Lrot()
{
	register rot,val;		/* these must be the first registers */
	register struct argent *mylbot = lbot;

	chkarg(2,"rot");
	if((TYPE(mylbot->val) != INT) || (TYPE(mylbot[1].val) != INT))
		errorh2(Vermisc,
		       "Non ints to rot",
		       nil,FALSE,0,mylbot->val,mylbot[1].val);
	val = mylbot[0].val->i;
	rot = mylbot[1].val->i;
	rot = rot % 32 ;	/* bring it down below one byte in size */
	asm(" rotl r11,r10,r10 ");  /* rotate val by rot and put back in val */
	return( inewint(val));
}
/* new version of showstack,
	We will set fp to point where the register fp points.
	Then fp+2 = saved ap
	     fp+4 = saved pc
	     fp+3 = saved fp
	     ap+1 = first arg
	If we find that the saved pc is somewhere in the routine eval,
   then we print the first argument to that eval frame. This is done
   by looking one beyond the saved ap.
*/
lispval
Lshostk()
{	lispval isho();
	return(isho(1));
}
static lispval
isho(f)
int f;
{
	register struct machframe *myfp; register lispval handy;
	int **fp;	/* this must be the first local */
	int virgin=1;
	lispval linterp();
	lispval _qfuncl(),tynames();	/* locations in qfuncl */
	extern int plevel,plength;

	if(TYPE(Vprinlevel->a.clb) == INT)
	{ 
	   plevel = Vprinlevel->a.clb->i;
	}
	else plevel = -1;
	if(TYPE(Vprinlength->a.clb) == INT)
	{
	    plength = Vprinlength->a.clb->i;
	}
	else plength = -1;

	if(f==1)
		printf("Forms in evaluation:\n");
	else
		printf("Backtrace:\n\n");

	myfp = (struct machframe *) (&fp +1);	/* point to current frame */

	while(TRUE)
	{
	    if( (myfp->pc > eval  &&  		/* interpreted code */
		 myfp->pc < popnames)
		||
		(myfp->pc > Lfuncal &&		/* compiled code */
		 myfp->pc < linterp)  )
	    {
	      if(((int) myfp->ap[0]) == 1)		/* only if arg given */
	      { handy = (myfp->ap[1]);
		if(f==1)
			printr(handy,stdout), putchar('\n');
		else {
			if(virgin)
				virgin = 0;
			else
				printf(" -- ");
			printr((TYPE(handy)==DTPR)?handy->d.car:handy,stdout);
		}
	      }

	    }

	    if(myfp > myfp->fp) break;	/* end of frames */
	    else myfp = myfp->fp;
	}
	putchar('\n');
	return(nil);
}

/*
 *
 *	(baktrace)
 *
 * baktrace will print the names of all functions being evaluated
 * from the current one (baktrace) down to the first one.
 * currently it only prints the function name.  Planned is a
 * list of local variables in all stack frames.
 * written by jkf.
 *
 */
lispval
Lbaktrace()
{
	isho(0);
}

/*
 * (int:showstack 'stack_pointer)
 * return
 *   nil if at the end of the stack or illegal
 *   ( expresssion . next_stack_pointer) otherwise
 *   where expression is something passed to eval
 * very vax specific
 */
lispval
LIshowstack()
{
    int **fp;	/* must be the first local variable */
    register lispval handy;
    register struct machframe *myfp;
    lispval retval, Lfuncal(), Ifuncal();
    Savestack(2);
    
    chkarg(1,"int:showstack");

    if((TYPE(handy=lbot[0].val) != INT) && (handy != nil))
        error("int:showstack non fixnum arg", FALSE);

    if(handy == nil)
        myfp = (struct machframe *) (&fp +1);
    else
        myfp = (struct machframe *) handy->i;
	
    if((int ***)myfp <= &fp) error("int:showstack illegal stack value",FALSE);
    while(myfp > 0)
    {
        if( (myfp->pc > eval  &&  		/* interpreted code */
            myfp->pc < popnames)
	    ||
	    (myfp->pc > Ifuncal &&		/* compiled code */
	    myfp->pc < Lfuncal)  )
        {
	    if(((int) myfp->ap[0]) == 1)	/* only if arg given */
	    {
		handy = (lispval)(myfp->ap[1]);	/* arg to eval */

		protect(retval=newdot());
		retval->d.car = handy;
		if(myfp > myfp->fp)
		    myfp = 0;	/* end of frames */
		else
		    myfp = myfp->fp;
		retval->d.cdr = inewint(myfp);
		return(retval);
	    }
	}
	if(myfp > myfp->fp)
	     myfp = 0;	/* end of frames */
	else
	     myfp = myfp->fp;

    }
    return(nil);
}
#include "frame.h"
/*
 * this code is very similar to ftolsp.
 * if it gets revised, so should this.
 */
lispval
dothunk(func,count,arglist)
lispval func;
long count;
register long *arglist;
{

	lispval save;
	pbuf pb;
	Savestack(1);

	if(errp->class==F_TO_FORT)
		np = errp->svnp;
	errp = Pushframe(F_TO_LISP,nil,nil);
	lbot = np;
	np++->val = func;
	arglist++;
	for(; count > 0; count--)
		np++->val = inewint(*arglist++);
	save = Lfuncal();
	errp = Popframe();
	Restorestack();
	return(save);
}
/*
_thcpy:
	movl	(sp),r0
	pushl	ap
	pushl	(r0)+
	pushl	(r0)+
	calls	$3,_dothunk
	ret */
static char fourwords[] = "0123456789012345";

lispval
Lmkcth()
{
	register struct argent *mylbot = lbot;
	register struct thunk {
		short	mask;
		short 	jsri;
		char	*thcpy;
		long	count;
		lispval func;
	} *th;
	extern char thcpy[];

	chkarg(2,"make-c-thunk");
	th = (struct thunk *)pinewstr(fourwords);
	th->mask = 0;
	th->jsri = 0x9f16;
	th->thcpy = thcpy;
	th->func = mylbot->val;
	th->count = mylbot[1].val->i;

	return((lispval)th);
}
EndOfFile
cat >  franz/vax/malloc.c  << 'EndOfFile'
#ifndef lint
static char sccsid[] = "@(#)malloc.c	4.3 (Berkeley) 9/16/83";
#endif

/*
 * malloc.c (Caltech) 2/21/82
 * Chris Kingsley, kingsley@cit-20.
 *
 * This is a very fast storage allocator.  It allocates blocks of a small 
 * number of different sizes, and keeps free lists of each size.  Blocks that
 * don't exactly fit are passed up to the next larger size.  In this 
 * implementation, the available sizes are 2^n-4 (or 2^n-12) bytes long.
 * This is designed for use in a program that uses vast quantities of memory,
 * but bombs when it runs out. 
 */

#include <sys/types.h>

#define	NULL 0

/*
 * The overhead on a block is at least 4 bytes.  When free, this space
 * contains a pointer to the next free block, and the bottom two bits must
 * be zero.  When in use, the first byte is set to MAGIC, and the second
 * byte is the size index.  The remaining bytes are for alignment.
 * If range checking is enabled and the size of the block fits
 * in two bytes, then the top two bytes hold the size of the requested block
 * plus the range checking words, and the header word MINUS ONE.
 */
union	overhead {
	union	overhead *ov_next;	/* when free */
	struct {
		u_char	ovu_magic;	/* magic number */
		u_char	ovu_index;	/* bucket # */
#ifdef RCHECK
		u_short	ovu_size;	/* actual block size */
		u_int	ovu_rmagic;	/* range magic number */
#endif
	} ovu;
#define	ov_magic	ovu.ovu_magic
#define	ov_index	ovu.ovu_index
#define	ov_size		ovu.ovu_size
#define	ov_rmagic	ovu.ovu_rmagic
};

#define	MAGIC		0xff		/* magic # on accounting info */
#define RMAGIC		0x55555555	/* magic # on range info */
#ifdef RCHECK
#define	RSLOP		sizeof (u_int)
#else
#define	RSLOP		0
#endif

/*
 * nextf[i] is the pointer to the next free block of size 2^(i+3).  The
 * smallest allocatable block is 8 bytes.  The overhead information
 * precedes the data area returned to the user.
 */
#define	NBUCKETS 30
static	union overhead *nextf[NBUCKETS];
extern	char *sbrk();

#ifdef MSTATS
/*
 * nmalloc[i] is the difference between the number of mallocs and frees
 * for a given block size.
 */
static	u_int nmalloc[NBUCKETS];
#include <stdio.h>
#endif

#ifdef debug
#define	ASSERT(p)   if (!(p)) botch("p"); else
static
botch(s)
	char *s;
{

	printf("assertion botched: %s\n", s);
	abort();
}
#else
#define	ASSERT(p)
#endif

char *
malloc(nbytes)
	register unsigned nbytes;
{
  	register union overhead *p;
  	register int bucket = 0;
  	register unsigned shiftr;

	/*
	 * Convert amount of memory requested into
	 * closest block size stored in hash buckets
	 * which satisfies request.  Account for
	 * space used per block for accounting.
	 */
  	nbytes += sizeof (union overhead) + RSLOP;
  	nbytes = (nbytes + 3) &~ 3; 
  	shiftr = (nbytes - 1) >> 2;
	/* apart from this loop, this is O(1) */
  	while (shiftr >>= 1)
  		bucket++;
	/*
	 * If nothing in hash bucket right now,
	 * request more memory from the system.
	 */
  	if (nextf[bucket] == NULL)    
  		morecore(bucket);
  	if ((p = (union overhead *)nextf[bucket]) == NULL)
  		return (NULL);
	/* remove from linked list */
  	nextf[bucket] = nextf[bucket]->ov_next;
	p->ov_magic = MAGIC;
	p->ov_index= bucket;
#ifdef MSTATS
  	nmalloc[bucket]++;
#endif
#ifdef RCHECK
	/*
	 * Record allocated size of block and
	 * bound space with magic numbers.
	 */
  	if (nbytes <= 0x10000)
		p->ov_size = nbytes - 1;
	p->ov_rmagic = RMAGIC;
  	*((u_int *)((caddr_t)p + nbytes - RSLOP)) = RMAGIC;
#endif
  	return ((char *)(p + 1));
}

/*
 * Allocate more memory to the indicated bucket.
 */
static
morecore(bucket)
	register bucket;
{
  	register union overhead *op;
  	register int rnu;       /* 2^rnu bytes will be requested */
  	register int nblks;     /* become nblks blocks of the desired size */
	register int siz;

  	if (nextf[bucket])
  		return;
	/*
	 * Insure memory is allocated
	 * on a page boundary.  Should
	 * make getpageize call?
	 */
  	op = (union overhead *)sbrk(0);
  	if ((int)op & 0x3ff)
  		sbrk(1024 - ((int)op & 0x3ff));
	/* take 2k unless the block is bigger than that */
  	rnu = (bucket <= 8) ? 11 : bucket + 3;
  	nblks = 1 << (rnu - (bucket + 3));  /* how many blocks to get */
  	if (rnu < bucket)
		rnu = bucket;
	op = (union overhead *)sbrk(1 << rnu);
	/* no more room! */
  	if ((int)op == -1)
  		return;
	/*
	 * Round up to minimum allocation size boundary
	 * and deduct from block count to reflect.
	 */
  	if ((int)op & 7) {
  		op = (union overhead *)(((int)op + 8) &~ 7);
  		nblks--;
  	}
	/*
	 * Add new memory allocated to that on
	 * free list for this hash bucket.
	 */
  	nextf[bucket] = op;
  	siz = 1 << (bucket + 3);
  	while (--nblks > 0) {
		op->ov_next = (union overhead *)((caddr_t)op + siz);
		op = (union overhead *)((caddr_t)op + siz);
  	}
}

free(cp)
	char *cp;
{   
  	register int size;
	register union overhead *op;

  	if (cp == NULL)
  		return;
	op = (union overhead *)((caddr_t)cp - sizeof (union overhead));
#ifdef debug
  	ASSERT(op->ov_magic == MAGIC);		/* make sure it was in use */
#else
	if (op->ov_magic != MAGIC)
		return;				/* sanity */
#endif
#ifdef RCHECK
  	ASSERT(op->ov_rmagic == RMAGIC);
	if (op->ov_index <= 13)
		ASSERT(*(u_int *)((caddr_t)op + op->ov_size + 1 - RSLOP) == RMAGIC);
#endif
  	ASSERT(op->ov_index < NBUCKETS);
  	size = op->ov_index;
	op->ov_next = nextf[size];
  	nextf[size] = op;
#ifdef MSTATS
  	nmalloc[size]--;
#endif
}

/*
 * When a program attempts "storage compaction" as mentioned in the
 * old malloc man page, it realloc's an already freed block.  Usually
 * this is the last block it freed; occasionally it might be farther
 * back.  We have to search all the free lists for the block in order
 * to determine its bucket: 1st we make one pass thru the lists
 * checking only the first block in each; if that fails we search
 * ``realloc_srchlen'' blocks in each list for a match (the variable
 * is extern so the caller can modify it).  If that fails we just copy
 * however many bytes was given to realloc() and hope it's not huge.
 */
int realloc_srchlen = 4;	/* 4 should be plenty, -1 =>'s whole list */

char *
realloc(cp, nbytes)
	char *cp; 
	unsigned nbytes;
{   
  	register u_int onb;
	union overhead *op;
  	char *res;
	register int i;
	int was_alloced = 0;

  	if (cp == NULL)
  		return (malloc(nbytes));
	op = (union overhead *)((caddr_t)cp - sizeof (union overhead));
	if (op->ov_magic == MAGIC) {
		was_alloced++;
		i = op->ov_index;
	} else {
		/*
		 * Already free, doing "compaction".
		 *
		 * Search for the old block of memory on the
		 * free list.  First, check the most common
		 * case (last element free'd), then (this failing)
		 * the last ``realloc_srchlen'' items free'd.
		 * If all lookups fail, then assume the size of
		 * the memory block being realloc'd is the
		 * smallest possible.
		 */
		if ((i = findbucket(op, 1)) < 0 &&
		    (i = findbucket(op, realloc_srchlen)) < 0)
			i = 0;
	}
	onb = (1 << (i + 3)) - sizeof (*op) - RSLOP;
	/* avoid the copy if same size block */
	if (was_alloced &&
	    nbytes <= onb && nbytes > (onb >> 1) - sizeof(*op) - RSLOP)
		return(cp);
  	if ((res = malloc(nbytes)) == NULL)
  		return (NULL);
  	if (cp != res)			/* common optimization */
		bcopy(cp, res, (nbytes < onb) ? nbytes : onb);
  	if (was_alloced)
		free(cp);
  	return (res);
}

/*
 * Search ``srchlen'' elements of each free list for a block whose
 * header starts at ``freep''.  If srchlen is -1 search the whole list.
 * Return bucket number, or -1 if not found.
 */
static
findbucket(freep, srchlen)
	union overhead *freep;
	int srchlen;
{
	register union overhead *p;
	register int i, j;

	for (i = 0; i < NBUCKETS; i++) {
		j = 0;
		for (p = nextf[i]; p && j != srchlen; p = p->ov_next) {
			if (p == freep)
				return (i);
			j++;
		}
	}
	return (-1);
}

#ifdef MSTATS
/*
 * mstats - print out statistics about malloc
 * 
 * Prints two lines of numbers, one showing the length of the free list
 * for each size category, the second showing the number of mallocs -
 * frees for each size category.
 */
mstats(s)
	char *s;
{
  	register int i, j;
  	register union overhead *p;
  	int totfree = 0,
  	totused = 0;

  	fprintf(stderr, "Memory allocation statistics %s\nfree:\t", s);
  	for (i = 0; i < NBUCKETS; i++) {
  		for (j = 0, p = nextf[i]; p; p = p->ov_next, j++)
  			;
  		fprintf(stderr, " %d", j);
  		totfree += j * (1 << (i + 3));
  	}
  	fprintf(stderr, "\nused:\t");
  	for (i = 0; i < NBUCKETS; i++) {
  		fprintf(stderr, " %d", nmalloc[i]);
  		totused += nmalloc[i] * (1 << (i + 3));
  	}
  	fprintf(stderr, "\n\tTotal in use: %d, total free: %d\n",
	    totused, totfree);
}
#endif
EndOfFile
cat >  franz/vax/Make.vms  << 'EndOfFile'
#
# 
# $Header: Make.vms 1.3 83/04/26 14:22:20 sklower Exp $
#
# $Locker:  $
#  Franz Lisp C coded kernel 
#
#-- Default Paths:
#  see ../../ReadMe for a explaination of what LibDir and CopyTo mean
#  D is the directory used for holding intermediate files during 
#    compilation
#-- Options:
#  there is one compile time options which can be set in this file
#  * do profiling (ala the unix prof(1) command)
#
#  The selection of this options is made below
#  Other options can be selected by editing h/config.h or via
#  ../../lispconf
#
AS = vmsas	# Generate VMS object files

LibDir = /usr/lib/lisp
ObjDir = /usr/ucb
CopyTo = /dev/null
Liszt = liszt
Lisp = lisp
# if you change this you must recompile rlc.c 
# (and change the value in ../Makefile)
#
HOLE=2097152

.DEFAULT: nlisp

MipSrc1= ../low.c ../lowaux.s
MipSrc2= ../alloc.c ../data.c
MipSrc3= ../rlc.c
MipSrc4= ../lisp.c ../eval.c ../eval2.c ../inits.c ../io.c ../error.c \
	 ../sysat.c ../lam1.c ../lam2.c ../lam3.c ../lam4.c ../lam5.c\
	 ../lam6.c  ../lam7.c ../lam8.c ../lam9.c ../lamr.c ../lamp.c \
	 ../fex1.c ../fex2.c ../fex3.c ../fex4.c ../fexr.c\
	 ../fpipe.c \
	 ../subbig.c ../pbignum.c ../divbig.c \
	 ../ffasl.c ../fasl.c \
	 ../trace.c ../evalf.c ../frame.c ../lamgc.c

MipSrc = ${MipSrc1} ${MipSrc2} ${MipSrc3} ${MipSrc4}

MipObj1= ../low.o  ../lowaux.o
MipObj2= ../alloc.o ../data.o
HoleMipObj2 = ../Salloc.o ../Sdata.o
HoleMipObj3 = ../rlc.o
MipObj4= ../lisp.o ../eval.o ../eval2.o ../inits.o ../io.o ../error.o \
	 ../sysat.o ../lam1.o ../lam2.o ../lam3.o ../lam4.o ../lam5.o\
	 ../lam6.o  ../lam7.o ../lam8.o ../lam9.o ../lamr.o ../lamp.o \
	 ../fex1.o ../fex2.o ../fex3.o ../fex4.o ../fexr.o\
	 ../fpipe.o \
	 ../subbig.o ../pbignum.o ../divbig.o \
	 ../ffasl.o ../fasl.o \
	 ../trace.o ../evalf.o ../frame.o ../lamgc.o

# this list must contain all the include files, not just those used
# in the vax version.  The include filenames are relative to ..
#
Includes = h/config.h 	h/global.h 	h/oaout.h 	h/vaxframe.h \
	h/catchfram.h 	h/dfuncs.h 	h/gtabs.h 	h/sigtab.h \
	h/chars.h 	h/frame.h 	h/lfuncs.h 	h/structs.h \
	h/chkrtab.h 	h/gc.h 		h/naout.h 	h/types.h \
	h/lconf.h	h/ltypes.h

#------ Options

#--- profiling selection
# If the lisp system is to run with profiling, this must be done:
#  1) remove the # (comment character) from the ProfFlag and
#     ProfFlag2 definitions below (also do it in ../Makefile)
#  2) remove all .o files and do a make.
#
ProfFlag = # -XP
ProfFlag2 = # -DPROF


# The order of loading of certain files is important.
# low.o must be first and lowaux second.
# 
BottomObj = ${MipObj1}

# Different objects are required depending on whether there is to be
# a hole between text and data space.
#
NoHoleObj = ${MipObj2}
HoleObj   = hole.obj ${HoleMipObj2} ${HoleMipObj3}

VaxObj = bigmath.o qfuncl.o vax.o prealloc.o

VaxSrc = bigmath.c qfuncl.c vax.c crt0.s hcrt0.s

# AllSrc does not (and should not) include ${Includes}

AllSrc = Makefile  fixmask.c fixpbig.e ${VaxSrc} ${MipSrc}


.SUFFIXES : .c.l
#
# use temporary files rather than pipes to keep the number of procs. down
# thus, users with low process quotas on VMS can still build lisp
#
.c.o :
	@csh -cfe "echo cc -c  $*.c;\
	rm -f $*.o;\
	/lib/cpp $< -I../h > $*.tm0;\
	/lib/ccom ${ProfFlag} $*.tm0 $*.tm1;\
	fixmask <$*.tm1 >$*.tm2;\
	sed -f fixpbig.e <$*.tm2 >$*.tm3;\
	/lib/c2 $*.tm3 >$*.tms;\
	${AS} -o $*.o $*.tms;\
	rm $*.tms $*.tm0 $*.tm1 $*.tm2 $*.tm3"

.l.o :
	liszt $< > #resc
	@echo liszt $< done

# one special case:
#  add -DPROF if you want to profile the assembler code

# EXPLICITLY USE "unixcpp" SO THAT "$"s IN ASSEMBLER CODE WORK!
qfuncl.o: qfuncl.c
	/lib/unixcpp -I../h ${ProfFlag2} qfuncl.c | ${AS} -o qfuncl.o

bigmath.o: bigmath.c
	/lib/unixcpp -I../h ${ProfFlag2} bigmath.c | ${AS} -o bigmath.o

../rlc.o: ../rlc.c 
	cc -S -O -DHOLE=${HOLE} ../rlc.c
	${AS} -o rlc.o rlc.s
	rm rlc.s
	mv rlc.o ../rlc.o

../low.o: ../low.c
	cc -I../h -R -S ../low.c
	${AS} -R -o low.o low.s
	rm low.s
	mv low.o ../low.o

../Salloc.o: ../alloc.c
	(echo "# define HOLE"; cat ../alloc.c) > Salloc.c;\
	make Salloc.o; mv Salloc.o .. < /dev/null ; rm Salloc.c
	
../Sdata.o: ../data.c
	(echo "# define HOLE=${HOLE}"; cat ../data.c) > Sdata.c;\
	make Sdata.o; mv Sdata.o .. < /dev/null  ; rm Sdata.c

fixmask: fixmask.c
	cc -O -o fixmask fixmask.c

# rawlisp is the standard raw lisp system.

rawlisp: fixmask fixpbig.e rawlisp.com \
		${BottomObj} ${NoHoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawlisp
	vms @rawlisp.com
	ls -l rawlisp


# hlisp is a raw lisp system with a hole between text and data

rawhlisp: fixmask fixpbig.e rawhlisp.com \
		${BottomObj} ${HoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawhlisp
	vms @rawhlisp.com ${HOLE}
	ls -l rawhlisp


clean:
	rm -f *.o

lint:
	lint h/*.h *.c

install: nlisp 
	-rm -f ${ObjDir}/lisp
	mv nlisp ${ObjDir}/lisp
	@echo lisp installed

nlisp: rawlisp ${LibDir}
	-rm -f nlisp
	(cd ${LibDir} ; make Liszt=${Liszt} required)
	echo "(progn (setq build:map 'map \
			   build:lisp-type 'franz \
		           lisp-library-directory '${LibDir} \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}) \
		     (load '${LibDir}/buildlisp)\
	             (dumplisp nlisp))" | rawlisp
	${LibDir}/tackon map nlisp
	@echo nlisp built


donlisp:
	-rm -f nlisp
	make LibDir=${LibDir} Liszt=${Liszt} ObjDir=${ObjDir} nlisp

#--- snlisp: create a totally interpreted lisp.
#	dump as snlisp
snlisp: rawlisp
	echo "(progn (setq build:load t		\
			   build:lisp-type 'franz \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}\
			   lisp-library-directory '${LibDir})\
		     (load '${LibDir}/buildlisp)\
		     (dumplisp snlisp))" | rawlisp


tags:  
	ctags $(VaxSrc) ${MipSrc}

#--- copysource : copy source files to another directory
#  called via   make CopyTo=/xx/yyy/zz copysource
# 
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@../../scriptcat . franz/vax ${AllSrc}
	@../../scriptcat .. franz ${Includes}

	
#--- prealloc.o: the "C" runtime startup for EUNICE with data structure
#	preallocation and restart capabilities
#		NFILES  - # file descriptors of data structure to allocate
#		RESTART	- allow restart from saved image
#
prealloc.o:	Makefile
	/lib/cpp -DNFILES=20 -DRESTART /usr/include/eunice/prealloc.c prealloc.tm0
	/lib/ccom prealloc.tm0 prealloc.tm1
	/lib/c2 prealloc.tm1 prealloc.tm2
	sed -f /usr/include/eunice/sedfixup.e <prealloc.tm2 >prealloc.tm3
	${AS} -o prealloc.o prealloc.tm3
	rm prealloc.tm0 prealloc.tm1 prealloc.tm2 prealloc.tm3

rawlisp.com: rawlisp.unx totxtfile
	totxtfile rawlisp.unx rawlisp.com

rawhlisp.com: rawhlisp.unx totxtfile
	totxtfile rawhlisp.unx rawhlisp.com

hole.obj: hole.unx totxtfile
	sed "s/%d/${HOLE}/" < hole.unx | totxtfile hole.mar
	vms macro/nolist hole.mar

totxtfile: totxtfile.c
	cc -O totxtfile.c -o totxtfile
EndOfFile
cat >  franz/vax/Make.uobj  << 'EndOfFile'
#
# 
# $Header: /na/franz/franz/vax/RCS/Makefile,v 1.3 83/03/23 22:33:01 jkf Exp $
#
#  Franz Lisp C coded kernel 
#
#-- Default Paths:
#  see ../../ReadMe for a explaination of what LibDir and CopyTo mean
#  D is the directory used for holding intermediate files during 
#    compilation
#-- Options:
#  there is one compile time options which can be set in this file
#  * do profiling (ala the unix prof(1) command)
#
#  The selection of this options is made below
#  Other options can be selected by editing h/config.h or via
#  ../../lispconf
#
AS = unixas	# Generate VMS object files
LD = unixld	# Generate VMS object files
CFLAGS = -DEUNICE_UNIX_OBJECT_FILE_CFASL	# enable UNIX object CFASL

LibDir = /usr/lib/lisp
ObjDir = /usr/ucb
CopyTo = /dev/null
Liszt = liszt
Lisp = lisp
# if you change this you must recompile rlc.c 
# (and change the value in ../Makefile)
#
HOLE=2097152

.DEFAULT: nlisp

MipSrc1= ../low.c
MipSrc2= ../alloc.c ../data.c
MipSrc3=
MipSrc4= ../lisp.c ../eval.c ../eval2.c ../inits.c ../io.c ../error.c \
	 ../sysat.c ../lam1.c ../lam2.c ../lam3.c ../lam4.c ../lam5.c\
	 ../lam6.c  ../lam7.c ../lam8.c ../lam9.c ../lamr.c ../lamp.c \
	 ../fex1.c ../fex2.c ../fex3.c ../fex4.c ../fexr.c\
	 ../fpipe.c \
	 ../subbig.c ../pbignum.c ../divbig.c \
	 ../ffasl.c ../fasl.c \
	 ../trace.c ../evalf.c ../frame.c ../lamgc.c

MipSrc = ${MipSrc1} ${MipSrc2} ${MipSrc3} ${MipSrc4}

MipObj1= ../low.o
MipObj2= ../alloc.o ../data.o
HoleMipObj2 = ../Salloc.o ../Sdata.o
HoleMipObj3 =
MipObj4= ../lisp.o ../eval.o ../eval2.o ../inits.o ../io.o ../error.o \
	 ../sysat.o ../lam1.o ../lam2.o ../lam3.o ../lam4.o ../lam5.o\
	 ../lam6.o  ../lam7.o ../lam8.o ../lam9.o ../lamr.o ../lamp.o \
	 ../fex1.o ../fex2.o ../fex3.o ../fex4.o ../fexr.o\
	 ../fpipe.o \
	 ../subbig.o ../pbignum.o ../divbig.o \
	 ../ffasl.o ../fasl.o \
	 ../trace.o ../evalf.o ../frame.o ../lamgc.o

# this list must contain all the include files, not just those used
# in the vax version.  The include filenames are relative to ..
#
Includes = h/config.h 	h/global.h 	h/oaout.h 	h/vaxframe.h \
	h/catchfram.h 	h/dfuncs.h 	h/gtabs.h 	h/sigtab.h \
	h/chars.h 	h/frame.h 	h/lfuncs.h 	h/structs.h \
	h/chkrtab.h 	h/gc.h 		h/naout.h 	h/types.h \
	h/lconf.h	h/ltypes.h

#------ Options

#--- profiling selection
# If the lisp system is to run with profiling, this must be done:
#  1) remove the # (comment character) from the ProfFlag and
#     ProfFlag2 definitions below (also do it in ../Makefile)
#  2) remove all .o files and do a make.
#
ProfFlag = # -XP
ProfFlag2 = # -DPROF


# The order of loading of certain files is important.
# low.o must be first and lowaux second.
# 
BottomObj = ${MipObj1} ../lowaux.o
HBottomObj = ${MipObj1} hlowaux.o

# Different objects are required depending on whether there is to be
# a hole between text and data space.
#
NoHoleObj = ${MipObj2}
HoleObj   = ${HoleMipObj2} ${HoleMipObj3}

VaxObj = bigmath.o qfuncl.o vax.o prealloc.o

VaxSrc = bigmath.c qfuncl.c vax.c crt0.s hcrt0.s lowaux.s

# AllSrc does not (and should not) include ${Includes}

AllSrc = Makefile  fixmask.c fixpbig.e ${VaxSrc} ${MipSrc}


.SUFFIXES : .c.l
#
# use temporary files rather than pipes to keep the number of procs. down
# thus, users with low process quotas on VMS can still build lisp
#
.c.o :
	@csh -cfe "echo cc -c  $*.c;\
	rm -f $*.o;\
	/lib/cpp ${CFLAGS} $< -I../h > $*.tm0;\
	/lib/ccom ${ProfFlag} $*.tm0 $*.tm1;\
	fixmask <$*.tm1 >$*.tm2;\
	sed -f fixpbig.e <$*.tm2 >$*.tm3;\
	/lib/c2 $*.tm3 >$*.tms;\
	${AS} -o $*.o $*.tms;\
	rm $*.tms $*.tm0 $*.tm1 $*.tm2 $*.tm3"

.l.o :
	liszt $< > #resc
	@echo liszt $< done

# one special case:
#  add -DPROF if you want to profile the assembler code

# EXPLICITLY USE "unixcpp" SO THAT "$"s IN ASSEMBLER CODE WORK!
qfuncl.o: qfuncl.c
	/lib/unixcpp -I../h ${ProfFlag2} qfuncl.c | ${AS} -o qfuncl.o

bigmath.o: bigmath.c
	/lib/unixcpp -I../h ${ProfFlag2} bigmath.c | ${AS} -o bigmath.o

../rlc.o: ../rlc.c 
	cc -S -O ${CFLAGS} -DHOLE=${HOLE} ../rlc.c
	${AS} -o rlc.o rlc.s
	rm rlc.s
	mv rlc.o ../rlc.o

../low.o: ../low.c
	cc ${CFLAGS} -I../h -R -S ../low.c
	${AS} -R -o low.o low.s
	rm low.s
	mv low.o ../low.o

../Salloc.o: ../alloc.c
	(echo "# define HOLE ${HOLE}"; cat ../alloc.c) > Salloc.c;\
	make Salloc.o; mv Salloc.o .. < /dev/null ; rm Salloc.c
	
../Sdata.o: ../data.c
	(echo "# define HOLE ${HOLE}"; cat ../data.c) > Sdata.c;\
	make Sdata.o; mv Sdata.o .. < /dev/null  ; rm Sdata.c

fixmask: fixmask.c
	cc -O -o fixmask fixmask.c

# rawlisp is the standard raw lisp system.

rawlisp: fixmask fixpbig.e \
		${BottomObj} ${NoHoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawlisp
	ld -noshare -nop0bufs -x -o rawlisp ${BottomObj} /lib/crt0.o \
				${NoHoleObj} ${VaxObj} ${MipObj4} \
				/lib/fastexecp.o  -lm -lc -ltermlib
	ls -l rawlisp


# hlisp is a raw lisp system with a hole between text and data

rawhlisp: fixmask fixpbig.e ${HBottomObj} ${HoleObj} ${MipObj4} ${VaxObj} 
	rm -f rawhlisp
	ld -noshare -nop0bufs -x -o rawhlisp ${HBottomObj} \
			        /lib/crt0.o ${HoleObj} \
				${VaxObj}  ${MipObj4} \
				/lib/fastexecp.o -lm -lc -ltermlib
	ls -l rawhlisp

hlowaux.o: ../lowaux.s
	sed "s/holbeg:/holbeg: .space ${HOLE}/" <../lowaux.s >hlowaux.s
	${AS} -o hlowaux.o hlowaux.s
	rm -f hlowaux.s


clean:
	rm -f *.o

lint:
	lint h/*.h *.c

install: nlisp 
	-rm -f ${ObjDir}/lisp
	mv nlisp ${ObjDir}/lisp
	@echo lisp installed

nlisp: rawlisp ${LibDir}
	-rm -f nlisp
	(cd ${LibDir} ; make Liszt=${Liszt} required)
	echo "(progn (setq build:map 'map \
			   build:lisp-type 'franz \
		           lisp-library-directory '${LibDir} \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}) \
		     (load '${LibDir}/buildlisp)\
	             (dumplisp nlisp))" | rawlisp
	${LibDir}/tackon map nlisp
	@echo nlisp built


donlisp:
	-rm -f nlisp
	make LibDir=${LibDir} Liszt=${Liszt} ObjDir=${ObjDir} nlisp

#--- snlisp: create a totally interpreted lisp.
#	dump as snlisp
snlisp: rawlisp
	echo "(progn (setq build:load t		\
			   build:lisp-type 'franz \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}\
			   lisp-library-directory '${LibDir})\
		     (load '${LibDir}/buildlisp)\
		     (dumplisp snlisp))" | rawlisp


tags:  
	ctags $(VaxSrc) ${MipSrc}

#--- copysource : copy source files to another directory
#  called via   make CopyTo=/xx/yyy/zz copysource
# 
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@../../scriptcat . franz/vax ${AllSrc}
	@../../scriptcat .. franz ${Includes}

	
#--- prealloc.o: the "C" runtime startup for EUNICE with data structure
#	preallocation and restart capabilities
#		NFILES  - # file descriptors of data structure to allocate
#		RESTART	- allow restart from saved image
#
prealloc.o:	Makefile
	/lib/cpp -DNFILES=20 -DRESTART /usr/include/eunice/prealloc.c prealloc.tm0
	/lib/ccom prealloc.tm0 prealloc.tm1
	/lib/c2 prealloc.tm1 prealloc.tm2
	sed -f /usr/include/eunice/sedfixup.e <prealloc.tm2 >prealloc.tm3
	${AS} -o prealloc.o prealloc.tm3
	rm prealloc.tm0 prealloc.tm1 prealloc.tm2 prealloc.tm3

totxtfile: totxtfile.c 
	cc -O totxtfile.c -o totxtfile
EndOfFile
cat >  franz/vax/rawlisp.unx  << 'EndOfFile'
$!
$!	Command file to link a "rawlisp" image
$!
$ link/exe=rawlisp/sym=rawlisp/map=rawlisp/full/cross sys$input:/opt
!
!	The 1st cluster gets all the lowcore data
!
cluster=0lowcore,0,,[-]low.o
!
!	The 2nd cluster gets everything else
!
cluster=lisp,,,[]bigmath.o,-
[-]alloc.o,-
[-]data.o,-
[-]divbig.o,-
[-]error.o,-
[-]eval.o,-
[-]eval2.o,-
[-]evalf.o,-
[-]fasl.o,-
[-]fex1.o,-
[-]fex2.o,-
[-]fex3.o,-
[-]fex4.o,-
[-]fexr.o,-
[-]ffasl.o,-
[-]fpipe.o,-
[-]frame.o,-
[-]inits.o,-
[-]io.o,-
[-]lam1.o,-
[-]lam2.o,-
[-]lam3.o,-
[-]lam4.o,-
[-]lam5.o,-
[-]lam6.o,-
[-]lam7.o,-
[-]lam8.o,-
[-]lam9.o,-
[-]lamgc.o,-
[-]lamp.o,-
[-]lamr.o,-
[-]lisp.o,-
[-]lowaux.o,-
[-]pbignum.o,-
[]qfuncl.o,-
[-]subbig.o,-
[-]sysat.o,-
[-]trace.o,-
[]vax.o,-
[]prealloc.o,-
lib:fastexecp.obj,-
lib:libtrmlib/library,lib:libm/library,lib:libc/library
iosegment=250,NOP0BUFS
$ !
$ !	Done: COPY the rawlisp.exe image to rawlisp. (for Make to be happy)
$ !
$ write sys$Output "Link Complete"
$ copy/log rawlisp.exe rawlisp.
EndOfFile
cat >  franz/vax/rawhlisp.unx  << 'EndOfFile'

$!
$!	Command file to link a "rawlisp" image
$!
$ link/exe=rawhlisp/sym=rawhlisp/map=rawhlisp/full/cross sys$input:/opt
!
!	The 1st cluster gets all the lowcore data
!
cluster=0lowcore,0,,[-]low.o
!
!	The 2nd cluster gets everything else
!
cluster=lisp,,,[]bigmath.o,-
[-]alloc.o,-
[-]data.o,-
[-]divbig.o,-
[-]error.o,-
[-]eval.o,-
[-]eval2.o,-
[-]evalf.o,-
[-]fasl.o,-
[-]fex1.o,-
[-]fex2.o,-
[-]fex3.o,-
[-]fex4.o,-
[-]fexr.o,-
[-]ffasl.o,-
[-]fpipe.o,-
[-]frame.o,-
[-]inits.o,-
[-]io.o,-
[-]lam1.o,-
[-]lam2.o,-
[-]lam3.o,-
[-]lam4.o,-
[-]lam5.o,-
[-]lam6.o,-
[-]lam7.o,-
[-]lam8.o,-
[-]lam9.o,-
[-]lamgc.o,-
[-]lamp.o,-
[-]lamr.o,-
[-]lisp.o,-
[-]pbignum.o,-
[]qfuncl.o,-
[-]subbig.o,-
[-]sysat.o,-
[-]trace.o,-
[]vax.o,-
[]prealloc.o,-
[]hole.obj,-
lib:fastexecp.obj,-
lib:libtrmlib/library,lib:libm/library,lib:libc/library
iosegment=250,NOP0BUFS
$ !
$ !	Done: COPY the rawlisp.exe image to rawlisp. (for Make to be happy)
$ !
$ write sys$Output "Link Complete"
$ copy/log rawhlisp.exe rawhlisp.
EndOfFile
cat >  franz/vax/hole.unx  << 'EndOfFile'
	.PSECT	$$$$$$$$$$HOLE,LONG,PIC,USR,CON,REL,LCL,NOSHR,EXE,RD,WRT
holbeg::	.BLKB	%d
holend::
	.END
EndOfFile
cat >  franz/vax/totxtfile.c  << 'EndOfFile'

/*
 *
 *	This program changes a unix textfile to a VMS text file.
 *
 *	$Locker:  $
 *
 */
#include <stdio.h>

static char *rcsid = "$Header: /na/franz/franz/vax/RCS/totxtfile.c,v 1.1 83/04/11 00:31:07 sklower Exp $";

main(argc,argv)
char *argv[];
{
	int fd;
	register FILE *f, *in;
	register c;
	/*
	 *	Open the input file
	 */
	if(argc==3) {
		if(NULL==(in = fopen(argv[1],"r"))) {
			fprintf(stderr,
				"Couldn't open %s for reading\n",argv[1]);
			exit(2);
		}
		argc--; argv++;
	} else {
		in = fdopen(0,"r");
	}
	if(argc!=2) {
		fprintf(stderr,"Usage: totxtfile <unixfile> <vmsfile>\n");
		exit(1);
	}
	/*
	 *	Open the .txt file
	 */
	if ((fd = creat(argv[1],0777,"txt")) < 0) {
		fprintf(stderr,"Couldn't open %s for writing\n",argv[1]);
		exit(3);
	}
	f = fdopen(fd,"w");
	/*
	 *	Do the copy
	 */
	for(;;) {
		c = getc(in);
		if(c==EOF) break;
		putc(c,f);
	}
	/*
	 *	Close the file
	 */
	fclose(f);
	/*
	 *	Done
	 */
	exit(0);
}
EndOfFile
cat >  franz/vax/../low.c  << 'EndOfFile'
/*					-[Sat Jan 29 13:27:05 1983 by jkf]-
 * 	low.c				$Locker:  $
 * low core definition
 *
 * $Header: low.c,v 1.5 85/05/22 07:53:54 sklower Exp $
 * The static char* header must appear at the end of the file to
 * make sure that the following things are alligned correctly
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "hpagsiz.h"

extern char nilpname[];
struct atom nilatom = { nil, nil, nil, (struct atom *) CNIL, nilpname };

extern char eofpname[];
struct atom eofatom = { nil, nil, nil, (struct atom *) CNIL, eofpname };

static char padding[LBPG - sizeof nilatom - sizeof eofatom] = {0};

#ifndef RTPORTS
FILE *xports[128] = { _iob+0, _iob+1, _iob+2, _iob+3, _iob+4, _iob+5, _iob+6,
_iob+7, _iob+8, _iob+9, _iob+10, _iob+11, _iob+12, _iob+13, _iob+14, _iob+15,
_iob+16, _iob+17, _iob+18, _iob+19};
#else
static char WasXports[LBPG] = {0};
#endif

long Negs[] = {
-1024,-1023,-1022,-1021,-1020,-1019,-1018,-1017,
-1016,-1015,-1014,-1013,-1012,-1011,-1010,-1009,
-1008,-1007,-1006,-1005,-1004,-1003,-1002,-1001,
-1000,-999,-998,-997,-996,-995,-994,-993,
-992,-991,-990,-989,-988,-987,-986,-985,
-984,-983,-982,-981,-980,-979,-978,-977,
-976,-975,-974,-973,-972,-971,-970,-969,
-968,-967,-966,-965,-964,-963,-962,-961,
-960,-959,-958,-957,-956,-955,-954,-953,
-952,-951,-950,-949,-948,-947,-946,-945,
-944,-943,-942,-941,-940,-939,-938,-937,
-936,-935,-934,-933,-932,-931,-930,-929,
-928,-927,-926,-925,-924,-923,-922,-921,
-920,-919,-918,-917,-916,-915,-914,-913,
-912,-911,-910,-909,-908,-907,-906,-905,
-904,-903,-902,-901,-900,-899,-898,-897,
-896,-895,-894,-893,-892,-891,-890,-889,
-888,-887,-886,-885,-884,-883,-882,-881,
-880,-879,-878,-877,-876,-875,-874,-873,
-872,-871,-870,-869,-868,-867,-866,-865,
-864,-863,-862,-861,-860,-859,-858,-857,
-856,-855,-854,-853,-852,-851,-850,-849,
-848,-847,-846,-845,-844,-843,-842,-841,
-840,-839,-838,-837,-836,-835,-834,-833,
-832,-831,-830,-829,-828,-827,-826,-825,
-824,-823,-822,-821,-820,-819,-818,-817,
-816,-815,-814,-813,-812,-811,-810,-809,
-808,-807,-806,-805,-804,-803,-802,-801,
-800,-799,-798,-797,-796,-795,-794,-793,
-792,-791,-790,-789,-788,-787,-786,-785,
-784,-783,-782,-781,-780,-779,-778,-777,
-776,-775,-774,-773,-772,-771,-770,-769,
-768,-767,-766,-765,-764,-763,-762,-761,
-760,-759,-758,-757,-756,-755,-754,-753,
-752,-751,-750,-749,-748,-747,-746,-745,
-744,-743,-742,-741,-740,-739,-738,-737,
-736,-735,-734,-733,-732,-731,-730,-729,
-728,-727,-726,-725,-724,-723,-722,-721,
-720,-719,-718,-717,-716,-715,-714,-713,
-712,-711,-710,-709,-708,-707,-706,-705,
-704,-703,-702,-701,-700,-699,-698,-697,
-696,-695,-694,-693,-692,-691,-690,-689,
-688,-687,-686,-685,-684,-683,-682,-681,
-680,-679,-678,-677,-676,-675,-674,-673,
-672,-671,-670,-669,-668,-667,-666,-665,
-664,-663,-662,-661,-660,-659,-658,-657,
-656,-655,-654,-653,-652,-651,-650,-649,
-648,-647,-646,-645,-644,-643,-642,-641,
-640,-639,-638,-637,-636,-635,-634,-633,
-632,-631,-630,-629,-628,-627,-626,-625,
-624,-623,-622,-621,-620,-619,-618,-617,
-616,-615,-614,-613,-612,-611,-610,-609,
-608,-607,-606,-605,-604,-603,-602,-601,
-600,-599,-598,-597,-596,-595,-594,-593,
-592,-591,-590,-589,-588,-587,-586,-585,
-584,-583,-582,-581,-580,-579,-578,-577,
-576,-575,-574,-573,-572,-571,-570,-569,
-568,-567,-566,-565,-564,-563,-562,-561,
-560,-559,-558,-557,-556,-555,-554,-553,
-552,-551,-550,-549,-548,-547,-546,-545,
-544,-543,-542,-541,-540,-539,-538,-537,
-536,-535,-534,-533,-532,-531,-530,-529,
-528,-527,-526,-525,-524,-523,-522,-521,
-520,-519,-518,-517,-516,-515,-514,-513,
-512,-511,-510,-509,-508,-507,-506,-505,
-504,-503,-502,-501,-500,-499,-498,-497,
-496,-495,-494,-493,-492,-491,-490,-489,
-488,-487,-486,-485,-484,-483,-482,-481,
-480,-479,-478,-477,-476,-475,-474,-473,
-472,-471,-470,-469,-468,-467,-466,-465,
-464,-463,-462,-461,-460,-459,-458,-457,
-456,-455,-454,-453,-452,-451,-450,-449,
-448,-447,-446,-445,-444,-443,-442,-441,
-440,-439,-438,-437,-436,-435,-434,-433,
-432,-431,-430,-429,-428,-427,-426,-425,
-424,-423,-422,-421,-420,-419,-418,-417,
-416,-415,-414,-413,-412,-411,-410,-409,
-408,-407,-406,-405,-404,-403,-402,-401,
-400,-399,-398,-397,-396,-395,-394,-393,
-392,-391,-390,-389,-388,-387,-386,-385,
-384,-383,-382,-381,-380,-379,-378,-377,
-376,-375,-374,-373,-372,-371,-370,-369,
-368,-367,-366,-365,-364,-363,-362,-361,
-360,-359,-358,-357,-356,-355,-354,-353,
-352,-351,-350,-349,-348,-347,-346,-345,
-344,-343,-342,-341,-340,-339,-338,-337,
-336,-335,-334,-333,-332,-331,-330,-329,
-328,-327,-326,-325,-324,-323,-322,-321,
-320,-319,-318,-317,-316,-315,-314,-313,
-312,-311,-310,-309,-308,-307,-306,-305,
-304,-303,-302,-301,-300,-299,-298,-297,
-296,-295,-294,-293,-292,-291,-290,-289,
-288,-287,-286,-285,-284,-283,-282,-281,
-280,-279,-278,-277,-276,-275,-274,-273,
-272,-271,-270,-269,-268,-267,-266,-265,
-264,-263,-262,-261,-260,-259,-258,-257,
-256,-255,-254,-253,-252,-251,-250,-249,
-248,-247,-246,-245,-244,-243,-242,-241,
-240,-239,-238,-237,-236,-235,-234,-233,
-232,-231,-230,-229,-228,-227,-226,-225,
-224,-223,-222,-221,-220,-219,-218,-217,
-216,-215,-214,-213,-212,-211,-210,-209,
-208,-207,-206,-205,-204,-203,-202,-201,
-200,-199,-198,-197,-196,-195,-194,-193,
-192,-191,-190,-189,-188,-187,-186,-185,
-184,-183,-182,-181,-180,-179,-178,-177,
-176,-175,-174,-173,-172,-171,-170,-169,
-168,-167,-166,-165,-164,-163,-162,-161,
-160,-159,-158,-157,-156,-155,-154,-153,
-152,-151,-150,-149,-148,-147,-146,-145,
-144,-143,-142,-141,-140,-139,-138,-137,
-136,-135,-134,-133,-132,-131,-130,-129,
-128,-127,-126,-125,-124,-123,-122,-121,
-120,-119,-118,-117,-116,-115,-114,-113,
-112,-111,-110,-109,-108,-107,-106,-105,
-104,-103,-102,-101,-100,-99,-98,-97,
-96,-95,-94,-93,-92,-91,-90,-89,
-88,-87,-86,-85,-84,-83,-82,-81,
-80,-79,-78,-77,-76,-75,-74,-73,
-72,-71,-70,-69,-68,-67,-66,-65,
-64,-63,-62,-61,-60,-59,-58,-57,
-56,-55,-54,-53,-52,-51,-50,-49,
-48,-47,-46,-45,-44,-43,-42,-41,
-40,-39,-38,-37,-36,-35,-34,-33,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10,-9,
-8,-7,-6,-5,-4,-3,-2,-1};
long Fixzero[] = {
0,1,2,3,4,5,6,7,
8,9,10,11,12,13,14,15,
16,17,18,19,20,21,22,23,
24,25,26,27,28,29,30,31,
32,33,34,35,36,37,38,39,
40,41,42,43,44,45,46,47,
48,49,50,51,52,53,54,55,
56,57,58,59,60,61,62,63,
64,65,66,67,68,69,70,71,
72,73,74,75,76,77,78,79,
80,81,82,83,84,85,86,87,
88,89,90,91,92,93,94,95,
96,97,98,99,100,101,102,103,
104,105,106,107,108,109,110,111,
112,113,114,115,116,117,118,119,
120,121,122,123,124,125,126,127,
128,129,130,131,132,133,134,135,
136,137,138,139,140,141,142,143,
144,145,146,147,148,149,150,151,
152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,
168,169,170,171,172,173,174,175,
176,177,178,179,180,181,182,183,
184,185,186,187,188,189,190,191,
192,193,194,195,196,197,198,199,
200,201,202,203,204,205,206,207,
208,209,210,211,212,213,214,215,
216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,
232,233,234,235,236,237,238,239,
240,241,242,243,244,245,246,247,
248,249,250,251,252,253,254,255,
256,257,258,259,260,261,262,263,
264,265,266,267,268,269,270,271,
272,273,274,275,276,277,278,279,
280,281,282,283,284,285,286,287,
288,289,290,291,292,293,294,295,
296,297,298,299,300,301,302,303,
304,305,306,307,308,309,310,311,
312,313,314,315,316,317,318,319,
320,321,322,323,324,325,326,327,
328,329,330,331,332,333,334,335,
336,337,338,339,340,341,342,343,
344,345,346,347,348,349,350,351,
352,353,354,355,356,357,358,359,
360,361,362,363,364,365,366,367,
368,369,370,371,372,373,374,375,
376,377,378,379,380,381,382,383,
384,385,386,387,388,389,390,391,
392,393,394,395,396,397,398,399,
400,401,402,403,404,405,406,407,
408,409,410,411,412,413,414,415,
416,417,418,419,420,421,422,423,
424,425,426,427,428,429,430,431,
432,433,434,435,436,437,438,439,
440,441,442,443,444,445,446,447,
448,449,450,451,452,453,454,455,
456,457,458,459,460,461,462,463,
464,465,466,467,468,469,470,471,
472,473,474,475,476,477,478,479,
480,481,482,483,484,485,486,487,
488,489,490,491,492,493,494,495,
496,497,498,499,500,501,502,503,
504,505,506,507,508,509,510,511,
512,513,514,515,516,517,518,519,
520,521,522,523,524,525,526,527,
528,529,530,531,532,533,534,535,
536,537,538,539,540,541,542,543,
544,545,546,547,548,549,550,551,
552,553,554,555,556,557,558,559,
560,561,562,563,564,565,566,567,
568,569,570,571,572,573,574,575,
576,577,578,579,580,581,582,583,
584,585,586,587,588,589,590,591,
592,593,594,595,596,597,598,599,
600,601,602,603,604,605,606,607,
608,609,610,611,612,613,614,615,
616,617,618,619,620,621,622,623,
624,625,626,627,628,629,630,631,
632,633,634,635,636,637,638,639,
640,641,642,643,644,645,646,647,
648,649,650,651,652,653,654,655,
656,657,658,659,660,661,662,663,
664,665,666,667,668,669,670,671,
672,673,674,675,676,677,678,679,
680,681,682,683,684,685,686,687,
688,689,690,691,692,693,694,695,
696,697,698,699,700,701,702,703,
704,705,706,707,708,709,710,711,
712,713,714,715,716,717,718,719,
720,721,722,723,724,725,726,727,
728,729,730,731,732,733,734,735,
736,737,738,739,740,741,742,743,
744,745,746,747,748,749,750,751,
752,753,754,755,756,757,758,759,
760,761,762,763,764,765,766,767,
768,769,770,771,772,773,774,775,
776,777,778,779,780,781,782,783,
784,785,786,787,788,789,790,791,
792,793,794,795,796,797,798,799,
800,801,802,803,804,805,806,807,
808,809,810,811,812,813,814,815,
816,817,818,819,820,821,822,823,
824,825,826,827,828,829,830,831,
832,833,834,835,836,837,838,839,
840,841,842,843,844,845,846,847,
848,849,850,851,852,853,854,855,
856,857,858,859,860,861,862,863,
864,865,866,867,868,869,870,871,
872,873,874,875,876,877,878,879,
880,881,882,883,884,885,886,887,
888,889,890,891,892,893,894,895,
896,897,898,899,900,901,902,903,
904,905,906,907,908,909,910,911,
912,913,914,915,916,917,918,919,
920,921,922,923,924,925,926,927,
928,929,930,931,932,933,934,935,
936,937,938,939,940,941,942,943,
944,945,946,947,948,949,950,951,
952,953,954,955,956,957,958,959,
960,961,962,963,964,965,966,967,
968,969,970,971,972,973,974,975,
976,977,978,979,980,981,982,983,
984,985,986,987,988,989,990,991,
992,993,994,995,996,997,998,999,
1000,1001,1002,1003,1004,1005,1006,1007,
1008,1009,1010,1011,1012,1013,1014,1015,
1016,1017,1018,1019,1020,1021,1022};
long Lastfix[] = {1023};

#ifndef lint
static char *rcsid = "$Header: low.c,v 1.5 85/05/22 07:53:54 sklower Exp $";
#endif
EndOfFile
cat >  franz/vax/../lowaux.s  << 'EndOfFile'
	.globl	_holbeg
	.globl	_holend
	.data
_holbeg:
_holend:
EndOfFile
cat >  franz/vax/../alloc.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: alloc.c,v 1.12 85/03/24 10:59:57 sklower Exp $";
#endif

/*					-[Thu Feb  2 16:15:30 1984 by jkf]-
 * 	alloc.c				$Locker:  $
 * storage allocator and garbage collector
 *
 * (c) copyright 1982, Regents of the University of California
 */
 
# include "global.h"
# include "structs.h"

#include <sys/types.h>
#include <sys/times.h>
#ifdef METER
#include <sys/vtimes.h>
#endif
 
# define NUMWORDS TTSIZE * 128  /*  max number of words in P0 space  */
# define BITQUADS TTSIZE * 2	/*  length of bit map in quad words  */
# define BITLONGS TTSIZE * 4	/*  length of bit map in long words  */

# ifdef vax
# define ftstbit	asm("	ashl	$-2,r11,r3");\
			asm("	bbcs	r3,_bitmapi,1f");\
			asm("	ret"); \
			asm("1:");

/* setbit is a fast way of setting a bit, it is like ftstbit except it
 * always continues on to the next instruction
 */
# define setbit		asm("	ashl	$-2,r11,r0"); \
			asm("	bbcs	r0,_bitmapi,$0");
# endif

# if m_68k
# define ftstbit {if(Itstbt()) return;}
# define setbit Itstbt()
# endif

/*  define ftstbit	if( readbit(p) ) return; oksetbit;  */
# define readbit(p)	((int)bbitmap[r=(int)p>>5] & (s=bitmsk[((int)p>>2)&7]))
# define lookbit(p)	(bbitmap[(int)p>>5] & bitmsk[((int)p>>2) & 7])
/* # define setbit(p)	{bbitmap[(int)p>>5] |= bitmsk[((int)p >> 2) & 7];} */
# define oksetbit	{bbitmap[r] |= s;}

# define readchk(p)	((int)bitfre[(int)p>>5] & bitmsk[((int)p>>2)&7])
# define setchk(p)	{bitfre[(int)p>>5] |= bitmsk[((int)p >> 2) & 7];}
# define roundup(x,l)	(((x - 1) | (l - 1)) + 1) 

# define MARKVAL(v)	if(((int)v) >= (int)beginsweep) markdp(v);
# define ATOLX(p)	((((int)p)-OFFSET)>>7)

/* the Vax hardware only allows 2^16-1 bytes to be accessed with one
 * movc5 instruction.  We use the movc5 instruction to clear the 
 * bitmaps.
 */
# define MAXCLEAR ((1<<16)-1)

/* METER denotes something added to help meter storage allocation. */

extern int *beginsweep;			/* first sweepable data		*/
extern char purepage[];
extern int fakettsize;
extern int gcstrings;
int debugin  = FALSE;	/* temp debug flag */

extern lispval datalim;			/*  end of data space */
int bitmapi[BITLONGS];			/*  the bit map--one bit per long  */
double zeroq;				/*  a quad word of zeros  */
char *bbitmap = (char *) bitmapi;	/*  byte version of bit map array */
double  *qbitmap = (double *) bitmapi;	/*  integer version of bit map array */
#ifdef METER
extern int gcstat;
extern struct vtimes
	premark,presweep,alldone;	/* actually struct tbuffer's */

extern int mrkdpcnt;
extern int conssame, consdiff,consnil;	/* count of cells whose cdr point
					 * to the same page and different
					 * pages respectively
					 */
#endif
char bitmsk[8]={1,2,4,8,16,32,64,128};  /*  used by bit-marking macros  */
extern int  *bind_lists ;		/*  lisp data for compiled code */

char *xsbrk();
char *gethspace();


extern struct types atom_str, strng_str, int_str, dtpr_str, doub_str,
	array_str, sdot_str, val_str, funct_str, hunk_str[], vect_str,
	vecti_str, other_str;

extern struct str_x str_current[];

lispval hunk_items[7], hunk_pages[7], hunk_name[7];

extern int initflag; /* starts off TRUE: initially gc not allowed */


/* this is a table of pointers to all struct types objects
 * the index is the type number.
 */
static struct types *spaces[NUMSPACES] = 
	{&strng_str, &atom_str, &int_str,
	 &dtpr_str, &doub_str, &funct_str, 
	 (struct types *) 0,  /* port objects not allocated in this way  */
	 &array_str,
	 &other_str,  /* other objects not allocated in this way  */
	 &sdot_str,&val_str, 
	 &hunk_str[0], &hunk_str[1], &hunk_str[2],
	 &hunk_str[3], &hunk_str[4], &hunk_str[5],
	 &hunk_str[6],
	 &vect_str, &vecti_str};


/* this is a table of pointers to collectable struct types objects
 * the index is the type number.
 */
struct types *gcableptr[] = {
#ifndef GCSTRINGS
     (struct types *) 0,  /* strings not collectable */
#else
     &strng_str,
#endif
     &atom_str,
     &int_str, &dtpr_str, &doub_str,
     (struct types *) 0,  /* binary objects not collectable */
     (struct types *) 0,  /* port objects not collectable */
     &array_str,
     (struct types *) 0,  /* gap in the type number sequence */
     &sdot_str,&val_str, 
     &hunk_str[0], &hunk_str[1], &hunk_str[2],
     &hunk_str[3], &hunk_str[4], &hunk_str[5],
     &hunk_str[6],
     &vect_str, &vecti_str};


/*
 *   get_more_space(type_struct,purep) 
 *									
 *  Allocates and structures a new page, returning 0.
 *  If no space is available, returns positive number.
 *  If purep is TRUE, then pure space is allocated.
 */
get_more_space(type_struct,purep)                                 
struct types *type_struct;
{
	int cntr;
	char *start;
	int *loop, *temp;
	lispval p;
	extern char holend[];

	if( (int) datalim >= TTSIZE*LBPG+OFFSET ) return(2);

	/*
	 * If the hole is defined, then we allocate binary objects
	 * and strings in the hole.  However we don't put strings in
	 * the hole if strings are gc'ed.
	 */
#ifdef HOLE
	if(   purep
#ifndef GCSTRINGS
	   || type_struct==&strng_str
#endif
	   || type_struct==&funct_str)
		start = gethspace(LBPG,type_struct->type);
	else
#endif
		start = xsbrk(1);		/* get new page */


	SETTYPE(start, type_struct->type,20);  /*  set type of page  */

	purepage[ATOX(start)] = (char)purep;  /* remember if page was pure*/

	/* bump the page counter for this space if not pure */

	if(!purep) ++((*(type_struct->pages))->i);

	type_struct->space_left = type_struct->space;
	temp = loop = (int *) start;
	for(cntr=1; cntr < type_struct->space; cntr++)
		loop = (int *) (*loop = (int) (loop + type_struct->type_len));

	/* attach new cells to either the pure space free list  or the 
	 * standard free list
	 */
	if(purep) {
	    *loop = (int) (type_struct->next_pure_free);
	    type_struct->next_pure_free = (char *) temp;
	}
	else  {
	    *loop = (int) (type_struct->next_free);
	    type_struct->next_free = (char *) temp;
	}

	/*  if type atom, set pnames to CNIL  */

	if( type_struct == &atom_str )
		for(cntr=0, p=(lispval) temp; cntr<atom_str.space; ++cntr)
			{
			p->a.pname = (char *) CNIL;
			p = (lispval) ((int *)p + atom_str.type_len);
			}
	return(0);  /*  space was available  */
}


/*
 * next_one(type_struct) 
 *
 *  Allocates one new item of each kind of space, except STRNG.	
 *  If there is no space, calls gc, the garbage collector.
 *  If there is still no space, allocates a new page using
 *  get_more_space
 */

lispval
next_one(type_struct)
struct types *type_struct;
{

	register char *temp;

	while(type_struct->next_free == (char *) CNIL)
		{
		int g;

		if(
		   (initflag == FALSE) && 	/* dont gc during init */
#ifndef GCSTRINGS
		   (type_struct->type != STRNG) && /* can't collect strings */
#else
		   gcstrings &&			/* user (sstatus gcstrings) */
#endif
		   (type_struct->type != BCD) &&   /* nor function headers  */
		   gcdis->a.clb == nil )		/* gc not disabled */
					/* not to collect during load */

			{
			gc(type_struct);  /*  collect  */
			}

		if( type_struct->next_free != (char *) CNIL ) break;

		if(! (g=get_more_space(type_struct,FALSE))) break;

		space_warn(g);
		}
	temp = type_struct->next_free;
	type_struct->next_free = * (char **)(type_struct->next_free);
	(*(type_struct->items))->i ++;
	return((lispval) temp);
}
/*
 * Warn about exhaustion of space,
 * shared with next_pure_free().
 */
space_warn(g)
{
	if( g==1 ) {
	    plimit->i += NUMSPACES; /*  allow a few more pages  */
	    copval(plima,plimit);	/*  restore to reserved reg  */

	    error("PAGE LIMIT EXCEEDED--EMERGENCY PAGES ALLOCATED", TRUE);
	} else error("SORRY, ABSOLUTE PAGE LIMIT HAS BEEN REACHED", TRUE);
}


/* allocate an element of a pure structure.  Pure structures will
 * be ignored by the garbage collector.
 */
lispval
next_pure_one(type_struct)
struct types *type_struct;
{

	register char *temp;

	while(type_struct->next_pure_free == (char *) CNIL)
		{
		int g;
		if(! (g=get_more_space(type_struct,TRUE))) break;
		space_warn(g);
		}

	temp = type_struct->next_pure_free;
	type_struct->next_pure_free = * (char **)(type_struct->next_pure_free);
	return((lispval) temp);
}

lispval
newint()
{
	return(next_one(&int_str));
}

lispval
pnewint()
{
	return(next_pure_one(&int_str));
}

lispval
newdot()
{
	lispval temp;

	temp = next_one(&dtpr_str);
	temp->d.car = temp->d.cdr = nil;
	return(temp);
}

lispval
pnewdot()
{
	lispval temp;

	temp = next_pure_one(&dtpr_str);
	temp->d.car = temp->d.cdr = nil;
	return(temp);
}

lispval
newdoub()
{
	return(next_one(&doub_str));
}

lispval
pnewdb()
{
	return(next_pure_one(&doub_str));
}

lispval
newsdot()
{
	register lispval temp;
	temp = next_one(&sdot_str);
	temp->d.car = temp->d.cdr = 0;
	return(temp);
}

lispval
pnewsdot()
{
	register lispval temp;
	temp = next_pure_one(&sdot_str);
	temp->d.car = temp->d.cdr = 0;
	return(temp);
}

struct atom *
newatom(pure) {
	struct atom *save; char *mypname;

	mypname = newstr(pure);
	pnameprot = ((lispval) mypname);
	save = (struct atom *) next_one(&atom_str) ;	
	save->plist = save->fnbnd = nil;
	save->hshlnk = (struct atom *)CNIL;
	save->clb = CNIL;
	save->pname = mypname;
	return (save);
}

char *
newstr(purep) {
	char *save, *strcpy();
	int atmlen;
	register struct str_x *p = str_current + purep;

	atmlen = strlen(strbuf)+1;
	if(atmlen > p->space_left) {
		if(atmlen >= STRBLEN) {
			save = (char *)csegment(OTHER, atmlen, purep);
			SETTYPE(save,STRNG,40);
			purepage[ATOX(save)] = (char)purep;
			strcpy(save,strbuf);
			return(save);
		}
		p->next_free =  (char *) (purep ?
			next_pure_one(&strng_str) : next_one(&strng_str)) ;
		p->space_left = LBPG;
	}
	strcpy((save = p->next_free), strbuf);
	/*while(atmlen & 3) ++atmlen;	/*  even up length of string  */
	p->next_free += atmlen;
	p->space_left -= atmlen;
	return(save);
}

static char * Iinewstr(s,purep) char *s;
{
	int len = strlen(s);
	while(len > (endstrb - strbuf - 1)) atomtoolong(strbuf);
	strcpy(strbuf,s);
	return(newstr(purep));
}


char *inewstr(s) char *s;
{
	Iinewstr(s,0);
}

char *pinewstr(s) char *s;
{
	Iinewstr(s,1);
}

lispval
newarray()
	{
	register lispval temp;

	temp = next_one(&array_str);
	temp->ar.data = (char *)nil;
	temp->ar.accfun = nil;
	temp->ar.aux = nil;
	temp->ar.length = SMALL(0);
	temp->ar.delta = SMALL(0);
	return(temp);
	}

lispval
newfunct()
	{
	register lispval temp;
	lispval Badcall();
	temp = next_one(&funct_str);
	temp->bcd.start = Badcall;
	temp->bcd.discipline = nil;
	return(temp);
	}

lispval
newval()
	{
	register lispval temp;
	temp = next_one(&val_str);
	temp->l = nil;
	return(temp);
	}

lispval
pnewval()
	{
	register lispval temp;
	temp = next_pure_one(&val_str);
	temp->l = nil;
	return(temp);
	}

lispval
newhunk(hunknum)
int hunknum;
	{
	register lispval temp;

	temp = next_one(&hunk_str[hunknum]);	/* Get a hunk */
	return(temp);
	}

lispval
pnewhunk(hunknum)
int hunknum;
	{
	register lispval temp;

	temp = next_pure_one(&hunk_str[hunknum]);	/* Get a hunk */
	return(temp);
	}

lispval
inewval(arg) lispval arg;
	{
	lispval temp;
	temp = next_one(&val_str);
	temp->l = arg;
	return(temp);
	}

/*
 * Vector allocators.
 * a vector looks like:
 *  longword: N = size in bytes
 *  longword: pointer to lisp object, this is the vector property field
 *  N consecutive bytes
 *
 */
lispval getvec();

lispval
newvec(size)
{
    return(getvec(size,&vect_str,FALSE));
}

lispval
pnewvec(size)
{
    return(getvec(size,&vect_str,TRUE));
}

lispval
nveci(size)
{
    return(getvec(size,&vecti_str,FALSE));
}

lispval
pnveci(size)
{
    return(getvec(size,&vecti_str,TRUE));
}

/*
 * getvec
 *  get a vector of size byte, from type structure typestr and
 * get it from pure space if purep is TRUE.
 *  vectors are stored linked through their property field.  Thus
 * when the code here refers to v.vector[0], it is the prop field
 * and vl.vectorl[-1] is the size field.   In other code,
 * v.vector[-1] is the prop field, and vl.vectorl[-2] is the size.
 */
lispval
getvec(size,typestr,purep)
register struct types *typestr;
{
    register lispval back, current;
    int sizewant, bytes, thissize, pages, pindex, triedgc = FALSE;

    /* we have to round up to a multiple of 4 bytes to determine the
     * size of vector we want.  The rounding up assures that the
     * property pointers are longword aligned
     */
    sizewant = VecTotSize(size);
    if(debugin) fprintf(stderr,"want vect %db\n",size);    
 again:
    if(purep)
        back = (lispval) &(typestr->next_pure_free);
    else
        back = (lispval) &(typestr->next_free);
    current = back->v.vector[0];
    while(current !=  CNIL)
    {
	if(debugin)
            fprintf(stderr,"next free size %db; ", current->vl.vectorl[-1]);
	if ((thissize = VecTotSize(current->vl.vectorl[-1])) == sizewant)
	{
	    if(debugin) fprintf(stderr,"exact match of size %d at 0x%x\n",
	    			4*thissize, &current->v.vector[1]);
	    back->v.vector[0]
	    	= current->v.vector[0];/* change free pointer*/
	    current->v.vector[0] = nil; /* put nil in property */
	    /* to the user, vector begins one after property*/
	    return((lispval)&current->v.vector[1]);
	}
	else if (thissize >= sizewant + 3)
	{
	    /* the reason that there is a `+ 3' instead of `+ 2'
	     * is that we don't want to leave a zero sized vector which
	     * isn't guaranteed to be followed by another vector
	     */
	    if(debugin)
	     fprintf(stderr,"breaking a %d vector into a ",
	     				current->vl.vectorl[-1]);

	    current->v.vector[1+sizewant+1]
	    		= current->v.vector[0];  /* free list pointer */
	    current->vl.vectorl[1+sizewant]
	    		= VecTotToByte(thissize - sizewant - 2);/*size info */
	    back->v.vector[0] = (lispval) &(current->v.vector[1+sizewant+1]);
	    current->vl.vectorl[-1] = size;

	    if(debugin)fprintf(stderr," %d one and a %d one\n",
	    	current->vl.vectorl[-1],current->vl.vectorl[1+sizewant]);
	    current->v.vector[0] = nil; /* put nil in property */
	    /* vector begins one after the property */
	    if(debugin) fprintf(stderr," and returning vector at 0x%x\n",
	    			&current->v.vector[1]);
	    return((lispval)(&current->v.vector[1]));
	}
	back =  current;
	current =  current->v.vector[0];
    }
    if(!triedgc
        && !purep
    	&& (gcdis->a.clb == nil)
	&& (initflag == FALSE))
    {
	gc(typestr);
	triedgc = TRUE;
	goto again;
    }
    
    /* set bytes to size needed for this vector */
    bytes = size + 2*sizeof(long);
    
    /* must make sure that if the vector we are allocating doesnt
       completely fill a page, there is room for another vector to record
       the size left over */
    if((bytes & (LBPG - 1)) > (LBPG - 2*sizeof(long))) bytes += LBPG;
    bytes = roundup(bytes,LBPG);

    current = csegment(typestr->type,bytes/sizeof(long),purep);
    current->vl.vectorl[0] = bytes - 2*sizeof(long);
    
    if(purep) {
        current->v.vector[1] = (lispval)(typestr->next_pure_free);
        typestr->next_pure_free = (char *) &(current->v.vector[1]);
	/* make them pure */
	pages = bytes/LBPG;
	for(pindex = ATOX(current); pages ; pages--)
	{
	    purepage[pindex++] = TRUE;
	}
    } else {
        current->v.vector[1] = (lispval)(typestr->next_free);
        typestr->next_free = (char *) &(current->v.vector[1]);
	if(debugin) fprintf(stderr,"grabbed %d vec pages\n",bytes/LBPG);
    }
    if(debugin)
      fprintf(stderr,"creating a new vec, size %d\n",current->v.vector[0]);
    goto again;
}

/*
 * Ipurep :: routine to check for pureness of a data item
 *
 */
lispval 
Ipurep(element)
lispval element;
{
    if(purepage[ATOX(element)]) return(tatom) ; else return(nil);
}

/* routines to return space to the free list.  These are used by the
 * arithmetic routines which tend to create large intermediate results
 * which are know to be garbage after the calculation is over.
 *
 * There are jsb callable versions of these routines in qfuncl.s
 */

/* pruneb   - prune bignum. A bignum is an sdot followed by a list of
 *  dtprs.    The dtpr list is linked by car instead of cdr so when we
 *  put it in the free list, we have to change the links.
 */
pruneb(bignum)
lispval bignum;
{
	register lispval temp = bignum;

	if(TYPE(temp) != SDOT) 
	    errorh(Vermisc,"value to pruneb not a sdot",nil,FALSE,0);

	--(sdot_items->i);
	temp->s.I = (int) sdot_str.next_free;
	sdot_str.next_free = (char *) temp;

	/* bignums are not terminated by nil on the dual,
	   they are terminated by (lispval) 0 */

	while(temp = temp->s.CDR)
	{
	    if(TYPE(temp) != DTPR) 
	      errorh(Vermisc,"value to pruneb not a list",
		      nil,FALSE,0);
	    --(dtpr_items->i);
	    temp->s.I = (int) dtpr_str.next_free;
	    dtpr_str.next_free = (char *) temp;
	}
}
lispval
Badcall()
	{ error("BAD FUNCTION DESCRIPTOR USED IN CALL",FALSE); }



/*
 * Ngc 
 *  this is the lisp function gc
 *
 */

lispval
Ngc()
{
    return(gc((struct types *)CNIL));
}

/*
 * gc(type_struct) 
 *
 *  garbage collector:  Collects garbage by mark and sweep algorithm.
 *  After this is done, calls the Nlambda, gcafter.
 *  gc may also be called from LISP, as an  nlambda of no arguments.
 * type_struct is the type of lisp data that ran out causing this
 * garbage collection
 */
int printall = 0;
lispval
gc(type_struct)
	struct types *type_struct;
	{
	lispval save;
	struct tms begin, finish;
	extern int gctime;

	/* if this was called automatically when space ran out
	 * print out a message
	 */
	if((Vgcprint->a.clb != nil)
	   && (type_struct != (struct types *) CNIL ))
	{
	    FILE *port = okport(Vpoport->a.clb,poport);
	    fprintf(port,"gc:");
	    fflush(port);
	}
	
	if(gctime) times(&begin);

	gc1(); /* mark&sweep */

	/* Now we call gcafter--special c ase if gc called from LISP */

	if( type_struct == (struct types *) CNIL )
		gccall1->d.cdr = nil;  /* make the call "(gcafter)" */
	else
		{
		gccall1->d.cdr = gccall2;
		gccall2->d.car = *(type_struct->type_name);
		}
	PUSHDOWN(gcdis,gcdis);	/*  flag to indicate in garbage collector  */
	save = eval(gccall1);	/*  call gcafter  */
	POP;			/*  turn off flag  */

	if(gctime) {
		times(&finish);
		gctime += (finish.tms_utime - begin.tms_utime);
	}
	return(save);	/*  return result of gcafter  */
	}

	

/*  gc1()  **************************************************************/
/*									*/
/*  Mark-and-sweep phase						*/

gc1()
{
	int j, k;
	register int *start,bvalue,type_len; 
	register struct types *s;
	int *point,i,freecnt,itemstogo,bits,bindex,type,bytestoclear;
	int usedcnt;
	char *pindex;
	struct argent *loop2;
	struct nament *loop3;
	struct atom *symb;
	int markdp();
	extern int hashtop;

	pagerand(); 
	/*  decide whether to check LISP structure or not  */


#ifdef METER
	vtimes(&premark,0);
	mrkdpcnt = 0;
	conssame = consdiff = consnil = 0;
#endif

	/*  first set all bit maps to zero  */


#ifdef SLOCLEAR
	{
	    int enddat;
	    enddat = (int)(datalim-OFFSET) >> 8;
	    for(bvalue=0; bvalue < (int)enddat ; ++bvalue)
	    {
		 qbitmap[bvalue] = zeroq; 
	    }
	}
#endif

	/* try the movc5 to clear the bit maps */
	/* the maximum number of bytes we can clear in one sweep is
	 * 2^16 (or 1<<16 in the C lingo)
	 */
	bytestoclear = ((((int)datalim)-((int)beginsweep)) >> 9) * 16; 
	for(start = bitmapi + ATOLX(beginsweep);
	    bytestoclear > 0;)
	    {
		if(bytestoclear > MAXCLEAR)
			blzero((int)start,MAXCLEAR);
		else
			blzero((int)start,bytestoclear);
		start = (int *) (MAXCLEAR + (int) start);
		bytestoclear -= MAXCLEAR;
	    }
			
	/* mark all atoms in the oblist */
        for( bvalue=0 ; bvalue <= hashtop-1 ; bvalue++ ) /* though oblist */
        {
	    for( symb = hasht[bvalue] ; symb != (struct atom *) CNIL ;
		      symb = symb-> hshlnk) {
		  markdp((lispval)symb); 
	    }
	}


	/* Mark all the atoms and ints associated with the hunk
	   data types */
	   
	for(i=0; i<7; i++) {
		markdp(hunk_items[i]);
		markdp(hunk_name[i]);
		markdp(hunk_pages[i]);
	}
	/* next run up the name stack */
	for(loop2 = np - 1; loop2 >=  orgnp; --loop2) MARKVAL(loop2->val);	

	/* now the bindstack (vals only, atoms are marked elsewhere ) */
	for(loop3 = bnp - 1; loop3 >= orgbnp; --loop3)MARKVAL(loop3->val);

	
	/* next mark all compiler linked data */
	/* if the Vpurcopylits switch is non nil (lisp variable $purcopylits)
	 * then when compiled code is read in, it tables will not be linked
	 * into this table and thus will not be marked here.  That is ok
	 * though, since that data is assumed to be pure.
	 */
	 point = bind_lists;
	 while((start = point) != (int *)CNIL) {
	 	while( *start != -1 )
	 	{
	 		markdp((lispval)*start);
	 		start++;
	 	}
	 	point = (int *)*(point-1);
	 }

	/* next mark all system-significant lisp data */

	
	for(i=0; i<SIGNIF; ++i) markdp((lispsys[i]));

#ifdef METER
	vtimes(&presweep,0);
#endif
	/* all accessible data has now been marked. */
	/* all collectable spaces must be swept,    */
	/* and freelists constructed.		    */

	/* first clear the structure elements for types
	 * we will sweep
	 */
	
	for(k=0 ; k <= VECTORI ; k++)
	{
		if( s=gcableptr[k]) {
		    if(k==STRNG && !gcstrings) { /* don't do anything*/ }
		    else
			{
			  (*(s->items))->i = 0;
			  s->space_left = 0;
			  s->next_free = (char *) CNIL;
			}
		}
	}
#if m_68k
	fixbits(bitmapi+ATOLX(beginsweep),bitmapi+ATOLX(datalim));
#endif


	/* sweep up in memory looking at gcable pages */

	for(start = beginsweep,  bindex = ATOLX(start), 
		  pindex = &purepage[ATOX(start)]; 
	    start < (int *)datalim;
	    start += 128, pindex++)
	{
	    if(!(s=gcableptr[type = TYPE(start)]) || *pindex
#ifdef GCSTRINGS
	     || (type==STRNG && !gcstrings) 
#endif
		)
	    {
		/* ignore this page but advance pointer 	*/
		bindex += 4;   /* and 4 words of 32 bit bitmap words */
		continue;
	    }

	    freecnt = 0;		/* number of free items found */
	    usedcnt = 0;		/* number of used items found */
	    
	    point = start;
	    /* sweep dtprs as a special case, since
	     * 1) there will (usually) be more dtpr pages than any other type
	     * 2) most dtpr pages will be empty so we can really win by special
	     *    caseing the sweeping of massive numbers of free cells
	     */
	    /* since sdot's have the same structure as dtprs, this code will
	       work for them too
	     */
	    if((type == DTPR) || (type == SDOT))
	    {
		int *head,*lim;
		head = (int *) s->next_free;	/* first value on free list*/

		for(i=0; i < 4; i++)	/* 4 bit map words per page  */
		{
		    bvalue = bitmapi[bindex++];	/* 32 bits = 16 dtprs */
		    if(bvalue == 0)	/* if all are free	*/
		    {
			*point = (int)head;
			lim = point + 32;   /* 16 dtprs = 32 ints */
			for(point += 2; point < lim ; point += 2)
			{
			    *point = (int)(point - 2);
			}
			head = point - 2;
			freecnt += 16;
		    }
		    else for(j = 0; j < 16 ; j++)
		    {
			if(!(bvalue & 1))
			{
			    freecnt++;
			    *point = (int)head;
			    head = point;
			}
#ifdef METER
			/* check if the page address of this cell is the
			 * same as the address of its cdr
			 */
			else if(FALSE && gcstat && (type == DTPR))
			{  
			   if(((int)point & ~511) 
			      == ((int)(*point) & ~511)) conssame++;
			   else consdiff++;
			   usedcnt++;
			}
#endif
			else usedcnt++;		/* keep track of used */
			
			point += 2;
			bvalue = bvalue >> 2;
		    }
		}
		s->next_free = (char *) head;
	    }
	    else if((type == VECTOR) || (type == VECTORI))
	    {
		int canjoin = FALSE;
		int *tempp;

		/* check if first item on freelist ends exactly at
		   this page
		 */
		if(((tempp = (int *)s->next_free) != (int *)CNIL)
		   && ((VecTotSize(((lispval)tempp)->vl.vectorl[-1])
		   					    + 1 + tempp)
		   			== point))
		   canjoin = TRUE;
		   
		/* arbitrary sized vector sweeper */
		/*
		 * jump past first word since that is a size fixnum
		 * and second word since that is property word
		 */
		if(debugin)
		  fprintf(stderr,"vector sweeping, start at 0x%x\n",
				point);
		bits = 30;
		bvalue = bitmapi[bindex++] >> 2;
		point += 2;
		while (TRUE) {
		    type_len = point[VSizeOff];
		    if(debugin) {
		      fprintf(stderr,"point: 0x%x, type_len %d\n",
		    		point, type_len);
		      fprintf(stderr,"bvalue: 0x%x, bits: %d, bindex: 0x%x\n",
				bvalue, bits, bindex);
		    }
		    			/* get size of vector */
		    if(!(bvalue & 1))	/* if free */
		    {
			if(debugin) fprintf(stderr,"free\n");
			freecnt += type_len + 2*sizeof(long);
			if(canjoin)
			{
			    /* join by adjusting size of first vector */
			    ((lispval)(s->next_free))->vl.vectorl[-1]
			      +=  type_len + 2*sizeof(long); 
			    if(debugin)
			      fprintf(stderr,"joined size: %d\n",
			          ((lispval)(s->next_free))->vl.vectorl[-1]);
			}
			else {
			    /* vectors are linked at the property word */
			    *(point - 1) = (int)(s->next_free);
			    s->next_free = (char *) (point - 1);
			}
			canjoin = TRUE;
		    }
		    else {
		    	canjoin = FALSE;
			usedcnt += type_len + 2*sizeof(long);
		    }
		    
		    point += VecTotSize(type_len);
		    /* we stop sweeping only when we reach a page
		       boundary since vectors can span pages
		     */
		    if(((int)point & 511) == 0)
		    {
			/* reset the counters, we cannot predict how
			 * many pages we have crossed over
			 */
			bindex = ATOLX(point);
			/* these will be inced, so we must dec */
			pindex = &purepage[ATOX(point)] - 1;
			start = point - 128;
			if(debugin)
			fprintf(stderr,
				"out of vector sweep when point = 0x%x\n",
				point);
			break;
		    }
		    /* must advance to next point and next value in bitmap.
		     * we add VecTotSize(type_len) + 2 to get us to the 0th
		     * entry in the next vector (beyond the size fixnum)
		     */
		    point += 2; 	/* point to next 0th entry */
		    if ( (bits -= (VecTotSize(type_len) + 2)) > 0)  
		        bvalue = bvalue >> (VecTotSize(type_len) + 2);
		    else {
			bits = -bits;	/* must advance to next word in map */
			bindex += bits / 32; /* this is tricky stuff... */
			bits = bits % 32;
			bvalue = bitmapi[bindex++] >> bits;
			bits = 32 - bits;
		    }
		}
	    }
	    else { 
		/* general sweeper, will work for all types */
		itemstogo = s->space;	/* number of items per page  */
		bits = 32;			/* number of bits per word */
		type_len = s->type_len;

		/* printf(" s %d, itemstogo %d, len %d\n",s,itemstogo,type_len);*/
		bvalue = bitmapi[bindex++];

		while(TRUE)
		{
		    if(!(bvalue & 1))	/* if data element is not marked */
		    {
			freecnt++;
			*point = (int) (s->next_free) ;
			s->next_free = (char *) point;
		    }
		    else usedcnt++;

		    if( --itemstogo <= 0 ) 
		    {    if(type_len >= 64) 
			 {
			    bindex++;
			    if(type_len >=128) bindex += 2;
			 }
			 break;
		    }

		    point += type_len;
		    /* shift over mask by number of words in data type */

		    if( (bits -= type_len) > 0)
		    {  bvalue = bvalue >> type_len;
		    } 
		    else if( bits == 0 ) 
		    {  bvalue = bitmapi[bindex++];
		       bits = 32;
		    }
		    else
		    {  bits = -bits;
		       while( bits >= 32) { bindex++;
					    bits -= 32;
					  }
		       bvalue = bitmapi[bindex++];
		       bvalue = bvalue >> bits;
		       bits = 32 - bits;;
		    }
	    }
	}

     s->space_left += freecnt;
     (*(s->items))->i += usedcnt;
     }

#ifdef METER
        vtimes(&alldone,0);
	if(gcstat) gcdump();
#endif
	pagenorm(); 
}

/*
 * alloc
 *
 *  This routine tries to allocate one or more pages of the space named
 *  by the first argument.   Returns the number of pages actually allocated.
 *  
 */

lispval
alloc(tname,npages)
lispval tname; long npages;
{
	long ii, jj;
	struct types *typeptr;

	ii = typenum(tname);
        typeptr = spaces[ii];
	if(npages <= 0) return(inewint(npages));
	
	if((ATOX(datalim)) + npages > TTSIZE)
	   error("Space request would exceed maximum memory allocation",FALSE);
	if((ii == VECTOR) || (ii == VECTORI))
	{
	    /* allocate in one big chunk */
	    tname = csegment((int) ii,(int) npages*128,0);
	    tname->vl.vectorl[0] = (npages*512 - 2*sizeof(long));
	    tname->v.vector[1] = (lispval) typeptr->next_free;
	    typeptr->next_free = (char *) &(tname->v.vector[1]);
	    if(debugin) fprintf(stderr,"alloced %d vec pages\n",npages);
	    return(inewint(npages));
	}
	   
	for( jj=0; jj<npages; ++jj)
		if(get_more_space(spaces[ii],FALSE)) break;
	return(inewint(jj));
}

/*
 * csegment(typecode,nitems,useholeflag)
 *  allocate nitems of type typecode.  If useholeflag is true, then
 * allocate in the hole if there is room.  This routine doesn't look
 * in the free lists, it always allocates space.
 */	
lispval
csegment(typecode,nitems,useholeflag)
{
	register int ii, jj;
	register char *charadd;

	ii = typecode;

	if(ii!=OTHER) nitems *= 4*spaces[ii]->type_len;
	nitems = roundup(nitems,512);		/*  round up to right length  */
#ifdef HOLE
	if(useholeflag)
		charadd = gethspace(nitems,ii);
	else
#endif
	{
		charadd = sbrk(nitems);
		datalim = (lispval)(charadd+nitems);
	}
	if( (int) charadd <= 0 )
		error("NOT ENOUGH SPACE FOR ARRAY",FALSE);
	/*if(ii!=OTHER)*/ (*spaces[ii]->pages)->i +=  nitems/512;
	if(ATOX(datalim) > fakettsize) {
		datalim = (lispval) (OFFSET + (fakettsize << 9));
		if(fakettsize >= TTSIZE)
		{
		    printf("There isn't room enough to continue, goodbye\n");
		    franzexit(1);
		}
		fakettsize++;
		badmem(53);
	}
	for(jj=0; jj<nitems; jj=jj+512) {
		SETTYPE(charadd+jj, ii,30);
	}
	ii = (int) charadd;
	while(nitems > MAXCLEAR)
	{
	    blzero(ii,MAXCLEAR);
	    nitems -= MAXCLEAR;
	    ii += MAXCLEAR;
	}
	blzero(ii,nitems);
	return((lispval)charadd);
}

int csizeof(tname) lispval tname;
	{
	return( spaces[typenum(tname)]->type_len * 4 );
	}

int typenum(tname) lispval tname;
	{
	int ii;

chek:	for(ii=0; ii<NUMSPACES; ++ii)
		if(spaces[ii] && tname == *(spaces[ii]->type_name)) break;
	if(ii == NUMSPACES)
		{
		tname = error("BAD TYPE NAME",TRUE);
		goto chek;
		}

	return(ii);
	
	}
char *
gethspace(segsiz,type)
{
	extern usehole; extern char holend[]; extern char *curhbeg;
	register char *value;

	if(usehole) {	
		curhbeg = (char *) roundup(((int)curhbeg),LBPG);
		if((holend - curhbeg) < segsiz)
		{	
			usehole = FALSE;
			curhbeg = holend;
		} else {
			value = curhbeg;
			curhbeg = curhbeg + segsiz;
			/*printf("start %d, finish %d, size %d\n",value, curhbeg,segsiz);*/
			return(value);
		}
	}
	value = (ysbrk(segsiz/LBPG,type));
	datalim = (lispval)(value + segsiz);
	return(value);
}
gcrebear()
{
#ifdef HOLE
        register int i; register struct types *p;

	/* this gets done upon rebirth */
	str_current[1].space_left = 0;
#ifndef GCSTRINGS
	str_current[0].space_left = 0;  /* both kinds of strings go in hole*/
#endif
	funct_str.space_left = 0;
	funct_str.next_free = (char *) CNIL;
	/* clear pure space pointers */
	for(i = 0; i < NUMSPACES; i++)
	{
	    if(p=spaces[i])
	    p->next_pure_free = (char *) CNIL;
	}
#endif
}

/** markit(p) ***********************************************************/
/*  just calls markdp							*/

markit(p) lispval *p; { markdp(*p); }

/*
 * markdp(p)
 *
 *  markdp is the routine which marks each data item.  If it is a
 *  dotted pair, the car and cdr are marked also.
 *  An iterative method is used to mark list structure, to avoid
 *  excessive recursion.
 */
markdp(p) register lispval p;
	{
/*	register int r, s;	(goes with non-asm readbit, oksetbit)	*/
/*	register hsize, hcntr;						*/
	int hsize, hcntr;

#ifdef METER
	mrkdpcnt++;
#endif
ptr_loop:
	if(((int)p) <= ((int)nil)) return;	/*  do not mark special data types or nil=0  */

        	
	switch( TYPE(p) )
		{
		case ATOM:
			ftstbit;
			MARKVAL(p->a.clb);
			MARKVAL(p->a.plist);
			MARKVAL(p->a.fnbnd);
#ifdef GCSTRINGS
			if(gcstrings) MARKVAL(((lispval)p->a.pname));
			return;

		case STRNG:
			p = (lispval) (((int) p) & ~ (LBPG-1));
			ftstbit;
#endif
			return;
			
		case INT:
		case DOUB:
			ftstbit;
			return;
		case VALUE:
			ftstbit;
			p = p->l;
			goto ptr_loop;
		case DTPR:
			ftstbit;
			MARKVAL(p->d.car);
#ifdef METER
			/* if we are metering , then check if the cdr is
			 * nil, or if the cdr is on the same page, and if
			 * it isn't one of those, then it is on a different
			 * page
			 */
			 if(gcstat)
			 {
			     if(p->d.cdr == nil) consnil++;
			     else if(((int)p & ~511) 
				     == (((int)(p->d.cdr)) & ~511))
				conssame++;
			     else consdiff++;
			  }
#endif
			p = p->d.cdr;
			goto ptr_loop;

		case ARRAY:
			ftstbit;	/* mark array itself */

			MARKVAL(p->ar.accfun);	/* mark access function */
			MARKVAL(p->ar.aux);		/* mark aux data */
			MARKVAL(p->ar.length);	/* mark length */
			MARKVAL(p->ar.delta);	/* mark delta */
			if(TYPE(p->ar.aux)==DTPR && p->ar.aux->d.car==Vnogbar)
			{
			    /* a non garbage collected array must have its
			     * array space marked but the value of the array
			     * space is not marked
			     */
			     int l; 
			     int cnt,d;
			     if(debugin && FALSE) {
			       printf("mark array holders len %d, del %d, start 0x%x\n",
			         p->ar.length->i,p->ar.delta->i,p->ar.data);
				 fflush(stdout);
			    }
			     l = p->ar.length->i; /* number of elements */
			     d = p->ar.delta->i;  /* bytes per element  */
			     p = (lispval) p->ar.data;/* address of first one*/
			     if(purepage[ATOX(p)]) return;

			     for((cnt = 0); cnt<l ; 
				      p = (lispval)(((char *) p) + d), cnt++)
			     {
				setbit;
			     }
			} else {
/*			register int i, l; int d;		*/
/*			register char *dataptr = p->ar.data;	*/
			int i,l,d;
			char *dataptr = p->ar.data;

			for(i=0, l=p->ar.length->i, d=p->ar.delta->i; i<l; ++i)
				{
				markdp((lispval)dataptr);
				dataptr += d;
				}
			}
			return;
		case SDOT:
			do {
				ftstbit;
				p = p->s.CDR;
			} while (p!=0);
			return;

		case BCD:
			ftstbit;
			markdp(p->bcd.discipline);
			return;

		case HUNK2:
		case HUNK4:
		case HUNK8:
		case HUNK16:
		case HUNK32:
		case HUNK64:
		case HUNK128:
			{
				hsize = 2 << HUNKSIZE(p);
				ftstbit;
				for (hcntr = 0; hcntr < hsize; hcntr++)
					MARKVAL(p->h.hunk[hcntr]);
				return;
			}
			
		case VECTORI:
			ftstbit;
			MARKVAL(p->v.vector[-1]);	/* mark property */
			return;
			
		case VECTOR:
			{
			    register int vsize;
			    ftstbit;
			    vsize = VecSize(p->vl.vectorl[VSizeOff]);
			    if(debugin)
			       fprintf(stderr,"mark vect at %x  size %d\n",
			       		p,vsize);
			    while(--vsize >= -1)
			    {
				MARKVAL(p->v.vector[vsize]);
			    };
			    return;
			}
		}
	return;
	}


/* xsbrk allocates space in large chunks (currently 16 pages)
 * xsbrk(1)  returns a pointer to a page
 * xsbrk(0)  returns a pointer to the next page we will allocate (like sbrk(0))
 */

char *
xsbrk(n)
	{
	static char *xx;	/*  pointer to next available blank page  */
	extern int xcycle;	/*  number of blank pages available  */
	lispval u;			/*  used to compute limits of bit table  */

	if( (xcycle--) <= 0 )
		{
		xcycle = 15;
		xx = sbrk(16*LBPG);	/*  get pages 16 at a time  */
		if( (int)xx== -1 )
			lispend("For sbrk from lisp: no space... Goodbye!");
		}
	else xx += LBPG;

	if(n == 0)
	{
	    xcycle++;	/* don't allocate the page */
	    xx -= LBPG;
	    return(xx);	/* just return its address */
	}

	if( (u = (lispval)(xx+LBPG))  > datalim ) datalim = u;
	return(xx);
	}

char *ysbrk(pages,type) int pages, type;
	{
	char *xx;	/*  will point to block of storage  */
	int i;

	xx = sbrk(pages*LBPG);
	if((int)xx == -1)
		error("OUT OF SPACE FOR ARRAY REQUEST",FALSE);

	datalim = (lispval)(xx+pages*LBPG);	/*  compute bit table limit  */

	/*  set type for pages  */

	for(i = 0; i < pages; ++i) {
		SETTYPE((xx + i*LBPG),type,10);
	}

	return(xx);	/*  return pointer to block of storage  */
	}
	
/*
 * getatom 
 * returns either an existing atom with the name specified in strbuf, or
 * if the atom does not already exist, regurgitates a new one and 
 * returns it.
 */
lispval
getatom(purep)
{   register lispval aptr;
    register char *name, *endname;
    register int hash;
    lispval	b;
    char	c;

	name = strbuf;
	if (*name == (char)0377) return (eofa);
	hash = hashfcn(name);
	atmlen = strlen(name) + 1;
	aptr = (lispval) hasht[hash];
	while (aptr != CNIL)
	    /* if (strcmp(name,aptr->a.pname)==0) */
	    if (*name==*aptr->a.pname && strcmp(name,aptr->a.pname)==0)
		return (aptr);
	    else
		aptr = (lispval) aptr->a.hshlnk;
	aptr = (lispval) newatom(purep);  /*share pname of atoms on oblist*/
	aptr->a.hshlnk = hasht[hash];
	hasht[hash] = (struct atom *) aptr;
	endname = name + atmlen - 2;
	if ((atmlen != 4) && (*name == 'c') && (*endname == 'r'))
		{
		b = newdot();
		protect(b);
		b->d.car = lambda;
		b->d.cdr = newdot();
		b = b->d.cdr;
		b->d.car = newdot();
		(b->d.car)->d.car = xatom;
		while(TRUE)
			{
			b->d.cdr = newdot();
			b= b->d.cdr;
			if(++name == endname)
				{
				b->d.car= (lispval) xatom;
				aptr->a.fnbnd = (--np)->val;
				break;
				}
			b->d.car= newdot();
			b= b->d.car;
			if((c = *name) == 'a') b->d.car = cara;
			else if (c == 'd') b->d.car = cdra;
			else{ --np;
			   break;
			 }
			}
		}

	return(aptr);
	}

/*
 * inewatom is like getatom, except that you provide it a string
 * to be used as the print name.  It doesn't do the automagic
 * creation of things of the form c[ad]*r.
 */
lispval
inewatom(name)
register char *name;
{   register struct atom *aptr;
    register int hash;
    extern struct types atom_str;
    char	c;

	if (*name == (char)0377) return (eofa);
	hash = hashfcn(name);
	aptr = hasht[hash];
	while (aptr != (struct atom *)CNIL)
	    if (strcmp(name,aptr->pname)==0)
		return ((lispval) aptr);
	    else
		aptr = aptr->hshlnk;
	aptr = (struct atom *) next_one(&atom_str) ;	
	aptr->plist = aptr->fnbnd = nil;
	aptr->clb = CNIL;
	aptr->pname = name;
	aptr->hshlnk = hasht[hash];
	hasht[hash] = aptr;
	return((lispval)aptr);
}


/* our hash function */

hashfcn(symb)
register char *symb;
{
	register int i;
/*	for (i=0 ; *symb ; i += i + *symb++); return(i & (HASHTOP-1)); */
	for (i=0 ; *symb ; i += i*2 + *symb++);
	return(i&077777 % HASHTOP);
}

lispval
LImemory()
{
    int nextadr, pagesinuse;
    
    printf("Memory report. max pages = %d (0x%x) = %d Bytes\n",
    		TTSIZE,TTSIZE,TTSIZE*LBPG);
#ifdef HOLE
        printf("This lisp has a hole:\n");
	printf("  current hole start: %d (0x%x), end %d (0x%x)\n",
		curhbeg, curhbeg, holend, holend);
	printf("  hole free: %d bytes = %d pages\n\n",
	       holend-curhbeg, (holend-curhbeg)/LBPG);
#endif 
    nextadr = (int) xsbrk(0);	/* next space to be allocated */
    pagesinuse = nextadr/LBPG;
    printf("Next allocation at addr %d (0x%x) = page %d\n",
			nextadr, nextadr, pagesinuse);
    printf("Free data pages: %d\n", TTSIZE-pagesinuse);
    return(nil);
}

extern struct atom *hasht[HASHTOP];
myhook(){}
EndOfFile
cat >  franz/vax/../data.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: data.c,v 1.8 85/03/24 11:02:24 sklower Exp $";
#endif

/*					-[Sun Jun 19 14:41:00 1983 by jkf]-
 * 	data.c				$Locker:  $
 * static storage declarations
 *
 * (c) copyright 1982, Regents of the University of California
 */



#include 	"global.h"
#include	"gtabs.h"
#include	"structs.h"
#include	"frame.h"
#include	<stdio.h>

/*char firstalloc[NBPG] = { 'x' };	/* first thing allocated in file */
lispval lispsys[SIGNIF];	/* lisp data used by system */

lispval gftab[GFTABLEN];	/* global function table for interpreter */

lispval gctab[GCTABLEN] = 	/* global constant table for interpreter */
	{nil,0,SMALL(-1),SMALL(0),SMALL(1),SMALL(2),SMALL(3),SMALL(4)};


/* Port definitions *****************************************************/
FILE	*piport,		/* standard input port		*/
	*poport,		/* standard output port		*/
	*errport,		/* port for error messages	*/
	*rdrport,		/* temporary port for readr	*/
	*proport;		/* port for protocal		*/
int	lineleng =	80;		/* line length desired		*/
int	rlevel;			/* used to indicate depth of recursion
				   in reader.  No longer really necessary */
char	keybin =	FALSE;		/* logical flag: using keyboard	*/
char	protflag =	FALSE;		/* logical flag: want protocall */
char	rbktf;				/* logical flag: ] mode		*/

#ifdef RTPORTS
lispval ioname[128];		/* strings of names of files currently open	*/
#else 
lispval ioname[_NFILE];		/* strings of names of files currently open	*/
#endif

/* name stack ***********************************************************/
struct argent *orgnp;		/* used by top level to reset to start  */
struct argent		*namptr,		/* temporary pointer	*/
#ifndef NPINREG
			*lbot,			/* beginning of frame	*/
			*np,			/* first free entry   	*/
#endif
			*nplim;			/* don't have this = np	*/
struct nament		*bnp,			/* top of bind stack    */
			*orgbnp,		/* absolute bottom of ""*/
			*bnplim;		/* absolute top of ""   */



/* hashing things *******************************************************/
int	hash;					/* set by ratom		*/
int	atmlen;			/* length of atom including final null	*/


/* big string buffer for whomever needs it ******************************/
static char	i_strbuf[600];
char	*strbuf		= i_strbuf;
char	*endstrb	= i_strbuf + 599;

/* in the case we can't use the C stack for extending automatics */
#ifdef SPISFP
long xstack[16384];
long *xsp;
long *exsp = xstack + ((sizeof xstack)/(sizeof (long)));
#endif

/* strings needed by the two hand crafted atoms, nil and eof */
char nilpname[] = "nil";
char eofpname[] = "eof";

/* set by sstatus commands */
int uctolc = 0;		/* when set, uc chars in atoms go to lc */
			/* default mode for dumplisp 
			   (note this is decimal not octal) */
#if os_unisoft || os_unix_ts
int dmpmode = 410;
#else
int dmpmode = 413;
#endif

/* break and error declarations *****************************************/
int	depth =	0;		/* depth of nested breaks		*/
lispval	contval;		/* the value being returned up		*/
int	retval;			/* used by each error/prog call		*/
lispval lispretval;		/* used by non-local goto's		*/
int	rsetsw;			/* when set, trace frames built		*/
int	bcdtrsw;		/* when set with rsetsw, trace bcd too	*/
int 	evalhcallsw;		/* when set will not evalhook next eval */
int 	funhcallsw;		/* when set will not funcallhook next eval */


/* exception handling stuff *********************************************/
int exception;			/* true if an exception is pending */
int sigintcnt;			/* number of SIGINT's pending	   */

/* current state of the hole (for fasling into) *************************/
#ifndef HOLE
#define HOLE 0
#endif
extern char holbeg[];
char *curhbeg = holbeg;			/* next location to fasl into */
int usehole = HOLE;			/* if TRUE, fasl tries to use hole */
int holesize = HOLE;			/* This avoids an ifdef in dumplisp */

/* other stuff **********************************************************/
lispval	ftemp,vtemp,argptr,ttemp;	/* temporaries: use briefly	*/
int itemp;
lispval sigacts[16];			/* for catching interrupts	*/
int sigstruck,sigdelay;			/* for catching interrupts	*/
lispval stattab[16];			/* miscelleneous options	*/
lispval Vprintsym;			/* value is the symbol 'print'  */

/*  interpreter globals    */

int lctrace;
int fvirgin = 1;		/* set to 1 initially 			*/
int gctime;
struct frame *errp;		/* stack of error frames 		*/


/* global pointers to the transfer tables */


struct trtab *trhead=		/* first in list of transfer tables 	   */
      (struct trtab *) 0;
struct trent *trcur;		/* next entry to allocate	    	   */
int trleft = 0;			/* number of entries left in current table */

/* globals from sysat.c  */

int *beginsweep;		/* place for sweeper to begin 		*/
int initflag = TRUE;		/* inhibit gcing initially		*/
int tgcthresh = 15;
int page_limit = (5 * TTSIZE) / 6;
int ttsize = TTSIZE;


/* global used in io.c */

lispval lastrtab;

/* globals from [VT]alloc.c  */


char purepage[TTSIZE];
int fakettsize = TTSIZE - 8;
int gcstrings;				/*  Do we mark and sweep strings? */
int  *bind_lists = (int *) CNIL;	/*  lisp data for compiled code */


struct str_x str_current[2];		/*  next free string spaces */

struct types
	atom_str =
	{
		(char *)CNIL,	0,	ATOMSPP,	ATOM,	5,
		&atom_items,	&atom_pages,	&atom_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	strng_str =
	{
		(char *) CNIL,	0,	STRSPP,		STRNG,	128,
		&str_items,	&str_pages,	&str_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	int_str =
	{
		(char *) CNIL,	0,	INTSPP,		INT,	1,
		&int_items,	&int_pages,	&int_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	dtpr_str =
	{
		(char *) CNIL,	0,	DTPRSPP,	DTPR,	2,
		&dtpr_items,	&dtpr_pages,	&dtpr_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	doub_str =
	{
		(char *) CNIL,	0,	DOUBSPP,	DOUB,	2,
		&doub_items,	&doub_pages,	&doub_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	array_str =
	{
		(char *) CNIL,	0,	ARRAYSPP,	ARRAY,	5,
		&array_items,	&array_pages,	&array_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	other_str =
	{
		(char *) CNIL,	0,	STRSPP,		OTHER,	128,
		&other_items,	&other_pages,	&other_name,
		(struct heads *) CNIL, (char *)CNIL
	},

	sdot_str =
	{
		(char *) CNIL,	0,	SDOTSPP,	SDOT,	2,
		&sdot_items,	&sdot_pages,	&sdot_name,
		(struct heads *) CNIL, (char *)CNIL
	},
	val_str =
	{
		(char *) CNIL,	0,	VALSPP,		VALUE,	1,
		&val_items,	&val_pages,	&val_name,
		(struct heads *) CNIL, (char *)CNIL
	},
funct_str =
	{
		(char *) CNIL,	0,	BCDSPP,		BCD,	2,
		&funct_items,	&funct_pages,	&funct_name,
		(struct heads *) CNIL, (char *)CNIL
	},
vect_str =
	{
	        
		(char *) CNIL,	0,	VECTORSPP,	VECTOR,	1,
		&vect_items,	&vect_pages,	&vect_name,
		(struct heads *) CNIL, (char *)CNIL
	},
vecti_str =
	{
	        
		(char *) CNIL,	0,	VECTORSPP,	VECTORI, 1,
		&vect_items,	&vecti_pages,	&vecti_name,
		(struct heads *) CNIL, (char *)CNIL
	},

hunk_str[7] =
	{
		{
			(char *) CNIL,	0,	HUNK2SPP,	HUNK2,	2,
			&hunk_items[0],	&hunk_pages[0],	&hunk_name[0],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK4SPP,	HUNK4,	4,
			&hunk_items[1],	&hunk_pages[1],	&hunk_name[1],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK8SPP,	HUNK8,	8,
			&hunk_items[2],	&hunk_pages[2],	&hunk_name[2],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK16SPP,	HUNK16,	16,
			&hunk_items[3],	&hunk_pages[3],	&hunk_name[3],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK32SPP,	HUNK32,	32,
			&hunk_items[4],	&hunk_pages[4],	&hunk_name[4],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK64SPP,	HUNK64,	64,
			&hunk_items[5],	&hunk_pages[5],	&hunk_name[5],
			(struct heads *) CNIL, (char *)CNIL
		},
		{
			(char *) CNIL,	0,	HUNK128SPP,	HUNK128, 128,
			&hunk_items[6],	&hunk_pages[6],	&hunk_name[6],
			(struct heads *) CNIL, (char *)CNIL
		}
	};
extern struct readtable { unsigned char	ctable[132]; } initread;
unsigned char *ctable = initread.ctable;
int gensymcounter = 0;

int hashtop = HASHTOP;
int xcycle = 0;		/* used by xsbrk   */
struct	atom *hasht[HASHTOP];
lispval datalim;	/* pointer to next location to allocate */

char typetable[TTSIZE+1] = {UNBO,ATOM,PORT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT,INT};

/* this must be the last thing allocated in this file	*/
char lsbrkpnt,zfreespace;
EndOfFile
cat >  franz/vax/../rlc.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: rlc.c,v 1.4 85/05/22 07:53:51 sklower Exp $";
#endif

/*					-[Sat Jan 29 13:32:26 1983 by jkf]-
 * 	rlc.c				$Locker:  $
 * relocator for data space 
 *
 * (c) copyright 1982, Regents of the University of California
 */

#define TRUE 1
#include "h/global.h"
#if vax_4_2 | vax_4_3
#define brk(p) syscall(17,p)
#endif
extern char holend[], end[];
extern int usehole;
extern char *curhbeg;

rlc()
{
	char *cp, *dp;
	
	brk(end);
	dp = holend;
	cp = dp - HOLE;
	while (dp < end)
		*dp++ = *cp++;
	curhbeg = holend - HOLE;	/* set up the hole */
	usehole = TRUE;
}
EndOfFile
cat >  franz/vax/../lisp.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lisp.c,v 1.3 83/11/26 12:00:58 sklower Exp $";
#endif

/*					-[Sat Jan 29 13:24:33 1983 by jkf]-
 * 	lisp.c				$Locker:  $
 * main program
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include	"global.h"
#include	"frame.h"

/* main *****************************************************************/
/* Execution of the lisp system begins here.  This is the top level	*/
/* executor which is an infinite loop.  The structure is similar to	*/
/* error.								*/

extern lispval reborn;
extern int rlevel;
static int virgin = 0;
int	Xargc;
char	**Xargv;
extern char **environ;

main(argc,argv,arge)
char **argv,**arge;
{
	lispval matom(), Lapply();
	extern struct frame *errp;
	extern int holbeg,holend,usehole;
	extern int *curhbeg;
	pbuf pb;
	
	environ = arge;
#if sun_4_2 || sun_4_2beta
	setlinebuf(stdout);
#else
	{extern char _sobuf[]; setbuf(stdout,_sobuf);}
#endif
	Xargc = argc;
	Xargv = argv;
	virgin = 0;
	errp = (struct frame *)0;
	initial();

	errp = Pushframe(F_RESET,nil,nil);
	switch(retval)
	{
	case C_RESET: break;	/* what to do? */
	case C_INITIAL: break;	/* first time  */
	}

	for(EVER) {
		lbot = np = orgnp;
		rlevel = 0;
		depth = 0;
		clearerr(piport = stdin);
		clearerr(poport = stdout);
		np++->val = matom("top-level");
		np++->val = nil;
		Lapply();
	}
}

lispval
Ntpl()
{
	lispval Lread(),Istsrch();

	if (virgin == 0) {
		fputs((char *)Istsrch(matom("version"))->d.cdr->d.cdr->d.cdr,poport);
		virgin = 1;
	}
	lbot = np;
	np++->val = P(stdin);
	np++->val = eofa;
	while (TRUE)
		{
		fputs("\n-> ",stdout);
		dmpport(stdout);
		vtemp = Lread();
		if(vtemp == eofa) exit(0);
		printr(eval(vtemp),stdout);
		}
	}

/* franzexit :: give up the ghost
 * this function is called whenever one decides to kill this process. 
 * We clean up a bit then call then standard exit routine.  C code 
 * in franz should never call exit() directly.
 */
franzexit(code)
{
	extern int fvirgin;
	extern char *stabf;
	if(!fvirgin) unlink(stabf);	/* give up any /tmp symbol tables */
	exit(code);
/* is this something special??	_cleanup();
 *			        proflush();
 *				_exit(code);
 */
				
}
EndOfFile
cat >  franz/vax/../eval.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: eval.c,v 1.6 83/09/07 17:54:42 sklower Exp $";
#endif

/*					-[Thu Aug 18 10:07:22 1983 by jkf]-
 * 	eval.c				$Locker:  $
 * evaluator
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include <signal.h>
#include "frame.h"



/*
 *	eval
 * returns the value of the pointer passed as the argument.		
 *
 */

lispval
eval(actarg)
lispval actarg;
{
#define argptr handy
    register lispval a = actarg;
    register lispval handy;
    register struct nament *namptr;
    register struct argent *workp;
    struct nament *oldbnp = bnp;
    int dopopframe = FALSE;
    int type, shortcircuit = TRUE;
    lispval Ifcall(), Iarray();
    Savestack(4);

    /*debugging 
    if (rsetsw && rsetatom->a.clb != nil) {
	printf("Eval:");
	printr(a,stdout);
	printf("\nrsetsw: %d evalhsw: %d\n", rsetsw, evalhsw);
	printf("*rset: ");
	printr(rsetatom->a.clb,stdout);
	printf(" evalhook: ");
	printr(evalhatom->a.clb,stdout);
	printf(" evalhook call flag^G: %d\n", evalhcallsw);
	fflush(stdout); 
    };  
    */

    /* check if an interrupt is pending	 and handle if so */
    if(sigintcnt > 0) sigcall(SIGINT);

    if (rsetsw && rsetatom->a.clb != nil)  /* if (*rset t) has been done */
    {
	pbuf pb;
	shortcircuit = FALSE;
	if (evalhsw != nil && evalhatom->a.clb != nil)
	{
						/*if (sstatus evalhook t)
						    and evalhook non-nil */
	    if (!evalhcallsw)
	    		/*if we got here after calling evalhook, then
			  evalhcallsw will be TRUE, so we want to skip calling
			  the hook function, permitting one form to be
			  evaluated before the hook fires.
			 */
	    {
		/* setup equivalent of (funcall evalhook <arg to eval>) */
		(np++)->val = a;		/* push form on namestack */
		lbot=np;			/* set up args to funcall */
		(np++)->val = evalhatom->a.clb; /* push evalhook's clb */
		(np++)->val = a;		/* eval's arg becomes
					           2nd arg to funcall */
		PUSHDOWN(evalhatom, nil);	/* bind evalhook to nil*/
		PUSHDOWN(funhatom, nil);	/* bind funcallhook to nil*/
		funhcallsw = TRUE;		/* skip any funcall hook */
		handy = Lfuncal();		/* now call funcall */
		funhcallsw = FALSE;
		POP;
		POP;
		Restorestack();
		return(handy);
	    };
	}
	errp = Pushframe(F_EVAL,a,nil);
	dopopframe = TRUE;	/* remember to pop later */
	if(retval == C_FRETURN)
	{
	    Restorestack();
	    errp = Popframe();
	    return(lispretval);
	}
    };
        
    evalhcallsw = FALSE;   /* clear indication that evalhook called */
    
    switch (TYPE(a))
    {
    case ATOM:
	if (rsetsw && rsetatom->a.clb != nil && bptr_atom->a.clb != nil) {

	    struct nament *bpntr, *eval1bptr;
				  /* Both rsetsw and rsetatom for efficiency*/
				    /* bptr_atom set by second arg to eval1 */
	    eval1bptr = (struct nament *) bptr_atom->a.clb->d.cdr;
				    /* eval1bptr is bnp when eval1 was called;
				       if an atom was bound after this,
				       then its clb is valid */
	    for (bpntr = eval1bptr; bpntr < bnp; bpntr++)
		if (bpntr->atm==a) {
		    handy = a->a.clb;
		    goto gotatom;
		};		    /* Value saved in first binding of a,
				       if any, after pointer to eval1,
				       is the valid value, else use its clb */
	    for (bpntr = (struct nament *)bptr_atom->a.clb->d.car;
	      bpntr < eval1bptr; bpntr++)
		if (bpntr->atm==a) {
		    handy=bpntr->val;
		    goto gotatom;   /* Simply no way around goto here */
		};
	};
        handy = a->a.clb;
    gotatom:
        if(handy==CNIL) {
            handy = errorh1(Vermisc,"Unbound Variable:",nil,TRUE,0,a);
        }
	if(dopopframe) errp = Popframe();
	Restorestack();
        return(handy);

    case VALUE:
	if(dopopframe) errp = Popframe();
	Restorestack();
        return(a->l);

    case DTPR:
        (np++)->val = a;		/* push form on namestack */
        lbot = np;			/* define beginning of argstack */
        /* oldbnp = bnp;		   redundant - Mitch Marcus */
        a = a->d.car;			/* function name or lambda-expr */
        for(EVER)
            {
            switch(TYPE(a))
                {
            case ATOM:
					/*  get function binding  */
                if(a->a.fnbnd==nil && a->a.clb!=nil) {
                    a=a->a.clb;
                    if(TYPE(a)==ATOM)
                        a=a->a.fnbnd;
                } else
                    a = a->a.fnbnd;
                break;
            case VALUE:
                a = a->l;		/*  get value  */
                break;
                }

            vtemp = (CNIL-1);       /* sentinel value for error test */

        /*funcal:*/    switch (TYPE(a))
                {
            case BCD:    /* function */
                argptr = actarg->d.cdr;

				    /* decide whether lambda, nlambda or
				       macro and push args onto argstack
				       accordingly.                */

                if(a->bcd.discipline==nlambda) {
                    (np++)->val = argptr;
                    TNP;
                } else if(a->bcd.discipline==macro) {
                    (np++)->val = actarg;
                    TNP;
                } else for(;argptr!=nil; argptr = argptr->d.cdr) {
		    /* short circuit evaluations of ATOM, INT, DOUB
		     * if not in debugging mode
		     */
		    if(shortcircuit
		       && ((type = TYPE(argptr->d.car)) == ATOM)
		       && (argptr->d.car->a.clb != CNIL))
                       (np++)->val = argptr->d.car->a.clb;
		    else if(shortcircuit &&
		    		((type == INT) || (type == STRNG)))
                       (np++)->val = argptr->d.car;
		    else
                       (np++)->val = eval(argptr->d.car);
                    TNP;
                }
                /* go for it */

                if(TYPE(a->bcd.discipline)==STRNG)
                    vtemp = Ifcall(a);
                else
                    vtemp = (*(lispval (*)())(a->bcd.start))();
                break;

            case ARRAY:
                vtemp = Iarray(a,actarg->d.cdr,TRUE);
                break;

            case DTPR:		    /* push args on argstack according to
				       type                */
		protect(a);	/* save function definition in case function
				   is redefined */
		lbot = np;
                argptr = a->d.car;
                if (argptr==lambda) {
                    for(argptr = actarg->d.cdr;
                        argptr!=nil; argptr=argptr->d.cdr) {
                        
                        (np++)->val = eval(argptr->d.car);
                        TNP;
                    }
                } else if (argptr==nlambda) {
                    (np++)->val = actarg->d.cdr;
                    TNP;
                } else if (argptr==macro) {
                    (np++)->val = actarg;
                    TNP;
                } else if (argptr==lexpr) {
                    for(argptr = actarg->d.cdr;
                      argptr!=nil; argptr=argptr->d.cdr) {
                        
                        (np++)->val = eval(argptr->d.car);
                        TNP;
                    }
                    handy = newdot();
                    handy->d.car = (lispval)lbot;
                    handy->d.cdr = (lispval)np;
                    PUSHDOWN(lexpr_atom,handy);
                    lbot = np;
                    (np++)->val = inewint(((lispval *)handy->d.cdr) - (lispval *)handy->d.car);

                } else break;    /* something is wrong - this isn't a proper function */

                argptr = (a->d.cdr)->d.car;
                namptr =  bnp;
                workp = lbot;
                if(bnp + (np - lbot)> bnplim)
                    binderr();
                for(;argptr != (lispval)nil;
                     workp++,argptr = argptr->d.cdr)    /* rebind formal names (shallow) */
                {
                    if(argptr->d.car==nil)
                        continue;
                    /*if(((namptr)->atm = argptr->d.car)==nil)
                        error("Attempt to lambda bind nil",FALSE);*/
                    namptr->atm = argptr->d.car;
                    if (workp < np) {
                        namptr->val = namptr->atm->a.clb;
                        namptr->atm->a.clb = workp->val;
                    } else
                        bnp = namptr,
                        error("Too few actual parameters",FALSE);
                    namptr++;
                }
                bnp = namptr;
                if (workp < np)
                    error("Too many actual parameters",FALSE);

				    /* execute body, implied prog allowed */

                for (handy = a->d.cdr->d.cdr;
                    handy != nil;
                    handy = handy->d.cdr) {
                        vtemp = eval(handy->d.car);
                    }
                }
            if (vtemp != (CNIL-1)) {
				/* if we get here with a believable value, */
				/* we must have executed a function. */
                popnames(oldbnp);

                /* in case some clown trashed t */

                tatom->a.clb = (lispval) tatom;
                if(a->d.car==macro)
		{
		    if(Vdisplacemacros->a.clb && (TYPE(vtemp) == DTPR))
		    {
			actarg->d.car = vtemp->d.car;
			actarg->d.cdr = vtemp->d.cdr;
		    }
		    vtemp = eval(vtemp);
		}
                    /* It is of the most wonderful 
                       coincidence that the offset
                       for car is the same as for
                       discipline so we get bcd macros
                       for free here ! */
		if(dopopframe) errp = Popframe();
		Restorestack();
		return(vtemp);
	    }
            popnames(oldbnp);
            a = (lispval) errorh1(Verundef,"eval: Undefined function ",nil,TRUE,0,actarg->d.car);
            }

        }
    if(dopopframe) errp = Popframe();
    Restorestack();
    return(a);    /* other data types are considered constants */
}

/*
 *    popnames
 * removes from the name stack all entries above the first argument.   
 * routine should usually be used to clean up the name stack as it    
 * knows about the special cases.  bnp is returned pointing to the
 * same place as the argument passed.
 */
lispval
popnames(llimit)
register struct nament *llimit;
{
    register struct nament *rnp;

    for(rnp = bnp; --rnp >= llimit;)
        rnp->atm->a.clb = rnp->val;
    bnp = llimit;
}


/* dumpnamestack
 * utility routine to dump out the namestack.
 * from bottom to 5 above np
 * should be put elsewhere
 */
dumpnamestack()
{
    struct argent *newnp;

    printf("namestack dump:\n");
    for(newnp = orgnp ; (newnp < np + 6) && (newnp < nplim) ; newnp++)
    {
	if(newnp == np) printf("**np:**\n");
	printf("[%d]: ",newnp-orgnp);
	printr(newnp->val,stdout);
	printf("\n");
    }
    printf("end namestack dump\n");
}



lispval
Lapply()
{
    register lispval a;
    register lispval handy;
    lispval vtemp, Ifclosure();
    struct nament *oldbnp = bnp;
    struct argent *oldlbot = lbot; /* Bottom of my frame! */
    struct argent *oldnp = np; /* First free on stack */
    int extrapush;		/* if must save function value */

    a = lbot->val;
    argptr = lbot[1].val;
    if(np-lbot!=2)
        errorh2(Vermisc,"Apply: Wrong number of args.",nil,FALSE,
               999,a,argptr);
    if(TYPE(argptr)!=DTPR && argptr!=nil)
        argptr = errorh1(Vermisc,"Apply: non-list of args",nil,TRUE,
                998,argptr);
    (np++)->val = a;    /* push form on namestack */
    TNP;
    lbot = np;        /* bottom of current frame */
    for(EVER)
        {
	extrapush = 0;
        if (TYPE(a) == ATOM) { a = a->a.fnbnd; extrapush = 1; }
					/* get function definition (unless
					   calling form is itself a lambda-
					   expression) */
        vtemp = CNIL;			/* sentinel value for error test */
        switch (TYPE(a)) {

        case BCD: 
					/* push arguments - value of a */
            if(a->bcd.discipline==nlambda || a->bcd.discipline==macro) {
                (np++)->val=argptr;
                TNP;
            } else for (; argptr!=nil; argptr = argptr->d.cdr) {
                (np++)->val=argptr->d.car;
                TNP;
            }

	    if(TYPE(a->bcd.discipline) == STRNG)
	      vtemp = Ifcall(a);	/* foreign function */
	    else
              vtemp = (*(lispval (*)())(a->bcd.start))(); /* go for it */
            break;

        case ARRAY:
            vtemp = Iarray(a,argptr,FALSE);
            break;


        case DTPR:
            if (a->d.car==nlambda || a->d.car==macro) {
                (np++)->val = argptr;
                TNP;
            } else if (a->d.car==lambda)
                for (; argptr!=nil; argptr = argptr->d.cdr) {
                    (np++)->val = argptr->d.car;
                    TNP;
                }
            else if(a->d.car==lexpr) {
                for (; argptr!=nil; argptr = argptr->d.cdr) {
                    
                    (np++)->val = argptr->d.car;
                    TNP;
                }
                handy = newdot();
                handy->d.car = (lispval)lbot;
                handy->d.cdr = (lispval)np;
                PUSHDOWN(lexpr_atom,handy);
                lbot = np;
                (np++)->val = inewint(((lispval *)handy->d.cdr) - (lispval *)handy->d.car);

            } else break;    /* something is wrong - this isnt a proper function */
            rebind(a->d.cdr->d.car,lbot);

	    if (extrapush == 1) { protect(a); extrapush = 2;}
            for (handy = a->d.cdr->d.cdr;
                handy != nil;
                handy = handy->d.cdr) {
                    vtemp = eval(handy->d.car);    /* go for it */
                }
	    break;
	    
	case VECTOR:
	    /* certain vectors are valid (fclosures) */
	   if(a->v.vector[VPropOff] == fclosure)
	       vtemp = (lispval) Ifclosure(a,FALSE);
	   break;
		
        };
	
	/* pop off extra value if we pushed it before */
	if (extrapush == 2)
	{
	    np--;
	    extrapush = 0;
	};
	
        if (vtemp != CNIL)
				/* if we get here with a believable value, */
				/* we must have executed a function. */
            {
            popnames(oldbnp);

            /* in case some clown trashed t */

            tatom->a.clb = (lispval) tatom;
	    np = oldnp; lbot = oldlbot;
            return(vtemp);
            }
        popnames(oldbnp);
        a = (lispval) errorh1(Verundef,"apply: Undefined Function ",
					      nil,TRUE,0,oldlbot->val);
    }
    /*NOT REACHED*/
}


/*
 * Rebind -- rebind formal names
 */
rebind(argptr,workp)
register lispval argptr;        /* argptr points to list of atoms */
register struct argent * workp;        /* workp points to position on stack
                       where evaluated args begin */
{
    register struct nament *namptr = bnp;

    for(;argptr != (lispval)nil;
         workp++,argptr = argptr->d.cdr)  /* rebind formal names (shallow) */
    {
        if(argptr->d.car==nil)
            continue;
        namptr->atm = argptr->d.car;
        if (workp < np) {
            namptr->val = namptr->atm->a.clb;
            namptr->atm->a.clb = workp->val;
        } else
            bnp = namptr,
            error("Too few actual parameters",FALSE);
        namptr++;
        if(namptr > bnplim)
            binderr();
    }
    bnp = namptr;
    if (workp < np)
        error("Too many actual parameters",FALSE);
}

/* the argument to Lfuncal is now mandatory since nargs
 * wont work on RISC. If it is given  then it is 
 * the name of the function to call and lbot points to the first arg.
 * if it is not given, then lbot points to the function to call
 */
lispval
Ifuncal(fcn)
lispval fcn;
{
    register lispval a;
    register lispval handy; 
    struct nament *oldbnp = bnp;	/* MUST be first local for evalframe */
    lispval fcncalled;
    lispval Ifcall(),Llist(),Iarray(), Ifclosure();
    lispval vtemp;
    int typ, dopopframe = FALSE, extrapush;
    extern lispval end[];
    Savestack(3);

    /*if(nargs()==1)			/* function I am evaling.    */
	a = fcncalled = fcn;
    /*else { a = fcncalled = lbot->val; lbot++; }*/

    /*debugging 
    if (rsetsw && rsetatom->a.clb != nil) {
	printf("funcall:");
	printr(a,stdout);
	printf("\nrsetsw: %d evalhsw: %d\n", rsetsw, evalhsw);
	printf("*rset: ");
	printr(rsetatom->a.clb,stdout);
	printf(" funhook: ");
	printr(funhatom->a.clb,stdout);
	printf(" funhook call flag^G: %d\n",funhcallsw);
	fflush(stdout); 
    };  
    */

    /* check if exception pending */
    if(sigintcnt > 0 ) sigcall(SIGINT);

    if (rsetsw && rsetatom->a.clb != nil)  /* if (*rset t) has been done */
    {    	
	pbuf pb;
	if (evalhsw != nil && funhatom->a.clb != nil)
	{
						/*if (sstatus evalhook t)
						    and evalhook non-nil */
	    if (!funhcallsw)
			/*if we got here after calling funcallhook, then
			  funhcallsw will be TRUE, so we want to skip calling
			  the hook function, permitting one form to be
			  evaluated before the hook fires.
			 */
	    {
		/* setup equivalent of (funcall funcallhook <args to eval>) */
		protect(a);
		a = fcncalled = funhatom->a.clb; /* new function to funcall */
		PUSHDOWN(funhatom, nil);	/* lambda-bind 
						 * funcallhook to nil
						 */
		PUSHDOWN(evalhatom, nil);	
	     /* printf(" now will funcall ");
		printr(a,stdout);
		putchar('\n');
		fflush(stdout); */
	    };
	}
	errp = Pushframe(F_FUNCALL,a,nil);
	dopopframe = TRUE;	/* remember to pop later */
	if(retval == C_FRETURN)
	{
	    popnames(oldbnp);
	    errp = Popframe();
	    Restorestack();
	    return(lispretval);
	}
    };
    
    funhcallsw = FALSE;	/* so recursive calls to funcall will cause hook
    			   to fire */
    for(EVER)
    {
     top:
        extrapush = 0;
	
        typ = TYPE(a);
        if (typ == ATOM)
	{   /* get function defn (unless calling form */
            /* is itself a lambda-expr) */
	    a = a->a.fnbnd;
	    typ = TYPE(a);
	    extrapush = 1;	/* must protect this later */
	}
        vtemp = CNIL-1;            /* sentinel value for error test */
        switch (typ) {
        case ARRAY:
	    protect(a);			/* stack array descriptor on top */
	    a = a->ar.accfun;		/* now funcall access function */
	    goto top;
        case BCD:
            if(a->bcd.discipline==nlambda)
                {   if(np==lbot) protect(nil);  /* default is nil */
                while(np-lbot!=1 || (lbot->val != nil &&
                      TYPE(lbot->val)!=DTPR)) {

			    lbot->val = errorh1(Vermisc,"Bad funcall arg(s) to fexpr.",
						 nil,TRUE,0,lbot->val);
			    
                    np = lbot+1;
                    }
                }
            /* go for it */

            if(TYPE(a->bcd.discipline)==STRNG)
                vtemp = Ifcall(a);
            else
                vtemp = (*(lispval (*)())(a->bcd.start))();
            if(a->bcd.discipline==macro)
                vtemp = eval(vtemp);
            break;


        case DTPR:
            if (a->d.car == lambda) {
                ;/* VOID */
            } else if (a->d.car == nlambda || a->d.car==macro) {
                if( np==lbot ) protect(nil);    /* default */
                while(np-lbot!=1 || (lbot->val != nil &&
                          TYPE(lbot->val)!=DTPR)) {
                    lbot->val = error("Bad funcall arg(s) to fexpr.",TRUE);
                    np = lbot+1;
                    }
            } else if (a->d.car == lexpr) {
                handy = newdot();
                handy->d.car = (lispval) lbot;
                handy->d.cdr = (lispval) np;
                PUSHDOWN(lexpr_atom,handy);
                lbot = np;
                (np++)->val = inewint(((lispval *)handy->d.cdr) - (lispval *)handy->d.car);
            } else break;        /* something is wrong - this isn't a proper function */
            rebind(a->d.cdr->d.car,lbot);

	    /* since the actual arguments are bound to their formal params
	     * we can pop them off the stack.  However if we are doing
	     * debugging (that is if we've pushed a frame on the stack)
	     * then we must not pop off the actual args since they must
	     * be visible for evalframe to work
	     */
            if(!dopopframe) np = lbot;
	    if (extrapush == 1) {protect(a);  extrapush = 2;}
            for (handy = a->d.cdr->d.cdr;
                handy != nil;
                handy = handy->d.cdr) {
                    vtemp = eval(handy->d.car);    /* go for it */
                }
            if(a->d.car==macro)
                vtemp = eval(vtemp);
	    break;
	    
	case VECTOR:
	   /* A fclosure represented as a vector with the property 'fclosure' */
	   if(a->v.vector[VPropOff] == fclosure)
	       vtemp = (lispval) Ifclosure(a,TRUE);
	   break;
	   
        }
	
	/* pop off extra value if we pushed it before */
	if(extrapush == 2) { np-- ; extrapush = 0; }
	
        if (vtemp != CNIL-1)
            /* if we get here with a believable value, */
            /* we must have executed a function. */
            {
            popnames(oldbnp);

            /* in case some clown trashed t */

            tatom->a.clb = (lispval) tatom;

	    if(dopopframe) errp = Popframe();
	    Restorestack();
            return(vtemp);
            }
        popnames(oldbnp);
	    a = fcncalled = (lispval) errorh1(Verundef,"funcall: Bad function",
					       nil,TRUE,0,fcncalled);
    }
    /*NOT REACHED*/
}
lispval   /* this version called from lisp */
Lfuncal()
{
	lispval handy;
	Savestack(0);
	
	switch(np-lbot)
	{
	    case 0: argerr("funcall");
	    	    break;
	}
	handy = lbot++->val;
	handy = Ifuncal(handy);
	Restorestack();
	return(handy);
}

/* The following must be the next "function" after Lfuncal, for the
sake of Levalf.  */
fchack () {}


/*
 * Llexfun  :: lisp function lexpr-funcall
 * lexpr-funcall is a cross between funcall and apply.
 * the last argument is nil or a list of the rest of the arguments.
 * we push those arguments on the stack and call funcall
 *
 */
lispval
Llexfun()
{
    register lispval handy;
    
    switch(np-lbot)
    {
	case 0: argerr("lexpr-funcall");	/* need at least one arg */
		break;
	case 1: return(Lfuncal());	 /* no args besides function */
    }
    /* have at least one argument past the function to funcall */
    handy = np[-1].val;		/* get last value */
    np--;			/* pop it off stack */
    
    while((handy != nil) && (TYPE(handy) != DTPR))
    	handy = errorh1(Vermisc,"lexpr-funcall: last argument is not a list ",
			nil,TRUE,0,handy);

    /* stack arguments */
    for( ; handy != nil ; handy = handy->d.cdr) protect(handy->d.car);

    return(Lfuncal());
}

	
#undef protect
	
/* protect 
 * pushes the first argument onto namestack, thereby protecting from gc
 */
lispval
protect(a)
lispval a;
{
    (np++)->val = a;
       if (np >=  nplim)
        namerr();
}

/* unprot
 * returns the top thing on the name stack.  Underflow had better not
 * occur.
 */
lispval
unprot()
    {
    return((--np)->val);
    }

lispval
linterp()
    {
    error("BYTE INTERPRETER CALLED ERRONEOUSLY",FALSE);
    }

/* Undeff - called from qfuncl when it detects a call to a undefined
    function from compiled code, we print out a message and
    will continue only if returned a symbol (ATOM in C parlance).
*/
lispval
Undeff(atmn)
lispval atmn;
{
    do {atmn =errorh1(Verundef,"Undefined function called from compiled code ",
				      nil,TRUE,0,atmn);}
	while(TYPE(atmn) != ATOM);
    return(atmn);		      
}

/* VARARGS1 */
bindfix(firstarg)
lispval firstarg;
{
    register lispval *argp = &firstarg;
    register struct nament *mybnp = bnp;
    while(*argp != nil) {
        mybnp->atm = *argp++;
        mybnp->val = mybnp->atm->a.clb;
        mybnp->atm->a.clb = *argp++;
        bnp = mybnp++;
    }
}

EndOfFile
cat >  franz/vax/../eval2.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: eval2.c,v 1.8 85/03/24 11:03:02 sklower Exp $";
#endif

/*					-[Sat May  7 23:38:37 1983 by jkf]-
 * 	eval2.c				$Locker:  $
 * more of the evaluator
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include "frame.h"

/* Iarray - handle array call.
 *  fun - array object
 *  args - arguments to the array call , most likely subscripts.
 *  evalp - flag, if TRUE then the arguments should be evaluated when they
 *	are stacked.
 */
lispval
Iarray(fun,args,evalp)
register lispval fun,args;
{
	Savestack(2);
	
	lbot = np;
	protect(fun->ar.accfun);
	for ( ; args != nil ; args = args->d.cdr)  /* stack subscripts */
	  if(evalp) protect(eval(args->d.car));
	  else protect(args->d.car);
	protect(fun);
	vtemp = Lfuncal();
	Restorestack();
	return(vtemp);
}

    
dumpmydata(thing)
int thing;
{
	register int *ip = &thing;
	register int *lim = ip + nargs();

	printf("Dumpdata got %d args:\n",nargs());
	while(ip < lim) printf("%x\n",*ip++);
	return(0);
}
/* Ifcall :: call foreign function/subroutine
 *   Ifcall is handed a binary object which is the function to call.
 * This function has already been determined to be a foreign function
 * by noticing that its discipline field is a string.  
 * The arguments to pass have already been evaluated and stacked.  We
 * create on the stack a 'callg' type argument list to give to the 
 * function.  What is passed to the foreign function depends on the
 * type of argument.  Certain args are passes directly, others must be
 * copied since the foreign function my want to change them.
 * When the foreign function returns, we may have to box the result,
 * depending on the type of foreign function.
 */
lispval
Ifcall(a)
lispval a;
{
	char *alloca();
	long callg_();
	register int *arglist;
	register int index;
	register struct argent *mynp;
	register lispval ltemp;
	pbuf pb;
	int nargs = np - lbot, kind, mysize, *ap;
	Keepxs();

	/* put a frame on the stack which will save np and lbot in a
	   easy to find place in a standard way */
	errp = Pushframe(F_TO_FORT,nil,nil);
	mynp = lbot;
	kind = (((char *)a->bcd.discipline)[0]);

	/* dispatch according to whether call by reference or value semantics */
	switch(kind) {
	case 'f': case 'i': case 's': case 'r':
		arglist = (int *) alloca((nargs + 1) * sizeof(int));
		*arglist = nargs;
		for(index = 1; index <=  nargs; index++) {
			switch(TYPE(ltemp=mynp->val)) {
				/* fixnums and flonums must be reboxed */
			case INT:
				stack(0);
				arglist[index] = (int) sp();
				*(int *) arglist[index] = ltemp->i;
				break;
			case DOUB:
				stack(0);
				stack(0);
				arglist[index] = (int) sp();
				*(double *) arglist[index] = ltemp->r;
				break;

				/* these cause only part of the structure to be sent */

			case ARRAY:
				arglist[index] = (int) ltemp->ar.data;
				break;


			case BCD:
				arglist[index] = (int) ltemp->bcd.start;
				break;

				/* anything else should be sent directly */

			default:
				arglist[index] = (int) ltemp;
				break;
			}
			mynp++;
		}
		break;
	case 'v':
		while(TYPE(mynp->val)!=VECTORI)
			mynp->val = error(
"First arg to c-function-returning-vector must be of type vector-immediate",
					  TRUE);
		nargs--;
		mynp++;
		lbot++;
	case 'c': case 'd':
		/* make one pass over args 
		calculating size of arglist */
		while(mynp < np) switch(TYPE(ltemp=mynp++->val)) {
		case DOUB:
			nargs += ((sizeof(double)/sizeof(int))-1);
			break;
		case VECTORI:
			if(ltemp->v.vector[-1]==Vpbv) {
			    nargs += -1+VecTotSize(ltemp->vl.vectorl[-2]);
			}
		}
		arglist = (int *) alloca((nargs+1)*sizeof(int));
		*arglist = nargs;
		ap = arglist + 1;
		/* make another pass over the args
		   actually copying the arguments */
		for(mynp = lbot; mynp < np; mynp++)
			switch(TYPE(ltemp=mynp->val)) {
		case INT:
			*ap++ = ltemp->i;
			break;
		case DOUB:
			*(double *)ap = ltemp->r;
			ap += (sizeof (double)) / (sizeof (long));
			break;
		case VECTORI:
			if(ltemp->v.vector[-1]==Vpbv) {
				mysize = ltemp->vl.vectorl[-2];
				mysize = sizeof(long) * VecTotSize(mysize);
				xbcopy(ap,ltemp,mysize);
				ap = (long *) (mysize + (int) ap);
				break;
			}
		default:
			*ap++ = (long) ltemp;
		}
	}
	switch(kind) {
		case 'i': /* integer-function */
		case 'c': /* C-function */
			ltemp = inewint(callg_(a->bcd.start,arglist));
			break;

		case 'r': /* real-function*/
		case 'd': /* C function declared returning double */
			{
			double result =
			   (* ((double (*)()) callg_))(a->bcd.start,arglist);
			ltemp = newdoub();
			ltemp->r = result; 
			}
			break;

		case 'f':  /* function */
			ltemp = (lispval) callg_(a->bcd.start,arglist);
			break;

		case 'v': /* C function returning a structure */
			ap = (long *) callg_(a->bcd.start,arglist);
			ltemp = (--lbot)->val;
			mysize = ltemp->vl.vectorl[-2];
			mysize = sizeof(long) * VecTotSize(mysize);
			xbcopy(ltemp,ap,mysize);
			break;

		default:
		case 's': /* subroutine */
			callg_(a->bcd.start,arglist);
			ltemp = tatom;
	}
	errp = Popframe();
	Freexs();
	return(ltemp);
}

xbcopy(to,from,size)
register char *to, *from;
register size;
{
	while(--size >= 0) *to++ = *from++;
}

lispval
ftolsp_(arg1)
lispval arg1;
{
	int count; 
	register lispval *ap = &arg1;
	lispval save;
	pbuf pb;
	Savestack(1);

	if((count = nargs())==0) return;;

	if(errp->class==F_TO_FORT)
		np = errp->svnp;
	errp = Pushframe(F_TO_LISP,nil,nil);
	lbot = np;
	for(; count > 0; count--)
		np++->val = *ap++;
	save = Lfuncal();
	errp = Popframe();
	Restorestack();
	return(save);
}

lispval
ftlspn_(func,arglist)
lispval func;
register long *arglist;
{
	int count; 
	lispval save;
	pbuf pb;
	Savestack(1);

	if(errp->class==F_TO_FORT)
		np = errp->svnp;
	errp = Pushframe(F_TO_LISP,nil,nil);
	lbot = np;
	np++->val = func;
	count = *arglist++;
	for(; count > 0; count--)
		np++->val = (lispval) (*arglist++);
	save = Lfuncal();
	errp = Popframe();
	Restorestack();
	return(save);
}


    
/* Ifclosure :: evaluate a fclosure  (new version)
 * the argument clos is a vector whose property is the atom fclosure
 * the form of the vector is
 *   0: function to run
 * then for each symbol there is on vector entry containing a
 * pointer to a sequence of two list cells of this form:
 *	(name value . count)
 * name is the symbol name to close over
 * value is the saved value of the closure
 *	(if the closure is 'active', the current value will be in the
 *	 symbol itself)
 * count is a fixnum box (which can be destructively modified safely)
 *  it is normally 0.  Each time the variable is put on the stack, it is
 *  incremented.  It is decremented each time the the closure is left.
 *  If the closure is invoked recusively without a rebinding of the
 *  closure variable X, then the count will not be incremented.
 *
 * when entering a fclosure, for each variable there are three
 * possibities:
 *  (a) this is the first instance of this closed variable
 *  (b) this is the second or greater recursive instance of
 *      this closure variable, however it hasn't been normally lambda
 *	bound since the last closure invocation
 *  (c) like (b) but it has been lambda bound before the most recent
 *	closure.
 *
 * case (a) can be determined by seeing if the count is 0.
 * if the count is >0 then we must scan from the top of the stack down
 * until we find either the closure or a lambda binding of the variable
 * this determines whether it is case (b) or (c).
 *
 * There are three actions to perform in this routine:
 * 1.  determine the closure type (a,b or c) and do any binding necessary
 * 2.  call the closure function
 * 3.  unbind any necessary closure variables.
 *
 * Now, the details of those actions:
 * 1. for case (b), do nothing as we are still working with the correct
 *    value
 *    for case (a), pushdown the symbol and give it the value from
 *	the closure, inc the closure count
 *      push a closure marker on the bindstack too.
 *    for case (c), must locate the correct value to set by searching
 *      for the last lambda binding before the previous closure.
 *      pushdown the symbol and that value, inc the closure count
 *      push a closure marker on the bindstack too.
 *    a closure marker has atom == int:closure-marker and value pointing
 *      to the closure list.  This will be noticed when unbinding.
 *
 *  3. unbinding is just like popnames except if a closure marker is
 *     seen, then this must be done:
 *	if the count is 1, just store the symbol's value in the closure
 *	 and decrement the count.
 *      if the count is >1, then search up the stack for the last
 *	 lambda before the next occurance of this closure variable
 *	 and set its value to the current value of the closure.
 *	 decrement the closure count.
 *
 * clos is the fclosure, funcallp is TRUE if this is called from funcall,
 * otherwise it is called from apply
 */

#define Case_A 0
#define Case_B 1
#define Case_C 2

lispval
Ifclosure(clos,funcallp)
register lispval clos;
{
    struct nament *oldbnp = bnp, *lbnp, *locatevar();
    register int i;
    register lispval vect;
    int numvars, vlength, tcase, foundc;
    lispval handy, atm_dtpr, value_dtpr, Ifuncal(), Lapply();
    Savestack(3);

    /* bind variables to their values given in the fclosure */
    vlength = VecTotSize(clos->vl.vectorl[VSizeOff]);
    /* vector length must be positive (it has to have a function at least) */
    if (vlength < 1)
	errorh1(Vermisc,"funcall: fclosure has wrong size ",nil,FALSE,0, clos);

    numvars = (vlength - 1);	/* number of varibles */
    
    for (i = 1 ; i < vlength ; i += 1)
    {
	atm_dtpr = clos->v.vector[i];	/* car is symbol name */
	value_dtpr = atm_dtpr->d.cdr;   /* car: value, cdr:  fixnum count */

	if(value_dtpr->d.cdr->i == 0)
		tcase = Case_A;		/* first call */
	else {
	    lbnp = locatevar(atm_dtpr,&foundc,bnp-1);
	    if (!foundc)
	    {
		/* didn't find the expected closure, count must be
		   wrong, correct it and assume case (a)
		 */
		tcase = Case_A;
		value_dtpr->d.cdr->i = 0;
	    }
	    else if(lbnp) tcase = Case_C ; /* found intermediate lambda bnd*/
	    else tcase = Case_B;	   /* no intermediate lambda bind */
	}

	/* now bind the value if necessary */
	switch(tcase) {
	    case Case_A: PUSHDOWN(atm_dtpr->d.car,value_dtpr->d.car);
	    		 PUSHVAL(clos_marker,atm_dtpr);
			 value_dtpr->d.cdr->i += 1;
			 break;
			 
	    case Case_B: break;		/* nothing to do */

	    case Case_C: /* push first bound value after last close */
	    	         PUSHDOWN(atm_dtpr->d.car,lbnp->val);
			 PUSHVAL(clos_marker,atm_dtpr);
			 value_dtpr->d.cdr->i += 1;
			 break;
	}
    }

    if(funcallp)
       handy = Ifuncal(clos->v.vector[0]);
    else {
       handy = lbot[-2].val;	/* get args to apply.  This is hacky and may
       				   fail if apply is changed */
       lbot = np;
       protect(clos->v.vector[0]);
       protect(handy);
       handy = Lapply();
    }

    xpopnames(oldbnp);	/* pop names with consideration for closure markers */
    
    if(!funcallp) Restorestack();
    return(handy);
}

/* xpopnames :: pop values from bindstack, but look out for
 *  closure markers.  This is  used (instead of the faster popnames)
 * when we know there will be closure markers or when we can't
 * be sure that there won't be closure markers (eg. in non-local go's)
 */
xpopnames(llimit)
register struct nament *llimit;
{
    register struct nament *rnp, *lbnp;
    lispval atm_dtpr, value_dtpr;
    int foundc;

    for(rnp = bnp; --rnp >= llimit;)
    {
        if(rnp->atm == clos_marker)
	{
	    atm_dtpr = rnp->val;
	    value_dtpr = atm_dtpr->d.cdr;
	    if(value_dtpr->d.cdr->i <= 1)
	    {
		/* this is the only occurance of this closure variable
		 * just restore current value to this closure.
		 */
		value_dtpr->d.car = atm_dtpr->d.car->a.clb;
	    }
	    else {
		/* locate the last lambda before the next occurance of
		 * this closure and store the current symbol's value
		 * there
		 */
		lbnp = locatevar(atm_dtpr,&foundc,rnp-2);
		if(!foundc)
		{
		    /* strange, there wasn't a closure to be found.
		     * well, we will fix things up so the count is
		     * right.
		     */
		    value_dtpr->d.car = atm_dtpr->d.car->a.clb;
		    value_dtpr->d.cdr->i = 1;
		}
		else if (lbnp) {
		    /* note how the closures value isn't necessarily
		     * stored in the closure, it may be stored on
		     * the bindstack
		     */
		    lbnp->val = atm_dtpr->d.car->a.clb;
		}
		/* the case where lbnp is 0 should never happen, but
		   if it does, we can just do nothing safely
		 */
	    }
	    value_dtpr->d.cdr->i -= 1;
	} else rnp->atm->a.clb = rnp->val;  /* the normal case */
    }
    bnp = llimit;
}


struct nament *
locatevar(clos,foundc,rnp)
struct nament *rnp;
lispval clos;
int *foundc;
{
    register struct nament  *retbnp;
    lispval symb;

    retbnp = (struct nament *) 0;
    *foundc = 0;
    
    symb = clos->d.car;
    
    for(  ; rnp >= orgbnp ; rnp--)
    {
	if((rnp->atm == clos_marker) && (rnp->val == clos))
	{
	    *foundc = 1;	/* found the closure */
	    return(retbnp);
	}
	if(rnp->atm == symb) retbnp = rnp;
    }
    return(retbnp);	
}

lispval
LIfss()
{
	register lispval atm_dtpr, value_dtpr;
	struct nament *oldbnp = bnp, *lbnp;
	int tcase, foundc = 0;
	lispval newval;
	int argc = 1;
	Savestack(2);

	switch(np-lbot) {
	case 2:
		newval = np[-1].val;
		argc++;
	case 1:
		atm_dtpr = lbot->val;
		value_dtpr = atm_dtpr->d.cdr;
		break;
	default:
		argerr("int:fclosure-symbol-stuff");
	}
	/* this code is copied from Ifclosure */

	if(value_dtpr->d.cdr->i==0)
		tcase = Case_A;	/* closure is not active */
	else {
		lbnp = locatevar(atm_dtpr,&foundc,bnp-1);
		if (!foundc)
		{
			/* didn't find closure, count must be wrong,
			   correct it and assume case (a).*/
			tcase = Case_A;
			value_dtpr->d.cdr->i = 0;
		}
		else if(lbnp) tcase = Case_C; /* found intermediate lambda*/
		else tcase = Case_B;
	}

	switch(tcase) {
	case Case_B:
		if(argc==2) return(atm_dtpr->d.car->a.clb = newval);
		return(atm_dtpr->d.car->a.clb);

	case Case_A:
		if(argc==2) return(value_dtpr->d.car = newval);
		return(value_dtpr->d.car);

	case Case_C:
		if(argc==2) return(lbnp->val = newval);
		return(lbnp->val);
	}
	/*NOTREACHED*/
}
EndOfFile
cat >  franz/vax/../inits.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: inits.c,v 1.7 85/03/24 11:03:12 sklower Exp $";
#endif

/*					-[Sat Jan 29 12:59:39 1983 by jkf]-
 * 	inits.c				$Locker:  $
 * initialization routines
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include <signal.h>
#include "frame.h"

/* initial
 * initializes the parts of the system that cannot be automatically
 * accomplished in the declarations.
 */
 
int reborn=0;	/*  flag to tell whether we are in fast-load version  */
extern char *stabf;
extern int fvirgin;
extern int keywait;
extern sigstruck, sigdelay;
initial()
{
	int sigalrmh(), sigfpeh(),  sginth();
	lispval Isstatus(),Istsrch();
	extern int hashtop;

	/* clear any memory of pending SIGINT's */
	exception = FALSE;
	sigintcnt = 0;

	if( signal(SIGINT,SIG_IGN) != SIG_IGN)
	      signal(SIGINT,sginth);
	if( signal(SIGHUP,SIG_IGN) != SIG_IGN)
	      signal(SIGHUP,sginth);
	signal(SIGFPE,sginth);
	signal(SIGALRM,sginth);
	signal(SIGPIPE,sginth);
	/* signals SIGBUS and SIGSEGV will be set up when the status list
	   is set up when the lisp is virgin, and will be set up according
	   to the current value on the status list if the lisp is reborn
	*/

#ifdef SPISFP
	{extern long *exsp; xsp = exsp;}
#endif

	if( reborn ) {
		np = lbot = orgnp;
		Nioreset();
		stabf = 0;
		fvirgin = 1;
		loading->a.clb = nil;
		gcrebear();

		/* set up SIGBUS and SIGSEGV from current value 
		   of status flag dumpcore
		*/
		Isstatus(matom("dumpcore"),
			 (Istsrch(matom("dumpcore")))->d.cdr->d.cdr->d.cdr);

		makenv();
		return;
	}
	for (hash=0;hash<hashtop;hash++) hasht[hash] = (struct atom *) CNIL;
	
	sbrk( LBPG-(((int)sbrk(0)) % LBPG) );	/* even up the break */
	makevals();

	orgnp = np;
	makenv();

}

static
makenv()
{
	register lispval env, temp;
	register char *p, *q;
	char **envp, envstr[STRBLEN];
	extern char **environ;

	lbot = np;
	env = nil;
	np++->val = env;
	for (envp=environ; *envp!=NULL; envp++) ;
	while (--envp >= environ) {
		for(p= *envp,q=envstr; *p!='=' ; p++)
			if(q < envstr + STRBLEN)
				*q++ = *p;
		*q = 0; p++;
		/* at this point lbot->val==env, so it is protected
		   from gc */
		lbot->val = temp = newdot();
		temp->d.cdr = env;
		env = temp;
		temp = newdot();
		env->d.car = temp;
		temp->d.car = matom(envstr);
		temp->d.cdr = matom(p);
	}
	matom("environment")->a.clb = env;
	np--;
}

sginth(signo){
	re_enable(signo,sginth);
	sigstruck |= (1 << signo);
	/* handle SIGINT differently since it is the only
	   asychronous interrupt we handle		*/
	if( signo == SIGINT) {
	    if( ++sigintcnt == 1)
	    {  /* if this is the first interrupt, we just set a flag
		  which will be checked in qfuncl and eval.  This will
		  allow us to handle these interrupts when we are
		  ready.
	       */
	       exception = TRUE;
	       /*putchar('A');*/
	       fflush(stdout);
	       sigstruck &= ~(1 << signo);
	       return;
	    }
	    else if (sigintcnt == 2)
	    {  /* the setting of  exception was ignored, we better
		  make sure that all calls from compiled code
		  go through qlinker
		*/
		signal(SIGINT,SIG_IGN);  /* this may take a while, dont allow ints*/
		clrtt(0);
		/*putchar('B');*/
		fflush(stdout);
		signal(SIGINT,sginth);  /* ok to interrupt again */
		sigstruck &= ~(1 << signo);
		return;
	    }
	    else {
		/*putchar('C');*/
		fflush(stdout);
	    }
	}

	sigcall(signo);
}
sigcall(which)
register which;
{
	extern lispval Lfuncal();
	Savestack(1);

	if(which == SIGINT) { sigintcnt = 0; exception = 0; }

	if(sigacts[which]!=((lispval) 0)) {
		pbuf pb;
		int mustpop = 0;
		if(errp && errp->class==F_TO_FORT) {
			np = errp->svnp;
			mustpop = 1;
			errp = Pushframe(F_TO_LISP,nil,nil);
		}
		lbot = np;
		np -> val = sigacts[which];
		INRNP;
		np -> val = inewint((long)which);
		INRNP;
	{lispval temp;temp = rdrsdot, rdrsdot = rdrsdot2, rdrsdot2 = temp; /*KLUDGE*/}
		Lfuncal();
		if (mustpop) errp = Popframe();
	{lispval temp;temp = rdrsdot, rdrsdot = rdrsdot2, rdrsdot2 = temp; /*KLUDGE*/}
	}
	sigstruck &= ~ (1<<which);
	Restorestack();
}
delayoff(){
	sigdelay = FALSE;
	if(sigstruck)
		dosig();
}
dosig()
{
	register int i; int which;
	if(!sigdelay) 
		for(which=0, i = 1;  i <= 65536;  which++,i<<=1) {
			keywait = FALSE;
			if(sigstruck & i)
				sigcall(which);
		}
}
badmr(number)
{
	signal(number,badmr);
	fflush(stdout);
	error("Internal bad memory reference, you are advised to (reset).",FALSE);
}

#define	mask(s)	(1 << ((s)-1))
static
re_enable(signo,handler)
int (*handler)();
{
#if (os_4_2| os_4_3)
	sigsetmask(sigblock(0) &~ mask(signo));
#else
	signal(signo,handler);
#endif
}
EndOfFile
cat >  franz/vax/../io.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: io.c,v 1.11 85/03/24 11:03:19 sklower Exp $";
#endif

/*					-[Tue Nov 22 10:01:14 1983 by jkf]-
 * 	io.c				$Locker:  $
 * input output functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include <ctype.h>
#include "chars.h"
#include "chkrtab.h"

struct readtable {
unsigned char	ctable[132];
} initread = {
/*	^@ nul	^A soh	^B stx	^C etx	^D eot	^E eng	^F ack	^G bel  */
	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,
/*	^H bs	^I ht	^J nl	^K vt	^L np	^M cr	^N so	^O si	*/
	VCHAR,	VSEP,	VSEP,	VSEP,	VSEP,	VSEP,	VERR,	VERR,
/*	^P dle	^Q dc1	^R dc2	^S dc3	^T dc4	^U nak	^V syn	^W etb	*/
	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,	VERR,
/*	^X can	^Y em	^Z sub	^[ esc	^\ fs	^] gs	^^ rs	^_ us	*/
	VERR,	VERR,	VERR,	VSEP,	VERR,	VERR,	VERR,	VERR,
/*	sp	!	"	#	$	%	&	'	*/
	VSEP,	VCHAR,	VSD,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VSQ,
/*	(	)	*	+	,	-	.	/	*/
	VLPARA,	VRPARA,	VCHAR,	VSIGN,	VCHAR,	VSIGN,	VPERD,	VCHAR,
/*	0	1	2	3	4	5	6	7	*/
	VNUM,	VNUM,	VNUM,	VNUM,	VNUM,	VNUM,	VNUM,	VNUM,
/*	8	9	:	;	<	=	>	?	*/
	VNUM,	VNUM,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	@	A	B	C	D	E	F	G	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	H	I	J	K	L	M	N	O	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	P	Q	R	S	T	U	V	W	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	X	Y	Z	[	\	]	^	_	*/
	VCHAR,	VCHAR,	VCHAR,	VLBRCK,	VESC,	VRBRCK,	VCHAR,	VCHAR,
/*	`	a	b	c	d	e	f	g	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	h	i	j	k	l	m	n	o	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	p	q	r	s	t	u	v	w	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VCHAR,
/*	x	y	z	{	|	}	~	del	*/
	VCHAR,	VCHAR,	VCHAR,	VCHAR,	VDQ,	VCHAR,	VCHAR,	VERR,
/*	unused	Xsdc	Xesc	Xdqc					*/
	0,	'"',	'\\',	'|'
};

extern unsigned char *ctable;
lispval atomval;	/* external varaible containing atom returned
			   from internal atom reading routine */
lispval readrx(); lispval readr(); lispval readry();
char *atomtoolong();
int keywait;
int plevel = -1;	/* contains maximum list recursion count	*/
int plength = -1;   /* maximum number of list elements printed	*/
static int dbqflag;
static int mantisfl = 0;
extern int uctolc;
extern lispval	lastrtab;	/* external variable designating current reader
			   table */
static char baddot1[]=
"Bad reader construction: (. <something>)\nShould be (nil . <something>)\n";
static char baddot2[]=
"Bad reader construction: (<something> . <something> not followed by )";

/* readr ****************************************************************/
/* returns a s-expression read in from the port specified as the first	*/
/* argument.  Handles superbrackets, reader macros.			*/
lispval
readr(useport)
FILE *useport;
{
	register lispval handy = Vreadtable->a.clb;

	chkrtab(handy);
	rbktf = FALSE;
	rdrport = (FILE *) useport;
	if(useport==stdin)
		keywait = TRUE;	
	handy = readrx(Iratom());
	if(useport==stdin)
		keywait = FALSE;
	return(handy);

}


/* readrx **************************************************************/
/* returns a s-expression beginning with the syntax code of an atom	*/
/* passed in the first	*/
/* argument.  Does the actual work for readr, including list, dotted	*/
/* pair, and quoted atom detection					*/
lispval
readrx(code)
register int code;
{
	register lispval work;
	register lispval *current;
	register struct argent *result;
	int inlbkt = FALSE;
	lispval errorh();
	Savestack(4); /* ???not necessary because np explicitly restored if
	  changed */

top:
	switch(code)
	{
	case TLBKT:
		inlbkt = TRUE;
	case TLPARA:
		result = np;
		current = (lispval *)np;
		np++->val = nil; /*protect(nil);*/
		for(EVER) {
			switch(code = Iratom())
			{
			case TRPARA:
				if(rbktf && inlbkt)
					rbktf = FALSE;
				goto out;
			default:
				atomval = readrx(code);
			case TSCA:
				np++->val=atomval;
				*current = work = newdot();
				work->d.car = atomval;
				np--;
				current = (lispval *) &(work->d.cdr);
				break;
			case TINF:
				imacrox(result->val,TRUE);
				work = atomval;
				result->val = work->d.car;
				current = (lispval *) & (result->val);
				goto mcom;
			case TSPL:
				macrox(); /* input and output in atomval */
				*current = atomval;
			mcom:
				while(*current!=nil) {
					if(TYPE(*current)!=DTPR)
						errorh1(Vermisc,"Non-list returned from splicing macro",nil,FALSE,7,*current);
					current=(lispval *)&((*current)->d.cdr);
				}
				break;
			case TPERD:
				if(result->val==nil) {
					work = result->val=newdot();
					current = (lispval *) &(work->d.cdr);
					fprintf(stderr,baddot1);
				}
				work = readrx(TLPARA);
				if (work->d.cdr!=nil) {
					*current = work; work = newdot();
					work->d.cdr = *current; *current = nil;
					work->d.car = result->val;
					result->val = errorh1(Vermisc,baddot2,nil,TRUE,58,work);
					goto out;
				}
				*current = work->d.car;
				/* there is the possibility that the expression
				   following the dot is terminated with a "]"
				   and thus needs no closing lparens to follow
				*/
				if(rbktf && inlbkt)
					rbktf = FALSE;
				goto out;
			case TEOF:
				errorh1(Vermisc,"Premature end of file after ", 
							  nil,FALSE,0,result->val);
			}
			if(rbktf) {
				if(inlbkt)
					rbktf = FALSE;
				goto out;
			}
		}
	case TSCA:
		Restorestack();
		return(atomval);
	case TEOF:
		Restorestack();
		return(eofa);
	case TMAC:
		macrox();
		Restorestack();
		return(atomval);
	case TINF:
		imacrox(nil,FALSE);
		work = atomval;
		if(work==nil) { code = Iratom(); goto top;}
		work = work->d.car;
	        Restorestack();
		if(work->d.cdr==nil)
		    return(work->d.car);
		else
		    return(work);
	case TSPL:
		macrox();
		if((work = atomval)!=nil) {
			if(TYPE(work)==DTPR && work->d.cdr==nil) {
				Restorestack();
				return(work->d.car);
			} else {
				errorh1(Vermisc,
"Improper value returned from splicing macro at top-level",nil,FALSE,9,work);
			}
		}
		code = Iratom();
		goto top;
		/* return(readrx(Iratom())); */
	case TSQ:
		result = np;
		protect(newdot());
		(work = result->val)->d.car = quota;
		work = work->d.cdr = newdot();
		work->d.car = readrx(Iratom());
		goto out;

	case TRPARA:
		Restorestack();
		return(errorh(Vermisc,
		    "read: read a right paren when expecting an s-expression",
		    nil,FALSE,0));
	case TPERD:
		Restorestack();
		return(errorh(Vermisc,
		    "read: read a period when expecting an s-expression",
		    nil,FALSE,0));
		    
	/* should never get here, we should have covered all cases above */
	default:
		Restorestack();
		return(errorh1(Vermisc,"Readlist error,  code ",nil,FALSE,0,inewint((long)code)));
	}
out:
	work = result->val;
	np = result;
	Restorestack();
	return(work);
}
macrox()
{
    	FILE *svport;
	lispval handy, Lapply();

	Savestack(0);
	svport = rdrport;	/* save from possible changing */
	lbot = np;
	protect(handy=Iget(atomval,lastrtab));
	if (handy == nil)
	{
	    errorh1(Vermisc,"read: can't find the character macro for ",nil,
	    		FALSE,0,atomval);
	}
	protect(nil);
	atomval = Lapply();
	chkrtab(Vreadtable->a.clb);	/* the macro could have changed
					   the readtable
					 */
	rdrport = svport;	/* restore old value */
	Restorestack();
	return;
}
imacrox(current,inlist)
register lispval current;
{
    	FILE *svport;
	register lispval work;
	lispval Lapply(), handy;

	Savestack(2);
	svport = rdrport;	/* save from possible changing */
	if(inlist)
	{
	    protect(handy = newdot());
	    handy->d.car = current;
	    for(work = handy->d.car; (TYPE(work->d.cdr))==DTPR; )
	    	work = work->d.cdr;
            handy->d.cdr = work;
	}
	else handy = current;
	
	lbot = np;
	protect(Iget(atomval,lastrtab));
	protect(handy);
	atomval = Lfuncal();
	chkrtab(Vreadtable->a.clb);	/* the macro could have changed
					   the readtable
					 */
	rdrport = svport;	/* restore old value */
	Restorestack();
	return;
}



/* ratomr ***************************************************************/
/* this routine returns a pointer to an atom read in from the port given*/
/* by the first argument						*/
lispval
ratomr(useport)
register FILE	*useport;
{
	rdrport = useport;
	switch(Iratom())
	{
	case TEOF:
		return(eofa);
	case TSQ:
	case TRPARA:
	case TLPARA:
	case TLBKT:
	case TPERD:
		strbuf[1]=0;
		return(getatom(TRUE));
	default:
		return(atomval);
	}
}

#define push(); *name++ = c; if(name>=endstrb) name = atomtoolong(name);
#define next() (((cc=getc(useport))!=EOF)?(stats = ctable[c = cc &0177]):\
					((c=0),(saweof = 1),(stats = SEPMASK)))
Iratom()
{
	register FILE	*useport = rdrport;
	register char	c, marker, *name;
	extern lispval finatom(), calcnum(), getnum();
	int code, cc;
	int strflag = FALSE;

	name = strbuf;

again:	cc = getc(useport);
	if(cc==EOF)
	{
	    clearerr(useport);
	    return(TEOF);
	}
	c = cc & 0177;
	*name = c;

	switch(synclass(ctable[c])) {

	default:	goto again;

	case synclass(VNUM):

	case synclass(VSIGN):	*name++ = c;
			atomval = (getnum(name));
			return(TSCA);

	case synclass(VESC):
			dbqflag = TRUE;
			*name++ = getc(useport) & 0177;
			atomval = (finatom(name));
			return(TSCA);
			
	case synclass(VCHAR):
			if(uctolc && isupper(c)) c = tolower(c);
			*name++ = c;
			atomval = (finatom(name));
			return(TSCA);

	case synclass(VLPARA):	return(TLPARA);

	case synclass(VRPARA):	return(TRPARA);

	case synclass(VPERD):	marker = peekc(useport) & 0177;
			if(synclass(VNUM)!=synclass(ctable[marker]))
			{  if(SEPMASK & ctable[marker])
				return(TPERD);
			   else { *name++ = c;	/* this period begins an atm */
				  atomval = finatom(name);
				  return(TSCA);
			   }
			}
			*name++ = '.';
			mantisfl = 1;
			atomval = (getnum(name));
			return(TSCA);

	case synclass(VLBRCK):	return(TLBKT);

	case synclass(VRBRCK):	rbktf = TRUE;
			return(TRPARA);

	case synclass(VSQ):	return(TSQ);

	case synclass(VSD):	strflag = TRUE;
	case synclass(VDQ):	name = strbuf;
			marker = c;
			while ((c = getc(useport)) != marker) {

				if(synclass(VESC)==synclass(ctable[c]))
					c = getc(useport) & 0177;
				push();
				if (feof(useport)) {
					clearerr(useport);
					error("EOF encountered while reading atom", FALSE);
				}
			}
			*name = NULL_CHAR;
			if(strflag)
				atomval = (lispval) newstr(TRUE);
			else
				atomval = (getatom(TRUE));
			return(TSCA);

	case synclass(VERR):	if (c == '\0') 
			{
			  fprintf(stderr,"[read: null read and ignored]\n");
			  goto again;	/* null pname */
			}
			fprintf(stderr,"%c (%o): ",c,(int) c);
			error("ILLEGAL CHARACTER IN ATOM",TRUE);

	case synclass(VSINF):
		code = TINF;
		goto same;
	case synclass(VSSPL):
		code = TSPL;
		goto same;
	case synclass(VSMAC):
		code = TMAC;
	same:
		marker = peekc(rdrport);
		if(! (SEPMASK & ctable[marker]) ) {
		    *name++ = c;  /* this is not a macro */
		    atomval = (finatom(name));
		    return(TSCA);
		}
		goto simple;
	case synclass(VINF):
		code = TINF;
		goto simple;
	case synclass(VSCA):
		code = TSCA;
		goto simple;
	case synclass(VSPL):
		code = TSPL;
		goto simple;
	case synclass(VMAC):
		code = TMAC;
	simple:
		strbuf[0] = c;
		strbuf[1] = 0;
		atomval = (getatom(TRUE));
		return(code);
	}
}

lispval
getnum(name)
register char *name;
{
	unsigned char c;
	register lispval result;
	register FILE *useport=rdrport;
	unsigned char  stats;
	int sawdigit = 0, saweof = 0,cc;
	char *exploc = (char *) 0;
	double realno;
	extern lispval finatom(), calcnum(), newdoub(), dopow();

	if(mantisfl) {
		mantisfl = 0;
		next();
		goto mantissa;
	}
	if(VNUM==ctable[*(unsigned char*)(name-1)]) sawdigit = 1;
	while(VNUM==next()) {
		push();		/* recognize [0-9]*, in "ex" parlance */
		sawdigit = 1;
	}
	if(c=='.') {
		push();		/* continue */ 
	} else if(stats & SEPMASK) {
		if(!saweof)ungetc((int)c,useport);
		return(calcnum(strbuf,name,(int)ibase->a.clb->i));
	} else if(c=='^') {
		push();
		return(dopow(name,(int)ibase->a.clb->i));
	} else if(c=='_') {
		if(sawdigit)	/* _ must be preceeded by a digit */
		{
		    push();
		    return(dopow(name,2));
		}
		else goto backout;
	} else if(c=='e' || c=='E' || c=='d' ||c=='D') {
		if(sawdigit) goto expt;
		else goto backout;
	} else {
	backout:
		ungetc((int)c,useport);
		return(finatom(name));
	}
				/* at this point we have [0-9]*\. , which might
				   be a decimal int or the leading part of a
				   float				*/
	if(next()!=VNUM) {
		if(c=='e' || c=='E' || c=='d' ||c=='D')
			goto expt;
		else if(c=='^') {
			push();
			return(dopow(name,(int)ibase->a.clb->i));
		} else if(c=='_') {
			push();
			return(dopow(name,2));
		} else if( stats & SEPMASK) {
				/* Here we have 1.x where x is not number
				 * but is a separator 
				 * Here we have decimal int. NOT FORTRAN!
				 */
			if(!saweof)ungetc((int)c,useport);
			return(calcnum(strbuf,name-1,10));
		}
		else goto last;	 /* return a symbol */
	}
mantissa:
	do {
		push();
	} while (VNUM==next());
	
	/* Here we have [0-9]*\.[0-9]*
	 * three possibilities:
	 *   next character is e,E,d or D in which case we examine
	 *	the exponent [then we are faced with a similar
	 *	situation to this one: is the character after the
	 *	exponent a separator or not]
	 *   next character is a separator, in which case we have a
	 *      number (without an exponent)
	 *   next character is not a separator in which case we have
	 *      an atom (whose prefix just happens to look like a
	 *	number)
	 */
	if( (c == 'e') || (c == 'E') || (c == 'd') || (c == 'D')) goto expt;
	
	if(stats & SEPMASK) goto verylast;	/* a real number */
	else goto last;	/* prefix makes it look like a number, but it isn't */
	
expt:
	exploc = name;  /* remember location of exponent character */
	push();
	next();
	if(c=='+' || c =='-') {
		push();
		next();
	}
	while (VNUM==stats) {
		push();
		next();
	}

	/* if a separator follows then we have a number, else just
	 * an atom
	 */
	if (stats & SEPMASK) goto verylast;
	
last:	/* get here when what looks like a number turns out to be an atom */
	if(!saweof) ungetc((int)c,useport);
	return(finatom(name));

verylast:
	if(!saweof) ungetc((int)c,useport);
 	/* scanf requires that the exponent be 'e' */
	if(exploc != (char *) 0 ) *exploc = 'e';
	*name=0;
	sscanf(strbuf,"%F",&realno);
	(result = newdoub())->r = realno;
	return(result);
}

lispval
dopow(part2,base)
register char *part2;
{
	register char *name = part2;
	register FILE *useport = rdrport;
	register int power;
	lispval work;
	unsigned char stats,c;
	int cc, saweof = 0;
	char *end1 = part2 - 1; lispval Ltimes();
	Savestack(4);

	while(VNUM==next()) {
		push();
	}
	if(c!='.') {
		if(!saweof)ungetc((int)c,useport);
	}
	if(c!='.' && !(stats & SEPMASK)) {
		return(finatom(name));
	}
	lbot = np;
	np++->val = inewint(base);
	/* calculate "mantissa"*/
	if(*end1=='.')
		np++->val = calcnum(strbuf,end1-1,10);
	else
		np++->val = calcnum(strbuf,end1,(int)ibase->a.clb->i);

	/* calculate exponent */
	if(c=='.')
		power = calcnum(part2,name,10)->i;
	else
		power = calcnum(part2,name,(int)ibase->a.clb->i)->i;
	while(power-- > 0)
		lbot[1].val = Ltimes();
	work = lbot[1].val;
	Restorestack();
	return(work);
}
	

lispval
calcnum(strbuf,name,base)
register char *name;
char *strbuf;
{
	register char *p;
	register lispval result, temp;
	int negflag = 0;

	result = temp = newsdot();		/* initialize sdot cell */
	protect(temp);
	p = strbuf;
	if(*p=='+') p++;
	else if(*p=='-') {negflag = 1; p++;}
	*name = 0;
	if(p>=name) return(getatom(TRUE));

	for(;p < name; p++)
		dmlad(temp,(long)base,(long)*p-'0');
	if(negflag)
		dmlad(temp,-1L,0L);

	if(temp->s.CDR==0) {
		result = inewint(temp->i);
		pruneb(np[-1].val);
	}
	np--;
	return(result);
}
lispval
finatom(name)
register char *name;
{
	register FILE *useport = rdrport;
	unsigned char c, stats;
	int cc, saweof = 0;

	while(!(next()&SEPMASK)) {

		if(synclass(stats) == synclass(VESC)) {
			c = getc(useport) & 0177;
		} else {
			if(uctolc && isupper(c)) c = tolower(c);
		}
		push();
	}
	*name = NULL_CHAR;
	if(!saweof)ungetc((int)c,useport);
	return(getatom(TRUE));
}

char *
atomtoolong(copyto)
char *copyto;
{
    int size;
    register char *oldp = strbuf;
    register char *newp;
    lispval nveci();
    /*
     * the string buffer contains an string which is too long 
     * so we get a bigger buffer.
     */

    size =  (endstrb - strbuf)*4 + 28 ;
    newp = (char *) nveci(size);
    atom_buffer = (lispval) newp;
    strbuf = newp;
    endstrb = newp + size - 1;
    while(oldp < copyto) *newp++ = *oldp++;
	return(newp);
}
    
/* printr ***************************************************************/
/* prints the first argument onto the port specified by the second 	*/

/*
 * Last modified Mar 21, 1980 for hunks
 */

printr(a,useport)
register lispval a;
register FILE *useport;
{
	register hsize, i;
	char strflag = 0;
	char Idqc = 0;
	char *chstr;
	int curplength = plength;
	int quot;
	lispval Istsrch();
	lispval debugmode;

val_loop:
	if(! VALID(a)) {
	    debugmode = Istsrch(matom("debugging"))->d.cdr->d.cdr->d.cdr;
	    if(debugmode != nil) {
		printf("<printr:bad lisp data: 0x%x>\n",a);
 		error("Bad lisp data encountered by printr", FALSE); 
	    } else {
		a = badst;
		printf("<printr:bad lisp data: 0x%x>",a);
		return;
	    }
	}

	switch (TYPE(a))
	{


	case UNBO:	fputs("<UNBOUND>",useport);
			break;

	case VALUE:	fputs("(ptr to)",useport);
			a = a->l;
			goto val_loop;

	case INT:	fprintf(useport,"%d",a->i);
			break;

	case DOUB:	{  char buf[64];
			   lfltpr(buf,a->r);
			   fputs(buf,useport);
			}
			break;

	case PORT:	{ lispval  cp;
			  if((cp = ioname[PN(a->p)]) == nil)
			     fputs("%$unopenedport",useport);
			  else fprintf(useport,"%%%s",cp);
			}
			break;

	case HUNK2:
	case HUNK4:
	case HUNK8:
	case HUNK16:
	case HUNK32:
	case HUNK64:
	case HUNK128:
			if(plevel == 0) 
			{   
			     fputs("%",useport);
			     break;
			}
			hsize = 2 << HUNKSIZE(a);
			fputs("{", useport);
			plevel--;
			printr(a->h.hunk[0], useport);
			curplength--;
			for (i=1; i < hsize; i++)
			{
			    if (a->h.hunk[i] == hunkfree)
				break;
			    if (curplength-- == 0)
			    {
			    	fputs(" ...",useport); 
				break;
			    }
			    else
			    {
			        fputs(" ", useport);
				printr(a->h.hunk[i], useport);
			    }
			}
			fputs("}", useport);
			plevel++;
			break;
			
	case VECTOR:
			chstr = "vector";
			quot = 4; 	/* print out # of longwords */
			goto veccommon;

	case VECTORI:
			chstr = "vectori";
			quot = 1;
	   veccommon:
	   		/* print out 'vector' or 'vectori' except in
			 * these circumstances:
			 * property is a symbol, in which case print
			 *  the symbol's pname
			 * property is a list with a 'print' property,
			 *  in which case it is funcalled to print the
			 *  vector
			 */
		 	if(a->v.vector[VPropOff] != nil)
			{
			    if ((i=TYPE(a->v.vector[VPropOff])) == ATOM)
			    {
				chstr = a->v.vector[VPropOff]->a.pname;
			    }
			    else if ((i == DTPR) && vectorpr(a,useport))
			    {
				break;	/* printed by vectorpr */
			    }
			    else if ((i == DTPR)
			     	     && (a->v.vector[VPropOff]->d.car != nil)
			    	     && TYPE(a->v.vector[VPropOff]->d.car)
				         == ATOM)
			    {
				chstr = a->v.vector[VPropOff]->d.car->a.pname;
			    }
			}
			fprintf(useport,"%s[%d]",
			  	    chstr, a->vl.vectorl[VSizeOff]/quot);
			break;

	case ARRAY:	fputs("array[",useport);
			printr(a->ar.length,useport);
			fputs("]",useport);
			break;

	case BCD:	fprintf(useport,"#%X-",a->bcd.start);
			printr(a->bcd.discipline,useport);
			break;

	case OTHER:	fprintf(useport,"#Other-%X",a);
			break;

	case SDOT:	pbignum(a,useport);
			break;

	case DTPR:	if(plevel==0)
			{
			     fputs("&",useport);
			     break;
			}
			plevel--;
			if(a->d.car==quota && a->d.cdr!=nil 
			    && a->d.cdr->d.cdr==nil) {
				putc('\'',useport);
				printr(a->d.cdr->d.car,useport);
				plevel++;
				break;
			}
			putc('(',useport);
			curplength--;
	morelist:	printr(a->d.car,useport);
			if ((a = a->d.cdr) != nil)
				{
				if(curplength-- == 0)
				{
				    fputs(" ...",useport);
				    goto out;
				}
				putc(' ',useport);
				if (TYPE(a) == DTPR) goto morelist;
				fputs(". ",useport);
				printr(a,useport);
				}
		out:
			fputc(')',useport);
			plevel++;
			break;

	case STRNG:	strflag = TRUE;
			Idqc = Xsdc;

	case ATOM:	{
			char	*front, *temp, first; int clean;
			temp = front = (strflag ? ((char *) a) : a->a.pname);
			if(Idqc==0) Idqc = Xdqc;

			if(Idqc) {
				clean = first = *temp;
				first &= 0177;
				switch(QUTMASK & ctable[first]) {
				case QWNFRST:
				case QALWAYS:
					clean = 0; break;
				case QWNUNIQ:
					if(temp[1]==0) clean = 0;
				}
				if (first=='-'||first=='+') temp++;
				if(synclass(ctable[*temp])==VNUM) clean = 0;
				while (clean && *temp) {
					if((ctable[*temp]&QUTMASK)==QALWAYS)
						clean = 0;
					else if(uctolc && (isupper(*temp)))
					        clean = 0;
					temp++;
				}
				if (clean && !strflag)
					fputs(front,useport);
				else	 {
					putc(Idqc,useport);
					for(temp=front;*temp;temp++) {
						if(  *temp==Idqc
						  || (synclass(ctable[*temp])) == CESC)
							putc(Xesc,useport);
						putc(*temp,useport);
					}
					putc(Idqc,useport);
				}

			}  else {
				register char *cp = front;
				int handy = ctable[*cp & 0177];

				if(synclass(handy)==CNUM)
					putc(Xesc,useport);
				else switch(handy & QUTMASK) {
				case QWNUNIQ:
					if(cp[1]==0) putc(Xesc,useport);
					break;
				case QWNFRST:
				case QALWAYS:
					putc(Xesc,useport);
				}
				for(; *cp; cp++) {
					if((ctable[*cp]& QUTMASK)==QALWAYS)
						putc(Xesc,useport);
					putc(*cp,useport);
				}
			}
		}
	}
}

/* -- vectorpr
 * (perhaps) print out vector specially
 * this is called with a vector whose property list begins with
 * a list.  We search for the 'print' property and if it exists,
 * funcall the print function with two args: the vector and the port.
 * We return TRUE iff we funcalled the function, else we return FALSE
 * to have the standard printing done
 */

vectorpr(vec,port)
register lispval vec;
FILE *port;
{
    register lispval handy;
    int svplevel = plevel;	/* save these global values */
    int svplength = plength;
    Savestack(2);


    for ( handy = vec->v.vector[VPropOff]->d.cdr
          ; handy != nil; handy = handy->d.cdr->d.cdr)
    {
	if (handy->d.car == Vprintsym)
	{
	    lbot = np;
	    protect(handy->d.cdr->d.car);	/* function to call */
	    protect(vec);
	    protect(P(port));
	    Lfuncal();
	    plevel = svplevel;		/* restore globals */
	    plength = svplength;
	    Restorestack();
	    return(TRUE);	/* did the call */
	}
    }
    Restorestack();
    return(FALSE);	/* nothing printed */
}
	    
    
    



lfltpr(buf,val)		/* lisp floating point printer */
char *buf;
double val;
{
	register char *cp1; char *sprintf();

	sprintf(buf,(char *)Vfloatformat->a.clb,val);
	for(cp1 = buf; *cp1; cp1++)
		if(*cp1=='.'|| *cp1=='E' || *cp1 == 'e') return;

	/* if we are here, there was no dot, so the number was
	   an integer.  Furthermore, cp1 already points to the 
	   end of the string. */

	*cp1++ = '.';
	*cp1++ = '0';
	*cp1++ = 0;
}
	

/* dmpport ****************************************************************/
/* outputs buffer indicated by first argument whether full or not	*/

dmpport(useport)
FILE *useport;
{
	fflush(useport);
}

/*  protect and unprot moved to eval.c  (whr)  */
EndOfFile
cat >  franz/vax/../error.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: error.c,v 1.5 83/09/12 14:17:50 sklower Exp $";
#endif

/*					-[Sun Sep  4 09:06:21 1983 by jkf]-
 * 	error.c				$Locker:  $
 * error handler
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include "frame.h"
#include "catchfram.h"

static lispval	IEargs[5];
static int	IElimit;

/* error
 * this routine is always called on a non-fatal error.  The first argu-
 * ment is printed out.  The second a boolean flag indicating if the
 * error routine is permitted to return a pointer to a lisp value if
 * the "cont" command is executed.
 */
 
/* error from lisp C code, this temporarily replaces the old error
 * allowing us to interface with the new errset scheme with minimum
 * difficulty.  We assume that an error which comes to this routine
 * is of an "undefined error type" ER%misc .  Soon all calls to this
 * routine will be removed.
 *
 */

lispval
error(mesg,contvl)
char *mesg;
int contvl;
{
    lispval errorh();

    return(errorh(Vermisc,mesg,nil,contvl,0));
}


/* new error handler, works with errset 
 * 
 * call is errorh(type,message,valret,contuab) where
 * type is an atom which classifys the error, and whose clb, if not nil
 * is the name of a function to call to handle the error.
 * message is a character string to print to describe the error
 * valret is the value to return to an errset if one is found,
 * and contuab is non nil if this error is continuable.
 */
 

/* VARARGS5 */
static lispval
Ierrorh(type,message,valret,contuab,uniqid)
lispval type,valret;
int uniqid,contuab;
char *message;
{
 	register struct frame *curp, *uwpframe = (struct frame *)0; 
	register lispval handy;
	lispval *work = IEargs; 
	int limit = IElimit;
	int pass, curdepth;
	lispval Lread(), calhan();
	lispval contatm;
	lispval handy2;
	extern struct frame *errp;
	pbuf pb;
	Savestack(2);

	contatm = (contuab == TRUE ? tatom : nil);

	/* if there is a catch every error handler */
	if((handy = Verall->a.clb) != nil)	
	{
	    handy = Verall->a.clb;
	    Verall->a.clb = nil;		/* turn off before calling */
	    handy = calhan(limit,work,type,uniqid,contatm,message,handy);
	    if(contuab && (TYPE(handy) == DTPR))
		return(handy->d.car);
	}

	if((handy = type->a.clb) != nil)	/* if there is an error handler */
	{
	    handy = calhan(limit,work,type,uniqid,contatm,message,handy);
	    if(contuab && (TYPE(handy) == DTPR))
		return(handy->d.car);
	}

	pass = 1;
	/* search stack for error catcher */
  ps2:

	for (curp = errp ; curp != (struct frame *) 0 ; curp = curp->olderrp)
	{
	   if(curp->class == F_CATCH) 
	   {
		/* 
		 * interesting catch tags are ER%unwind-protect, generated
		 * by unwind-protect and ER%all, generated by errset
		 */
		if((pass == 1) && (curp->larg1 == Veruwpt))
		{
		    uwpframe = curp;
		    pass = 2;
		    goto ps2;
		}
		else if(curp->larg1 == Verall)
		{
		    /* 
		     * have found an errset to jump to. If there is an
		     * errset handler, first call that.
		     */
		    if((handy=Verrset->a.clb) != nil)
		    {
			calhan(limit,work,type,uniqid,contatm,message,handy);
		    }

		    /*
		     * if there is an unwind-protect then go to that first.
		     * The unwind protect will return to errorh after
		     * it has processed its cleanup forms.
		     * assert: if pass == 2 
		     *		then there is a pending unwind-protect
		     */
		     if(uwpframe != (struct frame *)0)
		     {
			/*
			 * generate form to return to unwind-protect 
			 */
			protect(handy2 = newdot());
			handy2->d.car = Veruwpt;
			handy = handy2->d.cdr = newdot();
			handy->d.car = nil;		/* indicates error */
			handy = handy->d.cdr = newdot();
			handy->d.car = type;
			handy = handy->d.cdr = newdot();
			handy->d.car = matom(message);
			handy = handy->d.cdr = newdot();
			handy->d.car = valret;
			handy = handy->d.cdr = newdot();
			handy->d.car = inewint(uniqid);
			handy = handy->d.cdr = newdot();
			handy->d.car = inewint(contuab);
			while (limit-- > 0)	/* put in optional args */
			{  handy = handy->d.cdr = newdot();
			   handy->d.car = *work++;
			}
			lispretval = handy2;		/* return this as value */
			retval = C_THROW;
			Iretfromfr(uwpframe);
			/* NOTREACHED */
		    }
		    /*
		     * Will return to errset
		     * print message if flag on this frame is non nil
		     */
		    if(curp->larg2 != nil)
		    {
			printf("%s  ",message);
			while(limit-->0) {
			    printr(*work++,stdout);
			    fflush(stdout);
			}
			fputc('\n',stdout);
			fflush(stdout);
		    }

		    lispretval = valret;
		    retval = C_THROW;		/* looks like a throw */
		    Iretfromfr(curp);
		}
	    }
	}
	    
	/* no one will catch this error, we must see if there is an
	   error-goes-to-top-level catcher */
	
	if (Vertpl->a.clb != nil)
	{
	    
	    handy = calhan(limit,work,type,uniqid,contatm,message,Vertpl->a.clb);
	    if( contuab  && (TYPE(handy) == DTPR))
		   return(handy->d.car);
	}

	/* at this point, print error message and break, just like
	   the current error scheme */
	printf("%s ",message);
	while(limit-->0) {
		printr(*work++,stdout);
		fflush(stdout);
	}


	/* If automatic-reset is set
	 * we will now jump to top level, calling the reset function
	 * if it exists, or using the c rest function if it does not 
	 */

	if(Sautor)
	{
		if ((handy = reseta->a.fnbnd) != nil)
		{
			lispval Lapply();
			lbot = np;
			protect(reseta);
			protect(nil);
			Lapply();
		}
		Inonlocalgo(C_RESET,inewint(0),nil);
		/* NOTREACHED */
	}
	
	/*
	 * no one wants the error.  We set up another read-eval-print
	 * loop. The user can get out of this error by typing (return 'val)
	 * if the error is continuable.  Normally this code be replaced
	 * by more clever lisp code, when the full lisp is built
	 */

	errp = Pushframe(F_PROG,nil,nil);

	if(TYPE(Verdepth->a.clb) != INT)
	{
		curdepth = 1;
	}
	else curdepth = 1 + Verdepth->a.clb->i;
	PUSHDOWN(Verdepth,inewint(curdepth));

	switch(retval) {
	case C_RET:	/* 
			 * attempt to return from error
			 */
			if(!contuab) error("Can't continue from this error",
						  FALSE);
			popnames(errp->svbnp);
			errp = Popframe();
			Restorestack();
			return(lispretval);

	case C_GO:	/*
			 * this may look like a valid prog, but it really
			 * isn't, since go's are not allowed.  Let the
			 * user know.
			 */
			error("Can't 'go' through an error break",FALSE);
			/* NOT REACHED */

	case C_INITIAL: /*
			  * normal case, just fall through into read-eval-print
			  * loop
			  */
			break;
	}
	lbot = np;
	protect(P(stdin));
	protect(eofa);

	while(TRUE) {
		
		fprintf(stdout,"\n%d:>",curdepth);
		dmpport(stdout);
		vtemp = Lread();
		if(vtemp == eofa) franzexit(0);
		printr(eval(vtemp),stdout);
	}
	/* NOTREACHED */
}

lispval
errorh(type,message,valret,contuab,uniqid)
lispval type,valret;
int uniqid,contuab;
char *message;
{
	IElimit = 0;
	Ierrorh(type,message,valret,contuab,uniqid);
	/* NOTREACHED */
}

lispval
errorh1(type,message,valret,contuab,uniqid,arg1)
lispval type,valret,arg1;
int uniqid,contuab;
char *message;
{
	IElimit = 1;
	IEargs[0] = arg1;
	Ierrorh(type,message,valret,contuab,uniqid);
	/* NOTREACHED */
}

lispval
errorh2(type,message,valret,contuab,uniqid,arg1,arg2)
lispval type,valret,arg1,arg2;
int uniqid,contuab;
char *message;
{
	IElimit = 2;
	IEargs[0] = arg1;
	IEargs[1] = arg2;
	Ierrorh(type,message,valret,contuab,uniqid);
	/* NOTREACHED */
}

lispval
calhan(limit,work,type,uniqid,contuab,message,handler)
register lispval *work;
lispval handler,type,contuab;
register limit;
register char *message;
int uniqid;
{
	    register lispval handy;
	    Savestack(4);
	    lbot = np;
	    protect(handler);		/* funcall the handler */
	    protect(handy = newdot());		/* with a list consisting of */
	    handy->d.car = type;			/* type, */
	    handy = (handy->d.cdr = newdot());
	    handy->d.car = inewint(uniqid);	/* identifying number, */
	    handy = (handy->d.cdr = newdot());
	    handy->d.car = contuab;
	    handy = (handy->d.cdr = newdot());
	    handy->d.car = matom(message);	/* message to be typed out, */
	    while(limit-- > 0)
	    {					/* any other args. */
		    handy = handy->d.cdr = newdot();
		    handy->d.car = *work++;
	    }
	    handy->d.cdr = nil;

	    handy = Lfuncal();
	    Restorestack();
	    return(handy);
}

/* lispend **************************************************************/
/* Fatal errors come here, with their epitaph.				*/
lispend(mesg)
	char	mesg[];
	{
	dmpport(poport);
	fprintf(errport,"%s\n",mesg);
	dmpport(errport);
	franzexit(0);
	/* NOT REACHED */
	}

/* namerr ***************************************************************/
/* handles namestack overflow, at present by simply giving a message	*/

namerr()
{
	if((nplim = np + NAMINC) > orgnp + NAMESIZE) 
	{  
	  printf("Unrecoverable Namestack Overflow, (reset) is forced\n");
	  fflush(stdout);
	  nplim = orgnp + NAMESIZE - 4*NAMINC;
	  lbot = np = nplim - NAMINC;
	  protect(matom("reset"));
	  Lfuncal();
	}
	error("NAMESTACK OVERFLOW",FALSE);
	/* NOT REACHED */
}

binderr()
{
	bnp -= 10;
	error("Bindstack overflow.",FALSE);
	/* NOT REACHED */
}

rtaberr()
{
	bindfix(Vreadtable,strtab,nil);
	error("Illegal read table.",FALSE);
	/* NOT REACHED */
}
xserr()
{
	error("Ran out of alternate stack",FALSE);
}
badmem(n)
{
	char errbuf[256], *sprintf();

	sprintf(errbuf,"Attempt to allocate beyond static structures (%d).",n);
	error(errbuf,FALSE);
	/* NOT REACHED */
}
argerr(msg)
char *msg;
{
	errorh1(Vermisc,"incorrect number of args to",
				  nil,FALSE,0,matom(msg));
	/* NOT REACHED */
}

lispval Vinterrfcn = nil;

/*
 * wnaerr - wrong number of arguments to a compiled function hander
 * called with the function name (symbol) and a descriptor of the
 * number of arguments that were expected.  The form of the descriptor
 * is (considered as a decimal number) xxyy where xx is the minumum
 * and yy-1 is the maximum.  A maximum of -1 means that there is no
 * maximum.
 *
 */
wnaerr(fcn,wantargs)
lispval fcn;
{
    if (Vinterrfcn == nil)
    {
	Vinterrfcn = matom("int:wrong-number-of-args-error");
    }
    if (Vinterrfcn->a.fnbnd != nil)
    {
	protect(fcn);
	protect(inewint(wantargs / 1000));	  /* min */
	protect(inewint((wantargs % 1000) - 1));  /* max */
	Ifuncal(Vinterrfcn);
	error("wrong number of args function should never return ", FALSE);
    }

    errorh1(Vermisc,"wrong number of arguments to ",nil,FALSE,0,fcn);
}

	
    
EndOfFile
cat >  franz/vax/../sysat.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: sysat.c,v 1.20 85/03/13 17:19:21 sklower Exp $";
#endif

/*					-[Thu Sep 29 14:05:32 1983 by jkf]-
 * 	sysat.c				$Locker:  $
 * startup data structure creation
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "lfuncs.h"
#define FIDDLE(z,b,c,y) z->a.clb=newdot(); (z->a.clb->d.car=newint())->i=b->i; \
	z->a.clb->d.cdr=newdot(); (z->a.clb->d.cdr->d.car=newint())->i=c->i; \
	z->a.clb->d.cdr->d.cdr=newdot(); (z->a.clb->d.cdr->d.cdr->d.car=newint())->i=y; \
	b = z->a.clb->d.car; c = z->a.clb->d.cdr->d.car; \
	copval(z,z->a.clb); z->a.clb = nil;

#define cforget(x) protect(x); Lforget(); unprot();

/*  The following array serves as the temporary counters of the items	*/
/*  and pages used in each space.					*/

long int tint[2*NUMSPACES];

extern int tgcthresh; 
extern int initflag; 	/*  starts off TRUE to indicate unsafe to gc  */

extern int *beginsweep;	/* place for garbage collector to begin sweeping */
extern int page_limit;  /* begin warning messages about running out of space */
extern char purepage[]; /* which pages should not be swept by gc */
extern int ttsize;	/* need to know how much of pagetable to set to other */

extern lispval Iaddstat(), Isstatus();
lispval inewatom();

makevals()
	{
	int i;
	lispval temp;

	/*  system list structure and atoms are initialized.  */

	/*  Before any lisp data can be created, the space usage */
	/*  counters must be set up, temporarily in array tint.  */

	atom_items = (lispval) &tint[0];
	atom_pages = (lispval) &tint[1];
	str_items = (lispval) &tint[2];
	str_pages = (lispval) &tint[3];
	int_items = (lispval) &tint[4];
	int_pages = (lispval) &tint[5];
	dtpr_items = (lispval) &tint[6];
	dtpr_pages = (lispval) &tint[7];
	doub_items = (lispval) &tint[8];
	doub_pages = (lispval) &tint[9];
	sdot_items = (lispval) &tint[10];
	sdot_pages = (lispval) &tint[11];
	array_items = (lispval) &tint[12];
	array_pages = (lispval) &tint[13];
	val_items = (lispval) &tint[14];
	val_pages = (lispval) &tint[15];
	funct_items = (lispval) &tint[16];
	funct_pages = (lispval) &tint[17];

	for (i=0; i < 7; i++)
	{
		hunk_pages[i] = (lispval) &tint[18+i*2];
		hunk_items[i] = (lispval) &tint[19+i*2];
	}

	vect_items = (lispval) &tint[34];
	vecti_items = (lispval) &tint[35];
	vect_pages = (lispval) &tint[36];
	vecti_pages = (lispval) &tint[37];
	other_items = (lispval) &tint[38];
	other_pages = (lispval) &tint[39];
	
	/*  This also applies to the garbage collection threshhold  */

	gcthresh = (lispval) &tgcthresh;

	/*  Now we commence constructing system lisp structures.  */

	/*  nil is a special case, constructed especially at location zero  */

	hasht[hashfcn("nil")] = (struct atom *)nil;


	/* allocate space for namestack and bindstack first
	 * then set up beginsweep variable so that the sweeper will
	 * ignore these `always in use' pages
	 */

	lbot = orgnp = np = ((struct argent *)csegment(VALUE,NAMESIZE,FALSE));
	orgbnp = bnp = ((struct nament *)csegment(DTPR,NAMESIZE,FALSE));
	/* since these dtpr pages will not be swept, we don't want them
	 * to show up in count of dtpr pages allocated or it will confuse
	 * gcafter when it tries to determine how much space is free
	 */
	dtpr_pages->i = 0;
	beginsweep = (int *) xsbrk(0);

	/*
	 *  patching up info in type and pure tables
	 */
#if unisys3botch
	/*
	 * This code is in here because Schriebman made Romberger tend
	 * more important things for too long for Apple and Fateman to
	 * wait
	 */
	{extern int dmpmode; int jj = ATOX(beginsweep);
	dmpmode = 407; for(i=19;i < jj; i++) typetable[i] = 0; }
#endif
	for(i=ATOX(beginsweep); i < ttsize; i++) (typetable+1)[i] = OTHER;
	purepage[ATOX(np)] = 1;  /* Mark these as non-gc'd arrays */
	purepage[ATOX(bnp)] = 1;

	/*
	 * Names of various spaces and things
	 */

	atom_name = inewatom("symbol");
	str_name = inewatom("string");
	int_name = inewatom("fixnum");
	dtpr_name = inewatom("list");
	doub_name = inewatom("flonum");
	sdot_name = inewatom("bignum");
	array_name = inewatom("array");
	val_name = inewatom("value");
	funct_name = inewatom("binary");
	port_name = inewatom("port");		/* not really a space */
	vect_name = inewatom("vector");
	vecti_name = inewatom("vectori");
	other_name = inewatom("other");

	{
	    char name[6], *strcpy();

	    strcpy(name, "hunk0");
	    for (i=0; i< 7; i++) {
		hunk_name[i] = matom(name);
		name[4]++;
	    }
	}
	
	/*  set up the name stack as an array of pointers */
	nplim = orgnp+NAMESIZE-6*NAMINC;
	temp = inewatom("namestack");
	nstack = temp->a.fnbnd = newarray();
	nstack->ar.data = (char *) (np);
	(nstack->ar.length = newint())->i = NAMESIZE;
	(nstack->ar.delta = newint())->i = sizeof(struct argent);
	Vnogbar = inewatom("unmarked_array");
	/* marking of the namestack will be done explicitly in gc1 */
	(nstack->ar.aux = newdot())->d.car = Vnogbar; 
						

	/* set up the binding stack as an array of dotted pairs */

	bnplim = orgbnp+NAMESIZE-5;
	temp = inewatom("bindstack");
	bstack = temp->a.fnbnd = newarray();
	bstack->ar.data = (char *) (bnp);
	(bstack->ar.length = newint())->i = NAMESIZE;
	(bstack->ar.delta = newint())->i = sizeof(struct nament);
	/* marking of the bindstack will be done explicitly in gc1 */
	(bstack->ar.aux = newdot())->d.car = Vnogbar; 

	/* more atoms */

	tatom = inewatom("t");
	tatom->a.clb = tatom;
	lambda = inewatom("lambda");
	nlambda = inewatom("nlambda");
	cara = inewatom("car");
	cdra = inewatom("cdr");
	Veval = inewatom("eval");
	quota = inewatom("quote");
	reseta = inewatom("reset");
	gcafter = inewatom("gcafter");	/* garbage collection wind-up */
	macro = inewatom("macro");
	ibase = inewatom("ibase");		/* base for input conversion */
	ibase->a.clb = inewint(10);
	(inewatom("base"))->a.clb = ibase->a.clb;
	fclosure = inewatom("fclosure");
	clos_marker = inewatom("int:closure-marker");
	Vpbv = inewatom("value-structure-argument");
	rsetatom = inewatom("*rset");
	rsetatom->a.clb = nil;
	Vsubrou = inewatom("subroutine");
	Vpiport = inewatom("piport");
	Vpiport->a.clb = P(piport = stdin);	/* standard input */
	Vpoport = inewatom("poport");
	Vpoport->a.clb = P(poport = stdout);	/* stand. output */
	inewatom("errport")->a.clb = (P(errport = stderr));/* stand. err. */
	ioname[PN(stdin)]  = (lispval) pinewstr("$stdin");
	ioname[PN(stdout)] = (lispval) pinewstr("$stdout");
	ioname[PN(stderr)] = (lispval) pinewstr("$stderr");
	inewatom("Standard-Input")->a.clb = Vpiport->a.clb;
	inewatom("Standard-Output")->a.clb = Vpoport->a.clb;
	inewatom("Standard-Error")->a.clb = P(errport);
	(Vreadtable = inewatom("readtable"))->a.clb  = Imkrtab(0);
	strtab = Imkrtab(0);
	Vptport = inewatom("ptport");
	Vptport->a.clb = nil;				/* protocal port */

	Vcntlw = inewatom("^w");	/* when non nil, inhibits output to term */
	Vcntlw->a.clb = nil;

	Vldprt = inewatom("$ldprint");	
			/* when nil, inhibits printing of fasl/autoload   */
						/* cfasl messages to term */
	Vldprt->a.clb = tatom;

	Vprinlevel = inewatom("prinlevel");	/* printer recursion count */
	Vprinlevel->a.clb = nil;		/* infinite recursion */

	Vprinlength = inewatom("prinlength");	/* printer element count */
	Vprinlength->a.clb = nil;		/* infinite elements */

	Vfloatformat = inewatom("float-format");
	Vfloatformat->a.clb = (lispval) pinewstr("%.16g");

	Verdepth = inewatom("Error-Depth");
	Verdepth->a.clb = inewint(0);		/* depth of error */

	Vpurcopylits = inewatom("$purcopylits");
	Vpurcopylits->a.clb = tatom;		/* tells fasl to purcopy
						 *  literals it reads
						 */
	Vdisplacemacros = inewatom("displace-macros");
        Vdisplacemacros->a.clb = nil;		/* replace macros calls
						 * with their expanded forms
						 */

	Vprintsym = inewatom("print");
	
	atom_buffer = (lispval) strbuf;
	Vlibdir = inewatom("lisp-library-directory");
	Vlibdir->a.clb = inewatom("/usr/lib/lisp");
	/*  The following atoms are used as tokens by the reader  */

	perda = inewatom(".");
	lpara = inewatom("(");
	rpara = inewatom(")");
	lbkta = inewatom("[");
	rbkta = inewatom("]");
	snqta = inewatom("'");
	exclpa = inewatom("!");


	(Eofa = inewatom("eof"))->a.clb = eofa;

	/*  The following few atoms have values the reader tokens.  */
	/*  Perhaps this is a kludge which should be abandoned.  */
	/*  On the other hand, perhaps it is an inspiration.	*/

	inewatom("perd")->a.clb = perda;
	inewatom("lpar")->a.clb = lpara;
	inewatom("rpar")->a.clb = rpara;
	inewatom("lbkt")->a.clb = lbkta;
	inewatom("rbkt")->a.clb = rbkta;

	noptop = inewatom("noptop");

	/*  atoms used in connection with comments.  */

	commta = inewatom("comment");
	rcomms = inewatom("readcomments");

	/*  the following atoms are used for lexprs */

	lexpr_atom = inewatom("last lexpr binding\7");
	lexpr = inewatom("lexpr");

	/* the following atom is used to reference the bind stack for eval */
	bptr_atom = inewatom("eval1 binding pointer\7");
	bptr_atom->a.clb = nil;

	/* the following atoms are used for evalhook hackery */
	evalhatom = inewatom("evalhook");
	evalhatom->a.clb = nil;
	evalhcallsw = FALSE;

	funhatom = inewatom("funcallhook");
	funhatom->a.clb = nil;
	funhcallsw = FALSE;

	Vevalframe = inewatom("evalframe");

	sysa = inewatom("sys");
	plima = inewatom("pagelimit");	/*  max number of pages  */


	startup = inewatom("startup");	/*  used by save and restore  */
	sysa = inewatom("sys");	/*  sys indicator for system variables  */
	splice = inewatom("splicing");


	
	/* vector stuff */

	odform = inewatom("odformat");	/* format for printf's used in od */
	rdrsdot = newsdot();		/* used in io conversions of bignums */
	rdrsdot2 = newsdot();		/* used in io conversions of bignums */
	rdrint = newint();		/* used as a temporary integer */
	(nilplist = newdot())->d.cdr = newdot();
					/* used as property list for nil,
					   since nil will eventually be put at
					   0 (consequently in text and not
					   writable) */

	/* error variables */
	(Vererr = inewatom("ER%err"))->a.clb = nil;
	(Vertpl = inewatom("ER%tpl"))->a.clb = nil;
	(Verall = inewatom("ER%all"))->a.clb = nil;
	(Vermisc = inewatom("ER%misc"))->a.clb = nil;
	(Verbrk = inewatom("ER%brk"))->a.clb = nil;
	(Verundef = inewatom("ER%undef"))->a.clb = nil;
	(Vlerall = newdot())->d.car = Verall;	/* list (ER%all) */
	(Veruwpt = inewatom("ER%unwind-protect"))->a.clb = nil;
	(Verrset = inewatom("errset"))->a.clb = nil;


	/* set up the initial status list */

	stlist = nil;			/* initially nil */
	{
	    lispval feature, dom;
	    Iaddstat(inewatom("features"),ST_READ,ST_NO,nil);
	    Iaddstat(feature = inewatom("feature"),ST_FEATR,ST_FEATW,nil);
	    Isstatus(feature,inewatom("franz"));
	    Isstatus(feature,inewatom("Franz"));
	    Isstatus(feature,inewatom(OS));
	    Isstatus(feature,inewatom("string"));
	    Isstatus(feature,dom = inewatom(DOMAIN));
	    Iaddstat(inewatom("domain"),ST_READ,ST_NO,dom);
	    Isstatus(feature,inewatom(MACHINE));
#ifdef PORTABLE
	    Isstatus(feature,inewatom("portable"));
#endif
#ifdef unisoft
	    Isstatus(feature,inewatom("unisoft"));
#endif
#ifdef sun
	    Isstatus(feature,inewatom("sun"));
#endif
#ifdef os_masscomp
	    Isstatus(feature,inewatom("mc500"));
#endif
#if os_4_1c | os_4_2 | os_4_3
	    Isstatus(feature,inewatom("long-filenames"));
#endif
	}
	Iaddstat(inewatom("nofeature"),ST_NFETR,ST_NFETW,nil);
	Iaddstat(inewatom("syntax"),ST_SYNT,ST_NO,nil);
	Iaddstat(inewatom("uctolc"),ST_READ,ST_TOLC,nil);
	Iaddstat(inewatom("dumpcore"),ST_READ,ST_CORE,nil);
	Isstatus(inewatom("dumpcore"),nil);	/*set up signals*/

	Iaddstat(inewatom("chainatom"),ST_RINTB,ST_INTB,inewint(0));
	Iaddstat(inewatom("dumpmode"),ST_DMPR,ST_DMPW,nil);
	Iaddstat(inewatom("appendmap"),ST_READ,ST_SET,nil);  /* used by fasl */
	Iaddstat(inewatom("debugging"),ST_READ,ST_SET,nil);  
	Iaddstat(inewatom("evalhook"),ST_RINTB,ST_INTB,inewint(3));
	Isstatus(inewatom("evalhook"),nil); /*evalhook switch off */
	Iaddstat(inewatom("bcdtrace"),ST_READ,ST_BCDTR,nil);
	Iaddstat(inewatom("ctime"),ST_CTIM,ST_NO,nil);
	Iaddstat(inewatom("localtime"),ST_LOCT,ST_NO,nil);
	Iaddstat(inewatom("isatty"),ST_ISTTY,ST_NO,nil);
	Iaddstat(inewatom("ignoreeof"),ST_READ,ST_SET,nil);
	Iaddstat(inewatom("version"),ST_READ,ST_NO,mstr("Franz Lisp, Opus 38"));
	Iaddstat(inewatom("automatic-reset"),ST_READ,ST_AUTR,nil);
	Iaddstat(inewatom("translink"),ST_READ,ST_TRAN,nil);
	Isstatus(inewatom("translink"),nil);		/* turn off tran links */
	Iaddstat(inewatom("undeffunc"),ST_UNDEF,ST_NO,nil); /* list undef funcs */
	Iaddstat(inewatom("gcstrings"),ST_READ,ST_GCSTR,nil); /* gc strings */

	/* garbage collector things */

	gcport = inewatom("gcport");	/* port for gc dumping */
	gccheck = inewatom("gccheck");	/* flag for checking during gc */
	gcdis = inewatom("gcdisable");	/* variable for disabling the gc */
	gcdis->a.clb = nil;
	gcload = inewatom("gcload");	/* option for gc while loading */
	loading = inewatom("loading");	/* flag--in loader if = t  */
	noautot = inewatom("noautotrace");	/* option to inhibit auto-trace */
	Vgcprint = inewatom("$gcprint");	/* if t then pring gc messages */
	Vgcprint->a.clb = nil;
	
	(gcthresh = newint())->i = tgcthresh;
	gccall1 = newdot();  gccall2 = newdot();  /* used to call gcafter */
	gccall1->d.car = gcafter;  /* start constructing a form for eval */

	arrayst = mstr("ARRAY");	/* array marker in name stack */
	bcdst = mstr("BINARY");		/* binary function marker */
	listst = mstr("INTERPRETED");	/* interpreted function marker */
	macrost = mstr("MACRO");	/* macro marker */
	protst = mstr("PROTECTED");	/* protection marker */
	badst = mstr("BADPTR");		/* bad pointer marker */
	argst = mstr("ARGST");		/* argument marker */
	hunkfree = mstr("EMPTY");	/* empty hunk cell value */

	/* type names */

	FIDDLE(atom_name,atom_items,atom_pages,ATOMSPP);
	FIDDLE(str_name,str_items,str_pages,STRSPP);
	FIDDLE(other_name,other_items,other_pages,STRSPP);
	FIDDLE(int_name,int_items,int_pages,INTSPP);
	FIDDLE(dtpr_name,dtpr_items,dtpr_pages,DTPRSPP);
	FIDDLE(doub_name,doub_items,doub_pages,DOUBSPP);
	FIDDLE(sdot_name,sdot_items,sdot_pages,SDOTSPP);
	FIDDLE(array_name,array_items,array_pages,ARRAYSPP);
	FIDDLE(val_name,val_items,val_pages,VALSPP);
	FIDDLE(funct_name,funct_items,funct_pages,BCDSPP);

	FIDDLE(hunk_name[0], hunk_items[0], hunk_pages[0], HUNK2SPP);
	FIDDLE(hunk_name[1], hunk_items[1], hunk_pages[1], HUNK4SPP);
	FIDDLE(hunk_name[2], hunk_items[2], hunk_pages[2], HUNK8SPP);
	FIDDLE(hunk_name[3], hunk_items[3], hunk_pages[3], HUNK16SPP);
	FIDDLE(hunk_name[4], hunk_items[4], hunk_pages[4], HUNK32SPP);
	FIDDLE(hunk_name[5], hunk_items[5], hunk_pages[5], HUNK64SPP);
	FIDDLE(hunk_name[6], hunk_items[6], hunk_pages[6], HUNK128SPP);
	
	FIDDLE(vect_name, vect_items, vect_pages, VECTORSPP)
	FIDDLE(vecti_name, vecti_items, vecti_pages, VECTORSPP)

	(plimit = newint())->i = page_limit;
	copval(plima,plimit);  /*  default value  */

	/* the following atom is used when reading caar, cdar, etc. */

	xatom = inewatom("??");
	dofuns();
#if sun_4_1c ||sun_4_2 || sun_4_2beta
	hookupcore();
#endif
	/*  now it is OK to collect garbage  */

	initflag = FALSE;
	}

/*  matom("name")  ******************************************************/
/*									*/
/*  simulates an atom being read in from the reader and returns a	*/
/*  pointer to it.							*/
/*									*/
/*  BEWARE:  if an atom becomes "truly worthless" and is collected,	*/
/*  the pointer becomes obsolete.					*/
/*									*/
lispval
matom(string)
char *string;
	{
	strbuf[0] = 0;
	strncat(strbuf,string,STRBLEN-1); /* strcpyn always pads to n */
	strbuf[STRBLEN-1] = 0;
	return(getatom(TRUE));
	}

/*  mstr  ***************************************************************/
/*									*/
/*  Makes a string.  Uses matom.					*/
/*  Not the most efficient but will do until the string from the code	*/
/*  itself can be used as a lispval.					*/

lispval mstr(string) char *string;
	{
	return((lispval)(pinewstr(string)));
	}

/*  mfun("name",start)  *************************************************/
/*									*/
/*  Same as matom, but entry point to c code is associated with		*/
/*  "name" as function binding.						*/
/*  A pointer to the atom is returned.					*/
/*									*/
lispval mfun(string,start,discip) char *string; lispval (*start)(), discip;
	{
	lispval v;
	v = inewatom(string);
	v->a.fnbnd = newfunct();
	v->a.fnbnd->bcd.start = start;
	v->a.fnbnd->bcd.discipline = discip;
	return(v);
	}

struct ftab {
	char *string;
	lispval (*start)();
	lispval *discip;
};

lispval
mftab(table)
register struct ftab *table;
{
	register lispval v;
	for(;table->string;table++) {
		v = inewatom(table->string);
		v = v->a.fnbnd = newfunct();
		v->bcd.start = table->start;
		v->bcd.discipline = *table->discip;
	}
}

static struct ftab cfuns[] = {
  {"car", Lcar, &(lambda)},
  {"cdr", Lcdr, &(lambda)},
  {"eval", Leval1, &(lambda)},
  {"asin", Lasin, &(lambda)},
  {"acos", Lacos, &(lambda)},
  {"atan", Latan, &(lambda)},
  {"cos", Lcos, &(lambda)},
  {"sin", Lsin, &(lambda)},
  {"sqrt", Lsqrt, &(lambda)},
  {"exp", Lexp, &(lambda)},
  {"log", Llog, &(lambda)},
  {"lsh", Llsh, &(lambda)},
  {"bignum-leftshift", Lbiglsh, &(lambda)},
  {"sticky-bignum-leftshift", Lsbiglsh, &(lambda)},
  {"frexp", Lfrexp, &(lambda)},
  {"rot", Lrot, &(lambda)},
  {"random", Lrandom, &(lambda)},
  {"atom", Latom, &(lambda)},
  {"apply", Lapply, &(lambda)},
  {"funcall", Lfuncal, &(lambda)},
  {"lexpr-funcall", Llexfun, &(lambda)},
  {"return", Lreturn, &(lambda)},
/* 	MK("cont",Lreturn,lambda),  */
  {"cons", Lcons, &(lambda)},
  {"scons", Lscons, &(lambda)},
  {"bignum-to-list", Lbigtol, &(lambda)},
  {"cadr", Lcadr, &(lambda)},
  {"caar", Lcaar, &(lambda)},
  {"cddr", Lc02r, &(lambda)},
  {"caddr", Lc12r, &(lambda)},
  {"cdddr", Lc03r, &(lambda)},
  {"cadddr", Lc13r, &(lambda)},
  {"cddddr", Lc04r, &(lambda)},
  {"caddddr", Lc14r, &(lambda)},
  {"nthelem", Lnthelem, &(lambda)},
  {"eq", Leq, &(lambda)},
  {"equal", Lequal, &(lambda)},
/**	MK("zqual",Zequal,lambda), 	*/
  {"numberp", Lnumberp, &(lambda)},
  {"dtpr", Ldtpr, &(lambda)},
  {"bcdp", Lbcdp, &(lambda)},
  {"portp", Lportp, &(lambda)},
  {"arrayp", Larrayp, &(lambda)},
  {"valuep", Lvaluep, &(lambda)},
  {"get_pname", Lpname, &(lambda)},
  {"ptr", Lptr, &(lambda)},
  {"arrayref", Larayref, &(lambda)},
  {"marray", Lmarray, &(lambda)},
  {"getlength", Lgetl, &(lambda)},
  {"putlength", Lputl, &(lambda)},
  {"getaccess", Lgeta, &(lambda)},
  {"putaccess", Lputa, &(lambda)},
  {"getdelta", Lgetdel, &(lambda)},
  {"putdelta", Lputdel, &(lambda)},
  {"getaux", Lgetaux, &(lambda)},
  {"putaux", Lputaux, &(lambda)},
  {"getdata", Lgetdata, &(lambda)},
  {"putdata", Lputdata, &(lambda)},
  {"mfunction", Lmfunction, &(lambda)},
  {"getentry", Lgtentry, &(lambda)},
  {"getdisc", Lgetdisc, &(lambda)},
  {"putdisc", Lputdisc, &(lambda)},
  {"segment", Lsegment, &(lambda)},
  {"rplaca", Lrplca, &(lambda)},
  {"rplacd", Lrplcd, &(lambda)},
  {"set", Lset, &(lambda)},
  {"replace", Lreplace, &(lambda)},
  {"infile", Linfile, &(lambda)},
  {"outfile", Loutfile, &(lambda)},
  {"terpr", Lterpr, &(lambda)},
  {"print", Lprint, &(lambda)},
  {"close", Lclose, &(lambda)},
  {"patom", Lpatom, &(lambda)},
  {"pntlen", Lpntlen, &(lambda)},
  {"read", Lread, &(lambda)},
  {"ratom", Lratom, &(lambda)},
  {"readc", Lreadc, &(lambda)},
  {"truename", Ltruename, &(lambda)},
  {"implode", Limplode, &(lambda)},
  {"maknam", Lmaknam, &(lambda)},
  {"deref", Lderef, &(lambda)},
  {"concat", Lconcat, &(lambda)},
  {"uconcat", Luconcat, &(lambda)},
  {"putprop", Lputprop, &(lambda)},
  {"monitor", Lmonitor, &(lambda)},
  {"get", Lget, &(lambda)},
  {"getd", Lgetd, &(lambda)},
  {"putd", Lputd, &(lambda)},
  {"prog", Nprog, &(nlambda)},
  {"quote", Nquote, &(nlambda)},
  {"function", Nfunction, &(nlambda)},
  {"go", Ngo, &(nlambda)},
  {"*catch", Ncatch, &(nlambda)},
  {"errset", Nerrset, &(nlambda)},
  {"status", Nstatus, &(nlambda)},
  {"sstatus", Nsstatus, &(nlambda)},
  {"err-with-message", Lerr, &(lambda)},
  {"*throw", Nthrow, &(lambda)},	/* this is a lambda now !! */
  {"reset", Nreset, &(nlambda)},
  {"break", Nbreak, &(nlambda)},
  {"exit", Lexit, &(lambda)},
  {"def", Ndef, &(nlambda)},
  {"null", Lnull, &(lambda)},
	  	/*{"framedump", Lframedump, &(lambda)},*/
  {"and", Nand, &(nlambda)},
  {"or", Nor, &(nlambda)},
  {"setq", Nsetq, &(nlambda)},
  {"cond", Ncond, &(nlambda)},
  {"list", Llist, &(lambda)},
  {"load", Lload, &(lambda)},
  {"nwritn", Lnwritn, &(lambda)},
  {"*process", Lprocess, &(lambda)},	/*  execute a shell command  */
  {"allocate", Lalloc, &(lambda)},	/*  allocate a page  */
  {"sizeof", Lsizeof, &(lambda)},	/*  size of one item of a data type  */
  {"dumplisp", Ndumplisp, &(nlambda)},	/*  NEW save the world  */
  {"top-level", Ntpl, &(nlambda)},	/*  top level eval-print read loop  */
  {"mapcar", Lmpcar, &(lambda)},
  {"maplist", Lmaplist, &(lambda)},
  {"mapcan", Lmapcan, &(lambda)},
  {"mapcon", Lmapcon, &(lambda)},
  {"assq", Lassq, &(lambda)},
  {"mapc", Lmapc, &(lambda)},
  {"map", Lmap, &(lambda)},
  {"flatc", Lflatsi, &(lambda)},
  {"alphalessp", Lalfalp, &(lambda)},
  {"drain", Ldrain, &(lambda)},
  {"killcopy", Lkilcopy, &(lambda)}, /*  forks aand aborts for adb */
  {"opval", Lopval, &(lambda)},	/*  sets and retrieves system variables  */
  {"ncons", Lncons, &(lambda)},
  {"remob", Lforget, &(lambda)},	/*  function to take atom out of hash table  */
  {"not", Lnull, &(lambda)},
  {"plus", Ladd, &(lambda)},
  {"add", Ladd, &(lambda)},
  {"times", Ltimes, &(lambda)},
  {"difference", Lsub, &(lambda)},
  {"quotient", Lquo, &(lambda)},
  {"+", Lfp, &(lambda)},
  {"-", Lfm, &(lambda)},
  {"*", Lft, &(lambda)},
  {"/", Lfd, &(lambda)},
  {"1+", Lfadd1, &(lambda)},
  {"1-", Lfsub1, &(lambda)},
  {"^", Lfexpt, &(lambda)},
  {"double-to-float", Ldbtofl, &(lambda)},
  {"float-to-double", Lfltodb, &(lambda)},
  {"<", Lflessp, &(lambda)},
  {"mod", Lmod, &(lambda)},
  {"minus", Lminus, &(lambda)},
  {"absval", Labsval, &(lambda)},
  {"add1", Ladd1, &(lambda)},
  {"sub1", Lsub1, &(lambda)},
  {"greaterp", Lgreaterp, &(lambda)},
  {"lessp", Llessp, &(lambda)},
  {"any-zerop", Lzerop, &(lambda)},   /* used when bignum arg possible */
  {"zerop", Lzerop, &(lambda)},
  {"minusp", Lnegp, &(lambda)},
  {"onep", Lonep, &(lambda)},
  {"sum", Ladd, &(lambda)},
  {"product", Ltimes, &(lambda)},
  {"do", Ndo, &(nlambda)},
  {"progv", Nprogv, &(nlambda)},
  {"progn", Nprogn, &(nlambda)},
  {"prog2", Nprog2, &(nlambda)},
  {"oblist", Loblist, &(lambda)},
  {"baktrace", Lbaktrace, &(lambda)},
  {"tyi", Ltyi, &(lambda)},
  {"tyipeek", Ltyipeek, &(lambda)},
  {"untyi", Luntyi, &(lambda)},
  {"tyo", Ltyo, &(lambda)},
  {"termcapinit", Ltci, &(lambda)},
  {"termcapexe", Ltcx, &(lambda)},
  {"int:setsyntax", Lsetsyn, &(lambda)},	/* an internal function */
  {"int:getsyntax", Lgetsyntax, &(lambda)},
  {"int:showstack", LIshowstack, &(lambda)},
  {"int:franz-call", LIfranzcall, &(lambda)},
  {"makereadtable", Lmakertbl, &(lambda)},
  {"zapline", Lzapline, &(lambda)},
  {"aexplode", Lxplda, &(lambda)},
  {"aexplodec", Lxpldc, &(lambda)},
  {"aexploden", Lxpldn, &(lambda)},
  {"hashtabstat", Lhashst, &(lambda)},
#ifdef METER
  {"gcstat", Lgcstat, &(lambda)},
#endif
  {"argv", Largv, &(lambda)},
  {"arg", Larg, &(lambda)},
  {"setarg", Lsetarg, &(lambda)},
  {"showstack", Lshostk, &(lambda)},
  {"freturn", Lfretn, &(lambda)},
  {"*rset", Lrset, &(lambda)},
  {"eval1", Leval1, &(lambda)},
  {"evalframe", Levalf, &(lambda)},
  {"evalhook", Levalhook, &(lambda)},
  {"funcallhook", Lfunhook, &(lambda)},
  {"int:fclosure-stack-stuff", LIfss, &(lambda)},
  {"resetio", Nioreset, &(nlambda)},
  {"chdir", Lchdir, &(lambda)},
  {"ascii", Lascii, &(lambda)},
  {"boole", Lboole, &(lambda)},
  {"type", Ltype, &(lambda)},	/* returns type-name of argument */
  {"fix", Lfix, &(lambda)},
  {"float", Lfloat, &(lambda)},
  {"fact", Lfact, &(lambda)},
  {"cpy1", Lcpy1, &(lambda)},
  {"Divide", LDivide, &(lambda)},
  {"Emuldiv", LEmuldiv, &(lambda)},
  {"readlist", Lreadli, &(lambda)},
  {"plist", Lplist, &(lambda)},	/* gives the plist of an atom */
  {"setplist", Lsetpli, &(lambda)},	/* get plist of an atom  */
  {"eval-when", Nevwhen, &(nlambda)},
  {"syscall", Lsyscall, &(lambda)},
  {"intern", Lntern, &(lambda)},
  {"ptime", Lptime, &(lambda)},	/* return process user time */
  {"fork", Lfork, &(lambda)},	/* turn on fork and wait */
  {"wait", Lwait, &(lambda)},
/*	MK("pipe",Lpipe,lambda),	*/
/*	MK("fdopen",Lfdopen,lambda), */
  {"exece", Lexece, &(lambda)},
  {"gensym", Lgensym, &(lambda)},
  {"remprop", Lremprop, &(lambda)},
  {"bcdad", Lbcdad, &(lambda)},
  {"symbolp", Lsymbolp, &(lambda)},
  {"stringp", Lstringp, &(lambda)},
  {"rematom", Lrematom, &(lambda)},
/**	MK("prname",Lprname,lambda),	*/
  {"getenv", Lgetenv, &(lambda)},
  {"I-throw-err", Lctcherr, &(lambda)}, /* directly force a throw or error */
  {"makunbound", Lmakunb, &(lambda)},
  {"haipart", Lhaipar, &(lambda)},
  {"haulong", Lhau, &(lambda)},
  {"signal", Lsignal, &(lambda)},
  {"fasl", Lfasl, &(lambda)},	/* NEW - new fasl loader */
  {"cfasl", Lcfasl, &(lambda)},	/* read in compiled C file */
  {"getaddress", Lgetaddress, &(lambda)},
  {"removeaddress", Lrmadd, &(lambda)}, 	/* unbind symbols    */
  {"make-c-thunk", Lmkcth, &(lambda)}, 	/* make wrappers    */
  {"boundp", Lboundp, &(lambda)},	/* tells if an atom is bound */
  {"fake", Lfake, &(lambda)},	/* makes a fake lisp pointer */
/***	MK("od",Lod,lambda),		/* dumps info */
  {"maknum", Lmaknum, &(lambda)},	/* converts a pointer to an integer */
  {"*mod", LstarMod, &(lambda)},		/* return fixnum modulus */
  {"*invmod", Lstarinvmod, &(lambda)},	/* return fixnum modulus ^-1 */
  {"fseek", Lfseek, &(lambda)},	/* seek to a specific byte in a file */
  {"fileopen",  Lfileopen, &( lambda)},
  {"pv%", Lpolyev, &(lambda)},	/* polynomial evaluation instruction*/
  {"cprintf", Lcprintf, &(lambda)},  /* formatted print 		    */
  {"sprintf", Lsprintf, &(lambda)},  /* formatted print to string	    */
  {"copyint*", Lcopyint, &(lambda)},	/* copyint*  */
  {"purcopy", Lpurcopy, &(lambda)},	/* pure copy */
  {"purep", Lpurep, &(lambda)},	/* check if pure */
  {"int:memreport", LImemory, &(lambda)}, /* dump memory stats */
/*
 * Hunk stuff
 */
  {"*makhunk", LMakhunk, &(lambda)},		/* special hunk creater */
  {"hunkp", Lhunkp, &(lambda)},		/* test a hunk */
  {"cxr", Lcxr, &(lambda)},			/* cxr of a hunk */
  {"rplacx", Lrplcx, &(lambda)},		/* replace element of a hunk */
  {"*rplacx", Lstarrpx, &(lambda)},		/* rplacx used by hunk */
  {"hunksize", Lhunksize, &(lambda)},	/* size of a hunk */
  {"hunk-to-list", Lhtol, &(lambda)},	/* hunk to list */
  {"new-vector", Lnvec, &(lambda)},
  {"new-vectori-byte", Lnvecb, &(lambda)},
  {"new-vectori-word", Lnvecw, &(lambda)},
  {"new-vectori-long", Lnvecl, &(lambda)},
  {"vectorp", Lvectorp, &(lambda)},
  {"vectorip", Lpvp, &(lambda)},
  {"int:vref", LIvref, &(lambda)},
  {"int:vset", LIvset, &(lambda)},
  {"int:vsize", LIvsize, &(lambda)},
  {"vsetprop", Lvsp, &(lambda)},
  {"vprop", Lvprop, &(lambda)},
  {"probef", Lprobef, &(lambda)},	/* test file existance */
  {"substring", Lsubstring, &(lambda)},
  {"substringn", Lsstrn, &(lambda)},
  {"character-index", Lcharindex, &(lambda)}, /* index of char in string */
  {"time-string", Ltymestr, &(lambda)},
  {"gc", Ngc, &(nlambda)},
  {"gcafter", Ngcafter, &(nlambda)},	/* garbage collection wind-up */
  {0}
};
static dofuns(){mftab(cfuns);}
EndOfFile
cat >  franz/vax/../lam1.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam1.c,v 1.7 85/03/24 11:04:00 sklower Exp $";
#endif

/*					-[Fri Feb 17 16:44:24 1984 by layer]-
 * 	lam1.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

# include "global.h"
# include <sgtty.h>
# include "chkrtab.h"
# include "frame.h"

lispval
Leval()
{
	register lispval temp;

	chkarg(1,"eval");
	temp = lbot->val;
	    return(eval(temp));
}

lispval
Lxcar()
{	register int typ;
	register lispval temp, result;

	chkarg(1,"xcar");
	temp = lbot->val;
	if (((typ = TYPE(temp)) == DTPR) || (typ == ATOM) || HUNKP(temp))
	    return(temp->d.car);
	else if(typ == SDOT) {
		result = inewint(temp->i);
		return(result);
	} else if(Schainp!=nil && typ==ATOM)
		return(nil);
	else
		return(error("Bad arg to car",FALSE));

}

lispval
Lxcdr()
{	register int typ;
	register lispval temp;

	chkarg(1,"xcdr");
	temp = lbot->val;
	if(temp==nil) return (nil);

	if (((typ = TYPE(temp)) == DTPR) || HUNKP(temp)) 
	    return(temp->d.cdr);
	else if(typ==SDOT) {
		if(temp->s.CDR==0) return(nil);
		temp = temp->s.CDR;
		if(TYPE(temp)==DTPR)
		    errorh1(Vermisc,"Fell off the end of a bignum",nil,FALSE,5,lbot->val);
		return(temp);
	} else if(Schainp!=nil && typ==ATOM)
		return(nil);
	else
		return(error("Bad arg to cdr", FALSE));
}

lispval
cxxr(as,ds)
register int as,ds;
{

	register lispval temp, temp2;
	int i, typ;
	lispval errorh();

	chkarg(1,"c{ad}+r");
	temp = lbot->val;

	for( i=0 ; i<ds ; i++)
	{
	    if( temp != nil)
	    {
		typ = TYPE(temp);
		if ((typ == DTPR) || HUNKP(temp))
		    temp = temp->d.cdr;
		else
		    if(typ==SDOT)
		    {
			if(temp->s.CDR==0)
			    temp = nil;
			else
			    temp = temp->s.CDR;
			if(TYPE(temp)==DTPR)
		    	    errorh1(Vermisc,"Fell off the end of a bignum",nil,FALSE,5,lbot->val);
		    }
		else
		    if(Schainp!=nil && typ==ATOM)
			return(nil);
		else
		    return(errorh1(Vermisc,"Bad arg to cdr",nil,FALSE,5,temp));
	    }
	}

	for( i=0 ; i<as ; i++)
	{
	    if( temp != nil )
	    {
		typ = TYPE(temp);
		if ((typ == DTPR) || HUNKP(temp))
		    temp = temp->d.car;
		else if(typ == SDOT)
			temp2 = inewint(temp->i), temp = temp2;
		else if(Schainp!=nil && typ==ATOM)
		    return(nil);
		else
		    return(errorh1(Vermisc,"Bad arg to car",nil,FALSE,5,temp));
	    }
	}

	return(temp);
}

lispval
Lcar()
{	return(cxxr(1,0)); }

lispval
Lcdr()
{	return(cxxr(0,1)); }

lispval
Lcadr()
{	return(cxxr(1,1)); }

lispval
Lcaar()
{	return(cxxr(2,0)); }

lispval
Lc02r()
{	return(cxxr(0,2)); }	/* cddr */

lispval
Lc12r()
{	return(cxxr(1,2)); }	/* caddr */

lispval
Lc03r()
{	return(cxxr(0,3)); }	/* cdddr */

lispval
Lc13r()
{	return(cxxr(1,3)); }	/* cadddr */

lispval
Lc04r()
{	return(cxxr(0,4)); }	/* cddddr */

lispval
Lc14r()
{	return(cxxr(1,4)); }	/* caddddr */

/*
 *  
 *	(nthelem num list)
 *
 * Returns the num'th element of the list, by doing a caddddd...ddr
 * where there are num-1 d's. If num<=0 or greater than the length of
 * the list, we return nil.
 *
 */

lispval
Lnthelem()
{
	register lispval temp;
	register int i;

	chkarg(2,"nthelem");

	if( TYPE(temp = lbot->val) != INT)
	return (error ("First arg to nthelem must be a fixnum",FALSE));

	i = temp->i;	/* pick up the first arg */

	if( i <= 0) return(nil);

	++lbot;			/* fix lbot for call to cxxr() 'cadddd..r' */
	temp = cxxr(1,i-1);
	--lbot;

	return(temp);
}

lispval
Lscons()
{
	register struct argent *argp = lbot;
	register lispval retp, handy;

	chkarg(2,"scons");
	retp = newsdot();
	handy = (argp) -> val;
	if(TYPE(handy)!=INT)
		error("First arg to scons must be an int.",FALSE);
	retp->s.I = handy->i;
	handy = (argp+1)->val;
	if(handy==nil)
		retp->s.CDR = (lispval) 0;
	else {
		if(TYPE(handy)!=SDOT)
		    error("Currently you may only link sdots to sdots.",FALSE);
		retp->s.CDR = handy;
	}
	return(retp);
}

lispval
Lbigtol(){
	register lispval handy,newp;

	chkarg(1,"Bignum-to-list");
	handy = lbot->val;
	while(TYPE(handy)!=SDOT)
		handy = errorh1(Vermisc,
				"Non bignum argument to Bignum-to-list",
				nil,TRUE,5755,handy);
	protect(newp = newdot());
	while(handy) {
		newp->d.car = inewint((long)handy->s.I);
		if(handy->s.CDR==(lispval) 0) break;
		newp->d.cdr = newdot();
		newp = newp->d.cdr;
		handy = handy->s.CDR;
	}
	handy = (--np)->val;
	return(handy);
}

lispval
Lcons()
{
	register lispval retp;
	register struct argent *argp;

	chkarg(2,"cons");
	retp = newdot();
	retp->d.car = ((argp = lbot) -> val);
	retp->d.cdr = argp[1].val;
	return(retp);
}
#define CA 0
#define CD 1

lispval
rpla(what)
int what;
{	register struct argent *argp;
	register int typ; register lispval first, second;

	chkarg(2,"rplac[ad]");
	argp = np-1;
	first = (argp-1)->val;
	while(first==nil)
		first = error("Attempt to rplac[ad] nil.",TRUE);
	second = argp->val;
	if (((typ = TYPE(first)) == DTPR) || (typ == ATOM) || HUNKP(first)) {
		if (what == CA)
			first->d.car = second;
		else 
			first->d.cdr = second;
		return(first);
	}
	if (typ==SDOT) {
		if(what == CA) {
			typ = TYPE(second);
			if(typ!=INT) error("Rplacca of a bignum will only replace INTS",FALSE);
			first->s.I = second->i;
		} else {
			if(second==nil)
				first->s.CDR = (lispval) 0;
			else
				first->s.CDR = second;
		}
		return(first);
	}
	return(error("Bad arg to rpla",FALSE));
}
lispval
Lrplca()
{	return(rpla(CA));	}

lispval
Lrplcd()
{	return(rpla(CD));	}


lispval
Leq()
{
	register struct argent *mynp = lbot + AD;

	chkarg(2,"eq");
	if(mynp->val==(mynp+1)->val) return(tatom);
	return(nil);
}



lispval
Lnull()
{	chkarg(1,"null");
	return ((lbot->val == nil) ? tatom : nil);
}



/* Lreturn **************************************************************/
/* Returns the first argument - which is nill if not specified.		*/

lispval
Lreturn()
{
	if(lbot==np) protect (nil);
	Inonlocalgo(C_RET,lbot->val,nil);
	/* NOT REACHED */
}


lispval
Linfile()
{
	FILE *port;
	register lispval name;

	chkarg(1,"infile");
	name = lbot->val;
loop:
	name = verify(name,"infile: file name must be atom or string");
	/* return nil if file couldnt be opened
	if ((port = fopen((char *)name,"r")) == NULL) return(nil); */	

	if ((port = fopen((char *)name,"r")) == NULL) {
		name = errorh1(Vermisc,"Unable to open file for reading.",nil,TRUE,31,name);
		goto loop;
	}
	ioname[PN(port)] = (lispval) inewstr((char *)name); /* remember name */
	return(P(port));
}

/* outfile - open a file for writing.  
 * 27feb81 [jkf] - modifed to accept two arguments, the second one being a
 *   string or atom, which if it begins with an `a' tells outfile to open the
 *   file in append mode
 */
lispval
Loutfile()
{
	FILE *port; register lispval name;
	char *mode ="w";    /* mode is w for create new file, a for append */
	char *given;

	if(lbot+1== np) protect(nil);
	chkarg(2,"outfile");
	name = lbot->val;
	given = (char *)verify((lbot+1)->val,"Illegal file open mode.");
	if(*given == 'a') mode = "a";
loop:
	name = verify(name,"Please supply atom or string name for port.");
#ifdef	os_vms
	/*
	 *	If "w" mode, open it as a "txt" file for convenience in VMS
	 */
	if (strcmp(mode,"w") == 0) {
		int fd;

		if ((fd = creat(name,0777,"txt")) < 0) {
			name = errorh1(Vermisc,"Unable to open file for writing.",nil,TRUE,31,name);
			goto loop;
		}
		port = fdopen(fd,mode);
	} else
#endif
	if ((port = fopen((char *)name,mode)) == NULL) {
		name = errorh1(Vermisc,"Unable to open file for writing.",nil,TRUE,31,name);
		goto loop;
	}
	ioname[PN(port)] = (lispval) inewstr((char *)name);
	return(P(port));
}

lispval
Lterpr()
{
	register lispval handy;
	FILE *port;

	if(lbot==np) handy = nil;
	else 
	{ 
	    chkarg(1,"terpr");
	    handy = lbot->val;
	}

	port = okport(handy,okport(Vpoport->a.clb,stdout));
	putc('\n',port);
	fflush(port);
	return(nil);
}

lispval
Lclose()
{
	lispval port;

	chkarg(1,"close");
	port = lbot->val;
	if((TYPE(port))==PORT) {
		fclose(port->p);
		ioname[PN(port->p)] = nil;
		return(tatom);
	}
	errorh1(Vermisc,"close:Non-port",nil,FALSE,987,port);
	/* not reached */
}

lispval
Ltruename()
{
    chkarg(1,"truename");
    if(TYPE(lbot->val) != PORT)
    	errorh1(Vermisc,"truename: non port argument",nil,FALSE,0,lbot->val);

    return(ioname[PN(lbot->val->p)]);
}

lispval
Lnwritn()
{
	register FILE *port;
	register value;
	register lispval handy;

	if(lbot==np) handy = nil;
	else 
	{
	    chkarg(1,"nwritn");
	    handy = lbot->val;
	}

	port = okport(handy,okport(Vpoport->a.clb,stdout));
	value = port->_ptr - port->_base;
	return(inewint(value));
}

lispval
Ldrain()
{
	register FILE *port;
	register int iodes;
	register lispval handy;
	struct sgttyb arg;

	if(lbot==np) handy = nil;
	else 
	{
	    chkarg(1,"nwritn");
	    handy = lbot->val;
	}
	port = okport(handy, okport(Vpoport->a.clb,stdout));
	if(port->_flag & _IOWRT) {
		fflush(port);
		return(nil);
	}
	if(! port->_flag & _IOREAD) return(nil);
	port->_cnt = 0;
	port->_ptr = port->_base;
	iodes = fileno(port);
	if(gtty(iodes,&arg) != -1) stty(iodes,&arg);
	return(P(port));
}

lispval
Llist()
{
	/* added for the benefit of mapping functions. */
	register struct argent *ulim, *namptr;
	register lispval temp, result;
	Savestack(4);

	ulim = np;
	namptr = lbot + AD;
	temp = result = (lispval) np;
	protect(nil);
	for(; namptr < ulim;) {
		temp = temp->l = newdot();
		temp->d.car = (namptr++)->val;
	}
	temp->l = nil;
	Restorestack();
	return(result->l);
}

lispval
Lnumberp()
{
	chkarg(1,"numberp");
	switch(TYPE(lbot->val)) {
	case INT: case DOUB: case SDOT:
		return(tatom);
	}
	return(nil);
}

lispval
Latom()
{
	register struct argent *lb = lbot;
	chkarg(1,"atom");
	if(TYPE(lb->val)==DTPR || (HUNKP(lb->val)))
		return(nil);
	else
		return(tatom);
}

lispval
Ltype()
{
	chkarg(1,"type");
	switch(TYPE(lbot->val)) {
	case INT:
		return(int_name);
	case ATOM:
		return(atom_name);
	case SDOT:
		return(sdot_name);
	case DOUB:
		return(doub_name);
	case DTPR:
		return(dtpr_name);
	case STRNG:
		return(str_name);
	case ARRAY:
		return(array_name);
	case BCD:
		return(funct_name);
	case OTHER:
		return(other_name);

	case HUNK2:
		return(hunk_name[0]);
	case HUNK4:
		return(hunk_name[1]);
	case HUNK8:
		return(hunk_name[2]);
	case HUNK16:
		return(hunk_name[3]);
	case HUNK32:
		return(hunk_name[4]);
	case HUNK64:
		return(hunk_name[5]);
	case HUNK128:
		return(hunk_name[6]);
		
	case VECTOR:
		return(vect_name);
	case VECTORI:
		return(vecti_name);

	case VALUE:
		return(val_name);
	case PORT:
		return(port_name);
	}
	return(nil);
}

lispval
Ldtpr()
{
	chkarg(1,"dtpr");
	return(typred(DTPR, lbot->val));
}

lispval
Lbcdp()
{
	chkarg(1,"bcdp");
	return(typred(BCD, lbot->val));
}

lispval
Lportp()
{
	chkarg(1,"portp");
	return(typred(PORT, lbot->val));
}

lispval
Larrayp()
{
	chkarg(1,"arrayp");
	return(typred(ARRAY, lbot->val));
}

/*
 *	(hunkp 'g_arg1)
 * Returns t if g_arg1 is a hunk, otherwise returns nil.
 */

lispval
Lhunkp()
{
	chkarg(1,"hunkp");
	if (HUNKP(lbot->val))
		return(tatom);		/* If a hunk, return t */
	else
		return(nil);		/* else nil */
}

lispval
Lset()
{
	lispval varble;

	chkarg(2,"set");
	varble = lbot->val;
	switch(TYPE(varble))
		{
	case ATOM:	return(varble->a.clb = lbot[1].val);

	case VALUE:	return(varble->l = lbot[1].val);
		}

	error("IMPROPER USE OF SET",FALSE);
	/* NOTREACHED */
}

lispval
Lequal()
{
	register lispval first, second;
	register type1, type2;
	lispval Lsub(),Lzerop();
	long *oldsp;
	Keepxs();
	chkarg(2,"equal");


	if(lbot->val==lbot[1].val) return(tatom);

	oldsp=sp(); stack((long)lbot->val);stack((long)lbot[1].val);
	for(;oldsp > sp();) {

	    first = (lispval) unstack(); second = (lispval) unstack();
    again:
	    if(first==second) continue;

	    type1=TYPE(first); type2=TYPE(second);
	    if(type1!=type2) {
		if((type1==SDOT&&type2==INT)||(type1==INT&&type2==SDOT))
		    goto dosub;
		{Freexs(); return(nil);}
	    }
	    switch(type1) {
	    case DTPR:
		stack((long)first->d.cdr); stack((long)second->d.cdr);
		first = first->d.car; second = second->d.car;
		goto again;
	    case DOUB:
		if(first->r!=second->r)
		    {Freexs(); return(nil);}
		continue;
	    case INT:
		if(first->i!=second->i)
		    {Freexs(); return(nil);}
		continue;
	    case VECTOR:
	        if(!vecequal(first,second)) {Freexs(); return(nil);}
		continue;
	    case VECTORI:
	    	if(!veciequal(first,second)) {Freexs(); return(nil);}
		continue;
    dosub:
	    case SDOT: {
		lispval temp;
		struct argent *OLDlbot = lbot;
		lbot = np;
		np++->val = first;
		np++->val = second;
		temp = Lsub();
		np = lbot;
		lbot = OLDlbot;
		if(TYPE(temp)!=INT || temp->i!=0)
		    {Freexs(); return(nil);}
		}
		continue;
	    case VALUE:
		if(first->l!=second->l)
		    {Freexs(); return(nil);}
		continue;
	    case STRNG:
		if(strcmp((char *)first,(char *)second)!=0)
		    {Freexs(); return(nil);}
		continue;

	    default:
		{Freexs(); return(nil);}
	    }
	}
	{Freexs(); return(tatom);}
}
lispval
oLequal()
{
	chkarg(2,"equal");

	if( lbot[1].val == lbot->val ) return(tatom);
	if(Iequal(lbot[1].val,lbot->val)) return(tatom); else return(nil);
}

Iequal(first,second) 
register lispval first, second;
{
	register type1, type2;
	lispval Lsub(),Lzerop();

	if(first==second)
		return(1);
	type1=TYPE(first);
	type2=TYPE(second);
	if(type1!=type2) {
		if((type1==SDOT&&type2==INT)||(type1==INT&&type2==SDOT))
			goto dosub;
		return(0);
	}
	switch(type1) {
	case DTPR:
		 return(
			Iequal(first->d.car,second->d.car) &&
			Iequal(first->d.cdr,second->d.cdr) );
	case DOUB:
		return(first->r==second->r);
	case INT:
		return( (first->i==second->i));
dosub:
	case SDOT:
	{
		lispval temp;
		struct argent *OLDlbot = lbot;
		lbot = np;
		np++->val = first;
		np++->val = second;
		temp = Lsub();
		np = lbot;
		lbot = OLDlbot;
		return(TYPE(temp)==INT&& temp->i==0);
	}
	case VALUE:
		return( first->l==second->l );
	case STRNG:
		return(strcmp((char *)first,(char *)second)==0);
	}
	return(0);
}
lispval
Zequal()
{
	register lispval first, second;
	register type1, type2;
	lispval Lsub(),Lzerop();
	long *oldsp;
	Keepxs();
	chkarg(2,"equal");


	if(lbot->val==lbot[1].val) return(tatom);

	oldsp=sp(); stack((long)lbot->val);stack((long)lbot[1].val);

	for(;oldsp > sp();) {

	    first = (lispval) unstack(); second = (lispval) unstack();
    again:
	    if(first==second) continue;

	    type1=TYPE(first); type2=TYPE(second);
	    if(type1!=type2) {
		if((type1==SDOT&&type2==INT)||(type1==INT&&type2==SDOT))
		    goto dosub;
		{Freexs(); return(nil);}
	    }
	    switch(type1) {
	    case DTPR:
		stack((long)first->d.cdr); stack((long)second->d.cdr);
		first = first->d.car; second = second->d.car;
		goto again;
	    case DOUB:
		if(first->r!=second->r)
		    {Freexs(); return(nil);}
		continue;
	    case INT:
		if(first->i!=second->i)
		    {Freexs(); return(nil);}
		continue;
    dosub:
	    case SDOT:
	    {
		lispval temp;
		struct argent *OLDlbot = lbot;
		lbot = np;
		np++->val = first;
		np++->val = second;
		temp = Lsub();
		np = lbot;
		lbot = OLDlbot;
		if(TYPE(temp)!=INT || temp->i!=0)
		    {Freexs(); return(nil);}
	    }
		continue;
	    case VALUE:
		if(first->l!=second->l)
		    {Freexs(); return(nil);}
		continue;
	    case STRNG:
		if(strcmp((char *)first,(char *)second)!=0)
		    {Freexs(); return(nil);}
		continue;
	    }
	}
	{Freexs(); return(tatom);}
}

/*
 * (print 'expression ['port]) prints the given expression to the given
 * port or poport if no port is given.  The amount of structure
 * printed is a function of global lisp variables plevel and
 * plength.
 */
lispval
Lprint()
{
	register lispval handy;
	extern int plevel,plength;


	handy = nil;			/* port is optional, default nil */
	switch(np-lbot) 
	{
	    case 2: handy = lbot[1].val;
	    case 1: break;
	    default: argerr("print");
	}

	chkrtab(Vreadtable->a.clb);
	if(TYPE(Vprinlevel->a.clb) == INT)
	{ 
	   plevel = Vprinlevel->a.clb->i;
	}
	else plevel = -1;
	if(TYPE(Vprinlength->a.clb) == INT)
	{
	    plength = Vprinlength->a.clb->i;
	}
	else plength = -1;
	printr(lbot->val,okport(handy,okport(Vpoport->a.clb,poport)));
	return(nil);
}

/* patom does not use plevel or plength 
 *
 * form is (patom 'value ['port])
 */
lispval
Lpatom()
{
	register lispval temp;
	register lispval handy;
	register int typ;
	FILE *port;

	handy = nil;			/* port is optional, default nil */
	switch(np-lbot) 
	{
	    case 2: handy = lbot[1].val;
	    case 1: break;
	    default: argerr("patom");
	}

	temp = Vreadtable->a.clb;
	chkrtab(temp);
	port = okport(handy, okport(Vpoport->a.clb,stdout));
	if ((typ= TYPE((temp = (lbot)->val))) == ATOM)
		fputs(temp->a.pname, port);
	else if(typ == STRNG)
		fputs((char *)temp,port);
	else
	{
	    	if(TYPE(Vprinlevel->a.clb) == INT)
		{
		    plevel = Vprinlevel->a.clb->i;
		}
		else plevel = -1;
		if(TYPE(Vprinlength->a.clb) == INT)
		{
		    plength = Vprinlength->a.clb->i;
		}
		else plength = -1;

		printr(temp, port);
	}
	return(temp);
}

/*
 * (pntlen thing) returns the length it takes to print out
 * an atom or number.
 */

lispval
Lpntlen()
{
	return(inewint((long)Ipntlen()));
}
Ipntlen()
{
	register lispval temp;
	register char *handy;
	char *sprintf();

	temp = np[-1].val;
loop:	switch(TYPE(temp)) {

	case ATOM:
		handy = temp->a.pname;
		break;

	case STRNG:
		handy = (char *) temp;
		break;

	case INT:
		sprintf(strbuf,"%d",temp->i);
		handy =strbuf;
		break;

	case DOUB:
		sprintf(strbuf,"%g",temp->r);
		handy =strbuf;
		break;

	default:
		temp = error("Non atom or number to pntlen\n",TRUE);
		goto loop;
	}

	return( strlen(handy));
}
#undef okport
FILE *
okport(arg,proper) 
lispval arg;
FILE *proper;
{
	if(TYPE(arg)!=PORT)
		return(proper);
	else
		return(arg->p);
}
EndOfFile
cat >  franz/vax/../lam2.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam2.c,v 1.5 83/12/09 16:35:49 sklower Exp $";
#endif

/*					-[Fri Aug  5 12:46:16 1983 by jkf]-
 * 	lam2.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

# include "global.h"
# include <signal.h>
# include "structs.h"
# include "chars.h"
# include "chkrtab.h"
/*
 * (flatc 'thing ['max]) returns the smaller of max and the number of chars
 * required to print thing linearly.
 * if max argument is not given, we assume the second arg is infinity
 */
static flen; /*Internal to this module, used as a running counter of flatsize*/
static fmax; /*used for maximum for quick reference */
char *strcpy();

lispval
Lflatsi()
{
	register lispval current;
	Savestack(1); 			/* fixup entry mask */

	fmax = 0x7fffffff;	/* biggest integer by default */
	switch(np-lbot) 
	{
	    case 2: current = lbot[1].val;
		    while(TYPE(current) != INT)
			current = errorh1(Vermisc,
					"flatsize: second arg not integer",
					nil,TRUE,0,current);
		    fmax = current->i;
	    case 1: break;
	    default: argerr("flatsize");
	}

	flen = 0; 
	current = lbot->val;
	protect(nil); 			/*create space for argument to pntlen*/
	Iflatsi(current);
	Restorestack();
	return(inewint(flen));
}
/*
 * Iflatsi does the real work of the calculation for flatc
 */
Iflatsi(current)
register lispval current;
{

	if(flen > fmax) return;
	switch(TYPE(current)) {

	patom:
	case INT: case ATOM: case DOUB: case STRNG:
		np[-1].val = current;
		flen += Ipntlen();
		return;
	
	pthing:
	case DTPR:
		flen++;
		Iflatsi(current->d.car);
		current = current->d.cdr;
		if(current == nil) {
			flen++;
			return;
		}
		if(flen > fmax) return;
		switch(TYPE(current)) {
		case INT: case ATOM: case DOUB:
			flen += 4;
			goto patom;
		case DTPR:
			goto pthing;
		}
	}
}


#define EADC -1
#define EAD  -2
lispval
Lread()
{ return (r(EAD)); }

lispval
Lratom()
{ return (r(ATOM)); }

lispval
Lreadc()
{ return (r(EADC)); }


extern unsigned char *ctable;
/* r *********************************************************************/
/* this function maps the desired read 	function into the system-defined */
/* reading functions after testing for a legal port.			 */
lispval
r(op)
int op;
{
	unsigned char c; register lispval result;
	register cc;
	int orlevel; extern int rlevel;
	FILE *ttemp;
	struct nament *oldbnp = bnp;
	Savestack(2);

	switch(np-lbot) {
	case 0:
		protect(nil);
	case 1:
		protect(nil);
	case 2: break;
	default:
		argerr("read or ratom or readc");
	}
	result = Vreadtable->a.clb;
	chkrtab(result);
	orlevel = rlevel;
	rlevel = 0;
	ttemp = okport(Vpiport->a.clb,stdin);
	ttemp = okport(lbot->val,ttemp);
/*printf("entering switch\n");*/
	if(ttemp == stdin) fflush(stdout);	/* flush any pending 
						 * characters if reading stdin 
						 * there should be tests to see
						 * if this is a tty or pipe
						 */

	switch (op)
	{
	case EADC:	rlevel = orlevel;
			cc = getc(ttemp);
			c = cc;
			if(cc == EOF)
			{
				Restorestack();
				return(lbot[1].val);
			} else {
				strbuf[0] = hash = (c & 0177);
				strbuf[1] = 0;
				atmlen = 2;
				Restorestack();
				return((lispval)getatom(TRUE));
			}

	case ATOM:	rlevel = orlevel;
			result = (ratomr(ttemp));
			goto out;

	case EAD:	PUSHDOWN(Vpiport,P(ttemp)); /* rebind Vpiport */
			result = readr(ttemp);
	out:		if(result==eofa)
			{    
			     if(sigintcnt > 0) sigcall(SIGINT);
			     result = lbot[1].val;
			}
			rlevel = orlevel;
			popnames(oldbnp);	/* unwind bindings */
			Restorestack();
			return(result);
	}
	/* NOTREACHED */
}

/* Lload *****************************************************************/
/* Reads in and executes forms from the specified file. This should      */
/* really be an nlambda taking multiple arguments, but the error 	 */
/* handling gets funny in that case (one file out of several not 	 */
/* openable, for instance).						 */
lispval
Lload()
{
	register FILE *port;
	register char *p, *ttemp; register lispval vtemp;
	struct nament *oldbnp = bnp;
	int orlevel,typ;
	char longname[100];
	char *shortname, *end2, *Ilibdir();
	/*Savestack(4); not necessary because np not altered */

	chkarg(1,"load");
	if((typ = TYPE(lbot->val)) == ATOM)
	    ttemp =  lbot->val->a.pname ;  /* ttemp will point to name */
	else if(typ == STRNG)
	    ttemp = (char *) lbot->val;
	else 
	     return(error("FILENAME MUST BE ATOMIC",FALSE));
	strcpy(longname, Ilibdir());
	for(p = longname; *p; p++);
	*p++ = '/'; *p = 0;
	shortname = p;
	strcpy(p,ttemp);
	for(; *p; p++);
		end2 = p;
	strcpy(p,".l");
	if ((port = fopen(shortname,"r")) == NULL &&
		(port = fopen(longname, "r")) == NULL) {
			*end2 = 0;
			if ((port = fopen(shortname,"r")) == NULL &&
				(port = fopen(longname, "r")) == NULL)
					errorh1(Vermisc,"Can't open file: ", 
						     nil,FALSE,0,lbot->val);
	}
	orlevel = rlevel;
	rlevel = 0;

	if(ISNIL(copval(gcload,CNIL)) &&
		loading->a.clb != tatom &&
		ISNIL(copval(gcdis,CNIL)))
		gc((struct types *)CNIL);    /*  do a gc if gc will be off  */

	/* shallow bind the value of lisp atom piport 	*/
	/* so readmacros will work			*/
	PUSHDOWN(Vpiport,P(port));
	PUSHDOWN(loading,tatom);	/* set indication of loading status */

	while ((vtemp = readr(port)) != eofa) {
	    eval(vtemp);
	}
	popnames(oldbnp);		/* unbind piport, loading */

	rlevel = orlevel;
	fclose(port);
	return(nil);
}

/* concat **************************************************
-
-  use: (concat arg1 arg2 ... )
-
-  concatenates the print names of all of its arguments.
- the arguments may be atoms, integers or real numbers.
-
- *********************************************************/
lispval
Iconcat(unintern)
{
	register struct argent *temnp;
	register char *cp = strbuf;
	register lispval cur;
	int n;
	char *sprintf(), *atomtoolong();
	lispval Lhau();

	*cp = NULL_CHAR ;

	/* loop for each argument */
	for(temnp = lbot + AD ; temnp < np ; temnp++)
	{
	    cur = temnp->val;
	    switch(TYPE(cur))
	    {
	    case ATOM:
		 n = strlen(cur->a.pname);
		 while(n + cp >= endstrb) cp = atomtoolong(cp);
		 strcpy(cp, cur->a.pname);
		 cp += n;
		 break;

	    case STRNG:
		 n = strlen( (char *) cur);
		 while(n + cp >= endstrb) cp = atomtoolong(cp);
		 strcpy(cp, (char *) cur);
		 cp += n;
		 break;

  	    case INT:
		 if(15 + cp >= endstrb) cp = atomtoolong(cp);
		 sprintf(cp,"%d",cur->i);
		 while(*cp) cp++;
		 break;

	    case DOUB:
		 if(15 + cp >= endstrb) cp = atomtoolong(cp);
		 sprintf(cp,"%f",cur->f);
		 while(*cp) cp++;
		 break;

	    case SDOT: {
		struct _iobuf _myiob;
		register lispval handy = cur;

		for(n = 12; handy->s.CDR!=(lispval) 0; handy = handy->s.CDR)
			n += 12;

		while(n + cp >= endstrb) cp = atomtoolong(cp);

		_myiob._flag = _IOWRT+_IOSTRG;
		_myiob._ptr = cp;
		_myiob._cnt = endstrb - cp - 1;

		pbignum(cur,&_myiob);
		cp = _myiob._ptr;
		*cp = 0;
		break; }
		    
	    default:
		 cur = error("Non atom or number to concat",TRUE);
		 continue;    /* if returns value, try it */
	   }

	}

	if(unintern)
		return( (lispval) newatom(FALSE)); /* uninterned atoms may
							have printname gc'd*/
	else
		return( (lispval) getatom(FALSE)) ;
}
lispval
Lconcat(){
	return(Iconcat(FALSE));
}
lispval
Luconcat(){
	return(Iconcat(TRUE));
}

lispval
Lputprop()
{
	lispval Iputprop();
	chkarg(3,"putprop");
	return(Iputprop(lbot->val,lbot[1].val,lbot[2].val));
}

/*
 * Iputprop :internal version of putprop used by some C functions
 *  note: prop and ind are lisp values but are not protected (by this
 * function) from gc.  The caller should protect them!!
 */
lispval
Iputprop(atm,prop,ind)
register lispval prop, ind, atm;
{
	register lispval pptr;
	lispval *tack;		/* place to begin property list */
	lispval pptr2;
	lispval errorh();
	Savestack(4);
	
 top:
	switch (TYPE(atm)) {
	case ATOM:
		if(atm == nil) tack = &nilplist;
		else tack =  &(atm->a.plist);
		break;
	case DTPR:
		for (pptr = atm->d.cdr ; pptr != nil ; pptr = pptr->d.cdr->d.cdr)
		    if(TYPE(pptr) != DTPR || TYPE(pptr->d.cdr) != DTPR) break;
		if(pptr != nil) 
		{   atm = errorh1(Vermisc,
				 "putprop: bad disembodied property list",
				 nil,TRUE,0,atm);
  		    goto top;
		}
		tack = (lispval *) &(atm->d.cdr);
		break;
	default:
		errorh1(Vermisc,"putprop: Bad first argument: ",nil,FALSE,0,atm);
	}
	pptr = *tack;	/* start of property list */
/*findit:*/
	for (pptr = *tack ; pptr != nil ; pptr = pptr->d.cdr->d.cdr)
		if (pptr->d.car == ind) {
			(pptr->d.cdr)->d.car = prop;
			Restorestack();
			return(prop);
		}
	/* not found, add to front
	   be careful, a gc could occur before the second newdot() */
	   
	pptr = newdot();
	pptr->d.car = prop;
	pptr->d.cdr = *tack;
	protect(pptr);
	pptr2 = newdot();
	pptr2->d.car = ind;
	pptr2->d.cdr = pptr;
	*tack = pptr2;
	Restorestack();
	return(prop);
}

/* get from property list 
 *   there are three routines to accomplish this
 *     Lget - lisp callable, the first arg can be a symbol or a disembodied
 *  	      property list.  In the latter case we check to make sure it
 *	      is a real one (as best we can).
 *     Iget - internal routine, the first arg must be a symbol, no disembodied
 *	      plists allowed
 *     Igetplist - internal routine, the first arg is the plist to search.
 */
lispval
Lget()
{
	register lispval ind, atm;
	register lispval dum1;
	lispval Igetplist();

	chkarg(2,"get");
	ind = lbot[1].val;
	atm = lbot[0].val;
top:
	switch(TYPE(atm)) {
	case ATOM:
		if(atm==nil) atm = nilplist;
		else atm = atm->a.plist;
		break;		

	case DTPR:
		for (dum1 = atm->d.cdr; dum1 != nil; dum1 = dum1->d.cdr->d.cdr)
		    if((TYPE(dum1) != DTPR) || 
		       (TYPE(dum1->d.cdr) != DTPR)) break; /* bad prop list */
		if(dum1 != nil) 
		{   atm = errorh1(Vermisc,
				 "get: bad disembodied property list",
				 nil,TRUE,0,atm);
  		    goto top;
		}
		atm = atm->d.cdr;
		break;
	default:
		/* remove since maclisp doesnt treat
		   this as an error, ugh
		   return(errorh1(Vermisc,"get: bad first argument: ",
			       nil,FALSE,0,atm));
		 */
		 return(nil);
	}

	while (atm != nil)
		{
			if (atm->d.car == ind)
				return ((atm->d.cdr)->d.car);
			atm = (atm->d.cdr)->d.cdr;
		}
	return(nil);
}
/*
 * Iget - the first arg must be a symbol.
 */
	
lispval
Iget(atm,ind)
register lispval atm, ind;
{
	lispval Igetplist();

	if(atm==nil)
		atm = nilplist;
	else
		atm = atm->a.plist;
	return(Igetplist(atm,ind));
}

/*
 *  Igetplist
 * pptr is a plist
 * ind is the indicator
 */

lispval
Igetplist(pptr,ind)
register lispval pptr,ind;
{
	while (pptr != nil)
		{
			if (pptr->d.car == ind)
				return ((pptr->d.cdr)->d.car);
			pptr = (pptr->d.cdr)->d.cdr;
		}
	return(nil);
}
lispval
Lgetd()
{
	register lispval typ;
	
	chkarg(1,"getd");
	typ = lbot->val;
	if (TYPE(typ) != ATOM) 
	   errorh1(Vermisc,
		  "getd: Only symbols have function definitions",
		  nil,
		  FALSE,
		  0,
		  typ);
	return(typ->a.fnbnd);
}
lispval
Lputd()
{
	register lispval atom, list;
	
	chkarg(2,"putd");
	list = lbot[1].val;
	atom = lbot->val;
	if (TYPE(atom) != ATOM) error("only symbols have function definitions",
					FALSE);
	atom->a.fnbnd = list;
	return(list);
}

/* ===========================================================
- mapping functions which return a list of the answers
- mapcar applies the given function to successive elements
- maplist applies the given function to successive sublists
- ===========================================================*/

lispval
Lmapcrx(maptyp,join)
int maptyp;		/* 0 = mapcar,  1 = maplist  */
int join;		/* 0 = the above, 1 = s/car/can/ */
{
	register struct argent *namptr;
	register index;
	register lispval temp;
	register lispval current;

	struct argent *first, *last;
	int count;
	lispval lists[25], result;
	Savestack(4);
	
	namptr = lbot + 1;
	count = np - namptr;
	if (count <= 0) return (nil);
	result = current =  (lispval) np;
	protect(nil);			/* set up space for returned list */
	protect(lbot->val);	/*copy funarg for call to funcall */
	lbot = np -1;
	first = np;
	last = np += count;
	for(index = 0; index < count; index++) {
		temp =(namptr++)->val; 
		if (TYPE (temp ) != DTPR && temp!=nil) 
			error ( "bad list argument to map",FALSE);
		lists[index] = temp;
	}
	for(;;) {
		for(namptr=first,index=0; index<count; index++) {
			temp = lists[index];
			if(temp==nil) goto done;

			if(maptyp==0) (namptr++)->val = temp->d.car;
			else (namptr++)->val = temp;

			lists[index] = temp->d.cdr;
		}
		if (join == 0) {
			current->l = newdot();
			current->l->d.car = Lfuncal();
			current = (lispval) &current->l->d.cdr;
		} else {
			current->l = Lfuncal();
			if ( TYPE ( current -> l) != DTPR && current->l != nil)
				error("bad type returned from funcall inside map",FALSE);
			else  while ( current -> l  != nil )
					current = (lispval) & (current ->l ->d.cdr);
		}
		np = last;
	}
done:	if (join == 0)current->l = nil;
	Restorestack();
	return(result->l);
}

/* ============================
-
- Lmapcar
- =============================*/

lispval
Lmpcar()
{
	return(Lmapcrx(0,0)); 	/* call general routine */
}


/* ============================
-
-
-  Lmaplist
- ==============================*/

lispval
Lmaplist()
{
	return(Lmapcrx(1,0)); 	/* call general routine */
}


/* ================================================
- mapping functions which return the value of the last function application.
- mapc and map
- ===================================================*/

lispval
Lmapcx(maptyp)
int maptyp;		/* 0= mapc   , 1= map  */
{
	register struct argent *namptr;
	register index;
	register lispval temp;
	register lispval result;

	int count;
	struct argent *first;
	lispval lists[25], errorh();
	Savestack(4);
	
	namptr = lbot + 1;
	count = np - namptr;
	if(count <= 0) return(nil);
	result = lbot[1].val;		/*This is what macsyma wants so ... */
					/*copy funarg for call to funcall */
	lbot = np; protect((namptr - 1)->val);
	first = np; np += count;

	for(index = 0; index < count; index++) {
		temp = (namptr++)->val;
		while(temp!=nil && TYPE(temp)!=DTPR)
			temp = errorh1(Vermisc,"Inappropriate list argument to mapc",nil,TRUE,0,temp);
		lists[index] = temp;
	}
	for(;;) {
		for(namptr=first,index=0; index<count; index++) {
			temp = lists[index];
			if(temp==nil)
				goto done;
			if(maptyp==0)
				(namptr++)->val = temp->d.car;
			else
				(namptr++)->val = temp;
			lists[index] = temp->d.cdr;
		}
		Lfuncal();
	}
done:	
	Restorestack();
	return(result);
}


/* ==================================
-
-	mapc   map the car of the lists
-
- ==================================*/

lispval
Lmapc()
{	return( Lmapcx(0) );  }


/* =================================
-
-	map    map the cdr of the lists
-
- ===================================*/

lispval
Lmap()
{	return( Lmapcx(1) );   }


lispval
Lmapcan()
{ 
	lispval Lmapcrx();

	return ( Lmapcrx ( 0,1 ) ); 
} 

lispval
Lmapcon()
{ 
	lispval Lmapcrx();

	return ( Lmapcrx ( 1,1 ) ); 
}
EndOfFile
cat >  franz/vax/../lam3.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam3.c,v 1.4 84/04/06 23:08:13 layer Exp $";
#endif

/*					-[Fri Aug  5 12:47:19 1983 by jkf]-
 * 	lam3.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

# include "global.h"
# include "chars.h"
# include "chkrtab.h"

lispval
Lalfalp()
{
	register char  *first, *second;

	chkarg(2,"alphalessp");
	first = (char *) verify(lbot->val,"alphalessp: non symbol or string arg");
	second = (char *) verify((lbot+1)->val,"alphalessp: non symbol or string arg");
	if(strcmp(first,second) < 0)
		return(tatom);
	else
		return(nil);
}

lispval
Lncons()
{
	register lispval handy;

	chkarg(1,"ncons");
	handy = newdot();
	handy->d.cdr = nil;
	handy->d.car = lbot->val;
	return(handy);
}
lispval
Lzerop()
{
	register lispval handy;

	chkarg(1,"zerop");
	handy = lbot->val;
	switch(TYPE(handy)) {
	case INT:
		return(handy->i==0?tatom:nil);
	case DOUB:
		return(handy->r==0.0?tatom:nil);
	}
	return(nil);
}
lispval
Lonep()
{
	register lispval handy; 
	lispval Ladd();

	handy = lbot->val;
	switch(TYPE(handy)) {
	case INT:
		return(handy->i==1?tatom:nil);
	case DOUB:
		return(handy->r==1.0?tatom:nil);
	case SDOT:
		protect(inewint(0));
		handy = Ladd();
		if(TYPE(handy)!=INT || handy->i !=1)
			return(nil);
		else
			return(tatom);
	}
	return(nil);
}

lispval
cmpx(lssp)
{
	register struct argent *argp;
	register struct argent *outarg;
	register struct argent *onp = np;
	Savestack(3);


	argp = lbot + 1;
	outarg = np;
	while(argp < onp) {

		np = outarg + 2;
		lbot = outarg;
		if(lssp)
			*outarg = argp[-1], outarg[1]  = *argp++;
		else
			outarg[1]  = argp[-1], *outarg = *argp++;
		lbot->val = Lsub();
		np = lbot + 1;
		if(Lnegp()==nil) 
		{
		    Restorestack();
		    return(nil);
		}
	}
	Restorestack();
	return(tatom);
}

lispval
Lgreaterp()
{
	register int typ;
	/* do the easy cases first */
	if(np-lbot == 2)
	{   if((typ=TYPE(lbot->val)) == INT)
	    {    if((typ=TYPE(lbot[1].val)) == INT)
		   return((lbot[0].val->i - lbot[1].val->i) > 0 ? tatom : nil);
		 else if(typ == DOUB)
		  return((lbot[0].val->i - lbot[1].val->r) > 0.0 ? tatom : nil);
	    }
	    else if(typ == DOUB)
	    {    if((typ=TYPE(lbot[1].val)) == INT)
		  return((lbot[0].val->r - lbot[1].val->i) > 0.0 ? tatom : nil);
		 else if(typ == DOUB)
		  return((lbot[0].val->r - lbot[1].val->r) > 0.0 ? tatom : nil);
	    }
	}
		  
	return(cmpx(FALSE));
}

lispval
Llessp()
{
	register int typ;
	/* do the easy cases first */
	if(np-lbot == 2)
	{   if((typ=TYPE(lbot->val)) == INT)
	    {    if((typ=TYPE(lbot[1].val)) == INT)
		   return((lbot[0].val->i - lbot[1].val->i) < 0 ? tatom : nil);
		 else if(typ == DOUB)
		  return((lbot[0].val->i - lbot[1].val->r) < 0.0 ? tatom : nil);
	    }
	    else if(typ == DOUB)
	    {    if((typ=TYPE(lbot[1].val)) == INT)
		  return((lbot[0].val->r - lbot[1].val->i) < 0.0 ? tatom : nil);
		 else if(typ == DOUB)
		  return((lbot[0].val->r - lbot[1].val->r) < 0.0 ? tatom : nil);
	    }
	}
		  
	return(cmpx(TRUE));
}

lispval
Ldiff()
{
	register lispval arg1,arg2; 
	register handy = 0;


	chkarg(2,"Ldiff");
	arg1 = lbot->val;
	arg2 = (lbot+1)->val;
	if(TYPE(arg1)==INT && TYPE(arg2)==INT) {
		handy=arg1->i - arg2->i;
	}
	else error("non-numeric argument",FALSE);
	return(inewint(handy));
}

lispval
Lmod()
{
	register lispval arg1,arg2;
	lispval  handy;
	struct sdot fake1, fake2;
	fake2.CDR = 0;
	fake1.CDR = 0;

	chkarg(2,"mod");
	handy = arg1 = lbot->val;
	arg2 = (lbot+1)->val;
	switch(TYPE(arg1)) {
	case SDOT:
		switch(TYPE(arg2)) {
		case SDOT:			/* both are already bignums */
			break;
		case INT:			/* convert arg2 to bignum   */
			fake2.I = arg2->i;
			arg2 =(lispval) &fake2;
			break;
		default:
			error("non-numeric argument",FALSE);
		}
		break;
	case INT:
		switch(TYPE(arg2)) {
		case SDOT:			/* convert arg1 to bignum */
			fake1.I = arg1->i;
			arg1 =(lispval) &fake1;
			break;
		case INT:			/* both are fixnums 	  */
			return( inewint ((arg1->i) % (arg2->i)) );
		default:
			error("non-numeric argument",FALSE);
		}
		break;
	default:
		error("non-numeric argument",FALSE);
	}
	if(TYPE((lbot+1)->val)==INT && lbot[1].val->i==0)
		return(handy);
	divbig(arg1,arg2,(lispval *)0,&handy);
	if(handy==((lispval)&fake1))
		handy = inewint(fake1.I);
	if(handy==((lispval)&fake2))
		handy = inewint(fake2.I);
	return(handy);
}
lispval
Ladd1()
{
	register lispval handy;
	lispval Ladd();
	Savestack(1); /* fixup entry mask */
	chkarg(1,"add1");

	/* simple test first */
	if((TYPE(lbot->val) == INT) && (lbot->val->i < MaxINT))
	{
	    Restorestack();
	    return(inewint(lbot->val->i + 1));
	}
	
	handy = rdrint;
	handy->i = 1;
	protect(handy);
	handy=Ladd();
	Restorestack();
	return(handy);

}



lispval
Lsub1()
{
	register lispval handy;
	lispval Ladd();
	Savestack(1); /* fixup entry mask */
	chkarg(1,"sub1");
	
	if((TYPE(lbot->val) == INT) && (lbot->val->i > MinINT))
	{
	    Restorestack();
	    return(inewint(lbot->val->i - 1));
	}

	handy = rdrint;
	handy->i = - 1;
	protect(handy);
	handy=Ladd();
	Restorestack();
	return(handy);
}

lispval
Lminus()
{
	register lispval arg1, handy;
	lispval subbig();

	chkarg(1,"minus");
	arg1 = lbot->val;
	handy = nil;
	switch(TYPE(arg1)) {
	case INT:
		handy= inewint(0 - arg1->i);
		break;
	case DOUB:
		handy = newdoub();
		handy->r = -arg1->r;
		break;
	case SDOT: { struct sdot dummyb;
		handy = (lispval) &dummyb;
		handy->s.I = 0;
		handy->s.CDR = (lispval) 0;
		handy = subbig(handy,arg1);
		break; }

	default:
		error("non-numeric argument",FALSE);
	}
	return(handy);
}

lispval
Lnegp()
{
	register lispval handy = np[-1].val, work;
	register flag = 0;

loop:
	switch(TYPE(handy)) {
	case INT:
		if(handy->i < 0) flag = TRUE;
		break;
	case DOUB:
		if(handy->r < 0) flag = TRUE;
		break;
	case SDOT:
		for(work = handy;
		    work->s.CDR!=(lispval) 0;
		    work = work->s.CDR) {;}
		if(work->s.I < 0) flag = TRUE;
		break;
	default:
		handy = errorh1(Vermisc,
				  "minusp: Non-(int,real,bignum) arg: ",
				  nil,
				  TRUE,
				  0,
				  handy);
		goto loop;
	}
	if(flag) return(tatom);
	return(nil);
}

lispval
Labsval()
{
	register lispval arg1;

	chkarg(1,"absval");
	arg1 = lbot->val;
	if(Lnegp()!=nil) return(Lminus());

	return(arg1);
}

/*
 *
 * (oblist)
 *
 * oblist returns a list of all symbols in the oblist
 *
 * written by jkf.
 */
lispval
Loblist()
{
    int indx;
    lispval headp, tailp ;
    struct atom *symb ;
    extern int hashtop;
    Savestack(0);

    headp = tailp = newdot(); /* allocate first DTPR */
    protect(headp);		/*protect the list from garbage collection*/
				/*line added by kls			  */

    for( indx=0 ; indx <= hashtop-1 ; indx++ ) /* though oblist */
    {
	for( symb = hasht[indx] ;
	     symb != (struct atom *) CNIL ;
	     symb = symb-> hshlnk)
	{
	    if(TYPE(symb) != ATOM) 
	    {   printf(" non symbol in hasht[%d] = %x: ",indx,symb);
		printr((lispval) symb,stdout);
		printf(" \n");
		fflush(stdout);
	    }
	    tailp->d.car = (lispval) symb  ; /* remember this atom */
	    tailp = tailp->d.cdr = newdot() ; /* link to next DTPR */
	}
    }

    tailp->d.cdr = nil ; /* close the list unfortunately throwing away
			  the last DTPR
			  */
    Restorestack();
    return(headp);
}

/*
 * Maclisp setsyntax function:
 *    (setsyntax c s x)
 * c represents character either by fixnum or atom
 * s is the atom "macro" or the atom "splicing" (in which case x is the
 * macro to be invoked); or nil (meaning don't change syntax of c); or
 * (well thats enough for now) if s is a fixnum then we modify the bits
 * for c in the readtable.
 */

lispval
Lsetsyn()
{
	register lispval s, c;
	register struct argent *mynp;
	register index;
	lispval x   /*  ,debugmode  */;
	extern unsigned char *ctable;
	extern lispval Istsrch();

	switch(np-lbot) {
	case 2:
		x= nil;			/* only 2 args given */
	case 3:
		x = lbot[2].val;	/* all three args given */
		break;
	default:
		argerr("setsyntax");
	}
	s = Vreadtable->a.clb;
	chkrtab(s);
	/* debugging code 
	debugmode = Istsrch(matom("debugging"))->d.cdr->d.cdr->d.cdr;
	if(debugmode)  printf("Readtable addr: %x\n",ctable);
	  end debugging code */
	mynp = lbot;
	c = (mynp++)->val;
	s = (mynp++)->val;

	switch(TYPE(c)) {
	default:
		error("neither fixnum, atom or string as char to setsyntax",FALSE);

	case ATOM:
		index = *(c->a.pname);
		if((c->a.pname)[1])
		    errorh1(Vermisc,"Only 1 char atoms to setsyntax",
		         nil,FALSE,0,c);
		break;

	case INT:
		index = c->i;
		break;

	case STRNG:
		index = (int) *((char *) c);
	}
	switch(TYPE(s)) {
	case ATOM:
		if(s==splice || s==macro) {
		    if(s==splice)
			    ctable[index] = VSPL;
		    else if(s==macro)
			    ctable[index] = VMAC;
		    if(TYPE(c)!=ATOM) {
			    strbuf[0] = index;
			    strbuf[1] = 0;
			    c = (getatom(TRUE));
		    }
		    Iputprop(c,x,lastrtab);
		    return(tatom);
		}

		/* ... fall into */
	default:  errorh1(Vermisc,"int:setsyntax : illegal second argument ",
				nil,FALSE,0,s);
		/* not reached */
		
	case INT:
		switch(synclass(s->i)) {
		case CESC: Xesc = (char) index; break;
		case CDQ: Xdqc = (char) index; break;
		case CSD: Xsdc = (char) index;	/* string */
		}

		if(synclass(ctable[index])==CESC   /* if we changed the current esc */
		  && (synclass(s->i)!=CESC)          /* to something else, pick current */
		  && Xesc == (char) index) {
	       		ctable[index] = s->i;
			rpltab(CESC,&Xesc);
		}
		else if(synclass(ctable[index])==CDQ   /*  likewise for double quote */
		       && synclass(s->i) != CDQ
		       && Xdqc == (char) index)  {
			ctable[index] = s->i;
			rpltab(CDQ,&Xdqc);
		}
		else if(synclass(ctable[index]) == CSD  /* and for string delimiter */
			&& synclass(s->i) != CSD
			&& Xsdc == (char) index) {
			 ctable[index] = s->i;
			 rpltab(CSD,&Xsdc);
		}
		else ctable[index] = s->i;

		break;

	}
	return(tatom);
}

/*
 * this aux function is used by setsyntax to determine the new current
 * escape or double quote character.  It scans the character table for
 * the first character with the given class (either VESC or VDQ) and
 * puts that character in Xesc or Xdqc (whichever is pointed to by
 * addr).
 */
rpltab(cclass,addr)
char cclass;
unsigned char *addr;
{
	register int i;
	extern unsigned char *ctable;
	for(i=0; i<=127 && synclass(ctable[i]) != cclass; i++);
	if(i<=127) *addr = (unsigned char) i;
	else *addr = '\0';
}


/*
 * int:getsyntax from lisp.
 * returns the fixnum syntax code from the readtable for the given character.
 * to be used by the lisp-code function getsyntax, not to be used by 
 * joe user.
 */
lispval
Lgetsyntax()
{
    register char *name;
    int number, typ;
    lispval handy;
    
    chkarg(1,"int:getsyntax");
    handy = lbot[0].val;
    while (1)
    {
	if((typ = TYPE(handy)) == ATOM)
	{
	    name = handy->a.pname;
	}
	else if (typ == STRNG)
	{
	    name = (char *)handy;
	}
	else if(typ == INT)
	{
	    number = handy->i;
	    break;
	}
	else {
	    handy =
	      errorh1(Vermisc,"int:getsyntax : bad character ",
	      		nil,TRUE,0,handy);
	    continue;	/* start at the top */
	}
	/* figure out the number of the first byte */
	number = (int) name[0];
	if(name[1] != '\0')
	{
	    handy = errorh1(Vermisc,
	    "int:getsyntax : only single character allowed ",
	    nil,TRUE,0,handy);
	}
	else break;
    }
    /* see if number is within range */
    if(number < 0 || number > 255)
    	errorh1(Vermisc,"int:getsyntax : character number out of range ",nil,
		FALSE,0,inewint(number));
    chkrtab(Vreadtable->a.clb);  /* make sure readtable is correct */
    return(inewint(ctable[number]));
}
    
    
	
    
lispval
Lzapline()
{
	register FILE *port;
	extern FILE * rdrport;

	port = rdrport;
	while (!feof(port) && (getc(port)!='\n') );
	return(nil);
}
EndOfFile
cat >  franz/vax/../lam4.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam4.c,v 1.5 83/12/28 16:21:08 sklower Exp $";
#endif

/*					-[Sun Jun 19 22:25:48 1983 by jkf]-
 * 	lam4.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
lispval adbig(),subbig(),mulbig();
double Ifloat();
lispval
Ladd()
{
	register lispval work;
	register struct argent *result, *mynp, *oldnp;
	long restype,prunep,hi,lo=0;
	struct sdot dummybig;
	double flacc;
	Savestack(4);

	oldnp = result = np;
	restype = INT;			/* now start as integers */
	protect(nil);

	for(mynp = lbot; mynp < oldnp; mynp++)
	{
	    work = mynp->val;
	    switch(TYPE(work)) {
	    case INT:
		switch(restype) {
		case SDOT:
		    dmlad(result->val,1L,work->i);
		    prunep = TRUE;
		    /* In adding the fixnum to the sdot we may make it
		    possible for the bignum to be represented as a fixnum */
		    break;
		case INT:
		    if(exarith(lo,1L,work->i,&hi,&lo)) {
			work = result->val = newsdot();
			work->s.I = lo;
			work = work->s.CDR = newdot();
			work->s.I = hi;
			work->s.CDR = 0;
			restype = SDOT; prunep = FALSE;
		    } 
		    break;
		case DOUB:
		    result->val->r += work->i;
		    break;
		default: goto urk;
		}
		break;
	    case SDOT:
		switch(restype) {
		case INT:
		    dummybig.I = lo;
		    dummybig.CDR = 0;
		    work=adbig(work,(lispval)&dummybig);
		    goto code1;
		case SDOT:
		    work=adbig(work,result->val);
		    /* previous result is no longer needed */
		    pruneb(result->val);
		code1:
		    restype = TYPE(work); /* SDOT or INT */
		    if(restype==INT) {
			lo = work->i;
			prunei(work);
		    } else {
			prunep = FALSE; /* sdot is cannonical */
			result->val = work;
		    } break;
		case DOUB:
		    result->val->r += Ifloat(work);
		    break;
		default: goto urk;
		}
		break;
	    case DOUB:
		switch(restype) {
		case SDOT:
		    if(prunep) {
			lispval handy;
			dummybig.I = 0;
			dummybig.CDR = (lispval) 0;
			handy = adbig((lispval)&dummybig,result->val);
			pruneb(result->val);
			result->val = handy;
		    }
		    flacc = Ifloat(result->val) + work->r;
		    pruneb(result->val);
		scrimp:
		    (result->val = newdoub())->r = flacc;
		    restype = DOUB;
		    break;
		case INT:
		    flacc = work->r + lo;
		    goto scrimp;
		case DOUB:
		    result->val->r += work->r;
		    break;
		default: goto urk;
		}
		break;
	    default:
		    errorh1(Vermisc,"Non-number to add",nil,0,FALSE,work);
	    }
	}
	work = result->val;
	switch(restype){
	case DOUB:
		break;
	case INT:
		work=inewint(lo);
		break;
	case SDOT:
		if(prunep) {
		    /* wouldn't (copy result->val) be faster ? -dhl */
		    /* It might, but isn't guaranteed to canonicalize */

		    dummybig.I = 0;
		    dummybig.CDR = (lispval) 0;
		    work = adbig((lispval)&dummybig,work);
		}
		break;
	default:
	urk:
		error("Internal error in add ",FALSE);
	}
	Restorestack();
	return(work);
}

/* exarith(a,b,c,lo,hi)
 * int a,b,c;
 * int *lo, *hi;
 * Exact arithmetic.
 * a,b and c are 32 bit 2's complement integers
 * calculates x=a*b+c to twice the precision of an int.
 * In the vax version, the 30 low bits only are returned
 * in *lo,and the next 32 bits of precision are returned in * hi.
 * this works since exarith is used either for calculating the sum of
 * two 32 bit numbers, (which is at most 33 bits), or
 * multiplying a 30 bit number by a 32 bit numbers,
 * which has a maximum precision of 62 bits.
 * If *phi is 0 or -1 then
 * x doesn't need any more than 31 bits plus sign to describe, so we
 * place the sign in the high two bits of *plo and return 0 from this
 * routine.  A non zero return indicates that x requires more than 31 bits
 * to describe.
 *
 * The definition has been moved to vax.c.
 */


lispval
Lsub()
{
	register lispval work;
	register struct argent *result, *mynp, *oldnp;
	long prunep,restype,hi,lo=0;
	struct sdot dummybig;
	double flacc;
	lispval Lminus();
	Savestack(4);

	oldnp = result = np;
	mynp = lbot + 1;
	restype = INT;
	prunep = TRUE;
	if(oldnp==lbot)
		goto out;
	if(oldnp==mynp) {
		work = Lminus();
		Restorestack();
		return(work);
	}
	protect(nil);
	work = lbot->val;

	/* examine the first argument and perhaps set restype to the 
	 * correct type.  If restype (result type) is INT, then the
	 * fixnum value is stored in lo.  Otherwise, if restype is 
	 * SDOT or DOUB, then the value is stored in result->val.
	 */
	switch(TYPE(work)) {
	case INT:
		lo = work->i;
		restype = INT;
		break;
	case SDOT:
		/* we want to copy the sdot we are given as an argument since
		 * the bignum arithmetic routine dmlad clobbers the values it
		 * is given.
		 */
		dummybig.I = 0;		/* create a zero sdot */
		dummybig.CDR = 0;
		work = adbig(work,(lispval)&dummybig);
		/* the resulting value may have been reduced from an
		 * sdot to a fixnum.  This should never happen though
		 * but if it does, we simplify things.
		 */
		restype = TYPE(work);
		if(restype==INT) {
		    lo = work->i;	/* has turned into an fixnum */
		    prunei(work);	/* return fixnum cell	     */
		} else {
		    prunep = FALSE; 	/* sdot is cannonical */
		    result->val = work;
		} 
		break;

	case DOUB:
		(result->val = newdoub())->r = work->r;
		restype = DOUB;
	}

	/* now loop through the rest of the arguments subtracting them
	 * from the running result in result or lo
	 */
	for(; mynp < oldnp; mynp++)
	{
		work = mynp->val;
		switch(TYPE(work)) {
		case INT:
			switch(restype) {
			case SDOT:
				/* subtracting a fixnum from an bignum
				 * use the distructive multiply (by 1)
				 * and add the negative of the work value.
				 * The result will still be pointed to
				 * by result->val
				 */
				dmlad(result->val,1L, -work->i);
				prunep = TRUE;  /* check up on exiting */
				break;		/* that it didn't collapse */
			case INT:
				/* subtracting a fixnum from a fixnum,
				 * the result could turn into a bignum
				 */
		    		if(exarith(lo,1L,-work->i,&hi,&lo)) {
				    work = result->val = newsdot();
				    work->s.I = lo;
				    work = work->s.CDR = newdot();
				    work->s.I = hi;
				    work->s.CDR = 0;
				    restype = SDOT; prunep = TRUE;
				}
				break;
			case DOUB:
				/* subtracting a fixnum from a flonum */
				result->val->r -= work->i;
				break;
			default:
				goto urk;
			}
			break;
		case SDOT:
			switch(restype) {
			case INT:
			    /* subtracting a bignum from an integer
			     * first make a bignum of the integer and
			     * then fall into the next case
			     */
			    dummybig.I = lo;
			    dummybig.CDR = (lispval) 0;
			    work = subbig((lispval)&dummybig,work);
			    goto on1;

			case SDOT:
			    /* subtracting one bignum from another.  The
			     * routine to do this ends up calling addbig
			     * and should probably be written specifically
			     * for subtraction.
			     */
			     work = subbig(result->val,work);
			     pruneb(result->val);
			on1:
			     /* check if the result has turned into a fixnum */
			     restype = TYPE(work);
			     if(restype==INT) {
				lo = work->i;		/* it has */
				prunei(work);
			     } else {
				prunep = FALSE; 	/* sdot is cannonical */
				result->val = work;
			     } 
			     break;
			case DOUB: /* Subtract bignum from float */
				   /* Death on overflow 	 */
			    result->val->r -= Ifloat(work);
			    break;
			default:
				goto urk;
			}
			break;

		case DOUB:
			switch(restype) {
			case SDOT:  /* subtracting a flonum from a bignum. */

			    if(prunep) {
				lispval handy;
				dummybig.I = 0;
				dummybig.CDR = (lispval) 0;
				handy = adbig((lispval)&dummybig,result->val);
				pruneb(result->val);
				result->val = handy;
			    }
			    flacc = Ifloat(result->val) - work->r;
			    pruneb(result->val);
		scrimp:	    (result->val = newdoub())->r = flacc;
			    restype = DOUB;
			    break;
			case INT:
				/* subtracting a flonum from an fixnum. 
				 * The result will be an flonum.
				 */
				flacc = lo - work->r;
				goto scrimp;
			case DOUB:
				/* subtracting a flonum from a flonum, what
				 * could be easier?
				 */
				result->val->r -= work->r;
				break;
			default:
				goto urk;
			}
			break;
		default:
			errorh1(Vermisc,"Non-number to minus",nil,FALSE,0,work);
		}
	}
out:
	work = result->val;
	switch(restype){
	case DOUB:
		break;
	case INT:
		work = inewint(lo);
		break;
	case SDOT:
		if(prunep) {
		    dummybig.I = 0;
		    dummybig.CDR = (lispval) 0;
		    work = adbig((lispval)&dummybig,work);
		}
		break;
	default:
	urk:
		error("Internal error in difference",FALSE);
	}
	Restorestack();
	return(work);
}

lispval
Ltimes()
{
	register lispval work;
	register struct argent *result, *mynp, *oldnp;
	long restype,prunep,hi,lo=1;
	struct sdot dummybig;
	double flacc;
	Savestack(4);

	oldnp = result = np;
	restype = INT;			/* now start as integers */
	prunep = TRUE;
	protect(nil);

	for(mynp = lbot; mynp < oldnp; mynp++)
	{
	    work = mynp->val;
	    switch(TYPE(work)) {
	    case INT:
		switch(restype) {
		case SDOT:
		    dmlad(result->val,work->i,0L);
		    prunep = TRUE;
		    /* In adding the fixnum to the sdot we may make it
		    possible for the bignum to be represented as a fixnum */
		    break;
		case INT:
		    if(exarith(lo,work->i,0L,&hi,&lo)) {
			work = result->val = newsdot();
			work->s.I = lo;
			work = work->s.CDR = newdot();
			work->s.I = hi;
			work->s.CDR = 0;
			restype = SDOT; prunep = TRUE;
		    } 
		    break;
		case DOUB:
		    result->val->r *= work->i;
		    break;
		default: goto urk;
		}
		break;
	    case SDOT:
		switch(restype) {
		case INT:
		    dummybig.I = lo;
		    dummybig.CDR = 0;
		    work=mulbig(work,(lispval)&dummybig);
		    goto code1;
		case SDOT:
		    work=mulbig(work,result->val);
		    /* previous result is no longer needed */
		    pruneb(result->val);
		code1:
		    restype = TYPE(work); /* SDOT or INT */
		    if(restype==INT) {
			lo = work->i;
			prunei(work);
		    } else {
			prunep = FALSE; /* sdot is cannonical */
			result->val = work;
		    } break;
		case DOUB:
		    result->val->r *= Ifloat(work);
		    break;
		default: goto urk;
		}
		break;
	    case DOUB:
		switch(restype) {
		case SDOT:
		    if(prunep) {
			lispval handy;
			dummybig.I = 0;
			dummybig.CDR = (lispval) 0;
			handy = adbig((lispval)&dummybig,result->val);
			pruneb(result->val);
			result->val = handy;
		    }
		    flacc = Ifloat(result->val) * work->r;
		    pruneb(result->val);
	scrimp:	    (result->val = newdoub())->r = flacc;
		    restype = DOUB;
		    break;
		case INT:
		    flacc = work->r * lo;
		    goto scrimp;
		case DOUB:
		    result->val->r *= work->r;
		    break;
		default: goto urk;
		}
		break;
	    default:
		    errorh1(Vermisc,"Non-number to add",nil,0,FALSE,work);
	    }
	}
	work = result->val;
	switch(restype){
	case DOUB:
		break;
	case INT:
		work = inewint(lo);
		break;
	case SDOT:
		if(prunep) {
		    dummybig.I = 0;
		    dummybig.CDR = (lispval) 0;
		    work = adbig((lispval)&dummybig,work);
		}
		break;
	default:
	urk:
		error("Internal error in times",FALSE);
	}
	Restorestack();
	return(work);
}

lispval
Lquo()
{
	register lispval work;
	register struct argent *result, *mynp, *oldnp;
	int restype; lispval quotient; double flacc;
	struct sdot dummybig;
	Savestack(4);

	oldnp = result = np;
	protect(nil);
	mynp = lbot + 1;
	restype = INT;
	dummybig.I = 1; dummybig.CDR = (lispval) 0;

	if(oldnp==lbot) goto out;
	if(oldnp==mynp) mynp = lbot;
	else {
	    /* examine the first argument and perhaps set restype to the 
	     * correct type.  If restype (result type) is INT, then the
	     * fixnum value is stored in lo.  Otherwise, if restype is 
	     * SDOT or DOUB, then the value is stored in result->val.
	     */
	    work = lbot->val;
	    switch(TYPE(work)) {
	    case INT:
		dummybig.I = work->i;
		break;
	    case SDOT:
		/* we want to copy the sdot we are given as an argument since
		 * the bignum divide routine divbig expects an argument in
		 * canonical form.
		 */
		dummybig.I = 0;		/* create a zero sdot */
		work = adbig(work,(lispval)&dummybig);
		restype = TYPE(work);
		if(restype==INT) {	/* Either INT or SDOT */
		    dummybig.I=work->i;	/* has turned into an fixnum */
		    prunei(work);	/* return fixnum cell	     */
		} else {
		    result->val = work;
		} 
		break;
	    case DOUB:
		(result->val = newdoub())->r = work->r;
		restype = DOUB;
		break;
	    default:
		errorh1(Vermisc,"Internal quotient error #1: ",nil,FALSE,0,
					 work);
		goto urk;
	    }
	}

	/* now loop through the rest of the arguments dividing them
	 * into the running result in result or dummybig.I
	 */
	for(; mynp < oldnp; mynp++)
	{
	    work = mynp->val;
	    switch(TYPE(work)) {
	    case INT:
		if (work->i==0)
		    kill(getpid(),8);
		switch(restype) {
		case SDOT:	/* there is no fast routine to destructively
				   divide a bignum by an int, so do it the
				   hard way. */
		    dummybig.I = work->i;
		    divbig(result->val,(lispval)&dummybig,&quotient,(lispval *)0);
		    pruneb(result->val);
		on1:
		    /* check if the result has turned into a fixnum */
		    restype = TYPE(quotient);
		    if(restype==INT) {		/* Either INT or SDOT */
			dummybig.I=quotient->i;	/* has turned into an fixnum */
			prunei(quotient);	/* return fixnum cell	     */
		    } else
			result->val = quotient;
		    break;
		case INT:	/* divide int by int */
		    dummybig.I /= work->i;
		    break;
		case DOUB:
		    result->val->r /= work->i;
		    break;
		default:
		    errorh1(Vermisc,"Internal quotient error #2: ",nil,FALSE,0,
					 result->val);
		    goto urk;
		}
		break;
	    case SDOT:
		switch(restype) {
		case INT:
		    /* Although it seems that dividing an int
		     * by a bignum can only lead to zero, it is
		     * concievable that the bignum is improperly boxed,
		     * i.e. actually an int.
		     */
		    divbig((lispval)&dummybig,work,&quotient,(lispval *)0);
		    goto on1;

		case SDOT:
		    /* dividing one bignum by another. */
		    divbig(result->val,work,&quotient,(lispval *)0);
		    pruneb(result->val);
		    goto on1;
		case DOUB:
		    /* dividing a bignum into a flonum.
		     */
		    result->val->r /= Ifloat(work);
		    break;
		default:
		    errorh1(Vermisc,"Internal quotient error #3: ",nil,FALSE,0,
					 result->val);
		    goto urk;
		}
		break;

	    case DOUB:
		switch(restype) {
		case SDOT: /* Divide bignum by flonum converting to flonum
			    * May die due to overflow */
		    flacc = Ifloat(result->val) / work->r;
		    pruneb(result->val);
		scrimp:
		    (result->val = newdoub())->r = flacc;
		    restype = DOUB;
		    break;
		case INT: /* dividing a flonum into a fixnum. 
			   * The result will be a flonum. */

		    flacc = ((double) dummybig.I) / work->r;
		    goto scrimp;
		case DOUB: /* dividing a flonum into a flonum, what
			    * could be easier?
			    */
		    result->val->r /= work->r;
		    break;
		default:
		        errorh1(Vermisc,"Internal quotient error #4: ",nil,
						 FALSE,0, result->val);
			goto urk;
		}
		    break;
	    default:
		    errorh1(Vermisc,"Non-number to quotient ",nil,FALSE,0,work);
	    }
	}
out:
	work = result->val;
	switch(restype){
	case SDOT:
	case DOUB:
	    break;
	case INT:
	    work = inewint(dummybig.I);
	    break;
	default:
	urk:
	    errorh1(Vermisc,"Internal quotient error #5: ",nil,FALSE,0,
					 work);
	}
	Restorestack();
	return(work);
}


lispval Lfp()
{
	register temp = 0;
	register struct argent *argp; 

	for(argp = lbot; argp < np; argp++)
	    if(TYPE(argp->val) != INT)
	    	errorh1(Vermisc,"+: non fixnum argument ",
				nil,FALSE,0,argp->val);
	    else
		temp += argp->val->i;
	return(inewint(temp));
}

lispval Lfm()
{
	register temp;
	register struct argent *argp;

	if(lbot==np)return(inewint(0));
	   if(TYPE(lbot->val) != INT)
	   	errorh1(Vermisc,"-: non fixnum argument ",
				nil,FALSE,0,lbot->val);
	   else
	       temp = lbot->val->i;
	if(lbot+1==np) return(inewint(-temp));
	for(argp = lbot+1; argp < np; argp++)
	    if(TYPE(argp->val) != INT)
	        errorh1(Vermisc,"-: non fixnum argument ",
				nil,FALSE,0,argp->val);
	    else
		temp -= argp->val->i;
	return(inewint(temp));
}

lispval Lft()
{
	register temp = 1;
	register struct argent *argp;

	for(argp = lbot; argp < np; argp++)
	    if(TYPE(argp->val) != INT)
	        errorh1(Vermisc,"*: non fixnum argument ",
				nil,FALSE,0,argp->val);
	    else
		temp *= argp->val->i;
	return(inewint(temp));
}

lispval Lflessp()
{
	register struct argent *argp = lbot;
	register old, new;

	if(np < argp + 2) return(nil);
	old = argp->val->i; argp++;
	for(; argp < np; argp++)
		if(TYPE(argp->val) != INT)
			errorh1(Vermisc,"<: non fixnum argument ",
			nil,FALSE,0,argp->val);
		else {
			new = argp->val->i;
			if(!(old < new)) return(nil);
			old = new;
		}
	return(tatom);
}

lispval Lfd()
{
	register temp = 0;
	register struct argent *argp;

	if(lbot==np)return(inewint(1));
	if(TYPE(lbot->val) != INT)
	    errorh1(Vermisc,"/: non fixnum argument ",
	    		nil,FALSE,0,lbot->val);
	temp = lbot->val->i;
	if(lbot+1==np) return(inewint(1/temp));
	for(argp = lbot+1; argp < np; argp++)
	    if(TYPE(argp->val) != INT)
	        errorh1(Vermisc,"/: non fixnum argument ",
	    		nil,FALSE,0,argp->val);
	    else
		temp /= argp->val->i;
	return(inewint(temp));
}

lispval Lfadd1()
{
    chkarg(1,"1+");
    if(TYPE(lbot->val) != INT)
        errorh1(Vermisc,"1+: non fixnum argument ",
			nil,FALSE,0,lbot->val);
    return(inewint(lbot->val->i + 1));
}

/*
 * Lfexpt	(^ 'x_a 'x_b)
 *   exponentiation of fixnums x_a and x_b returning a fixnum
 * result
 */
lispval Lfexpt()
{
    register int base;
    register int exp;
    register int res;
    
    chkarg(2,"^");
    if((TYPE(lbot[0].val) != INT ) || (TYPE(lbot[1].val) != INT))
      errorh2(Vermisc,"^: non fixnum arguments", nil,0,
      		lbot[0].val,lbot[1].val);
		
    base = lbot[0].val->i;
    exp = lbot[1].val->i;

    if(base == 0)
    {
	/* 0^0 == 1,  0 to any other power (even negative powers)
	 *  is zero (according to Maclisp)
	 */
	if(exp == 0) return(inewint(1));
	else return(inewint(0));
    }
    else if(base == 1)
        /*
	 *  1 to any power is 1
	 */
	return(lbot[0].val);	/* == 1 */
    else if(exp == 0)
    	/*
	 * anything to the zero power is 1
	 */
	return(inewint(1));
    else if(base == -1)
    {
        /*
	 * -1 to an even power is 1, to an odd is -1
	 */
	if(exp & 1) return(lbot[0].val);
	else return(inewint(1));
    }
    else if(exp < 0)
        /*
	 * anything not 0,-1,or 1  to a negative power is 0
	 *
	 */
	 return(inewint(0));

    /* compute exponentiation.  This should check for overflows,
       I suppose. --jkf
     */
    res = 1;
    while( exp > 0)
    {
	if( exp & 1 )
	{   /* odd, just multiply by one */
	    res = res * base;
	    exp--;
	}
	else {
	    /* even, square base */
	    base = base * base;
	    exp = exp / 2;
	}
    }
    return(inewint(res));
}
	    
    

lispval Lfsub1()
{
    chkarg(1,"1-");
    if(TYPE(lbot->val) != INT)
        errorh1(Vermisc,"1-: non fixnum argument ",
			nil,FALSE,0,lbot->val);
    return(inewint(lbot->val->i - 1));
}

lispval
Ldbtofl()
{
	float x;
	chkarg(1,"double-to-float");

	if(TYPE(lbot->val) != DOUB)
        errorh1(Vermisc,"double-to-float: non flonum argument ",
			nil,FALSE,0,lbot->val);
	x = lbot->val->r;
	return(inewint(*(long *)&x));
}

lispval
Lfltodb()
{
	register lispval handy;
	chkarg(1,"float-to-double");

	if(TYPE(lbot->val) != INT)
        errorh1(Vermisc,"float-to-double: non fixnum argument ",
			nil,FALSE,0,lbot->val);
	handy = newdoub();
	handy->r = *(float *)lbot->val;
	return(handy);
}
EndOfFile
cat >  franz/vax/../lam5.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam5.c,v 1.7 83/12/09 16:36:12 sklower Exp $";
#endif

/*					-[Fri Aug  5 12:49:06 1983 by jkf]-
 * 	lam5.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "chkrtab.h"
#include <ctype.h>
char *strcpy(), *sprintf();

/*===========================================
-
-	explode functions: aexplode , aexplodec, aexploden
- The following function partially implement the explode functions for atoms.
-  The full explode functions are written in lisp and call these for atom args.
-
-===========================================*/

#include "chars.h"
lispval
Lexpldx(kind,slashify)
int kind, slashify; 	/* kind = 0 => explode to characters 
				= 1 => explode to fixnums (aexploden)
			   slashify = 0 => do not quote bizarre characters
				    = 1 => quote bizarre characters
			*/
{
	int typ, i;
	char ch, *strb, strbb[BUFSIZ], *alloca();  /* temporary string buffer */
	register lispval last, handy;
	extern int uctolc;
	register char *cp;
	Savestack(3); /* kludge register save mask */
#ifdef SPISFP
	Keepxs();
#endif

	chkarg(1,"expldx");

	handy = Vreadtable->a.clb;
	chkrtab(handy);
	handy = lbot->val;
	*strbuf = 0;
	typ=TYPE(handy);	/* we only work for a few types */


	/* put the characters to return in the string buffer strb */

	switch(typ) {
	case STRNG:
		if(slashify && !Xsdc)
		    errorh1(Vermisc,"Can't explode without string delimiter",nil
					  ,FALSE,0,handy);
		
		strb = strbb;
		if(slashify) *strb++ = Xsdc;
		/* copy string into buffer, escape only occurances of the 
		   double quoting character if in slashify mode
		*/
		for(cp = (char *) handy; *cp; cp++)
		{
		  if(slashify &&
		     (*cp == Xsdc || synclass(ctable[*cp])==CESC))
			 *strb++ = Xesc;
		  *strb++ = *cp;
		}
		if(slashify) *strb++ = Xsdc;
		*strb = NULL_CHAR ;
		strb = strbb;
		break;

	case ATOM:
		strb = handy->a.pname;
		if(slashify && (strb[0]==0)) {
			strb = strbb;
			strbb[0] = Xdqc;
			strbb[1] = Xdqc;
			strbb[2] = 0;
		} else
	/*common:*/
		if(slashify != 0)
		{
			char *out = strbb;
			unsigned char code;

			cp = strb;
			strb = strbb;
			code = ctable[(*cp)&0177];
			switch(synclass(code)) {
			case CNUM:
				*out++ = Xesc;
				break;
			case CCHAR:
				if(uctolc && isupper((*cp)&0177)) {
				    *out++ = Xesc;
				}
				break;
			default:
			    switch(code&QUTMASK) {
			    case QWNUNIQ:
				    if (cp[1]==0) *out++ = Xesc;
				    break;
			    case QALWAYS:
			    case QWNFRST:
				    *out++ = Xesc;
			    }
			}
			*out++ = *cp++;
			for(; *cp; cp++)
			{
				if(((ctable[*cp]&QUTMASK)==QALWAYS) ||
				   (uctolc && isupper(*cp)))
					*out++ = Xesc;
				*out++ = *cp;
			}
			*out = 0;
		}
		break;
				
	case INT:
		strb = strbb;
		sprintf(strb, "%d", lbot->val->i);
		break;
	case DOUB:
		strb = strbb;
		lfltpr(strb, lbot->val->r);
		break;
	case SDOT:
	{
		struct _iobuf _strbuf;
		int count;
		for((handy = lbot->val), count = 12;
		    handy->s.CDR!=(lispval) 0;
		    (handy = handy->s.CDR), count += 12);
		strb = alloca(count);

		_strbuf._flag = _IOWRT+_IOSTRG;
		_strbuf._ptr = strb;
		_strbuf._cnt = count;
		pbignum(lbot->val,&_strbuf);
		putc(0,&_strbuf);
		break;
	}
	default:
			errorh1(Vermisc,"EXPLODE ARG MUST BE STRING, SYMBOL, FIXNUM, OR FLONUM",nil,FALSE,0,handy);
			Restorestack();
			Freexs();
			return(nil);
		}


	if( strb[0] != NULL_CHAR )	/* if there is something to do */
	{
	    lispval prev;

	    protect(handy = last = newdot()); 
	    strbuf[1] = NULL_CHAR ;     /* set up for getatom */
	    atmlen = 2;

	    for(i=0; ch = strb[i++]; ) {
		switch(kind) {

		  case 0: strbuf[0] = hash = ch;   /* character explode */
			  last->d.car = (lispval) getatom(TRUE); /* look in oblist */
			  break;

		  case 1: 
			  last->d.car = inewint(ch);
			  break;
		}

		/* advance pointers */
		prev = last;
		last->d.cdr = newdot();
		last = last->d.cdr;
	    }

	    /* end list with a nil pointer */
	    prev->d.cdr = nil;
	    Freexs();
	    Restorestack();
	    return(handy);
	}
	Freexs();
	Restorestack();
	return(nil);	/* return nil if no characters */
}

/*===========================
-
- (aexplodec 'atm) returns (a t m)
- (aexplodec 234) returns (\2 \3 \4)
-===========================*/

lispval
Lxpldc()
{ return(Lexpldx(0,0)); }


/*===========================
-
- (aexploden 'abc) returns (65 66 67)
- (aexploden 123)  returns (49 50 51)
-=============================*/


lispval
Lxpldn()
{ return(Lexpldx(1,0)); }

/*===========================
-
- (aexplode "123")  returns (\\ \1 \2 \3);
- (aexplode 123)  returns (\1 \2 \3);
-=============================*/

lispval
Lxplda()
{ return(Lexpldx(0,1)); }

/*
 * (argv) returns how many arguments where on the command line which invoked
 * lisp; (argv i) returns the i'th argument made into an atom;
 */

lispval
Largv()
{
	register lispval handy;
	extern int Xargc;
	extern char **Xargv;

	if(lbot-np==0)handy = nil;
	else handy = lbot->val;
	
	if(TYPE(handy)==INT && handy->i>=0 && handy->i<Xargc) {
		strcpy(strbuf,Xargv[handy->i]);
		return(getatom(FALSE));
	} else { 
		return(inewint(Xargc));
	}
}
/*
 * (chdir <atom>) executes a chdir command
 * if successful, return t otherwise returns nil
 */
lispval Lchdir(){
	register char *filenm;

	chkarg(1,"chdir");
	filenm = (char *) verify(lbot->val,"chdir - non symbol or string arg");
	if(chdir(filenm)>=0)
		return(tatom);
	else
		return(nil);
}

/* ==========================================================
-
-	ascii   - convert from number to ascii character
-
- form:(ascii number)
-
-	the number is checked so that it is in the range 0-255
- then it is made a character and returned
- =========================================================*/

lispval
Lascii() 
{
	register lispval handy;

	handy = lbot->val;		/* get argument */

	if(TYPE(handy) != INT)		/* insure that it is an integer */
	{	error("argument not an integer",FALSE);
		return(nil);
	}

	if(handy->i < 0 || handy->i > 0377)	/* insure that it is in range*/
	{	error("argument is out of ascii range",FALSE);
		return(nil);
	}

	strbuf[0] = handy->i ;	/* ok value, make into a char */
	strbuf[1] = NULL_CHAR;

	/* lookup and possibly intern the atom given in strbuf */

	return( (lispval) getatom(TRUE) );
}

/*
 *  boole - maclisp bitwise boolean function
 *  (boole k x y) where k determines which of 16 possible bitwise 
 *  truth tables may be applied.  Common values are 1 (and) 6 (xor) 7 (or)
 *  the result is mapped over each pair of bits on input
 */
lispval
Lboole(){
	register x, y;
	register struct argent *mynp;
	int k;

	if(np - lbot < 3)
		error("Boole demands at least 3 args",FALSE);
	mynp = lbot+AD;
	k = mynp->val->i & 15;
	x = (mynp+1)->val->i;
	for(mynp += 2; mynp < np; mynp++) {
		y = mynp->val->i;
		switch(k) {

		case 0: x = 0;
			break;
		case 1: x = x & y;
			break;
		case 2:	x = y & ~x;
			break;
		case 3:	x = y;
			break;
		case 4: x = x & ~y;
			break;
		/* case 5:	x = x; break; */
		case 6:	x = x ^ y;
			break;
		case 7:	x = x | y;
			break;
		case 8: x = ~(x | y);
			break;
		case 9: x = ~(x ^ y);
			break;
		case 10: x = ~x;
			break;
		case 11: x = ~x | y;
			break;
		case 12: x = ~y;
			break;
		case 13: x = x | ~y;
			break;
		case 14: x = ~x | ~y;
			break;
		case 15: x = -1;
		}
	}
	return(inewint(x));
}
lispval
Lfact()
{
	register lispval result, handy;
	register itemp;
	Savestack(3); /* fixup entry mask */

	result = lbot->val;
	if(TYPE(result)!=INT) error("Factorial of Non-fixnum.  If you want me\
to calculate fact of > 2^30 We will be here till doomsday!.",FALSE);
	itemp = result->i;
	protect(result = newsdot());
	result->s.CDR=(lispval)0;
	result->i = 1;
	for(; itemp > 1; itemp--)
		dmlad(result,(long)itemp,0L);
	if(result->s.CDR) 
	{
	    Restorestack();
	    return(result);
	}
	handy = inewint(result->s.I);
	pruneb(result);
	Restorestack();
	return(handy);
}
/*
 * fix -- maclisp floating to fixnum conversion
 * for the moment, mereley convert floats to ints.
 * eventual convert to bignum if too big to fit.
 */
 lispval Lfix() 
 {
	register lispval handy;
	double floor();

	chkarg(1,"fix");
	handy = lbot->val;
	switch(TYPE(handy)) {
	default:
		error("innaproriate arg to fix.",FALSE);
	case INT:
	case SDOT:
		return(handy);
	case DOUB:
		return(inewint((int)floor(handy->r)));
	}
}
/*
 * (frexp <real no>)
 * returns a dotted pair (<exponent>. <bignum>)
 * such that bignum is 56 bits long, and if you think of the binary
 * point occuring after the high order bit, <real no> = 2^<exp> * <bignum>
 *
 * myfrexp is an assembly language routine found in bigmath.s to do exactly
 * what is necessary to accomplish this.
 * this routine is horribly vax specific.
 *
 * Lfix should probably be rewritten to take advantage of myfrexp
 */
lispval
Lfrexp()
{
	register lispval handy, result;
	int exp, hi, lo;

	Savestack(2);
	chkarg(1,"frexp");

	myfrexp(lbot->val->r, &exp, &hi, &lo);
	if(lo < 0) {
		/* normalize for bignum */
		lo &= ~ 0xC0000000;
		hi += 1;
	}
	result = handy = newdot(); 
	protect(handy);
	handy->d.car = inewint(exp);
	if(hi==0&&lo==0) {
		handy->d.cdr = inewint(0);
	} else {
		handy = handy->d.cdr = newsdot();
		handy->s.I = lo;
		handy = handy->s.CDR = newdot();
		handy->s.I = hi;
		handy->s.CDR = 0;
	}
	np--;
	Restorestack();
	return(result);
}

#define SIGFPE 8
#define B 1073741824.0
static double table[] = { 1.0, B, B*B, B*B*B, B*B*B*B, 0.0};

lispval
Lfloat()
{
	register lispval handy,result;
	register double sum = 0;
	register int count;
	chkarg(1,"float");
	handy = lbot->val;
	switch(TYPE(handy))
	{
	  case DOUB: return(handy);


	  case INT:  result = newdoub();
		     result->r = (double) handy->i;
		     return(result);
	  case SDOT: 
	  {
		for(handy = lbot->val, count = 0;
		    count < 5;
		    count++, handy = handy->s.CDR) {
			sum += handy->s.I * table[count];
			if(handy->s.CDR==(lispval)0) goto done;
		}
		kill(getpid(),SIGFPE);
	done:
		result = newdoub();
		result->r = sum;
		return(result);
	}
	  default: errorh1(Vermisc,"Bad argument to float",nil,FALSE,0,handy);
	  /* NOTREACHED */
	}
}
double
Ifloat(handy)
register lispval handy;
{
	register double sum = 0.0; register int count=0;
	for(; count < 5; count++, handy = handy->s.CDR) {
		sum += handy->s.I * table[count];
		if(handy->s.CDR==(lispval)0) goto done;
	}
	kill(getpid(),SIGFPE);
	done:
	return(sum);
}

/* Lbreak ***************************************************************/
/* If first argument is not nil, this is evaluated and printed.  Then	*/
/* error is called with the "breaking" message.				*/
lispval Lbreak() {

	if (np > lbot) {
		printr(lbot->val,poport);
		dmpport(poport);
	}
	return(error("",TRUE));
}


lispval
LDivide() {
	register lispval result, work;
	register struct argent *mynp;
	lispval quo, rem, arg1, arg2; struct sdot dummy, dum2;
	Savestack(3);

	chkarg(2,"Divide");
	mynp = lbot;
	work = mynp++->val;
	switch(TYPE(work)) {
	case INT:
		arg1 = (lispval) &dummy;
		dummy.I = work->i;
		dummy.CDR = (lispval) 0;
		break;
	case SDOT:
		arg1 = work;
		break;
	urk:
	default:
		error("First arg to divide neither a bignum nor int.",FALSE);
	}
	work = mynp->val;
	switch(TYPE(work)) {
	case INT:
		arg2 = (lispval) &dum2;
		dum2.I = work->i;
		dum2.CDR = (lispval) 0;
		break;
	case SDOT:
		arg2 = work;
		break;
	default:
		goto urk;
	}
	divbig(arg1,arg2, &quo, &rem);
	protect(quo);
	if(rem==((lispval)&dummy))
		rem = inewint(dummy.I);
	protect(rem);
	protect(result = work = newdot());
	work->d.car = quo;
	(work->d.cdr = newdot())->d.car = rem;
	Restorestack();
	return(result);
}

lispval LEmuldiv(){
	register struct argent * mynp = lbot+AD;
	register lispval work, result;
	int quo, rem;
	Savestack(3); /* fix register mask */

	/* (Emuldiv mul1 mult2 add quo) => 
		temp = mul1 + mul2 + sext(add);
		result = (list temp/quo temp%quo);
		to mix C and lisp a bit */

	Imuldiv(mynp[0].val->i, mynp[1].val->i, mynp[2].val->i,
		mynp[3].val->i, &quo, &rem);
	protect(result=newdot());
	(result->d.car=inewint(quo));
	work = result->d.cdr = newdot();
	(work->d.car=inewint(rem));
	Restorestack();
	return(result);
}
EndOfFile
cat >  franz/vax/../lam6.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam6.c,v 1.7 85/03/24 11:04:21 sklower Exp $";
#endif

/*					-[Sun Sep  4 08:56:19 1983 by jkf]-
 * 	lam6.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "frame.h"
#include <signal.h>
#include <sys/types.h>
#include <sys/times.h>
#include "chkrtab.h"
#include "chars.h"


lispval
Lreadli()
{
	register lispval work, handy;
	register FILE *p;
	register char *string; char *alloca();
	FILE *fstopen();
	lispval Lread();
	int count;
	pbuf pb;
	Savestack(4);
#ifdef SPISFP
	Keepxs();
#endif

	if(lbot->val==nil) {		/*effectively, return(matom(""));*/
		strbuf[0] = 0;
		return(getatom(FALSE));
	}
	chkarg(1,"readlist");
	count = 1;

	/* compute length of list */
	for(work = lbot->val; TYPE(work)==DTPR; work=work->d.cdr)
		count++;
	string = alloca(count);
	p = fstopen(string, count - 1, "r");
	for(work = lbot->val; TYPE(work)==DTPR; work=work->d.cdr) {
		handy = work->d.car;
		switch(TYPE(handy)) {
		case SDOT:
		case INT:
			*string++=handy->i;
			break;
		case ATOM:
			*string++ = *(handy->a.pname);
			break;
		case STRNG:
			*string++ = *(char *)handy;
			break;
		default:
		        fclose(p);
			error("Non atom or int to readlist",FALSE);
		}
	}
	*string = 0;
	errp = Pushframe(F_CATCH,Veruwpt,nil);	/* must unwind protect
						   so can deallocate p
						 */
	switch(retval) { lispval Lctcherr();
	case C_THROW:
			/* an error has occured and we are given a chance
			   to unwind before the control goes higher
			   lispretval contains the error descriptor in
			   it's cdr
			 */
		      fclose(p);	/* free port */
		      errp = Popframe();
		      Freexs();
		      lbot = np;
		      protect(lispretval->d.cdr); /* error descriptor */
		      return(Lctcherr());	/* do a I-do-throw */
		      
	case C_INITIAL: 
			lbot = np;
			protect(P(p));
			work = Lread();  /* error  could occur here */
			Freexs();
			fclose(p);	/* whew.. no errors */
			errp = Popframe();	/* remove unwind-protect */
			Restorestack();
			return(work);
	}
	/* NOTREACHED */
}

lispval
Lgetenv()
{
	char *getenv(), *strcpy();
	char *res;
	chkarg(1,"getenv");
	

	if((TYPE(lbot->val))!=ATOM)
		error("argument to getenv must be atom",FALSE);

	res = getenv(lbot->val->a.pname);
	if(res) strcpy(strbuf,res);
	else strbuf[0] = '\0';
	return(getatom(FALSE));
}

lispval
Lboundp()
{
	register lispval result, handy;

	chkarg(1,"boundp");

	if((TYPE(lbot->val))!=ATOM)
		error("argument to boundp must be symbol",FALSE);
	if( (handy = lbot->val)->a.clb==CNIL)
		result = nil;
	else
		(result = newdot())->d.cdr = handy->a.clb;
	return(result);
}


lispval
Lplist()
{	
	register lispval atm;
	/* get property list of an atom or disembodied property list */

	chkarg(1,"plist");
	atm = lbot->val;
	switch(TYPE(atm)) {
	case ATOM:
	case DTPR:
		break;
	default:
		error("Only Atoms and disembodied property lists allowed for plist",FALSE);
	}
	if(atm==nil) return(nilplist);
	return(atm->a.plist);
}


lispval
Lsetpli()
{	/* set the property list of the given atom to the given list */
	register lispval atm, vall;

	chkarg(2,"setplist");
	atm = lbot->val;
	if (TYPE(atm) != ATOM) 
	   error("setplist: First argument must be an symbol",FALSE);
	vall = (np-1)->val;
	if (TYPE(vall)!= DTPR && vall !=nil)
	    error("setplist: Second argument must be a list",FALSE);
	if (atm==nil)
		nilplist = vall;
	else
		atm->a.plist = vall;
	return(vall);
}

lispval
Lsignal()
{
	register lispval handy, old, routine;
	int i;
	int sginth();

	switch(np-lbot) {

	case 1: routine = nil;		/* second arg defaults to nil */
		break;

	case 2: routine = lbot[1].val;
		break;			/* both args given 		*/

	default: argerr("signal");
	}

	handy = lbot->val;
	if(TYPE(handy)!=INT)
		error("First arg to signal must be an int",FALSE);
	i = handy->i & 15;

	if(TYPE(routine)!=ATOM)
		error("Second arg to signal must be an atom",FALSE);
	old = sigacts[i];

	if(old==0) old = nil;

	if(routine==nil)
		sigacts[i]=((lispval) 0);
	else
		sigacts[i]=routine;
	if(routine == nil)
	    signal(i,SIG_IGN);	/* ignore this signals */
	else if (old == nil)
	    signal(i,sginth);	/* look for this signal */
	if(i == SIGINT) sigintcnt = 0; /* clear memory */
	return(old);
}

lispval
Lassq()
{
	register lispval work, handy;

	chkarg(2,"assq");

	for(work = lbot[1].val, handy = lbot[0].val; 
	    (work->d.car->d.car != handy) && (work != nil);
	    work = work->d.cdr);
	return(work->d.car);
}

lispval
Lkilcopy()
{
	if(fork()==0) {
		abort();
	}
}

lispval
Larg()
{
	register lispval handy; register offset, count;

	handy = lexpr_atom->a.clb;
	if(handy==CNIL || TYPE(handy)!=DTPR)
		error("Arg: not in context of Lexpr.",FALSE);
	count = ((long *)handy->d.cdr) -1 - (long *)handy->d.car;
	if(np==lbot || lbot->val==nil)
		return(inewint(count+1));
	if(TYPE(lbot->val)!=INT || (offset = lbot->val->i - 1) > count || offset < 0 )
		error("Out of bounds: arg to \"Arg\"",FALSE);
	return( ((struct argent *)handy->d.car)[offset].val);
}

lispval
Lsetarg()
{
	register lispval handy, work;
	register limit, index;

	chkarg(2,"setarg");
	handy = lexpr_atom->a.clb;
	if(handy==CNIL || TYPE(handy)!=DTPR)
		error("Arg: not in context of Lexpr.",FALSE);
	limit = ((long *)handy->d.cdr) - 1 -  (long *)(work = handy->d.car);
	handy = lbot->val;
	if(TYPE(handy)!=INT)
		error("setarg: first argument not integer",FALSE);
	if((index = handy->i - 1) < 0 || index > limit)
		error("setarg: index out of range",FALSE);
	return(((struct argent *) work)[index].val = lbot[1].val);
}

lispval
Lptime(){
	extern int gctime;
	int lgctime = gctime;
	struct tms current;
	register lispval result, handy;
	Savestack(2);

	times(&current);
	result = newdot();
	handy = result;
	protect(result);
	result->d.cdr = newdot();
	result->d.car = inewint(current.tms_utime);
	handy = result->d.cdr;
	handy->d.car = inewint(lgctime);
	handy->d.cdr = nil;
	if(gctime==0)
		gctime = 1;
	Restorestack();
	return(result);
}

/* (err-with-message message [value])
   'message' is the error message to print.
   'value' is the value to return from the errset (if present).
	it defaults to nil.
    The message may not be printed if there is an (errset ... nil)
    pending.
 */

lispval Lerr()
{
	lispval errorh();
	lispval valret = nil;
	char *mesg;
	

	switch(np-lbot) {
	 case 2: valret = lbot[1].val;	/* return non nil */
	 case 1: mesg = (char *)verify(lbot[0].val,
	  			  "err-with-message: non atom or string arg");
		 break;
	 default: argerr("err-with-message");
	}
	
	return(errorh(Vererr,mesg,valret,FALSE,1));
}

/*
 *  (tyi ['p_port ['g_eofval]])
 * normally -1 is return on eof, but g_eofval will be returned if given.
 */
lispval
Ltyi()
{
	register FILE *port;
	register lispval handy;
	lispval eofval;
	int val;	/* really char but getc returns int on eof */
	int eofvalgiven;

	handy = nil;   /* default port */
	eofvalgiven = FALSE;  /* assume no eof value given */
	switch(np-lbot)
	{
	    case 2:  eofval = lbot[1].val;
	    	     eofvalgiven = TRUE;
	    case 1:  handy = lbot[0].val;	/* port to read */
	    case 0: 
		     break;
	    default: argerr("tyi");
	}

	port = okport(handy,okport(Vpiport->a.clb,stdin));


	fflush(stdout);		/* flush any pending output characters */
	val = getc(port);
	if(val==EOF)
	{
		clearerr(port);
		if(sigintcnt > 0) sigcall(SIGINT);  /* eof might mean int */
		if(eofvalgiven) return(eofval);
		else return(inewint(-1));
	}
	return(inewint(val));
}

/* Untyi (added by DNC Feb. '80) - (untyi number port) puts the
   character with ascii code number in the front of the input buffer of
   port.  Note that this buffer is limited to 1 character.  That buffer is
   also written by tyipeek, so a peek followed by an untyi will result in
   the loss of the peeked char.
 */
   
lispval
Luntyi()
{

    lispval port,ch;

    port = nil;

    switch(np-lbot) {
	case 2: port = lbot[1].val;
	case 1: ch = lbot[0].val;
		break;
	default:
		argerr("untyi");
    }

    if(TYPE(ch) != INT) {
       errorh1(Vermisc, "untyi: expects fixnum character ",
       			nil,FALSE,0,ch);
    }	

    ungetc((int) ch->i,okport(port,okport(Vpiport->a.clb,stdin)));
    return(ch);
}

lispval
Ltyipeek()
{
	register FILE *port;
	register lispval handy;
	int val;

	switch(np-lbot)
	{
	    case 0:  handy = nil;	/* default port */
		     break;
	    case 1:  handy = lbot->val;
		     break;
	    default: argerr("tyipeek");
	}

	port = okport(handy,okport(Vpiport->a.clb,stdin));

	fflush(stdout);		/* flush any pending output characters */
	val = getc(port);
	if(val==EOF)
		clearerr(port);
	ungetc(val,port);
	return(inewint(val));
}

lispval
Ltyo()
{
	register FILE *port;
	register lispval handy, where;
	char val;

	switch(np-lbot)
	{
	    case 1:  where = nil;	/* default port */
		     break;
	    case 2:  where = lbot[1].val;
		     break;
	    default: argerr("tyo");
	}

	handy = lbot->val;
	if(TYPE(handy)!=INT)
		error("Tyo demands number for 1st arg",FALSE);
	val = handy->i;

	port = (FILE *) okport(where,okport(Vpoport->a.clb,stdout));
	putc(val,port);
	return(handy);
}

lispval
Imkrtab(current)
{
	extern struct rtab {
		unsigned char ctable[132];
	} initread;
	register lispval handy; extern lispval lastrtab;

	static int cycle = 0;
	static char *nextfree;
	Savestack(3);
	
	if((cycle++)%3==0) {
		nextfree = (char *) csegment(STRNG,1,FALSE);
		mrtabspace = (lispval) nextfree;
		/* need to protect partially allocated read tables
		   from garbage collection. */
	}
	handy = newarray();
	protect(handy);
	
	handy->ar.data = nextfree;
	if(current == 0)
		*(struct rtab *)nextfree = initread;
	else
	{
		register index = 0; register char *cp = nextfree;
		lispval c;

		*(struct rtab *)cp = *(struct rtab *)ctable;
		for(; index < 128; index++) {
		    switch(synclass(cp[index])) {
		    case CSPL: case CSSPL: case CMAC: case CSMAC:
		    case CINF: case CSINF:
			strbuf[0] = index;
			strbuf[1] = 0;
			c = (getatom(TRUE));
			Iputprop(c,Iget(c,lastrtab),handy);
		    }
		}
	}
	handy->ar.delta = inewint(4);
	handy->ar.length = inewint(sizeof(struct rtab)/sizeof(int));
	handy->ar.accfun = handy->ar.aux  = nil;
	nextfree += sizeof(struct rtab);
	Restorestack();
	return(handy);
}

/* makereadtable - arg : t or nil
	returns a readtable, t means return a copy of the initial readtable

			     nil means return a copy of the current readtable
*/
lispval
Lmakertbl()
{
	lispval handy = Vreadtable->a.clb;
	lispval value;
	chkrtab(handy);

	if(lbot==np) value = nil;
	else if(TYPE(value=(lbot->val)) != ATOM) 
		error("makereadtable: arg must be atom",FALSE);

	if(value == nil) return(Imkrtab(1));
	else return(Imkrtab(0));
}

lispval
Lcpy1()
{
	register lispval handy = lbot->val, result = handy;

top:
	switch(TYPE(handy))
	{
	case INT:
		result = inewint(handy->i);
		break;
	case VALUE:
		(result = newval())->l = handy->l;
		break;
	case DOUB:
		(result = newdoub())->r = handy->r;
		break;
	default:
		lbot->val =
		    errorh1(Vermisc,"Bad arg to cpy1",nil,TRUE,67,handy);
		goto top;
	}
	return(result);
}

/* copyint* . This returns a copy of its integer argument.  The copy will
 *	 be a fresh integer cell, and will not point into the read only
 *	 small integer table.
 */
lispval
Lcopyint()
{
	register lispval handy = lbot->val;
	register lispval ret;

  	while (TYPE(handy) != INT)
	{ handy=errorh1(Vermisc,"copyint* : non integer arg",nil,TRUE,0,handy);}
	(ret = newint())->i = handy->i;
	return(ret);
}


EndOfFile
cat >  franz/vax/../lam7.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam7.c,v 1.8 84/04/06 23:09:07 layer Exp $";
#endif

/*					-[Fri Aug  5 12:51:31 1983 by jkf]-
 * 	lam7.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include <signal.h>

char *sprintf();

lispval
Lfork() {
	int pid;

	chkarg(0,"fork");
	if ((pid=fork())) {
		return(inewint(pid));
	} else
		return(nil);
}

lispval
Lwait()
{
	register lispval ret, temp;
	int status = -1, pid;
	Savestack(2);


	chkarg(0,"wait");
	pid = wait(&status);
	ret = newdot();
	protect(ret);
	temp = inewint(pid);
	ret->d.car = temp;
	temp = inewint(status);
	ret->d.cdr = temp;
	Restorestack();
	return(ret);
}

lispval
Lpipe()
{
	register lispval ret, temp;
	int pipes[2];
	Savestack(2);

	chkarg(0,"pipe");
	pipes[0] = -1;
	pipes[1] = -1;
	pipe(pipes);
	ret = newdot();
	protect(ret);
	temp = inewint(pipes[0]);
	ret->d.car = temp;
	temp = inewint(pipes[1]);
	ret->d.cdr = temp;
	Restorestack();
	return(ret);
}

lispval
Lfdopen()
{
	register lispval fd, type;
	FILE *ptr;

	chkarg(2,"fdopen");
	type = (np-1)->val;
	fd = lbot->val;
	if( TYPE(fd)!=INT )
		return(nil);
	if ( (ptr=fdopen((int)fd->i, (char *)type->a.pname))==NULL)
		return(nil);
	return(P(ptr));
}

lispval
Lexece()
{
	lispval fname, arglist, envlist, temp;
	char *args[100], *envs[100], estrs[1024];
	char *p, *cp, **argsp;

	fname = nil;
	arglist = nil;
	envlist = nil;

	switch(np-lbot) {
	case 3: envlist = lbot[2].val;
	case 2: arglist = lbot[1].val;
	case 1: fname   = lbot[0].val;
	case 0: break;
	default:
		argerr("exece");
	}

	while (TYPE(fname)!=ATOM)
	   fname = error("exece: non atom function name",TRUE);
	while (TYPE(arglist)!=DTPR && arglist!=nil)
		arglist = error("exece: non list arglist",TRUE);
	for (argsp=args; arglist!=nil; arglist=arglist->d.cdr) {
		temp = arglist->d.car;
		if (TYPE(temp)!=ATOM)
			error("exece: non atom argument seen",FALSE);
		*argsp++ = temp->a.pname;
	}
	*argsp = 0;
	if (TYPE(envlist)!=DTPR && envlist!=nil)
		return(nil);
	for (argsp=envs,cp=estrs; envlist!=nil; envlist=envlist->d.cdr) {
		temp = envlist->d.car;
		if (TYPE(temp)!=DTPR || TYPE(temp->d.car)!=ATOM
		  || TYPE(temp->d.cdr)!=ATOM)
 		     error("exece: Bad enviroment list",FALSE);
		*argsp++ = cp;
		for (p=temp->d.car->a.pname; (*cp++ = *p++);) ;
		*(cp-1) = '=';
		for (p=temp->d.cdr->a.pname; (*cp++ = *p++);) ;
	}
	*argsp = 0;
	
	return(inewint(execve(fname->a.pname, args, envs)));
}

/* Lprocess -
 * C code to implement the *process function
 * call:
 * 	(*process 'st_command ['s_readp ['s_writep]])
 * where st_command is the command to execute
 *   s_readp is non nil if you want a port to read from returned
 *   s_writep is non nil if you want a port to write to returned
 *   both flags default to nil
 * *process returns
 *    the exit status of the process if s_readp and s_writep not given
 *	(in this case the parent waits for the child to finish)
 *    a list of (readport writeport childpid) if one of s_readp or s_writep
 *    is given.  If only s_readp is non nil, then writeport will be nil,
 *    If only s_writep is non nil, then readport will be nil
 */

lispval
Lprocess()
{
	int wflag , childsi , childso , child;
	lispval handy;
	char *command, *p;
	int writep, readp;
	int itemp;
	int (*handler)(), (*signal())();
	FILE *bufs[2],*obufs[2], *fpipe();
	Savestack(0);

	writep = readp = FALSE;
	wflag = TRUE;
	
	switch(np-lbot) {
	case 3:  if(lbot[2].val != nil) writep = TRUE;
	case 2:  if(lbot[1].val != nil) readp = TRUE;
		 wflag = 0;
	case 1:  command = (char *) verify(lbot[0].val,
			   	  	    "*process: non atom first arg");
		 break;
	default:
		argerr("*process");
	}
	
	childsi = 0;
	childso = 1;

	/* if there will be communication between the processes,
	 * it will be through these pipes:
	 *  parent ->  bufs[1] ->  bufs[0] -> child    if writep
	 *  parent <- obufs[0] <- obufs[1] <- parent   if readp
	 */
	if(writep) {
	    fpipe(bufs);
	    childsi = fileno(bufs[0]);
	}
	
	if(readp) {
		fpipe(obufs);
		childso = fileno(obufs[1]);
	}
	
	handler = signal(SIGINT,SIG_IGN);
	if((child = vfork()) == 0 ) {
	        /* if we will wait for the child to finish
		 * and if the process had ignored interrupts before
		 * we were called, then leave them ignored, else
		 * set it back the the default (death)
		 */
		if(wflag && handler != SIG_IGN)
			signal(2,SIG_DFL);
			
		if(writep) {
			close(0);
			dup(childsi);
		}
		if (readp) {
			close(1);
			dup(childso);
		}
		if ((p = (char *)getenv("SHELL")) != (char *)0) {
			execlp(p , p, "-c",command,0);
			_exit(-1); /* if exec fails, signal problems*/
		} else {
			execlp("csh", "csh", "-c",command,0);
			execlp("sh", "sh", "-c",command,0);
			_exit(-1); /* if exec fails, signal problems*/
		}
	}

	/* close the duplicated file descriptors
	 * e.g. if writep is true then we've created two desriptors,
	 *  bufs[0] and bufs[1],  we will write to bufs[1] and the
	 *  child (who has a copy of our bufs[0]) will read from bufs[0]
	 *  We (the parent) close bufs[0] since we will not be reading
	 *  from it.
	 */
	if(writep) fclose(bufs[0]);
	if(readp) fclose(obufs[1]);

	if(wflag && child!= -1) {
		int status=0;
		/* we await the death of the child */
		while(wait(&status)!=child) {}
		/* the child has died */
		signal(2,handler);	/* restore the interrupt handler */
		itemp = status >> 8;
		Restorestack();
		return(inewint(itemp));	/* return its status */
	}
	/* we are not waiting for the childs death
	 * build a list containing the write and read ports
	 */
	protect(handy = newdot());
	handy->d.cdr = newdot();
	handy->d.cdr->d.cdr = newdot();
	if(readp) {
	    handy->d.car = P(obufs[0]);
	    ioname[PN(obufs[0])] = (lispval) inewstr((char *) "from-process");
	}
	if(writep) {
	    handy->d.cdr->d.car = P(bufs[1]);
	    ioname[PN(bufs[1])] = (lispval) inewstr((char *) "to-process");
	}
	handy->d.cdr->d.cdr->d.car = (lispval) inewint(child);
	signal(SIGINT,handler);
	Restorestack();
	return(handy);
}

extern int gensymcounter;

lispval
Lgensym()
{
	lispval arg;
	char leader;

	switch(np-lbot)
	{
	    case 0: arg = nil;
		    break;
	    case 1: arg = lbot->val;
		    break;
	    default: argerr("gensym");
	}
	leader = 'g';
	if (arg != nil && TYPE(arg)==ATOM)
		leader = arg->a.pname[0];
	sprintf(strbuf, "%c%05d", leader, gensymcounter++);
	atmlen = 7;
	return((lispval)newatom(0));
}

extern struct types {
char	*next_free;
int	space_left,
	space,
	type,
	type_len;			/*  note type_len is in units of int */
lispval *items,
	*pages,
	*type_name;
struct heads
	*first;
} atom_str ;

lispval
Lremprop()
{
	register struct argent *argp;
	register lispval pptr, ind, opptr;
	lispval atm;
	int disemp = FALSE;

	chkarg(2,"remprop");
	argp = lbot;
	ind = argp[1].val;
	atm = argp->val;
	switch (TYPE(atm)) {
	case DTPR:
		pptr = atm->d.cdr;
		disemp = TRUE;
		break;
	case ATOM:
		if((lispval)atm==nil)
			pptr = nilplist;
		else
			pptr = atm->a.plist;
		break;
	default:
		errorh1(Vermisc, "remprop: Illegal first argument :",
		       nil, FALSE, 0, atm);
	}
	opptr = nil;
	if (pptr==nil) 
		return(nil);
	while(TRUE) {
		if (TYPE(pptr->d.cdr)!=DTPR)
			errorh1(Vermisc, "remprop: Bad property list",
			       nil, FALSE, 0,atm);
		if (pptr->d.car == ind) {
			if( opptr != nil)
				opptr->d.cdr = pptr->d.cdr->d.cdr;
			else if(disemp)
				atm->d.cdr = pptr->d.cdr->d.cdr;
			else if(atm==nil)
				nilplist = pptr->d.cdr->d.cdr;
			else
				atm->a.plist = pptr->d.cdr->d.cdr;
			return(pptr->d.cdr);
		}
		if ((pptr->d.cdr)->d.cdr == nil) return(nil);
		opptr = pptr->d.cdr;
		pptr = (pptr->d.cdr)->d.cdr;
	}
}

lispval
Lbcdad()
{
	lispval ret, temp;

	chkarg(1,"bcdad");
	temp = lbot->val;
	if (TYPE(temp)!=ATOM)
		error("ONLY ATOMS HAVE FUNCTION BINDINGS", FALSE);
	temp = temp->a.fnbnd;
	if (TYPE(temp)!=BCD)
		return(nil);
	ret = newint();
	ret->i = (int)temp;
	return(ret);
}

lispval
Lstringp()
{
	chkarg(1,"stringp");
	if (TYPE(lbot->val)==STRNG)
		return(tatom);
	return(nil);
}

lispval
Lsymbolp()
{
	chkarg(1,"symbolp");
	if (TYPE(lbot->val)==ATOM)
		return(tatom);
	return(nil);
}

lispval
Lrematom()
{
	register lispval temp;

	chkarg(1,"rematom");
	temp = lbot->val;
	if (TYPE(temp)!=ATOM)
		return(nil);
	temp->a.fnbnd = nil;
	temp->a.pname = (char *)CNIL;
	temp->a.plist = nil;
	(atom_items->i)--;
	(atom_str.space_left)++;
	temp->a.clb=(lispval)atom_str.next_free;
	atom_str.next_free=(char *) temp;
	return(tatom);
}

#define QUTMASK 0200
#define VNUM 0000

lispval
Lprname()
{
	lispval a, ret;
	register lispval work, prev;
	char	*front, *temp; int clean;
	char ctemp[100];
	extern unsigned char *ctable;
	Savestack(2);

	chkarg(1,"prname");
	a = lbot->val;
	switch (TYPE(a)) {
		case INT:
			sprintf(ctemp,"%d",a->i);
			break;

		case DOUB:
			sprintf(ctemp,"%f",a->r);
			break;
	
		case ATOM:
			temp = front = a->a.pname;
			clean = *temp;
			if (*temp == '-') temp++;
			clean = clean && (ctable[*temp] != VNUM);
			while (clean && *temp)
				clean = (!(ctable[*temp++] & QUTMASK));
			if (clean)
				strncpy(ctemp, front, 99);
			else	
				sprintf(ctemp,"\"%s\"",front);
			break;
	
		default:
			error("prname does not support this type", FALSE);
	}
	temp = ctemp;
	protect(ret = prev = newdot());
	while (*temp) {
		prev->d.cdr = work = newdot();
		strbuf[0] = *temp++;
		strbuf[1] = 0;
		work->d.car = getatom(FALSE);
		work->d.cdr = nil;
		prev = work;
	}
	Restorestack();
	return(ret->d.cdr);
}

lispval
Lexit()
{
	register lispval handy;
	if(np-lbot==0) franzexit(0);
	handy = lbot->val;
	if(TYPE(handy)==INT)
		franzexit((int) handy->i);
	franzexit(-1);
}
lispval
Iimplode(unintern)
{
	register lispval handy, work;
	register char *cp = strbuf;
	extern int atmlen;	/* used by newatom and getatom */
	extern char *atomtoolong();

	chkarg(1,"implode");
	for(handy = lbot->val; handy!=nil; handy = handy->d.cdr)
	{
		work = handy->d.car;
		if(cp >= endstrb)
			cp = atomtoolong(cp);
	again:
		switch(TYPE(work))
		{
		case ATOM:
			*cp++ = work->a.pname[0];
			break;
		case SDOT:
			*cp++ = work->s.I;
			break;
		case INT:
			*cp++ = work->i;
			break;
		case STRNG:
			*cp++ = * (char *) work;
			break;
		default:
			work = errorh1(Vermisc,"implode/maknam: Illegal type for this arg:",nil,FALSE,44,work);
			goto again;
		}
	}
	*cp = 0;
	if(unintern) return((lispval)newatom(FALSE));
	else return((lispval) getatom(FALSE));
}

lispval
Lmaknam()
{
	return(Iimplode(TRUE));		/* unintern result */
}

lispval
Limplode()
{
	return(Iimplode(FALSE));	/* intern result */
}

lispval
Lntern()
{
	register int hash;
	register lispval handy,atpr;


	chkarg(1,"intern");
	if(TYPE(handy=lbot->val) != ATOM)
		errorh1(Vermisc,"non atom to intern ",nil,FALSE,0,handy);
	/* compute hash of pname of arg */
	hash = hashfcn(handy->a.pname);

	/* search for atom with same pname on hash list */

	atpr = (lispval) hasht[hash];
	for(atpr = (lispval) hasht[hash] 
		 ; atpr != CNIL 
		 ; atpr = (lispval)atpr->a.hshlnk)
	{
		if(strcmp(atpr->a.pname,handy->a.pname) == 0) return(atpr);
	}
	
	/* not there yet, put the given one on */

	handy->a.hshlnk = hasht[hash];
	hasht[hash] = (struct atom *)handy;
	return(handy);
}

/*** Ibindvars :: lambda bind values to variables
	called with a list of variables and values.
	does the special binding and returns a fixnum which represents
	the value of bnp before the binding
	Use by compiled progv's.
 ***/
lispval
Ibindvars()
{
    register lispval vars,vals,handy;
    struct nament *oldbnp = bnp;

    chkarg(2,"int:bindvars");

    vars = lbot[0].val;
    vals = lbot[1].val;

    if(vars == nil) return(inewint(oldbnp));

    if(TYPE(vars) != DTPR)
      errorh1(Vermisc,"progv (int:bindvars): bad first argument ", nil,
      		FALSE,0,vars);
   if((vals != nil) && (TYPE(vals) != DTPR))
     errorh1(Vermisc,"progv (int:bindvars): bad second argument ",nil,
     		FALSE,0,vals);

   for( ; vars != nil ; vars = vars->d.cdr , vals=vals->d.cdr)
   {
       handy = vars->d.car;
       if(TYPE(handy) != ATOM)
          errorh1(Vermisc,"progv (int:bindvars): non symbol argument to bind ",
	  	nil,FALSE,0,handy);
       PUSHDOWN(handy,vals->d.car);
   }
   return(inewint(oldbnp));
}


/*** Iunbindvars :: unbind the variable stacked by Ibindvars
     called by compiled progv's
 ***/
 
lispval
Iunbindvars()
{
    struct nament *oldbnp;
    
    chkarg(1,"int:unbindvars");
    oldbnp = (struct nament *) (lbot[0].val->i);
    if((oldbnp < orgbnp)  || ( oldbnp > bnp))
       errorh1(Vermisc,"int:unbindvars: bad bnp value given ",nil,FALSE,0,
       		lbot[0].val);
    popnames(oldbnp);
    return(nil);
}

/*
 * (time-string ['x_milliseconds])
 * if given no argument, returns the current time as a string
 * if given an argument which is a fixnum representing the current time
 * as a fixnum, it generates a string from that
 *
 * the format of the string returned is that defined in the Unix manual
 * except the trailing newline is removed.
 *
 */
lispval
Ltymestr()
{
    long timevalue;
    char *retval;
    
    switch(np-lbot)
    {
	case 0: time(&timevalue);
		break;
	case 1: while (TYPE(lbot[0].val) != INT)
	          lbot[0].val =
		     errorh(Vermisc,"time-string: non fixnum argument ",
		     		nil,TRUE,0,lbot[0].val);
		timevalue = lbot[0].val->i;
		break;
	default:
		argerr("time-string");
    }

    retval = (char *) ctime(&timevalue);
    /* remove newline character */
    retval[strlen(retval)-1] = '\0';
    return((lispval) inewstr(retval));
}
EndOfFile
cat >  franz/vax/../lam8.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam8.c,v 1.16 85/03/24 11:04:31 sklower Exp $";
#endif

/*					-[Thu Sep 29 22:24:10 1983 by jkf]-
 * 	lam8.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include <sys/types.h>
#include <sys/stat.h>
#include "frame.h"

/* various functions from the c math library */
double sin(),cos(),asin(),acos(),atan2(),sqrt(), log(), exp();
extern int current;

lispval Imath(func)
double (*func)();
{
	register lispval handy;
	register double res;
	chkarg(1,"Math functions");

	switch(TYPE(handy=lbot->val)) {
	 case INT: res = func((double)handy->i); 
		   break;

	 case DOUB: res = func(handy->r);
		   break;

	 default:  error("Non fixnum or flonum to math function",FALSE);
	}
	handy = newdoub();
	handy->r = res;
	return(handy);
}
lispval Lsin()
{
	return(Imath(sin));
}

lispval Lcos()
{
	return(Imath(cos));
}

lispval Lasin()
{
	return(Imath(asin));
}

lispval Lacos()
{
	return(Imath(acos));
}

lispval Lsqrt()
{
	return(Imath(sqrt));
}
lispval Lexp()
{
	return(Imath(exp));
}

lispval Llog()
{
	return(Imath(log));
}

/* although we call this atan, it is really atan2 to the c-world,
   that is, it takes two args
 */
lispval Latan()
{
	register lispval arg;
	register double arg1v;
	register double res;
	chkarg(2,"arctan");

	switch(TYPE(arg=lbot->val)) {

	case INT:  arg1v = (double) arg->i;
		   break;

	case DOUB: arg1v = arg->r;
		   break;

	default:   error("Non fixnum or flonum arg to atan2",FALSE);
	}

	switch(TYPE(arg = (lbot+1)->val)) {

	case INT: res = atan2(arg1v,(double) arg->i);
		  break;

	case DOUB: res = atan2(arg1v, arg->r);
		  break;

	default:  error("Non fixnum or flonum to atan2",FALSE);
	}
	arg = newdoub();
	arg->r = res;
	return(arg);
}

/* (random) returns a fixnum in the range -2**30 to 2**30 -1
   (random fixnum) returns a fixnum in the range 0 to fixnum-1
 */
lispval
Lrandom()
{
	register int curval;
	float pow();

	curval = rand();	/* get numb from 0 to 2**31-1 */

	if(np==lbot) return(inewint(curval-(int)pow((double)2,(double)30)));

	if((TYPE(lbot->val) != INT)
	    || (lbot->val->i <= 0)) errorh1(Vermisc,"random: non fixnum arg:",
						 nil, FALSE, 0, lbot->val);

	return(inewint(curval % lbot->val->i )); 

}
lispval
Lmakunb()
{
	register lispval work;

	chkarg(1,"makunbound");
	work = lbot->val;
	if(work==nil || (TYPE(work)!=ATOM))
		return(work);
	work->a.clb = CNIL;
	return(work);
}

lispval
Lfseek()
{

	FILE *f;
	long offset, whence;
	lispval retp;

	chkarg(3,"fseek");			/* Make sure there are three arguments*/

	f = lbot->val->p;		/* Get first argument into f */
	if (TYPE(lbot->val)!=PORT)	/* Check type of first */
		error("fseek: First argument must be a port.",FALSE);

	offset = lbot[1].val->i;	/* Get second argument */
	if (TYPE(lbot[1].val)!=INT)
		error("fseek: Second argument must be an integer.",FALSE);

	whence = lbot[2].val->i;	/* Get last arg	*/
	if (TYPE(lbot[2].val)!=INT)
		error("fseek: Third argument must be an integer.",FALSE);

	if (fseek(f, offset, (int)whence) == -1)
		error("fseek: Illegal parameters.",FALSE);

	retp = inewint(ftell(f));

	return((lispval) retp);
}

/* function hashtabstat  : return list of number of members in  each bucket */
lispval Lhashst()
{
	register lispval handy,cur;
	register struct atom *pnt;
	int i,cnt;
	extern int hashtop;
	Savestack(3);

	handy = newdot();
	protect(handy);
	cur = handy;
	for(i = 0; i < hashtop; i++)
	{
	    pnt = hasht[i];
	    for(cnt = 0; pnt != (struct atom *) CNIL ; pnt=pnt->hshlnk , cnt++);
	    cur->d.cdr = newdot();
	    cur = cur->d.cdr;
	    cur->d.car = inewint(cnt);
	}
	cur->d.cdr = nil;
	Restorestack();
	return(handy->d.cdr);
}


/* Lctcherr
  this routine should only be called by the unwind protect simulation
  lisp code
  It is called after an unwind-protect frame has been entered and
  evalated and we want to get on with the error or throw
  We only handle the case where there are 0 to 2 extra arguments to the
  error call.
*/
lispval
Lctcherr()
{
	register lispval handy;
	lispval type,messg,valret,contuab,uniqid,datum1,datum2;

	chkarg(1,"I-throw-err");

	handy = lbot->val;
	
	if(TYPE(handy->d.car) == INT)
	{	/* continuing a non error (throw,reset, etc) */
		Inonlocalgo((int)handy->d.car->i,
			    handy->d.cdr->d.car, 
			    handy->d.cdr->d.cdr->d.car);
		/* NOT REACHED */
	}

	if(handy->d.car != nil)
	{
	    errorh1(Vermisc,"I-do-throw: first element not fixnum or nil",
	           nil,FALSE,0,handy);
	}
	    
	/* decode the arg list */
	handy = handy->d.cdr;
	type = handy->d.car;
	handy = handy->d.cdr;
	messg = handy->d.car;
	handy = handy->d.cdr;
	valret = handy->d.car;
	handy = handy->d.cdr;
	contuab = handy->d.car;
	handy = handy->d.cdr;
	uniqid = handy->d.car;
	handy = handy->d.cdr;

	/* if not extra args */
	if(handy == nil)
	{
	  errorh(type,messg->a.pname,valret,(int)contuab->i,(int)uniqid->i);
	}
	datum1 = handy->d.car;
	handy = handy->d.cdr;

	/* if one extra arg */
	if(handy == nil)
	{
	  errorh1(type,messg->a.pname,valret,(int)contuab->i,(int)uniqid->i,datum1);
	}

	/* if two or more extra args, just use first 2 */
	datum2 = handy->d.car;
	errorh2(type,messg->a.pname,valret,(int)contuab->i,(int)uniqid->i,datum1,datum2);
}

/*
 *	(*makhunk '<fixnum>)
 *			  <fixnum>
 * Create a hunk of size 2       . <fixnum> must be between 0 and 6.
 *
 */

lispval
LMakhunk()
{
	register int hsize, hcntr;
	register lispval result;

	chkarg(1,"Makehunk");
	if (TYPE(lbot->val)==INT)
	{
		hsize = lbot->val->i;		/* size of hunk (0-6) */
		if ((hsize >= 0) && (hsize <= 6))
		{
			result = newhunk(hsize);
			hsize = 2 << hsize;	/* size of hunk (2-128) */
			for (hcntr = 0; hcntr < hsize; hcntr++)
				result->h.hunk[hcntr] = hunkfree;
		}
		else
			error("*makhunk: Illegal hunk size", FALSE);
	return(result);
	}
	else
		error("*makhunk: First arg must be an fixnum",FALSE);
	/* NOTREACHED */
}

/*
 *	(cxr '<fixnum> '<hunk>)
 * Returns the <fixnum>'th element of <hunk>
 *
 */
lispval
Lcxr()
{
	register lispval temp;

	chkarg(2,"cxr");
	if (TYPE(lbot->val)!=INT)
		error("cxr: First arg must be a fixnum", FALSE);
	else
	{
		if (! HUNKP(lbot[1].val))
			error("cxr: Second arg must be a hunk", FALSE);
		else
			if ( (lbot->val->i >= 0) &&
			     (lbot->val->i < (2 << HUNKSIZE(lbot[1].val))) )
			{
				temp = lbot[1].val->h.hunk[lbot->val->i];
				if (temp != hunkfree)
					return(temp);
				else
					error("cxr: Arg outside of hunk range",
					      FALSE);
			}
			else
				error("cxr: Arg outside of hunk range", FALSE);
	}
	/* NOTREACHED */
}

/*
 *	(rplacx '<fixnum> '<hunk> '<expr>)
 * Replaces the <fixnum>'th element of <hunk> with <expr>.
 *
 */
lispval
Lrplcx()
{
	lispval *handy;
	chkarg(3,"rplacx");
	if (TYPE(lbot->val)!=INT)
		error("rplacx: First arg must be a fixnum", FALSE);
	else
	{
		if (! HUNKP(lbot[1].val))
			error("rplacx: Second arg must be a hunk", FALSE);
		else
		{
			if ( (lbot->val->i >= 0) &&
			     (lbot->val->i < (2 << HUNKSIZE(lbot[1].val))) )
			{
			   if (*(handy = &(lbot[1].val->h.hunk[lbot->val->i]))
					!= hunkfree)
				    *handy  = lbot[2].val;
				else
					error("rplacx: Arg outside hunk range", FALSE);
			}
			else
				error("rplacx: Arg outside hunk range", FALSE);
		}
	}
	return(lbot[1].val);
}

/*
 *	(*rplacx '<fixnum> '<hunk> '<expr>)
 * Replaces the <fixnum>'th element of <hunk> with <expr>. This is the
 * same as (rplacx ...) except with this function you can replace EMPTY's.
 *
 */
lispval
Lstarrpx()
{
	chkarg(3,"*rplacx");
	if (TYPE(lbot->val)!=INT)
		error("*rplacx: First arg must be a fixnum", FALSE);
	else
	{
		if (! HUNKP(lbot[1].val))
			error("*rplacx: Second arg must be a hunk", FALSE);
		else
		{
			if ( (lbot->val->i >= 0) &&
			     (lbot->val->i < (2 << HUNKSIZE(lbot[1].val))) )
				lbot[1].val->h.hunk[lbot->val->i] = lbot[2].val;
			else
				error("*rplacx: Arg outside hunk range", FALSE);
		}
	}
	return(lbot[1].val);
}

/*
 *	(hunksize '<hunk>)
 * Returns the size of <hunk>
 *
 */
lispval
Lhunksize()
{
	register int size,i;

	chkarg(1,"hunksize");
	if (HUNKP(lbot->val))
	{
		size = 2 << HUNKSIZE(lbot->val);
		for (i = size-1; i >= 0; i--)
		{
			if (lbot->val->h.hunk[i] != hunkfree)
			{
				size = i + 1;
				break;
			}
		}
		return( inewint(size) );
	}
	else
		error("hunksize: First argument must me a hunk", FALSE);
			/* NOTREACHED */
}

/*
 * (hunk-to-list 'hunk)	returns a list of the hunk elements
 */
lispval
Lhtol()
{
    register lispval handy,retval,last;
    register int i;
    int size;
    Savestack(4);

    chkarg(1,"hunk-to-list");
    handy = lbot->val;
    if(!(HUNKP(handy)))
    	errorh1(Vermisc,"hunk-to-list: non hunk argument: ", nil,0,FALSE,
			handy);
    size = 2 << HUNKSIZE(handy);
    retval = nil;
    for(i=0 ; i < size ; i++)
    {
	if(handy->h.hunk[i] != hunkfree)
	{
	    if(retval==nil)
	    {
	        protect(retval=newdot());
		last = retval;
	    }
	    else {
		last = (last->d.cdr = newdot());
	    }
	    last->d.car = handy->h.hunk[i];
	}
	else break;
    }
    Restorestack();
    return(retval);
}
	    
/*
 *	(fileopen  filename mode)
 * open a file for read, write, or append the arguments can be either
 * strings or atoms.
 */
lispval
Lfileopen()
{
	FILE *port;
	register lispval name;
	register lispval mode;
	register char *namech;
	register char *modech;

	chkarg(2,"fileopen");
	name = lbot->val;
	mode = lbot[1].val;

	namech = (char *) verify(name,"fileopen:args must be atoms or strings");
	modech = (char *) verify(mode,"fileopen:args must be atoms or strings");

	while (modech[0] != 'r' && modech[0] != 'w' && modech[0] != 'a')
	{
		mode = errorh(Vermisc,"Modes are only r, w, a.",nil,TRUE,31);
		modech = (char *) verify(mode,"fileopen:args must be atoms or strings");
	}

	while ((port = fopen(namech, modech)) == NULL)
	{
	    name = errorh1(Vermisc,"Unable to open file.",nil,TRUE,31,name);
	    namech = (char *) verify(name,"fileopen:args must be atoms or strings");
	}
	    /* xports is a FILE *, cc complains about adding pointers */

	ioname[PN(port)] = (lispval) inewstr(namech);	/* remember name */
	return(P(port));
}

/*
 *	(*invmod '<number> '<modulus>)
 * This function returns the inverse of  <number>
 * mod <modulus> in balanced representation
 * It is used in vaxima as a speed enhancement.
 */

static lispval
Ibalmod(invmodp)
{
	register long mod_div_2, number, modulus;

	chkarg(2,"*mod");
	if ((TYPE(lbot->val) == INT) && (TYPE(lbot[1].val) == INT))
	{
		modulus = lbot[1].val->i;
		if(invmodp) number = invmod(lbot->val->i , modulus);
		else number = lbot->val->i % modulus;
		mod_div_2 = modulus / 2;
		if (number < 0)
		{
			if (number < (-mod_div_2))
				number += modulus;
		}
		else
		{
			if (number > mod_div_2)
				number -= modulus;
		}
		return( inewint(number) );
	}
	else
		error("*mod: Arguments must be fixnums", FALSE);
	/* NOTREACHED */
}

invmod (n,modulus)
long n , modulus;

{ 
	long a1,a2,a3,y1,y2,y3,q;

	a1 = modulus; 
	a2 = n; 
	y1 = 0; 
	y2= 1; 
	goto step3;
step2: 
	q = a1 /a2; /*truncated quotient */
	a3= mmuladd(modulus-a2,q,a1,modulus);
	y3= mmuladd(modulus-y2,q,y1,modulus);
	a1 = a2; 
	a2= a3; 
	y1=y2; 
	y2=y3;
step3: 
	if (a2==0) error("invmod: inverse of zero divisor",TRUE);
	else if (a2 != 1) goto step2;
	else return (y2);
	/* NOTREACHED */
}

lispval
Lstarinvmod()
{
	return(Ibalmod(TRUE));
}

/*
 *	(*mod '<number> '<modulus>)
 * This function returns <number> mod <modulus> (for balanced modulus).
 * It is used in vaxima as a speed enhancement.
 */
lispval
LstarMod()
{
	return(Ibalmod(FALSE));
}

lispval
Llsh()
{
	register struct argent *mylbot = lbot;
	int val,shift;

	chkarg(2,"lsh");
	if((TYPE(mylbot->val) != INT) || (TYPE(mylbot[1].val) != INT))
		errorh2(Vermisc,
		       "Non ints to lsh",
		       nil,FALSE,0,mylbot->val,mylbot[1].val);
	val = mylbot[0].val->i;
	shift = mylbot[1].val->i;
	if(shift < -32 || shift > 32)
	  return(inewint(0));
	if (shift < 0)
		val = val >> -shift;
	else
		val = val << shift;
	if((val < 0) && (shift < 0))
	{  	/* special case: the vax doesn't have a logical shift
		   instruction, so we must zero out the ones which
		   will propogate from the sign position
		*/
		return(inewint ( val & ~(0x80000000 >> -(shift+1))));
	}
	else return( inewint(val));
}

/* very temporary function to test the validity of the bind stack */

bndchk()
{  
	register struct nament *npt;
	register lispval in2;

	in2 = inewint(200);
	for(npt=orgbnp; npt < bnp; npt++)
	{  if((int) npt->atm < (int) in2) abort();
	}
}

/*
 *	formatted printer for lisp data
 *    use: (cprintf formatstring datum [port])
 */
lispval
Lcprintf()
{
    FILE *p;
    char *fstrng;
    lispval v;
    if(np-lbot == 2) protect(nil);	/* write to standard output port */
    chkarg(3,"cprintf");

    fstrng = (char *)verify(lbot->val,"cprintf: first arg not string or symbol");

    p = okport(lbot[2].val,okport(Vpoport->a.clb,poport));

    switch(TYPE(v=lbot[1].val)) {

	case INT:  fprintf(p,fstrng,v->i);
		   break;

	case DOUB: fprintf(p,fstrng,v->r);
		   break;

	case ATOM: fprintf(p,fstrng,v->a.pname);
		   break;

	case STRNG:fprintf(p,fstrng,v);
		   break;

	default:   error("cprintf: Illegal second argument",FALSE);
   };

   return(lbot[1].val);
}


/*
 * C style sprintf: (sprintf "format" {<arg-list>})
 *
 * This function stacks the arguments onto the C stack in reverse
 * order and then calls sprintf with one argument...This is what the
 * C compiler does, so it works just fine. The return value is the
 * string that is the result of the sprintf.
 */
lispval
Lsprintf()
{
	register struct argent *argp;
	register int j;
	char sbuf[600], *sprintf();			/* better way? */
	Keepxs();

	if (np-lbot == 0) {
		argerr("sprintf");
	}
	if (TYPE(lbot->val)==STRNG || TYPE(lbot->val)==INT) {
		for (argp = np-1; argp >= lbot; argp--) {
			switch(TYPE(argp->val)) {
			  case ATOM:
				stack((long)argp->val->a.pname);
				break;

			  case DOUB:
#ifndef SPISFP
				stack(argp->val->r);
#else
				{double rr = argp->val->r;
				stack(((long *)&rr)[1]);
				stack(((long *)&rr)[0]);}
#endif
				break;

			  case INT:
				stack(argp->val->i);
				break;

			  case STRNG:
				stack((long)argp->val);
				break;

			  default:
				error("sprintf: Bad data type to sprintf",
						FALSE);
			}
		}
		sprintf(sbuf);
		for (j = 0; j < np-lbot; j++)
			unstack();
	} else
		error("sprintf: First arg must be an atom or string", FALSE);
	Freexs();
	return ((lispval) inewstr(sbuf));
}

lispval
Lprobef()
{
	char *name;
	chkarg(1,"probef");

	name = (char *)verify(lbot->val,"probef: not symbol or string arg ");

	if(access(name,0) == 0) return(tatom);
	else return(nil);
}

lispval
Lsubstring()
{	register char *name;
	register lispval index,length;
	int restofstring = FALSE;
	int len,ind,reallen;

	switch (np-lbot) 
	{
	  case 2: restofstring = TRUE;
		  break;

	  case 3: break;

	  default: chkarg(3,"substring");
	}

	name = (char *)verify(lbot[0].val,"substring: not symbol or string arg ");

	while (TYPE(index = lbot[1].val) != INT)
	{  lbot[1].val = errorh1(Vermisc,"substring: non integer index ",nil,
						    TRUE,0,index);
	}

	len = strlen(name);
	ind = index->i;

	if(ind < 0) ind = len+1 + ind;

	if(ind < 1 || ind > len) return(nil);	/*index out of bounds*/
	if(restofstring) return((lispval)inewstr(name+ind-1));

	while (TYPE(length = lbot[2].val) != INT)
	{ lbot[2].val = errorh1(Vermisc,"substring: not integer length ",nil,
						   TRUE,0,length);
	}

	if((reallen = length->i ) < 0 || (reallen + ind) > len)
	  return((lispval)inewstr(name+ind-1));

	strncpy(strbuf,name+ind-1,reallen);
	strbuf[reallen] = '\0';
	return((lispval)newstr(0));
}

/*
 * This is substringn
 */
lispval
Lsstrn()
{
	register char *name;
	register int len,ind,reallen;
	lispval index,length;
	int restofstring = FALSE;
	Savestack(4);

	if((np-lbot) == 2) restofstring = TRUE;
	else { chkarg(3,"substringn");}

	name = (char *) verify(lbot[0].val,"substringn: non symbol or string arg ");

	while (TYPE(index = lbot[1].val) != INT)
	{  lbot[1].val = errorh1(Vermisc,"substringn: non integer index ",nil,
						    TRUE,0,index);
	}

	if(!restofstring)
	{
	    while (TYPE(length = lbot[2].val) != INT)
	    { lbot[2].val = errorh1(Vermisc,"substringn: not integer length ",
							nil, TRUE,0,length);
	    }
	    reallen = length->i;
	}
	else reallen = -1;

	len = strlen(name);
	ind = index->i;
	if(ind < 0) ind = len + 1 + ind;
	if( ind < 1 || ind > len) return(nil);

	if(reallen == 0) 
	    return((lispval)inewint(*(name + ind - 1)));
	else {
	    char *pnt = name + ind - 1;
	    char *last = name + len -1;
	    lispval cur,start;

	    protect(cur = start = newdot());
	    cur->d.car = inewint(*pnt);
	    while(++pnt <= last && --reallen != 0)
	    {
	       cur->d.cdr = newdot();
	       cur = cur->d.cdr;
	       cur->d.car = inewint(*pnt);
	    }
	    Restorestack();
	    return(start);
	}

}


/*
 * (character-index 'string 'char)
 * return the index of char in the string.
 * return nil if not present
 * char can be a fixnum (representing a character)
 *  a symbol or string (in which case the first char is used)
 *
 */

#if os_unix_ts
#define index strchr
#endif
lispval
Lcharindex()
{
    register char *string;
    register char ch;
    char *str2;
    
    chkarg(2,"character-index");
    

    string = (char *)verify(lbot[0].val,"character-index: non symbol or string arg ");
    if(TYPE(lbot[1].val) == INT)
    	ch = (char) lbot[1].val->i;
    else {
    	str2 = (char *) verify(lbot[1].val,"character-index: bad first argument ");
	ch = *str2;	/* grab the first character */
    }
    
    if((str2 = (char *) index(string,ch)) ==  0) return(nil); /* not there */
    /* return 1-based index of character */
    return(inewint(str2-string+1));
}
    
        
lispval Ipurcopy();


lispval
Lpurcopy()
{
	chkarg(1,"purcopy");
	return(Ipurcopy(lbot[0].val));
}
	    
lispval
Ipurcopy(handy)
lispval handy;
{
    extern int *beginsweep;
    register lispval retv, curv, lv;
    int i,size;

    switch(TYPE(handy)) {

	case DTPR:
		   retv = curv = pnewdot();
		   lv = handy;
		   while(TRUE)
		   {
		      curv->d.car = Ipurcopy(lv->d.car);
		      if(TYPE(lv = lv->d.cdr) == DTPR)
		      {
			  curv->d.cdr = pnewdot();
			  curv = curv->d.cdr;
		      }
		      else {
			  curv->d.cdr = Ipurcopy(lv);
			  break;
		      }
		    }
		    return(retv);

	case SDOT:
		    retv = curv = pnewsdot();
		    lv = handy;
		    while(TRUE)
		    {
			curv->s.I = lv->s.I;
			if(lv->s.CDR == (lispval) 0) break;
			lv = lv->s.CDR;
			curv->s.CDR = pnewdot();
			curv = curv->s.CDR;
		    }
		    curv->s.CDR = 0;
		    return(retv);

	case INT:
		    if((int *)handy < beginsweep) return(handy);
		    retv = pnewint();
		    retv->i = handy->i;
		    return(retv);

	case DOUB:
		    retv = pnewdb();
		    retv->r = handy->r;
		    return(retv);

	case HUNK2:
		i = 0;
		goto hunkit;

	case HUNK4:
		i = 1;
		goto hunkit;

	case HUNK8:
		i = 2;
		goto hunkit;

	case HUNK16:
		i = 3;
		goto hunkit;

	case HUNK32:
		i = 4;
		goto hunkit;

	case HUNK64:
		i = 5;
		goto hunkit;

	case HUNK128:
		i = 6; 

	    hunkit:
		retv = pnewhunk(i);
		size = 2 << i ; /* number of elements to copy over */
		for( i = 0; i < size ; i++)
		{
		    retv->h.hunk[i] = Ipurcopy(handy->h.hunk[i]);
		}
		return(retv);



	case STRNG:
#ifdef GCSTRINGS
		{ extern char purepage[];

		  if(purepage[((int)handy)>>9]==0)
			return((lispval)pinewstr((char *)handy));}
		
#endif
	case ATOM: 
	case BCD:
	case PORT:
	    return(handy);	/* We don't want to purcopy these, yet
				 * it won't hurt if we don't mark them
				 * since they either aren't swept or 
				 * will be marked in a special way 
				 */
	case ARRAY:
		error("purcopy: can't purcopy array structures",FALSE);

	default:
		error(" bad type to purcopy ",FALSE);
	/* NOTREACHED */
    }
}

/*
 * Lpurep returns t if the given arg is in pure space
 */
lispval
Lpurep()
{
    lispval Ipurep();

    chkarg(1,"purep");
    return(Ipurep(lbot->val));
}



/* vector functions */
lispval newvec(), nveci(), Inewvector();

/* vector creation and initialization functions */
lispval
Lnvec()
{
    return(Inewvector(3));
}

lispval
Lnvecb()
{
    return(Inewvector(0));
}

lispval
Lnvecw()
{
    return(Inewvector(1));
}

lispval
Lnvecl()
{
    return(Inewvector(2));
}

/*
 * (new-vector 'x_size ['g_fill] ['g_prop])
 * class = 0: byte \
 *       = 1: word  > immediate
 *       = 2: long /
 *	 = 3: long
 */
lispval
Inewvector(class)
{
    register int i;
    register lispval handy;
    register lispval *handy2;
    char *chandy;
    short *whandy;
    long *lhandy;
    lispval sizearg, fillarg, proparg;
    int size, vsize;

    fillarg = proparg = nil;
    
    switch(np-lbot) {
	case 3: proparg = lbot[2].val;
	case 2: fillarg = lbot[1].val;
	case 1: sizearg = lbot[0].val;
		break;
	default: argerr("new-vector");
    }
    
    while((TYPE(sizearg) != INT) || sizearg->i < 0)
	sizearg = errorh1(Vermisc,"new-vector: bad size for vector ",nil,
				TRUE,0,sizearg);
    size = sizearg->i;
    switch(class)
    {
	case 0: vsize = size * sizeof(char);
		break;
	case 1: vsize = size * sizeof(short);
		break;
	default: vsize = size * sizeof(long);
		break;
    }
    
    if(class != 3) handy = nveci(vsize);
    else handy = newvec(vsize);
    
    switch(class)
    {
	case 0: chandy = (char *)handy;
	        for(i = 0 ; i < size ; i++) *chandy++ = (char) (fillarg->i);
		break;
		
	case 1: whandy = (short *)handy;
	        for(i = 0 ; i < size ; i++) *whandy++ = (short) (fillarg->i);
		break;
		
	case 2: lhandy = (long *)handy;
	        for(i = 0 ; i < size ; i++) *lhandy++ = (fillarg->i);
		break;

	case 3: handy2 = (lispval *)handy;
	 	for(i = 0 ; i < size ; i++) *handy2++ = fillarg;
		break;
    }
    handy->v.vector[-1] = proparg;
    return(handy);
}

lispval
Lvectorp()
{
    chkarg(1,"vectorp");
    if(TYPE(lbot->val) == VECTOR) return(tatom);
    else return(nil);
}

lispval
Lpvp()
{
    chkarg(1,"vectorip");
    if(TYPE(lbot->val) == VECTORI) return(tatom);
    else return(nil);
}

/*
 * int:vref  vector[i] index class
 *  class = 0: byte immed, 1: word immed, 2: long immed, 3: long
 *
 * also do C style dereferencing of pointers.  This is a temporary
 * hack until we decide if we can live without it:
 *  class = 4: char, 5: short, 6: long, 7: float, 8: double
 */
lispval
LIvref()
{
    register lispval vect;
    register int index;
    int class;
    double value;
    
    chkarg(3,"int:vref");
    vect = lbot[0].val;
    index = lbot[1].val->i;
    class = lbot[2].val->i;
    switch(class)
    {
        case 0: return(inewint(vect->vb.vectorb[index]));
        case 1: return(inewint(vect->vw.vectorw[index]));
        case 2: return(inewint(vect->vl.vectorl[index]));
	case 3: return(vect->v.vector[index]);
	case 4: return(inewint(*(char *)(vect->i+index)));
	case 5: return(inewint(*(short *)(vect->i+index)));
	case 6: return(inewint(*(long *)(vect->i+index)));
	case 7: value = *(float *) (vect->i+index);
		vect = newdoub();
		vect->r = value;
		return(vect);
	case 8: value = *(double *) (vect->i+index);
		vect = newdoub();
		vect->r = value;
		return(vect);
    }
    error("int:vref: impossible class detected",FALSE);
    /* NOTREACHED */
}

/*
 * int:vset vector[i] index value class
 *  class = 0: byte immed, 1: word immed, 2: long immed, 3: long
 */
lispval
LIvset()
{
    register lispval vect,value;
    register int index;
    int class;
    
    chkarg(4,"int:vset");
    vect = lbot[0].val;
    index = lbot[1].val->i;
    value = lbot[2].val;
    class = lbot[3].val->i;
    switch(class)
    {
        case 0: vect->vb.vectorb[index] = (char)value->i;
		break;
        case 1: vect->vw.vectorw[index] = (short)value->i;
		break;
        case 2: vect->vl.vectorl[index] = value->i;
		break;
	case 3: vect->v.vector[index] = value;
		break;
	case 4: *(char *) (vect->i+index) = value->i;
		break;
	case 5: *(short *) (vect->i+index) = value->i;
		break;
	case 6: *(long *) (vect->i+index) = value->i;
		break;
	case 7: *(float *) (vect->i+index) = value->r;
		break;
	case 8: *(double *) (vect->i+index) = value->r;
		break;
	default:
	error("int:vref: impossible class detected",FALSE);
    }
    return(value);
}

/*
 * LIvsize == (int:vsize 'vector 'x_shift)
 *  return the vsize field of the vector shifted right by x_shift
 */
lispval
LIvsize()
{
    int typ;
    
    chkarg(2,"int:vsize");
    return(inewint((lbot[0].val->vl.vectorl[VSizeOff]) >> lbot[1].val->i));
}

lispval
Lvprop()
{
    int typ;
    chkarg(1,"vprop");
    
    if(((typ = TYPE(lbot->val)) != VECTOR) && (typ != VECTORI))
    	errorh1(Vermisc,"vprop: non vector argument: ", nil, FALSE,0,
			lbot->val);
    return(lbot[0].val->v.vector[VPropOff]);
}

    
lispval
Lvsp()
{
	int typ;
	lispval vector, property;
	chkarg(2,"vsetprop");

	vector = lbot->val;
	property = lbot[1].val;
	typ = TYPE(vector);

	if(typ != VECTOR && typ !=VECTORI)
		errorh1(Vermisc,"vsetprop: non vector argument: ",
				nil,FALSE,0,vector);
	vector->v.vector[VPropOff] = property;
	return(property);
}


/* vecequal
 *  check if the two vector arguments are 'equal'
 *  this is called by equal which has already checked that
 *  the arguments are vector
 */
vecequal(v,w)
lispval v,w;
{
    int i;
    lispval vv, ww, ret;
    int vsize = (int) v->v.vector[VSizeOff];
    int wsize = (int) w->v.vector[VSizeOff];
    struct argent *oldlbot = lbot;
    lispval Lequal();

    if(vsize != wsize) return(FALSE);

    vsize /= sizeof(int);	/* determine number of entries */

    for(i = 0 ; i < vsize ; i++)
    {
	vv = v->v.vector[i];
	ww = w->v.vector[i];
	/* avoid calling equal if they are eq */
	if(vv != ww)
	{
	    lbot = np;
	    protect(vv);
	    protect(ww);
	    ret = Lequal();
	    np = lbot;
	    lbot = oldlbot;
	    if(ret == nil)  return(FALSE);
	}
    }
    return(TRUE);
}
	     
/* veciequal
 *  check if the two vectori arguments are 'equal'
 *  this is called by equal which has already checked that
 *  the arguments are vector
 *  Note: this would run faster if we did as many 'longword'
 *  comparisons as possible and then did byte comparisons.
 *  or if we used pointers instead of indexing.
 */
veciequal(v,w)
lispval v,w;
{
    char vv, ww;
    int i;
    int vsize = (int) v->v.vector[VSizeOff];
    int wsize = (int) w->v.vector[VSizeOff];

    if(vsize != wsize) return(FALSE);


    for(i = 0 ; i < vsize ; i++)
    {
	if(v->vb.vectorb[i] != w->vb.vectorb[i]) return(FALSE);
    }
    return(TRUE);
}
EndOfFile
cat >  franz/vax/../lam9.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lam9.c,v 1.7 85/03/13 17:19:15 sklower Exp $";
#endif

/*					-[Sat Oct  1 19:44:47 1983 by jkf]-
 * 	lam9.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
/*
 * These routines writen in C will allow use of the termcap file
 * by any lisp program. They are very basic routines which initialize
 * termcap and allow the lisp to execute any of the termcap functions.
 */

#include <stdio.h>		/*add definations for I/O and bandrate */
#include <sgtty.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <pwd.h>


#undef putchar
int	putchar();		/* functions used from the termlib */
int	tgetflag();
char	*getenv();
char	*tgoto();
char	*tgetstr();

char 	bpbuf[1024];
char 	tstrbuf[100];
extern short 	ospeed;
extern char	PC;
extern char   *BC;
extern char   *UP;

/*
/*	This routine will initialize the termcap for the lisp programs.
/*	If the termcap file is not found, or terminal type is undefined,
/*	it will print out an error mesg.				*/

lispval
Ltci()
{
char *cp = getenv("TERM");
char *pc;
int found;
struct sgttyb tty;

found = tgetent(bpbuf,cp);		/* open ther termcap file */
switch(found) {
      case -1: 	printf("\nError Termcap File not found \n");break;
      case 0 :	printf("\nError No Termcap Entry for this terminal \n");
		break;
      case 1 : {			/* everything was ok	*/
		gtty(1, &tty);
		ospeed = tty.sg_ospeed;
	        }
		break;
	}
cp = tstrbuf;
BC = tgetstr("bc", &cp);
UP = tgetstr("up", &cp);
pc = tgetstr("pc", &cp);
if (pc)
    PC = *pc;
return(nil);
}
/* This routine will execute any of the termcap functions used by the lisp
/* program. If the feature is not include in the terminal defined it will
/* ignore the call.
/*		option	: feature to execute
/*		line	: line if is nessery
/*		colum	: colum if is nessaery
/*									*/
lispval
Ltcx()
{
	register struct argent *mylbot = lbot;
	int line, column;

	switch(np-lbot) {
	case 1:
		line = column = 0;
		break;
	case 2:
		error("Wrong number of Arguments to Termcapexecute",FALSE);
		break;
	case 3:
		line = mylbot[1].val->i;
		column = mylbot[2].val->i;
	}
	return(inewint(show((char *) mylbot->val,&line,&column)));
}


static
show(option,line,colum)
char *option;
int  *line,*colum;
{
int found;
char clbuf[20];
char *clbp = clbuf;
char *clear;

/* the tegetflag doesnot work ? */
clear = tgetstr(option,&clbp);  
/*printf("option = %d , %s \n",clear,option);*/
if (!clear) 
	{found = tgetnum(option);
	 if (found)
		return(found);
	  return(-1);
       }
PC = ' ';
if (strcmp(option, "cm") == 0) {		/* if cursor motion, do it */
	clear=tgoto(clear,*colum,*line);
       	if (*clear == 'O')
		clear = 0;
	}
if (clear)					/* execute the feature */
     tputs(clear,0,putchar);
return (0);
}



/*
 * LIfranzcall :: lisp function int:franz-call
 *   this function serves many purposes.  It provides access to
 *   those things that are best done in C or which required a
 *   C access to unix system calls.
 *
 *   Calls to this routine are not error checked, for the most part
 *   because this is only called from trusted lisp code.
 *
 *   The functions in this file may or may not be documented in the manual.
 *   See the lisp interface to this function for more details. (common2.l)
 *
 *  the first argument is always a fixnum index, the other arguments
 *   depend on the function.
 */

#define fc_getpwnam 1
#define fc_access   2 
#define fc_chdir    3
#define fc_unlink   4
#define fc_time	    5
#define fc_chmod    6
#define fc_getpid   7
#define fc_stat     8
#define fc_gethostname 9
#define fc_link     10
#define fc_sleep    11
#define fc_nice	    12

lispval
LIfranzcall()
{
    register lispval handy;
    
    if((np-lbot) <= 0) argerr("int:franz-call");

    switch (lbot[0].val->i) {
    
    case fc_getpwnam:
    	/* arg 1 = user name
	 * return vector of name, uid, gid, dir
	 * or nil if doesn't exist.
	 */
	 {
	     struct passwd *pw, *getpwnam();
	     lispval newvec(), inewint();
	     struct argent *oldnp;

	     pw = getpwnam(verify(lbot[1].val,"int:franz-call: invalid name"));
	     if(pw)
	     {
		 handy =  newvec(4 * sizeof(long));
		 oldnp = np;
		 protect(handy);
		 handy->v.vector[0] = (lispval) inewstr(pw->pw_name);
		 handy->v.vector[1] = inewint(pw->pw_uid);
		 handy->v.vector[2] = inewint(pw->pw_gid);
		 handy->v.vector[3] = (lispval) inewstr(pw->pw_dir);
		 np = oldnp;
		 return(handy);
	     }
	     return(nil);
	 }
	 case fc_access:
	 	return(inewint
		        (access
			   (verify(lbot[1].val, "i:fc,access: non string"),
			    lbot[2].val->i)));
	 case fc_chdir:
	 	return(inewint
		       (chdir(verify(lbot[1].val,"i:fc,chdir: non string"))));

	 case fc_unlink:
	 	return(inewint
		       (unlink(verify(lbot[1].val,"i:fc,unlink: non string"))));

	 case fc_time:
	 	return(inewint(time(0)));

	 case fc_chmod:
	 	return(inewint(chmod(verify(lbot[1].val,
						"i:fc,chmod: non string"),
				     lbot[2].val->i)));

	 case fc_getpid:
	 	return(inewint(getpid()));

	 case fc_stat:
	        {
		    struct argent *oldnp;
		    struct stat statbuf;

		    if(stat(verify(lbot[1].val,"ifc:stat bad file name "),
		    	    &statbuf)
			!= 0) return(nil);	/* nil on error */
		    handy = newvec(12 * sizeof(long));
		    oldnp = np;
		    protect(handy);
		    handy->v.vector[0] = inewint(statbuf.st_mode & 07777);
		    handy->v.vector[1] = inewint(
		       			   (statbuf.st_mode & S_IFMT) >> 12 );
		    handy->v.vector[2] = inewint(statbuf.st_nlink);
		    handy->v.vector[3] = inewint(statbuf.st_uid);
		    handy->v.vector[4] = inewint(statbuf.st_gid);
		    handy->v.vector[5] = inewint(statbuf.st_size);
		    handy->v.vector[6] = inewint(statbuf.st_atime);
		    handy->v.vector[7] = inewint(statbuf.st_mtime);
		    handy->v.vector[8] = inewint(statbuf.st_ctime);
		    handy->v.vector[9] = inewint(statbuf.st_dev);
		    handy->v.vector[10] = inewint(statbuf.st_rdev);
		    handy->v.vector[11] = inewint(statbuf.st_ino);
		    np = oldnp;
		    return(handy);
		}
	 case fc_gethostname:
	    {
#if os_4_1a || os_4_1c || os_4_2 || os_4_3
		char hostname[32];
		gethostname(hostname,sizeof(hostname));
		return((lispval) inewstr(hostname));
#else
		return((lispval) inewstr(SITE));
#endif		
	    }
	 case fc_link:
	    return(inewint
	    	    (link(verify(lbot[1].val,"i:fc,link: non string"),
		          verify(lbot[2].val,"i:fc,link: non string"))));

	 /* sleep for the given number of seconds */
	 case fc_sleep:
	    return(inewint(sleep(lbot[1].val->i)));

	 case fc_nice:
	    return(inewint(nice(lbot[1].val->i)));
	    
	 default:
	 	return(inewint(-1));
	} /* end of switch */
}

		 

		 
EndOfFile
cat >  franz/vax/../lamr.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lamr.c,v 1.6 84/04/06 23:14:05 layer Exp $";
#endif

/*					-[Sat Jan 29 13:09:59 1983 by jkf]-
 * 	lamr.c				$Locker:  $
 * lambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

# include "global.h"

/*
 *
 *  Lalloc
 *
 *  This lambda allows allocation of pages from lisp.  The first
 *  argument is the name of a space, n pages of which are allocated,
 *  if possible.  Returns the number of pages allocated.
 */

lispval
Lalloc()
	{
	long n;
	chkarg(2,"alloc");
	if(TYPE((lbot+1)->val) != INT && (lbot+1)->val != nil )
		error("2nd argument to allocate must be an integer",FALSE);
	n = 1;
	if((lbot+1)->val != nil) n = (lbot+1)->val->i;
	return(alloc((lbot)->val,n));	/*  call alloc to do the work  */
	}

lispval
Lsizeof()
	{
	chkarg(1,"sizeof");
	return(inewint(csizeof(lbot->val)));
	}

lispval
Lsegment()
	{
	chkarg(2,"segment");
chek:	while(TYPE(np[-1].val) != INT )
		np[-1].val=error("LENGTH ARG TO SEGMENT MUST BE INTEGER",TRUE);
	if( np[-1].val->i < 0 )
		{
		np[-1].val = error("LENGTH ARG TO SEGMENT MUST BE POSITIVE",TRUE);
		goto chek;
		}
	return(csegment(typenum((lbot)->val),(int)(np[-1].val->i),FALSE));
	}

/*  Lforget  *************************************************************/
/*									*/
/*  This function removes an atom from the hash table.			*/

lispval
Lforget()
	{
	char *name;
	struct atom *buckpt;
	int hash;
	chkarg(1,"forget");
	if(TYPE(lbot->val) != ATOM)
		error("remob: non-atom argument",FALSE);
	name = lbot->val->a.pname;
	hash = hashfcn(name);

	/*  We have found the hash bucket for the atom, now we remove it  */

	if( hasht[hash] == (struct atom *)lbot->val )
		{
		hasht[hash] = lbot->val->a.hshlnk;
		lbot->val->a.hshlnk = (struct atom *)CNIL;
		return(lbot->val);
		}

	buckpt = hasht[hash];
	while(buckpt != (struct atom *)CNIL)
		{
		if(buckpt->hshlnk == (struct atom *)lbot->val)
			{
			buckpt->hshlnk = lbot->val->a.hshlnk;
			lbot->val->a.hshlnk = (struct atom *)CNIL;
			return(lbot->val);
			}
		buckpt = buckpt->hshlnk;
		}

	/*  Whoops!  Guess it wasn't in the hash table after all.  */

	return(lbot->val);
	}

lispval
Lgetl()
	{
	chkarg(1,"getlength");
	if(TYPE(lbot->val) != ARRAY)
		error("ARG TO GETLENGTH MUST BE AN ARRAY",TRUE);
	return(lbot->val->ar.length);
	}

lispval
Lputl()
	{
	chkarg(2,"putlength");
	if(TYPE((lbot)->val) != ARRAY)
		error("ARG TO PUTLENGTH MUST BE AN ARRAY",FALSE);
chek:	while(TYPE(np[-1].val) != INT)
		np[-1].val = error("ARRAY LENGTH MUST BE AN INTEGER",FALSE);
	if(np[-1].val->i <= 0)
		{
		np[-1].val = error("ARRAY LENGTH MUST BE POSITIVE",TRUE);
		goto chek;
		}
	return((lbot)->val->ar.length = np[-1].val);
	}
lispval
Lgetdel()
	{
	chkarg(1,"getdelta");
	if(TYPE(lbot->val) != ARRAY)
		error("ARG TO GETDELTA MUST BE AN ARRAY",FALSE);
	return(lbot->val->ar.delta);
	}

lispval
Lputdel()
	{
	chkarg(2,"putdelta");
	if(TYPE((np-2)->val) != ARRAY)
		error("ARG TO PUTDELTA MUST BE AN ARRAY",FALSE);
chek:	while(TYPE(np[-1].val) != INT)
		np[-1].val = error("ARRAY LENGTH MUST BE AN INTEGER",TRUE);
	if(np[-1].val->i <= 0)
		{
		np[-1].val = error("Array delta must be positive",TRUE);
		goto chek;
		}
	return((lbot)->val->ar.delta = np[-1].val);
	}

lispval
Lgetaux()
	{
	chkarg(1,"getaux");
	if(TYPE(lbot->val)!=ARRAY)
		error("Arg to getaux must be an array", FALSE);
	return(lbot->val->ar.aux);
	}

lispval
Lputaux()
	{
	chkarg(2,"putaux");

	if(TYPE((lbot)->val)!=ARRAY)
		error("1st Arg to putaux must be array", FALSE);
	return((lbot)->val->ar.aux = np[-1].val);
	}

lispval
Lgetdata()
	{
	chkarg(1,"getdata");
	if(TYPE(lbot->val)!=ARRAY)
		error("Arg to getdata must be an array", FALSE);
	return((lispval)lbot->val->ar.data);
	}

lispval
Lputdata()
	{
	chkarg(2,"putdata");

	if(TYPE(lbot->val)!=ARRAY)
		error("1st Arg to putaux must be array", FALSE);
	return((lispval)(lbot->val->ar.data = (char *)(lbot[1].val)));
	}

lispval
Lgeta()
	{
	chkarg(1,"getaccess");
	if(TYPE(lbot->val) != ARRAY)
		error("ARG TO GETACCESS MUST BE AN ARRAY",FALSE);
	return(lbot->val->ar.accfun);
	}

lispval
Lputa()
	{
	chkarg(2,"putaccess");
	if(TYPE((lbot)->val) != ARRAY)
		error("ARG TO PUTACCESS MUST BE ARRAY",FALSE);
	return((lbot)->val->ar.accfun = np[-1].val);
	}

lispval
Lmarray()
{
	register lispval handy;

	chkarg(5,"marray");

	(handy = newarray());		/*  get a new array cell  */
	handy->ar.data=(char *)lbot->val;/*  insert data address  */
	handy->ar.accfun = lbot[1].val;	/*  insert access function  */
	handy->ar.aux = lbot[2].val;	/*  insert aux data  */
	handy->ar.length = lbot[3].val;	/*  insert length  */
	handy->ar.delta = lbot[4].val;	/*  push delta arg  */
	return(handy);
	}

lispval
Lgtentry()
	{
	chkarg(1,"getentry");
	if( TYPE(lbot->val) != BCD )
		error("ARG TO GETENTRY MUST BE FUNCTION",FALSE);
	return((lispval)(lbot->val->bcd.start));
	}

lispval
Lgetlang()
	{
	chkarg(1,"getlang");
	while(TYPE(lbot->val)!=BCD)
		lbot->val = error("ARG TO GETLANG MUST BE FUNCTION DESCRIPTOR",TRUE);
	return(lbot->val->bcd.language);
	}

lispval
Lputlang()
	{
	chkarg(2,"putlang");
	while(TYPE((lbot)->val)!=BCD)
		lbot->val = error("FIRST ARG TO PUTLANG MUST BE FUNCTION DESCRIPTOR",TRUE);
	(lbot)->val->bcd.language = np[-1].val;
	return(np[-1].val);
	}

lispval
Lgetparams()
	{
	chkarg(1,"getparams");
	if(TYPE(np[-1].val)!=BCD)
		error("ARG TO GETPARAMS MUST BE A FUNCTION DESCRIPTOR",FALSE);
	return(np[-1].val->bcd.params);
	}

lispval
Lputparams()
	{
	chkarg(2,"putparams");
	if(TYPE((lbot)->val)!=BCD)
		error("1st ARG TO PUTPARAMS MUST BE FUNCTION DESCRIPTOR",FALSE);
	return((lbot)->val->bcd.params = np[-1].val);
	}

lispval
Lgetdisc()
	{
	chkarg(1,"getdisc");
	if(TYPE(np[-1].val) != BCD)
		error("ARGUMENT OF GETDISC MUST BE FUNCTION",FALSE);
	return(np[-1].val->bcd.discipline);
	}

lispval
Lputdisc()
	{
	chkarg(2,"putdisc");
	if(TYPE(np[-2].val) != BCD)
		error("ARGUMENT OF PUTDISC MUST BE FUNCTION",FALSE);
	return((np-2)->val->bcd.discipline  = np[-1].val);
	}

lispval
Lgetloc()
	{
	chkarg(1,"getloc");
	if(TYPE(lbot->val)!=BCD)
		error("ARGUMENT TO GETLOC MUST BE FUNCTION",FALSE);
	return(lbot->val->bcd.loctab);
	}

lispval
Lputloc()
	{
	chkarg(2,"putloc");
	if(TYPE((lbot+1)->val)!=BCD);
		error("FIRST ARGUMENT TO PUTLOC MUST BE FUNCTION",FALSE);
	(lbot)->val->bcd.loctab = (lbot+1)->val;
	return((lbot+1)->val);
	}

lispval
Lmfunction()
	{
	register lispval handy;
	chkarg(2,"mfunction");
	handy = (newfunct());	/*  get a new function cell  */
	handy->bcd.start = (lispval (*)())((lbot)->val);	/* insert entry point */
	handy->bcd.discipline = ((lbot+1)->val); /*  insert discipline  */
	return(handy);
	}

/** Lreplace ************************************************************/
/*									*/
/*  Destructively modifies almost any kind of data.		 	*/

lispval
Lreplace()
	{
	register lispval a1, a2;
	register int t;
	chkarg(2,"replace");

	if((t = TYPE(a1 = (lbot)->val)) != TYPE(a2 = np[-1].val))
		error("REPLACE ARGS MUST BE SAME TYPE",FALSE);

	switch( t )
		{

	case VALUE:	a1->l = a2->l;
			return( a1 );

	case INT:	a1->i = a2->i;
			return( a1 );


	case ARRAY:	a1->ar.data = a2->ar.data;
			a1->ar.accfun = a2->ar.accfun;
			a1->ar.length = a2->ar.length;
			a1->ar.delta = a2->ar.delta;
			return( a1 );

	case DOUB:	a1->r = a2->r;
			return( a1 );

	case SDOT:
	case DTPR:	a1->d.car = a2->d.car;
			a1->d.cdr = a2->d.cdr;
			return( a1 );
	case BCD:	a1->bcd.start = a2->bcd.start;
			a1->bcd.discipline = a2->bcd.discipline;
			return( a1 );
	default:
			errorh1(Vermisc,"Replace: cannot handle the type of this arg",
						 nil,FALSE,0,a1);
		}
	/* NOTREACHED */
	}

/* Lvaluep */

lispval
Lvaluep()
	{
	chkarg(1,"valuep");
	if( TYPE(lbot->val) == VALUE ) return(tatom); else return(nil);
	}

CNTTYP() { return; /* HI! COUNT ONE TYPE CALL! */ }

lispval
Lod()
	{
	int i;
	chkarg(2,"od");

	while( TYPE(np[-1].val) != INT )
		np[-1].val = error("2nd ARG TO OD MUST BE INTEGER",TRUE);

	for( i = 0; i < np->val->i; ++i )
		printf(copval(odform,CNIL)->a.pname,((int *)(np[-2].val))[i]);

	dmpport(poport);
	return(nil);
	}
lispval
Lfake()
	{
	chkarg(1,"fake");

	if( TYPE(lbot->val) != INT )
		error("ARG TO FAKE MUST BE INTEGER",TRUE);

	return((lispval)(lbot->val->i));
	}

	/* this used to be Lwhat, but was changed to Lmaknum for maclisp
	   compatiblity
	*/
lispval
Lmaknum()
	{
	chkarg(1,"maknum");
	return(inewint((int)(lbot->val)));
	}
lispval
Lderef()
	{
	chkarg(1,"deref");

	if( TYPE(lbot->val) != INT )
		error("arg to deref must be integer",TRUE);

	return(inewint(*(int *)(lbot->val->i)));
	}

lispval
Lpname()
	{
	chkarg(1,"pname");
	if(TYPE(lbot->val) != ATOM)
		error("ARG TO PNAME MUST BE AN ATOM",FALSE);
	return((lispval)(lbot->val->a.pname));
	}

lispval
Larayref()
	{
	chkarg(2,"arrayref");
	if(TYPE((lbot)->val) != ARRAY)
		error("FIRST ARG TO ARRAYREF MUST BE ARRAY",FALSE);
	vtemp = (lbot + 1)->val;
chek:	while(TYPE(vtemp) != INT)
		vtemp = error("SECOND ARG TO ARRAYREF MUST BE INTEGER",TRUE);
	if( vtemp->i < 0 )
		{
		vtemp = error("NEGATIVE ARRAY OFFSET",TRUE);
		goto chek;
		}
	if( vtemp->i >= (np-2)->val->ar.length->i )
		{
		vtemp = error("ARRAY OFFSET TOO LARGE",TRUE);
		goto chek;
		}
	vtemp = (lispval)((np-2)->val->ar.data + ((np-2)->val->ar.delta->i)*(vtemp->i));
		/*  compute address of desired item  */
	return(vtemp);
			
	}

lispval
Lptr()
	{
	chkarg(1,"ptr");
	return(inewval(lbot->val));
	}

lispval
Llctrace()
	{
	chkarg(1,"lctrace");
	lctrace = (int)(lbot->val->a.clb);
	return((lispval)lctrace);
	}

lispval
Lslevel()
	{
	return(inewint(np-orgnp-2));
	}

lispval
Lsimpld()
	{
	register lispval pt;
	register char *cpt = strbuf;

	chkarg(1,"simpld");

	for(atmlen=1, pt=np->val; NOTNIL(pt); ++atmlen, pt = pt->d.cdr);

	if( atmlen > STRBLEN )
		{
		error("LCODE WAS TOO LONG",TRUE);
		return((lispval)inewstr(""));
		}

	for(pt=np->val; NOTNIL(pt); pt = pt->d.cdr) *(cpt++) = pt->d.car->i;
	*cpt = 0;

	return((lispval)newstr(1));
	}
	
	
/*  Lopval  *************************************************************/
/*									*/
/*  Routine which allows system registers and options to be examined	*/
/*  and modified.  Calls copval, the routine which is called by c code	*/
/*  to do the same thing from inside the system.			*/

lispval 
Lopval()
{
	lispval quant;

	if( lbot == np )
		return(error("bad call to opval",TRUE));
	quant = lbot->val;	 /*  get name of sys variable  */
	while( TYPE(quant) != ATOM )
		quant = error("first arg to opval must be an atom",TRUE);

	if(np > lbot+1)  vtemp = (lbot+1)->val ;
	else vtemp = CNIL;
	return(copval(quant,vtemp));
}
EndOfFile
cat >  franz/vax/../lamp.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lamp.c,v 1.3 83/12/09 16:51:36 sklower Exp $";
#endif

/*					-[Tue Mar 22 15:17:09 1983 by jkf]-
 * 	lamp.c				$Locker:  $
 * interface with unix profiling
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"

#ifdef PROF

#define PBUFSZ 500000
short pbuf[PBUFSZ];

/* data space for fasl to put counters */
int mcnts[NMCOUNT];
int mcntp = (int) mcnts;
int doprof = TRUE;

lispval
Lmonitor()
{
	extern etext, countbase;

	if (np==lbot) { monitor((int(*)())0); countbase = 0; }
	else if (TYPE(lbot->val)==INT) 
	 { monitor((int (*)())2, (int (*)())lbot->val->i, pbuf,
	 				PBUFSZ*(sizeof(short)), 7000); 
	   countbase = ((int)pbuf) +12; 
	}
	else {
	   monitor((int (*)())2, (int (*)())sbrk(0), pbuf,
	   				PBUFSZ*(sizeof(short)), 7000); 
	   countbase = ((int)pbuf) + 12; }
	return(tatom);
}


#else

/* if prof is not defined, create a dummy Lmonitor */

short	pbuf[8];

/* data space for fasl to put counters */
int mcnts[1];
int mcntp = (int) mcnts;
int doprof = FALSE;

Lmonitor()
{
	error("Profiling not enabled",FALSE);
}


#endif
EndOfFile
cat >  franz/vax/../fex1.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: fex1.c,v 1.5 85/03/24 11:03:51 sklower Exp $";
#endif

/*					-[Sat Mar  5 19:50:28 1983 by layer]-
 * 	fex1.c				$Locker:  $
 * nlambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include "frame.h"

/* Nprog ****************************************************************/
/* This first sets the local variables to nil while saving their old	*/
/* values on the name stack.  Then, pointers to various things are	*/
/* saved as this function may be returned to by an "Ngo" or by a	*/
/* "Lreturn".  At the end is the loop that cycles through the contents	*/
/* of the prog.								*/

lispval
Nprog() {
	register lispval where, temp;
	struct nament *savedbnp = bnp;
	extern struct frame *errp;
	pbuf pb;
	extern int retval;
	extern lispval lispretval;

	if((np-lbot) < 1) chkarg(1,"prog");

	/* shallow bind the local variables to nil */
	if(lbot->val->d.car != nil)
	{
	    for( where = lbot->val->d.car ; where != nil; where = where->d.cdr )
	    {
	        if(TYPE(where) != DTPR || TYPE(temp=where->d.car) != ATOM)
		    errorh1(Vermisc,
			   "Illegal local variable list in prog ",nil,FALSE,
			   1,where);
    	        PUSHDOWN(temp,nil);
	    }
	}

	/* put a frame on the stack which can be 'return'ed to or 'go'ed to */
	errp = Pushframe(F_PROG,nil,nil);

	where = lbot->val->d.cdr;	/* first thing in the prog body */

	switch (retval)	{
	case C_RET:	/*
			 * returning from this prog, value to return
			 * is in lispretval
			 */
			errp = Popframe();
			popnames(savedbnp);
			return(lispretval);

	case C_GO:	/*
			 * going to a certain label, label to go to in
			 * in lispretval
			 */
			where = (lbot->val)->d.cdr;
			while ((TYPE(where) == DTPR) 
			       && (where->d.car != lispretval))
				where = where->d.cdr;
			if (where->d.car == lispretval) {
				popnames(errp->svbnp);
				break;
			}
			/* label not found in this prog, must 
			 * go up to higher prog
			 */
			errp = Popframe();	/* go to next frame */
			Inonlocalgo(C_GO,lispretval,nil);

			/* NOT REACHED */

	case C_INITIAL: break;

	}

	while (TYPE(where) == DTPR)
		{
		temp = where->d.car;
		if((TYPE(temp))!=ATOM) eval(temp);
		where = where->d.cdr;
		}
	if((where != nil) && (TYPE(where) != DTPR)) 
	    errorh1(Vermisc,"Illegal form in prog body ", nil,FALSE,0,where);
	errp = Popframe();
	popnames(savedbnp);	/* pop off locals */
	return(nil);
}

lispval globtag;
/*
   Ncatch is now linked to the lisp symbol *catch , which has the form
     (*catch tag form)
    tag is evaluated and then the catch entry is set up.
      then form is evaluated
    finally the catch entry is removed.

  *catch is still an nlambda since its arguments should not be evaluated
   before this routine is called.

   (catch form [tag]) is translated to (*catch 'tag form) by a macro.
 */
lispval
Ncatch()
{
	register lispval tag;
	pbuf pb;
	Savestack(3);		/* save stack pointers */

	if((TYPE(lbot->val))!=DTPR) return(nil);
	protect(tag = eval(lbot->val->d.car));  /* protect tag from gc */

	errp = Pushframe(F_CATCH,tag,nil);

	switch(retval) {

	case C_THROW: 	/*
		       	 * value thrown is in lispretval
		       	 */
			break;

	case C_INITIAL: /*
			 * calculate value of expression
			 */
			 lispretval = eval(lbot->val->d.cdr->d.car);
	}
			
			
	errp = Popframe();
	Restorestack();
	return(lispretval);
}
/* (errset form [flag])  
   if present, flag determines if the error message will be printed
   if an error reaches the errset.
   if no error occurs, errset returns a list of one element, the 
    value returned from form.
   if an error occurs, nil is usually returned although it could
    be non nil if err threw a non nil value 
 */

lispval Nerrset()
{
	lispval temp,flag;
	pbuf pb;
	Savestack(0);

	if(TYPE(lbot->val) != DTPR) return(nil);	/* no form */

	/* evaluate and save flag first */
	flag = lbot->val->d.cdr;
	if(TYPE(flag) == DTPR) flag = eval(flag->d.car); 
	else flag = tatom; 	/* if not present , assume t */
	protect(flag);

	errp = Pushframe(F_CATCH,Verall,flag);

	switch(retval) {

	case C_THROW: 	/*
			 * error thrown to this routine, value thrown is
			 * in lispretval
			 */
			break;

	case C_INITIAL:	/*
			 * normally just evaluate expression and listify it.
			 */
			temp = eval(lbot->val->d.car);
			protect(temp);
			(lispretval = newdot())->d.car = temp;
			break;
	}

	errp = Popframe();
	Restorestack();
	return(lispretval);
}
	
/* this was changed from throw to *throw 21nov79
   it is now a lambda and really should be called Lthrow
*/
lispval
Nthrow()
{
	switch(np-lbot) {
	case 0:
		protect(nil);
	case 1:
		protect(nil);
	case 2: break;
	default:
		argerr("throw");
	}
	Inonlocalgo(C_THROW,lbot->val,(lbot+1)->val);
	/* NOT REACHED */
}



/* Ngo ******************************************************************/
/* First argument only is checked - and must be an atom or evaluate	*/
/* to one.								*/
lispval
Ngo() 
{
    register lispval temp;
    chkarg(1,"go");

    temp = (lbot->val)->d.car;
    if (TYPE(temp) != ATOM)
    {
	temp = eval(temp);
	while(TYPE(temp) != ATOM) 
	  temp = errorh1(Vermisc,"Illegal tag to go to",nil,TRUE, 0,lbot->val);
    }
    Inonlocalgo(C_GO,temp,nil);
    /* NOT REACHED */
}


/* Nreset ***************************************************************/
/* All arguments are ignored.  This just returns-from-break to depth 0.	*/
lispval
Nreset()
{
    Inonlocalgo(C_RESET,inewint(0),nil);
}



/* Nbreak ***************************************************************/
/* If first argument is not nil, this is evaluated and printed.  Then	*/
/* error is called with the "breaking" message.				*/

lispval
Nbreak()
{
	register lispval hold; register FILE *port;
	port = okport(Vpoport->a.clb,stdout);
	fprintf(port,"Breaking:");

	if ((hold = lbot->val) != nil && ((hold = hold->d.car) != nil))
	{
		printr(hold,port);
	}
	putc('\n',port);
	dmpport(port);
	return(errorh(Verbrk,"",nil,TRUE,0));
}


/* Nexit ****************************************************************/
/* Just calls lispend with no message.					*/
Nexit()
	{
	lispend("");
	}


/* Nsys *****************************************************************/
/* Just calls lispend with no message.					*/

lispval
Nsys()
	{
	lispend("");
	}




lispval
Ndef() {
	register lispval arglist, body, name, form;
	
	form = lbot->val;
	name = form->d.car;
	body = form->d.cdr->d.car;
	arglist = body->d.cdr->d.car;
	if((TYPE(arglist))!=DTPR && arglist != nil)
		error("Warning: defining function with nonlist of args",
			TRUE);
	name->a.fnbnd = body;
	return(name);
}


lispval
Nquote()
{
	return((lbot->val)->d.car);
}


lispval
Nsetq()
{	register lispval handy, where, value;
	register int lefttype;

	value = nil;
	
	for(where = lbot->val; where != nil; where = handy->d.cdr) {
		handy = where->d.cdr;
		if((TYPE(handy))!=DTPR)
			error("odd number of args to setq",FALSE);
		if((lefttype=TYPE(where->d.car))==ATOM) {
			if(where->d.car==nil)
				error("Attempt to set nil",FALSE);
			where->d.car->a.clb = value = eval(handy->d.car);
		 }else if(lefttype==VALUE)
			where->d.car->l = value = eval(handy->d.car);
		else errorh1(Vermisc,
			    "Can only setq atoms or values",nil,FALSE,0,
			    		where->d.car);
	}
	return(value);
}


lispval
Ncond()
{
	register lispval  where, last;

	where = lbot->val;
	last = nil;
	for(;;) {
		if ((TYPE(where))!=DTPR)
			break;
		if ((TYPE(where->d.car))!=DTPR)
			break;
		if ((last=eval((where->d.car)->d.car)) != nil)
			break;
		where = where->d.cdr;
	}

	if ((TYPE(where)) != DTPR)
			return(nil);
	where = (where->d.car)->d.cdr;
	while ((TYPE(where))==DTPR) {
			last = eval(where->d.car);
			where = where->d.cdr;
	}
	return(last);
}

lispval
Nand()
{
	register lispval current, temp;

	current = lbot->val;
	temp = tatom;
	while (current != nil)
		if ( (temp = current->d.car)!=nil && (temp = eval(temp))!=nil) 
			current = current->d.cdr;
		else {
			current = nil;
			temp = nil;
		}
	return(temp);
}


lispval
Nor()
{
	register lispval current, temp;

	current = lbot->val;
	temp = nil;
	while (current != nil)
		if ( (temp = eval(current->d.car)) == nil)
			current = current->d.cdr;
		else
			break;
	return(temp);
}
EndOfFile
cat >  franz/vax/../fex2.c  << 'EndOfFile'

#ifndef lint
static char *rcsid =
   "$Header: fex2.c,v 1.3 83/09/07 17:55:38 sklower Exp $";
#endif

/*					-[Mon Jan 31 21:54:52 1983 by layer]-
 * 	fex2.c				$Locker:  $
 * nlambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#define NDOVARS 30
#include "frame.h"

/*
 * Ndo  maclisp do function.
 */
lispval
Ndo()
{
	register lispval current, where, handy;
	register struct nament *mybnp;
	lispval temp, atom;
	lispval body, endtest, endform, varstuff, renewals[NDOVARS] ;
	struct argent *getem, *startnp;  
	struct nament *savedbnp = bnp;
	int count, repeatdo, index;
	extern struct frame *errp;
	pbuf pb;
	Savestack(3);

	current = lbot->val;
	varstuff = current->d.car;

	switch( TYPE(varstuff) ) {

	case ATOM:			/* This is old style maclisp do;
					   atom is var, cadr(current) = init;
					   caddr(current) = repeat etc. */
		if(varstuff==nil) goto newstyle;
		current = current->d.cdr;	/* car(current) is now init */
		PUSHDOWN(varstuff,eval(current->d.car));
					/* Init var.	    */
		*renewals = (current = current->d.cdr)->d.car;
					/* get repeat form  */
		endtest	= (current = current->d.cdr)->d.car;
		body = current->d.cdr;

		errp = Pushframe(F_PROG,nil,nil);

		switch (retval) {
		    case C_RET:	/*
				 * returning from this prog, value to return
				 * is in lispretval
				 */
				errp = Popframe();
				popnames(savedbnp);
				return(lispretval);

		    case C_GO:	/*
				 * going to a certain label, label to go to in
				 * in lispretval
				 */
				where = body;
				while ((TYPE(where) == DTPR) 
					& (where->d.car != lispretval))
				where = where->d.cdr;
				if (where->d.car == lispretval) {
					popnames(errp->svbnp);
					where = where->d.cdr;
					goto singbody;
				}
				/* label not found in this prog, must 
				 * go up to higher prog
				 */
				Inonlocalgo(C_GO,lispretval,nil);

				/* NOT REACHED */

		    case C_INITIAL: break;  	/* fall through */

		}

	    singtop:
		    if(eval(endtest)!=nil) {
			errp = Popframe();
			popnames(savedbnp);
			return(nil);
		    }
		    where = body;
		    
	    singbody:
		    while (TYPE(where) == DTPR)
		    {
			temp = where->d.car;
			if((TYPE(temp))!=ATOM) eval(temp);
			where = where->d.cdr;
		    }
		    varstuff->a.clb = eval(*renewals);
		    goto singtop;
	

	newstyle:
	case DTPR:			/* New style maclisp do; atom is
					   list of things of the form
					   (var init repeat)		*/
		count = 0;
		startnp = np;
		for(where = varstuff; where != nil; where = where->d.cdr) {
					/* do inits and count do vars. */
					/* requires "simultaneous" eval
					   of all inits			*/
		        while (TYPE(where->d.car) != DTPR)
			  where->d.car =
			     errorh1(Vermisc,"do: variable forms must be lists ",
			     nil,TRUE,0,where->d.car);
			handy = where->d.car->d.cdr;
			temp = nil;
			if(handy !=nil)
				temp = eval(handy->d.car);
			protect(temp);
			count++;
		}
		if(count > NDOVARS)
			error("More than 15 do vars",FALSE);
		where = varstuff;
		getem = startnp;	/* base of stack of init forms */
		for(index = 0; index < count; index++) {

			handy = where->d.car;
					/* get var name from group	*/

			atom = handy->d.car;
			while((TYPE(atom) != ATOM) || (atom == nil))
			  atom = errorh1(Vermisc,"do variable must be a non nil symbol ",
						    nil,TRUE,0,atom);
			PUSHDOWN(atom,getem->val);
			getem++;
			handy = handy->d.cdr->d.cdr;
			if(handy==nil)
				handy = CNIL;  /* be sure not to rebind later */
			else
				handy = handy->d.car;
			renewals[index] = handy;

					/* more loop "increments" */
			where = where->d.cdr;
		}
		np = startnp;		/* pop off all init forms */
					/* Examine End test and End form */
		current = current->d.cdr;
		handy = current->d.car;
		body = current->d.cdr;

		/* 
		 * a do form with a test of nil just does the body once
		 * and returns nil
		 */
		if (handy == nil) repeatdo = 1; /* just do it once */
		else repeatdo = -1;		/* do it forever   */

		endtest = handy->d.car;
		endform = handy->d.cdr;

		where = body;

		errp = Pushframe(F_PROG,nil,nil);
		while(TRUE) {

		    switch (retval) {
		    case C_RET:	/*
				 * returning from this prog, value to return
				 * is in lispretval
				 */
				errp = Popframe();
				popnames(savedbnp);
				Restorestack();
				return(lispretval);

		    case C_GO:	/*
				 * going to a certain label, label to go to in
				 * in lispretval
				 */
				where = body;
				while ((TYPE(where) == DTPR) 
					& (where->d.car != lispretval))
				where = where->d.cdr;
				if (where->d.car == lispretval) {
					popnames(errp->svbnp);
					where = where->d.cdr;
					goto bodystart;
				}
				/* label not found in this prog, must 
				 * go up to higher prog
				 */
				Inonlocalgo(C_GO,lispretval,nil);

				/* NOT REACHED */

		    case C_INITIAL: break;  	/* fall through */

		    }

	    loop:
	    	    np = startnp;	/* is bumped when doing repeat forms */

		    if((repeatdo-- == 0) || (eval(endtest) !=nil)) {
			for(handy = nil; endform!=nil; endform = endform->d.cdr)
			{
				handy = eval(endform->d.car);
			}
			errp = Popframe();
			popnames(savedbnp);
			Restorestack();
			return(handy);
		    }
		    
	    bodystart:
		    while (TYPE(where) == DTPR)
		    {
			temp = where->d.car;
			if((TYPE(temp))!=ATOM) eval(temp);
			where = where->d.cdr;
		    }
		    where = body;
		    getem = np = startnp;
					/* Simultaneously eval repeat forms */
		    for(index = 0; index < count; index++) {
			temp = renewals[index];
			if (temp == nil || temp == CNIL)
				protect(temp);
			else
				protect(eval(temp));
		    }
					/* now simult. rebind all the atoms */
		    mybnp = savedbnp;
		    for(index = 0; index < count; index++) 
		    {
		       if( getem->val != CNIL )  /* if this atom has a repeat */
			mybnp->atm->a.clb = (getem)->val;  /* rebind */
			mybnp++;
			getem++;
		    }
		    goto loop;
	   	}
	    default:
		error("do: neither list nor atom follows do", FALSE);
	    }
		/* NOTREACHED */
}

lispval
Nprogv()
{
	register lispval where, handy;
	register struct nament *namptr;
	register struct argent *vars;
	struct nament *oldbnp = bnp;
	Savestack(4);

	where = lbot->val;
	protect(eval(where->d.car));		/* list of vars = lbot[1].val */
	protect(eval((where = where->d.cdr)->d.car));
						/* list of vals */
	handy = lbot[2].val;
	namptr = oldbnp;
						/* simultaneous eval of all
						   args */
	for(;handy!=nil; handy = handy->d.cdr) {
		(np++)->val = (handy->d.car);
		/*  Note, each element should not be reevaluated like it 
		 *  was  before.  - dhl */
		/* Before: (np++)->val = eval(handy->d.car);*/
		TNP;
	}
	/*asm("# Here is where rebinding is done");	 /* very cute */
	for(handy=lbot[1].val,vars=lbot+3; handy!=nil; handy=handy->d.cdr) {
	    namptr->atm = handy->d.car;
	    ++namptr;				/* protect against interrupts
						   while re-lambda binding */
	    bnp = namptr;
	    namptr[-1].atm = handy->d.car;
	    namptr[-1].val = handy->d.car->a.clb;
	    if(vars < np)
		handy->d.car->a.clb = vars++->val;
	    else
		handy->d.car->a.clb = nil;
	}
		
	handy = nil;
	for(where = where->d.cdr; where != nil; where = where->d.cdr)
		handy = eval(where->d.car);
	popnames(oldbnp);
	Restorestack();
	return(handy);
}

lispval
Nprogn()
{
	register lispval result, where;

	result = nil;
	for(where = lbot->val; where != nil; where = where->d.cdr)
		result = eval(where->d.car);
	return(result);


}
lispval
Nprog2()
{
	register lispval result, where;

	where = lbot->val; 
	eval(where->d.car);
	result = eval((where = where->d.cdr)->d.car);
	protect(result);
	for(where = where->d.cdr; where != nil; where = where->d.cdr)
		eval(where->d.car);
	np--;
	return(result);
}
lispval
typred(typ,ptr)
int 	typ;
lispval	ptr;

{   int tx;
	if ((tx = TYPE(ptr)) == typ) return(tatom);
	if ((tx == INT) && (typ == ATOM)) return(tatom);
	return(nil);
}

/*
 * function
 * In the interpreter, function is the same as quote
 */
lispval
Nfunction()
{
	if((lbot->val == nil) || (lbot->val->d.cdr != nil))
		argerr("function");
	return(lbot->val->d.car);
}
EndOfFile
cat >  franz/vax/../fex3.c  << 'EndOfFile'
#ifndef lint
static char *rcsid = "$Header: fex3.c,v 1.15 85/03/13 17:18:29 sklower Exp $";
#endif
/*					-[Sat Apr  9 17:03:02 1983 by layer]-
 * 	fex3.c				$Locker:  $
 * nlambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
extern char *gstab();
static int pagsiz, pagrnd;


/*
 *Ndumplisp -- create executable version of current state of this lisp.
 */
#ifndef	os_vms
#include "aout.h"

lispval
Ndumplisp()
{
	register struct exec *workp;
	register lispval argptr, temp;
	register char *fname;
	extern int reborn;
	struct exec work, old;
	extern int dmpmode,usehole;
	extern char etext[], *curhbeg;
	int descrip, des2, ax,mode;
	extern int holesize;
	char tbuf[BUFSIZ];
	long count, lseek();


	pageseql();
	pagsiz = Igtpgsz();
	pagrnd = pagsiz - 1;

	/* dump mode is kept in decimal (which looks like octal in dmpmode)
	   and is changeable via (sstatus dumpmode n) where n is 413 or 410
	   base 10		
	*/
	if(dmpmode == 413) mode = 0413;
	else if(dmpmode == 407) mode = 0407;
	else mode = 0410;

	workp = &work;
	workp->a_magic	= mode;
#ifdef os_masscomp
	workp->a_stamp	= 1;
#endif

	if(holesize) {  /* was ifdef HOLE */
		curhbeg		= (char *) (1 + (pagrnd | ((int)curhbeg)-1));
		workp->a_text	= (unsigned long)curhbeg - (unsigned long)OFFSET;
		workp->a_data	= (unsigned) sbrk(0) - workp->a_text - OFFSET;
	} else {
		if(mode==0407)
	            workp->a_text = ((int)etext) - OFFSET;
		else
		    workp->a_text = 1 + ((((int)etext)-1-OFFSET) | pagrnd);
		workp->a_data	= (int) sbrk(0) - ((int)curhbeg);
	}
	workp->a_bss	= 0;
	workp->a_syms	= 0;
	workp->a_entry	= (unsigned) gstart();
	workp->a_trsize	= 0;
	workp->a_drsize	= 0;

	fname = "savedlisp"; /*set defaults*/
	reborn = (int) CNIL;
	argptr = lbot->val;
	if (argptr != nil) {
		temp = argptr->d.car;
		if((TYPE(temp))==ATOM)
			fname = temp->a.pname;
	}
	des2 = open(gstab(),0);
	if(des2 >= 0) {
		if(read(des2,(char *)&old,sizeof(old))>=0)
			work.a_syms = old.a_syms;
	}
	descrip=creat(fname,0777); /*doit!*/
	if(-1==write(descrip,(char *)workp,sizeof(work)))
	{
		close(descrip);
		error("Dumplisp header failed",FALSE);
	}
	if(mode == 0413) lseek(descrip,(long)pagsiz,0); 
	if( -1==write(descrip,(char *)nil,(int)workp->a_text) )
	{
		close(descrip);
		error("Dumplisp text failed",FALSE);
	}
	if( -1==write(descrip,(char *)curhbeg,(int)workp->a_data) )
	{
		close(descrip);
		error("Dumplisp data failed",FALSE);
	}
	if(des2>0  && work.a_syms) {
		count = old.a_text + old.a_data + (old.a_magic == 0413 ? pagsiz 
							       : sizeof(old));
		if(-1==lseek(des2,count,0))
			error("Could not seek to stab",FALSE);
		for(count = old.a_syms;count > 0; count -=BUFSIZ) {
			ax = read(des2,tbuf,(int)(count < BUFSIZ ? count : BUFSIZ));
			if(ax==0) {
				printf("Unexpected end of syms",count);
				fflush(stdout);
				break;
			} else if(ax >  0)
				write(descrip,tbuf,ax);
			else 
				error("Failure to write dumplisp stab",FALSE);
		}
#if ! (os_unix_ts | os_unisoft)
		if(-1 == lseek(des2,(long)
			((old.a_magic == 0413 ? pagsiz : sizeof(old))
			+ old.a_text + old.a_data
				+ old.a_trsize + old.a_drsize + old.a_syms),
			       0))
			error(" Could not seek to string table ",FALSE);
		for( ax = 1 ; ax > 0;) {
		     ax = read(des2,tbuf,BUFSIZ);
		     if(ax > 0)
			 write(descrip,tbuf,ax);
		     else if (ax < 0)
			 error("Error in string table read ",FALSE);
		}
#endif
	}
	close(descrip);
	if(des2>0) close(des2);
	reborn = 0;

	pagenorm();

	return(nil);
}


/*** VMS version of Ndumplisp ***/
#else
#include "aout.h"
#undef	protect
#include <vms/vmsexe.h>

lispval
Ndumplisp()
{
	register struct exec *workp;
	register lispval argptr, temp;
	char *fname;
	register ISD *Isd;
	register int i;
	extern lispval reborn;
	struct exec work,old;
	extern etext;
	extern int dmpmode,holend,curhbeg,usehole,holesize;
	int extra_cref_page = 0;
	char *start_of_data;
	int descrip, des2, count, ax,mode;
	char buf[5000],stabname[100],tbuf[BUFSIZ];
	int fp,fp1;
	union {
		char Buffer[512];
		struct {
			IHD Ihd;
			IHA Iha;
			IHS Ihs;
			IHI Ihi;
			} Header;
		} Buffer;	/* VMS Header */

	/*
	 *	Dumpmode is always 413!!
	 */
	mode = 0413;
	pagsiz = Igtpgsz();
	pagrnd = pagsiz - 1;

	workp = &work;
	workp->a_magic   = mode;
	if (holesize) {
		workp->a_text   =
			((unsigned)curhbeg) & (~pagrnd);
		if (((unsigned)curhbeg) & pagrnd) extra_cref_page = 1;
		start_of_data = (char *)
			(((((unsigned) (&holend)) -1) & (~pagrnd)) + pagsiz);
	} else {
		workp->a_text   =
			((((unsigned) (&etext)) -1) & (~pagrnd)) + pagsiz;
		start_of_data = (char *)workp->a_text;
	}
	workp->a_data   =
		(unsigned) sbrk(0) - (unsigned)start_of_data;
	workp->a_bss    = 0;
	workp->a_syms   = 0;
	workp->a_entry  = (unsigned) gstart();
	workp->a_trsize = 0;
	workp->a_drsize = 0;

	fname = "savedlisp";	/* set defaults */
	reborn = CNIL;
	argptr = lbot->val;
	if (argptr != nil) {
		temp = argptr->d.car;
		if((TYPE(temp))==ATOM)
			fname = temp->a.pname;
	}
	/*
	 *	Open the new executable file
	 */
	strcpy(buf,fname);
	if (index(buf,'.') == 0) strcat(buf,".exe");
	if ((descrip = creat(buf,0777)) < 0) error("Dumplisp failed",FALSE);
	/*
	 *	Create the VMS header
	 */
	for(i = 0; i < 512; i++) Buffer.Buffer[i] = 0;	/* Clear Header */
	Buffer.Header.Ihd.size		= sizeof(Buffer.Header);
	Buffer.Header.Ihd.activoff	= sizeof(IHD);
	Buffer.Header.Ihd.symdbgoff	= sizeof(IHD) + sizeof(IHA);
	Buffer.Header.Ihd.imgidoff	= sizeof(IHD) + sizeof(IHA) + sizeof(IHS);
	Buffer.Header.Ihd.majorid[0]	= '0';
	Buffer.Header.Ihd.majorid[1]	= '2';
	Buffer.Header.Ihd.minorid[0]	= '0';
	Buffer.Header.Ihd.minorid[1]	= '2';
	Buffer.Header.Ihd.imgtype	= IHD_EXECUTABLE;
	Buffer.Header.Ihd.privreqs[0]	= -1;
	Buffer.Header.Ihd.privreqs[1]	= -1;
	Buffer.Header.Ihd.lnkflags.nopobufs = 1;
	Buffer.Header.Ihd.imgiocnt = 250;

	Buffer.Header.Iha.tfradr1	= SYS$IMGSTA;
	Buffer.Header.Iha.tfradr2	= workp->a_entry;

	strcpy(Buffer.Header.Ihi.imgnam+1,"SAVEDLISP");
	Buffer.Header.Ihi.imgnam[0] = 9;
	Buffer.Header.Ihi.imgid[0] = 0;
	Buffer.Header.Ihi.imgid[1] = '0';
	sys$gettim(Buffer.Header.Ihi.linktime);
	strcpy(Buffer.Header.Ihi.linkid+1," Opus 38");
	Buffer.Header.Ihi.linkid[0] = 8;

	Isd = (ISD *)&Buffer.Buffer[sizeof(Buffer.Header)];
		/* Text ISD */
	Isd->size	= ISDSIZE_TEXT;
	Isd->pagcnt	= workp->a_text >> 9;
	Isd->vpnpfc.vpn = 0;
	Isd->flags.type = ISD_NORMAL;
	Isd->vbn	= 3;
	Isd = (ISD *)((char *)Isd + Isd->size);
		/* Hole ISDs (if necessary) */
	if (usehole) {
		/* Copy on Ref ISD for possible extra text page */
		if(extra_cref_page) {
			Isd->size	= ISDSIZE_TEXT;
			Isd->pagcnt	= 1;
			Isd->vpnpfc.vpn = (((unsigned)curhbeg) & (~pagrnd)) >> 9;
			Isd->flags.type = ISD_NORMAL;
			Isd->flags.crf	= 1;
			Isd->flags.wrt	= 1;
			Isd->vbn	= (workp->a_text >> 9) + 3;
			Isd = (ISD *)((char *)Isd + Isd->size);
		}
		/* Demand Zero ISD for rest of Hole */
		Isd->size	= ISDSIZE_DZRO;
		Isd->pagcnt	=
			((((unsigned)&holend)
				- (unsigned)curhbeg) & (~pagrnd)) >> 9;
		Isd->vpnpfc.vpn	=
			((((unsigned)curhbeg) & (~pagrnd)) >> 9) + extra_cref_page;
		Isd->flags.type = ISD_NORMAL;
		Isd->flags.dzro = 1;
		Isd->flags.wrt	= 1;
		Isd = (ISD *)((char *)Isd + Isd->size);
	}
		/* Data ISD */
	Isd->size	= ISDSIZE_TEXT;
	Isd->pagcnt	= workp->a_data >> 9;
	Isd->vpnpfc.vpn = ((unsigned)start_of_data) >> 9;
	Isd->flags.type = ISD_NORMAL;
	Isd->flags.crf	= 1;
	Isd->flags.wrt	= 1;
	Isd->vbn	= (workp->a_text >> 9) + 3;
	if (holesize) {
		/*
		 *	Correct the Data ISD
		 */
		Isd->vbn	+= extra_cref_page;
	}
	Isd = (ISD *)((char *)Isd + Isd->size);
		/* Stack ISD */
	Isd->size	= ISDSIZE_DZRO;
	Isd->pagcnt	= ISDSTACK_SIZE;
	Isd->vpnpfc.vpn	= ISDSTACK_BASE;
	Isd->flags.type = ISD_USERSTACK;
	Isd->flags.dzro	= 1;
	Isd->flags.wrt	= 1;
	Isd = (ISD *)((char *)Isd + Isd->size);
		/* End of ISD List */
	Isd->size = 0;
	Isd = (ISD *)((char *)Isd + 2);
	/*
	 *	Make the rest of the header -1s
	 */
	for (i = ((char *)Isd - Buffer.Buffer); i < 512; i++)
						Buffer.Buffer[i] = -1;
	/*
	 *	Write the VMS Header
	 */
	if (write(descrip,Buffer.Buffer,512) == -1)
					error("Dumplisp failed",FALSE);
#if	EUNICE_UNIX_OBJECT_FILE_CFASL
	/*
	 *	Get the UNIX symbol table file header
	 */
	des2 = open(gstab(),0);
	if (des2 >= 0) {
		old.a_magic = 0;
		if (read(des2,(char *)&old,sizeof(old)) >= 0) {
			if (N_BADMAG(old)) {
				lseek(des2,512,0);	/* Try block #1 */
				read(des2,(char *)&old,sizeof(old));
			}
			if (!N_BADMAG(old)) work.a_syms = old.a_syms;
		}
	}
#endif	EUNICE_UNIX_OBJECT_FILE_CFASL
	/*
	 *	Update the UNIX header so that the extra cref page is
	 *	considered part of data space.
	 */
	if (extra_cref_page) work.a_data += 512;
	/*
	 *	Write the UNIX header
	 */
	if (write(descrip,&work,sizeof(work)) == -1)
				error("Dumplisp failed",FALSE);
	/*
	 *	seek to 1024 (end of headers)
	 */
	if (lseek(descrip,1024,0) == -1)
				error("Dumplisp failed",FALSE);
	/*
	 *	write the world
	 */
	if (write(descrip,0,workp->a_text) == -1)
				error("Dumplisp failed",FALSE);
	if (extra_cref_page)
		if (write(descrip,(((unsigned)curhbeg) & pagrnd), pagsiz) == -1)
				error("Dumplisp failed",FALSE);
	if (write(descrip,start_of_data,workp->a_data) == -1)
				error("Dumplisp failed",FALSE);

#if	!EUNICE_UNIX_OBJECT_FILE_CFASL
	/*
	 *	VMS OBJECT files: We are done with the executable file
	 */
	close(descrip);
	/*
	 *	Now try to write the symbol table file!
	 */
	strcpy(buf,gstab());

	strcpy(stabname,fname);
	if (index(stabname,'.') == 0) strcat(stabname,".stb");
	else strcpy(index(stabname,'.'), ".stb");

	/* Use Link/Unlink to rename the symbol table */
	if (!strncmp(gstab(),"tmp:",4))
		if (link(buf,stabname) >= 0)
			if (unlink(buf) >= 0) return(nil);

	/* Copy the symbol table */
	if ((fp  = open(buf,0)) < 0)
			error("Symbol table file not there\n",FALSE);
	fp1 = creat(stabname,0666,"var");
	while((i = read(fp,buf,5000)) > 0)
		if (write(fp1,buf,i) == -1) {
			close(fp); close(fp1);
			error("Error writing symbol table\n",FALSE);
		}
	close(fp); close(fp1);
	if (i < 0) error("Error reading symbol table\n",FALSE);
	if (!strncmp(gstab(),"tmp:",4)) unlink(gstab);
	/*
	 *	Done
	 */
	reborn = 0;
	return(nil);
#else	EUNICE_UNIX_OBJECT_FILE_CFASL
	/*
	 *	UNIX OBJECT files: append the new symbol table
	 */
	if(des2>0  && work.a_syms) {
		count = old.a_text + old.a_data + (old.a_magic == 0413 ? 1024
							       : sizeof(old));
		if(-1==lseek(des2,count,0))
			error("Could not seek to stab",FALSE);
		for(count = old.a_syms;count > 0; count -=BUFSIZ) {
			ax = read(des2,tbuf,(int)(count < BUFSIZ ? count : BUFSIZ));
			if(ax==0) {
				printf("Unexpected end of syms",count);
				fflush(stdout);
				break;
			} else if(ax >  0)
				write(descrip,tbuf,ax);
			else 
				error("Failure to write dumplisp stab",FALSE);
		}
		if(-1 == lseek(des2,(long)
			((old.a_magic == 0413 ? 1024 : sizeof(old))
			+ old.a_text + old.a_data
				+ old.a_trsize + old.a_drsize + old.a_syms),
			       0))
			error(" Could not seek to string table ",FALSE);
		for( ax = 1 ; ax > 0;) {
		     ax = read(des2,tbuf,BUFSIZ);
		     if(ax > 0)
			 write(descrip,tbuf,ax);
		     else if (ax < 0)
			 error("Error in string table read ",FALSE);
		}
	}
	close(descrip);
	if(des2>0) close(des2);
	reborn = 0;

	return(nil);
#endif	EUNICE_UNIX_OBJECT_FILE_CFASL
}
#endif
#if (os_4_1 | os_4_1a | os_4_1c | os_4_2| os_4_3)

#if (os_4_2 | os_4_3)
#include <sys/vadvise.h>
#else
#include <vadvise.h>
#endif

pagerand() { vadvise(VA_ANOM); }
pageseql() { vadvise(VA_SEQL); }
pagenorm() { vadvise(VA_NORM); }
#endif
#if (os_unisoft | os_vms | os_unix_ts | os_masscomp)
pagerand() { }
pageseql() { }
pagenorm() { }
#endif

/* getaddress --
 *
 * (getaddress '|_entry1| 'fncname1 '|_entry2| 'fncname2 ...)
 *
 * binds value of symbol |_entry1| to function defition of atom fncname1, etc.
 *
 * returns fnc-binding of fncname1.
 *
 */
#if os_unisoft || os_unix_ts
#define N_name n_name
#define STASSGN(p,q) strncpy(NTABLE[(p)].n_name,(q),8)
#else
#define N_name n_un.n_name
#define STASSGN(p,q) (NTABLE[p].N_name = (q))
#endif

lispval
Lgetaddress(){
	register struct argent *mlbot = lbot;
	register lispval work;
	register int numberofargs, i;
	char ostabf[128];
	struct nlist NTABLE[100];
	lispval dispget();

	Savestack(4);

	if(np-lbot == 2) protect(nil);	/* allow 2 args */
	numberofargs = (np - lbot)/3;
	if(numberofargs * 3 != np-lbot)
	   error("getaddress: arguments must come in triples ",FALSE);

	for ( i=0; i<numberofargs; i++,mlbot += 3) {
		NTABLE[i].n_value = 0;
	        mlbot[0].val = verify(mlbot[0].val,"Incorrect entry specification for binding");
		STASSGN(i,(char *) mlbot[0].val);
		while(TYPE(mlbot[1].val) != ATOM)
			mlbot[1].val = errorh1(Vermisc,
					"Bad associated atom name for binding",
					  nil,TRUE,0,mlbot[1].val);
		mlbot[2].val = dispget(mlbot[2].val,"getaddress: Incorrect discipline specification ",(lispval)Vsubrou->a.pname);
	}
		STASSGN(numberofargs,"");
	strncpy(ostabf,gstab(),128);
	if ( nlist(ostabf,NTABLE) == -1 ) {
	    errorh1(Vermisc,"Getaddress: Bad file",nil,FALSE,0,inewstr(ostabf));
	} else 
	    for (i=0,mlbot=lbot+1; i<numberofargs; i++,mlbot+=3) {
		if ( NTABLE[i].n_value == 0 )
		    fprintf(stderr,"Undefined symbol: %s\n",
			      NTABLE[i].N_name);
		else {
		    work= newfunct();
		    work->bcd.start = (lispval (*) ())NTABLE[i].n_value;
		    work->bcd.discipline = mlbot[1].val;
		    mlbot->val->a.fnbnd = work;
		}
	    };
	Restorestack();
	return(lbot[1].val->a.fnbnd);
};

Igtpgsz()
{
#if (os_4_1c | os_4_2 | os_4_3)
	return(getpagesize());
#else
#if (vax_eunice_vms | os_unisoft)
	return(512);
#else
#if os_masscomp
	return(4096);
#else
	return(1024);
#endif
#endif
#endif
}
EndOfFile
cat >  franz/vax/../fex4.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: fex4.c,v 1.5 85/03/13 17:19:04 sklower Exp $";
#endif

/*					-[Sat Jan 29 12:40:56 1983 by jkf]-
 * 	fex4.c				$Locker:  $
 * nlambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include "lfuncs.h"
#include "chkrtab.h"
#include <signal.h>
#include <sys/types.h>

#if (os_4_2 || os_4_3)
#include <sys/time.h>
#else
#include <time.h>
#endif

/* this is now a lambda function instead of a nlambda.
   the only reason that it wasn't a lambda to begin with is that 
   the person who wrote it didn't know how to write a lexpr
						- jkf
*/
lispval
Lsyscall() {
	register lispval temp;
	register struct argent *aptr;
	register int acount = 1;
	extern syscall();
	int args[50];
	Savestack(3);

	/* there must be at least one argument */

	if (np==lbot) { chkarg(1,"syscall"); }

	aptr = lbot;
	temp = lbot->val;
	if (TYPE(temp) != INT) {
		Restorestack();
		return(error("syscall: bad first argument ", FALSE));
	}
	args[acount++] = temp->i;
	while( ++aptr < np && acount < 48) {
		temp = aptr->val;
		switch(TYPE(temp)) {

			case ATOM:	
				args[acount++] = (int)temp->a.pname;
				break;

			case STRNG:
				args[acount++] = (int) temp;
				break;

			case INT:
				args[acount++] = (int)temp->i;
				break;

			default:
				Restorestack();
				return(error("syscall: arg not symbol, string or fixnum", FALSE));
		}
	}

	Restorestack();
	args[0] = acount - 1;
	return(inewint(callg_(syscall,args)));
}

/* eval-when: this has the form (eval-when <list> <form1> <form2> ...)
   where the list may contain any combination of `eval', `load', `compile'.
   The interpreter (us) looks for the atom `eval', if it is present
   we treat the rest of the forms as a progn.
*/

lispval
Nevwhen()
{
	register lispval handy;
	register lispval handy2;
	Savestack(2);

	for (handy=(lbot->val)->d.car ; handy != nil ; handy = handy->d.cdr) {
	   if (handy->d.car == (lispval) Veval) {
		lbot=np;
		protect(((lbot-1)->val)->d.cdr);
		handy2 = Nprogn();
		Restorestack();
		return(handy2);
	    }
	}


	Restorestack();
	return(nil);	/* eval not seen */
}


/*	Status functions. 
 *  These operate on the statuslist stlist which has the form:
 *	( status_elem_1 status_elem_2 status_elem_3 ...)
 *  where each status element has the form:
 *	( name readcode setcode .  readvalue)
 *  where
 *	name - name of the status feature (the first arg to the status
 *		function).
 *	readcode - fixnum which tells status how to read the value of
 *		this status name.  The codes are #defined.
 *	setcode - fixnum which tells sstatus how to set the value of
 *		this status name
 *	readvalue - the value of the status feature is usually stored
 *		here.
 *	
 * Readcodes:
 *
 *	ST_READ - if no second arg, return readvalue.
 *		  if the second arg is given, we return t if it is eq to
 *		  the readvalue.
 *	ST_FEATR - used in (status feature xxx) where we test for xxx being
 *		  in the status features list
 *	ST_SYNT - used in (status syntax c) where we return c's syntax code
 *	ST_INTB - read stattab entry
 *	ST_NFETR - used in (status nofeature xxx) where we test for xxx not
 *		  being in the status features list
 *	ST_DMPR - read the dumpmode 
 *	ST_UNDEF - return the undefined functions in the transfer table
 * 
 * Setcodes:
 *	ST_NO -  if not allowed to set this status through sstatus.
 *	ST_SET - if the second arg is made the readvalue.
 *	ST_FEATW - for (sstatus feature xxx), we add xxx to the 
 *		  (status features) list.
 *	ST_TOLC - if non nil, map upper case chars in atoms to lc.
 *	ST_CORE - if non nil, have bus errors and segmentation violations
 *		  dump core, if nil have them produce a bad-mem err msg
 *	ST_INTB - set stattab table entry
 *	ST_NFETW - use in (sstatus nofeature xxx) where we wish to remove xxx
 *		   from the status feature list.
 *	ST_DMPW - set the dumpmode
 *	ST_BCDTR - (ifdef RSET) if non nil, creat trace stack entries for
 *		   calls from BCD functions to BCD functions
 *	ST_GCSTR - (ifdef GCSTRINGS) garbage collect strings
 */

lispval
Nstatus()
{
	register lispval handy,curitm,valarg;
	int indx,ctim;
	int typ;
	char *cp;
	char *ctime();
	struct tm *lctime,*localtime();
	extern unsigned char *ctable;
	extern int dmpmode;
	extern lispval chktt();
	lispval Istsrch();
	Savestack(3);

	if(lbot->val == nil) return(nil);
	handy = lbot->val;		/* arg list */

	while(TYPE(handy) != DTPR) handy = error("status: bad arg list",TRUE); 
	
	curitm = Istsrch(handy->d.car);	/* look for feature */

	if( curitm == nil ) return(nil);	/* non existant */

	if( handy->d.cdr == nil ) valarg = (lispval) CNIL;
	else valarg = handy->d.cdr->d.car;

	/* now do the processing with curitm pointing to the requested
	   item in the status list 
	 */
	
	switch( typ = curitm->d.cdr->d.car->i ) {	/* look at readcode */


	case ST_READ:
		curitm = Istsrch(handy->d.car);	/* look for name */
		if(curitm == nil) return(nil);
		if( valarg != (lispval) CNIL) 
		    error("status: Second arg not allowed.",FALSE);
		else return(curitm->d.cdr->d.cdr->d.cdr);

	case ST_NFETR:				/* look for feature present */
	case ST_FEATR:				/* look for feature */
		curitm = Istsrch(matom("features"));
		if( valarg == (lispval) CNIL) 
		    error("status: need second arg",FALSE);

		for( handy = curitm->d.cdr->d.cdr->d.cdr;
		     handy != nil;
		     handy = handy->d.cdr)
		   if(handy->d.car == valarg) 
			 return(typ == ST_FEATR ? tatom : nil);
		
		return(typ == ST_FEATR ? nil : tatom);

	case ST_SYNT:				/* want character syntax */
		handy = Vreadtable->a.clb;
		chkrtab(handy);
		if( valarg == (lispval) CNIL)
			error("status: need second arg",FALSE);
		
		while (TYPE(valarg) != ATOM) 
		    valarg = error("status: second arg must be atom",TRUE);
		
		indx = valarg->a.pname[0];	/* get first char */

		if(valarg->a.pname[1] != '\0')
			error("status: only one character atom allowed",FALSE);

		handy = inewint((long) ctable[indx]);
		return(handy);

	case ST_RINTB:
		return(stattab[curitm->d.cdr->d.cdr->d.cdr->i]);

	case ST_DMPR:
		return(inewint(dmpmode));
		
	case ST_CTIM:
		 ctim = time((time_t *)0);
		 cp = ctime(&ctim);
		 cp[24] = '\0';
		 return(matom(cp));

	case ST_LOCT:
		 ctim = time((time_t *)0);
		 lctime = localtime(&ctim);
		 (handy = newdot())->d.car = inewint(lctime->tm_sec);
		 protect(handy);
		 handy->d.cdr =  (valarg = newdot());
		 valarg->d.car = inewint(lctime->tm_min);
		 valarg->d.cdr = (curitm = newdot());
		 curitm->d.car = inewint(lctime->tm_hour);
		 curitm->d.cdr = (valarg = newdot());
		 valarg->d.car = inewint(lctime->tm_mday);
		 valarg->d.cdr = (curitm = newdot());
		 curitm->d.car = inewint(lctime->tm_mon);
		 curitm->d.cdr = (valarg = newdot());
		 valarg->d.car = inewint(lctime->tm_year);
		 valarg->d.cdr = (curitm = newdot());
		 curitm->d.car = inewint(lctime->tm_wday);
		 curitm->d.cdr = (valarg = newdot());
		 valarg->d.car = inewint(lctime->tm_yday);
		 valarg->d.cdr = (curitm = newdot());
		 curitm->d.car = inewint(lctime->tm_isdst);
		 Restorestack();
		 return(handy);

	case ST_ISTTY:
		return( (isatty(0) == TRUE ? tatom : nil));

	case ST_UNDEF:
		return(chktt());
	}
	error("Internal error in status: Couldn't figure out request",FALSE);
	/* NOTREACHED */
}
lispval
Nsstatus()
{
	register lispval handy;
	lispval Isstatus();

	handy = lbot->val;

	while( TYPE(handy) != DTPR || TYPE(handy->d.cdr) != DTPR)
	     handy = error("sstatus: Bad args",TRUE);
	
	return(Isstatus(handy->d.car,handy->d.cdr->d.car));
}

/* Isstatus - internal routine to do a set status.	*/
lispval
Isstatus(curnam,curval)
lispval curnam,curval;
{
	register lispval curitm,head;
	lispval Istsrch(),Iaddstat();
	int badmr(),clrtt();
	extern int uctolc, dmpmode, bcdtrsw, gcstrings;

	curitm = Istsrch(curnam);
	/* if doesnt exist, make one up */

	if(curitm == nil) curitm = Iaddstat(curnam,ST_READ,ST_SET,nil);

	switch (curitm->d.cdr->d.cdr->d.car->i) {

	case ST_NO: error("sstatus: cannot set this status",FALSE);

	case ST_SET: goto setit;

	case ST_FEATW: curitm = Istsrch(matom("features"));
		      (curnam = newdot())->d.car = curval;
		      curnam->d.cdr = curitm->d.cdr->d.cdr->d.cdr;	/* old val */
		      curitm->d.cdr->d.cdr->d.cdr = curnam;
		      return(curval);

	case ST_NFETW:	/* remove from features list */
		      curitm = Istsrch(matom("features"))->d.cdr->d.cdr;
		      for(head = curitm->d.cdr; head != nil; head = head->d.cdr)
		      {
			   if(head->d.car == curval) curitm->d.cdr = head->d.cdr;
			   else curitm = head;
		      }
		      return(nil);

		      
	case ST_TOLC: if(curval == nil) uctolc = FALSE;
		      else uctolc = TRUE;	
		      goto setit;

	case ST_CORE: if(curval == nil)
		      {
			signal(SIGBUS,badmr);	 /* catch bus errors */
			signal(SIGSEGV,badmr); /* and segmentation viols */
		      }
		      else {
			signal(SIGBUS,SIG_DFL);	/* let them core dump */
			signal(SIGSEGV,SIG_DFL);
		      }
		      goto setit;

	case ST_INTB: 
		      stattab[curitm->d.cdr->d.cdr->d.cdr->i] = curval;
		      return(curval);

	case ST_DMPW:	
		      if(TYPE(curval) != INT ||
			 (curval->i != 413    &&
			  curval->i != 407    &&
			  curval->i != 410)) errorh1(Vermisc,"sstatus: bad dump mode:",
						  nil,FALSE,0,curval);
		      dmpmode= curval->i;	
		      return(curval);

	 case ST_AUTR:
		      if(curval != nil) Sautor = (lispval) TRUE;
		      else Sautor = FALSE;
		      goto setit;
			
	 case ST_TRAN:
		      if(curval != nil) 
		      {     
			     Strans = (lispval) TRUE;
			     /* the atom `on' set to set up all table
			      * to their bcd fcn if possible
			      */
			     if(curval == matom("on")) clrtt(1);
		      }	
		      else { 
			     Strans = (lispval) FALSE;
			     clrtt(0);	/* clear all transfer tables */
		      }
		      goto setit;
	case ST_BCDTR:
		      if(curval == nil) bcdtrsw = FALSE;
		      else bcdtrsw = TRUE;
		      goto setit;
	case ST_GCSTR:
		      if(curval == nil) gcstrings = FALSE;
		      else gcstrings = TRUE;
		      goto setit;
	}

    setit:	      /* store value in status list */
		      curitm->d.cdr->d.cdr->d.cdr = curval;
		      return(curval);


}

/* Istsrch - utility routine to search the status list for the
   name given as an argument.  If such an entry is not found,
   we return nil
 */
			
lispval Istsrch(nam)
lispval nam;
{
	register lispval handy; 

	for(handy = stlist ; handy != nil ; handy = handy->d.cdr)
	  if(handy->d.car->d.car == nam) return(handy->d.car);

	return(nil);
}

/* Iaddstat - add a status entry to the status list	*/
/*	return new entry in status list */

lispval
Iaddstat(name,readcode,setcode,valu)
lispval name,valu;
int readcode,setcode;
{
	register lispval handy,handy2;
	Savestack(2);


	protect(handy=newdot());	/* build status list here */

	(handy2 = newdot())->d.car = name;

	handy->d.car = handy2;

	((handy2->d.cdr = newdot())->d.car = newint())->i = readcode;

	handy2 = handy2->d.cdr;

	((handy2->d.cdr = newdot())->d.car = newint())->i = setcode;

	handy2->d.cdr->d.cdr = valu;

	/* link this one in */

	handy->d.cdr = stlist;	
	stlist = handy;

	Restorestack();
	return(handy->d.car);	/* return new item in stlist */
}
EndOfFile
cat >  franz/vax/../fexr.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: /na/franz/franz/RCS/fexr.c,v 1.1 83/01/29 12:48:43 jkf Exp $";
#endif

/*					-[Sat Jan 29 12:41:19 1983 by jkf]-
 * 	fexr.c				$Locker:  $
 * nlambda functions
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"

/* Ngcafter *************************************************************/
/*									*/
/*  Default garbage collector routine which does nothing.		*/

lispval 
Ngcafter()
	{
	return(nil);
	}

/*  Nopval  *************************************************************/
/*									*/
/*  Routine which allows system registers and options to be examined	*/
/*  and modified.  Calls copval, the routine which is called by c code	*/
/*  to do the same thing from inside the system.			*/

lispval 
Nopval()
	{
	lispval quant;

	if( TYPE(lbot->val) != DTPR )
		return(error("BAD CALL TO OPVAL",TRUE));
	quant = eval(lbot->val->d.car);	/*  evaluate name of sys variable  */
	while( TYPE(quant) != ATOM )
		quant = error("FIRST ARG TO OPVAL MUST BE AN ATOM",TRUE);

	if( (vtemp=lbot->val->d.cdr) != nil && TYPE(lbot->val->d.cdr) != DTPR )
		return(error("BAD ARG LIST FOR OPVAL",TRUE));
	return(copval(
		quant,
		vtemp==nil ? (lispval)CNIL : eval(vtemp->d.car)
		));
	}
/*  copval  *************************************************************/
/*  This routine keeps track of system quantities, and is called from	*/
/*  C code.  If the second argument is CNIL, no change is made in the	*/
/*  quantity.								*/
/*  Since this routine may call newdot() if the second argument is not	*/
/*  CNIL, the arguments should be protected somehow in that case.	*/

lispval 
copval(option,value)
	lispval option, value;
	{
	struct dtpr fake;
	lispval rval;

	if( option->a.plist == nil && value != (lispval) CNIL)
		{
		protect(option); protect(value);
		option->a.plist = newdot();
		option->a.plist->d.car = sysa;
		option->a.plist->d.cdr = newdot();
		option->a.plist->d.cdr->d.car = value;
		unprot(); unprot();
		return(nil);
		}


	if( option->a.plist == nil ) return(nil);

	fake.cdr = option->a.plist;
	option = (lispval) (&fake);

	while( option->d.cdr != nil )	/*  can't be nil first time through  */
		{
		option = option->d.cdr;
		if( option->d.car == sysa )
			{
			rval = option->d.cdr->d.car;
			if( value != (lispval)CNIL )
				option->d.cdr->d.car = value;
			return(rval);
			}
		option = option->d.cdr;
		}

	if( value != (lispval)CNIL )
		{
		protect(option); protect(value);
		option->d.cdr = newdot();
		option->d.cdr->d.car = sysa;
		option->d.cdr->d.cdr = newdot();
		option->d.cdr->d.cdr->d.car = value;
		unprot(); unprot();
		}


	return(nil);
	}
EndOfFile
cat >  franz/vax/../fpipe.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: fpipe.c,v 1.3 85/05/22 07:53:41 sklower Exp $";
#endif


/*					-[Sat Jan 29 12:44:16 1983 by jkf]-
 * 	fpipe.c				$Locker:  $
 * pipe creation
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include <signal.h>

FILE *fpipe(info)
FILE *info[2];
{
	register FILE *p;
	int fd[2];

	if(0 > pipe(fd)) return( (FILE *) -1);

	if(NULL==(p = fdopen(fd[0],"r"))) {
		close(fd[0]);
		close(fd[1]);
		return( (FILE *) -1);
	}
	info[0] = p;
	if(NULL==(p = fdopen(fd[1],"w"))) {
		close(fd[0]);
		close(fd[1]);
		return( (FILE *) -1);
	}
	info[1] = p;

	return((FILE *) 2); /*indicate sucess*/
}
/* Nioreset *************************************************************/

lispval
Nioreset() {
#ifndef	RTPORTS
	register FILE *p;

	for(p = &_iob[3]; p < _iob + _NFILE; p++) {
		if(p->_flag & (_IOWRT | _IOREAD)) fclose(p);
		}
#else	RTPORTS
	lispval NiorUtil();

	_fwalk(NiorUtil);
#endif	RTPORTS
	return(nil);
}

#ifdef RTPORTS
FILE FILEdummy;

static lispval
NiorUtil(p)
FILE *p;
{
	lispval handy;
	if(p==stdin||p==stdout||p==stderr)
		return(0);
	fclose(p);
	handy = P(p);
	if(TYPE(handy)==PORT) {
		handy->p = &FILEdummy;
	}
	return(nil);
}
FILE **xports;

#define LOTS (LBPG/(sizeof (FILE *)))
lispval P(p)
FILE *p;
{
	register FILE **q;
	extern int fakettsize;

	if(xports==((FILE **) 0)) {
		/* this is gross.  I don't want to change csegment -- kls */
		xports = (FILE **) csegment(OTHER,LOTS,0);
		SETTYPE(xports,PORT,31);
		for(q = xports; q < xports + LOTS; q++) {
			*q = &FILEdummy;
		}
	}
	for(q = xports; q < xports + LOTS; q++) {
		if(*q==p) return ((lispval)q);
		if(*q==&FILEdummy) {
			*q = p;
			return ((lispval)q);
		}
	}
	/* Heavens above knows this could be disasterous in makevals() */
	error("Ran out of Ports",FALSE);
}

#endif	RTPORTS

FILE *
fstopen(base,count,flag)
char *base;
char *flag;
{
	register FILE *p = fdopen(0,flag);

	p->_flag |= _IOSTRG;
	p->_cnt = count;
	p->_ptr = p->_base = base;
	p->_file = -1;
	return(p);
}

#ifdef SPISFP
char *
alloca(howmuch)
register int howmuch;
{
	howmuch += 3 ;
	howmuch >>= 2;
	xsp -= howmuch;
	if (xsp < xstack) {
		xsp += howmuch;
		xserr();
	}
	return((char *) xsp);
}
#endif
EndOfFile
cat >  franz/vax/../subbig.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: subbig.c,v 1.2 83/09/12 14:17:31 sklower Exp $";
#endif

/*					-[Sat Jan 29 13:36:05 1983 by jkf]-
 * 	subbig.c			$Locker:  $
 * bignum subtraction
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"

/*
 * subbig -- subtract one bignum from another.
 *
 * What this does is it negates each coefficient of a copy of the bignum
 * which is just pushed on the stack for convenience.  This may give rise
 * to a bignum which is not in canonical form, but is nonetheless a repre
 * sentation of a bignum.  Addbig then adds it to a bignum, and produces
 * a result in canonical form.
 */
lispval
subbig(pos,neg)
lispval pos, neg;
{
	register lispval work;
	lispval adbig();
	register long *mysp = sp() - 2;
	register long *ersatz = mysp;
	Keepxs();

	for(work = neg; work!=0; work = work->s.CDR) {
		stack((long)(mysp -= 2));
		stack(-work->i);
	}
	mysp[3] = 0;
	work = (adbig(pos,(lispval)ersatz));
	Freexs();
	return(work);
}
EndOfFile
cat >  franz/vax/../pbignum.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: pbignum.c,v 1.3 83/09/12 14:17:59 sklower Exp $";
#endif

/*					-[Sat Jan 29 13:30:47 1983 by jkf]-
 * 	pbignum.c			$Locker:  $
 * print a bignum
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"

pbignum(current, useport)
register lispval current;
register FILE *useport;
{
	long  *top, *bot, *work, negflag = 0;
	char *alloca();
	register int *digitp;
	Keepxs();

	/* copy bignum onto stack */
	top = (sp()) - 1;
	do {
		stack(current->s.I);
	} while(current = current->s.CDR);

	bot = sp();
	if (top==bot) {
		fprintf(useport,"%d",*bot);
		Freexs();
		return;
	}

	/* save space for printed digits*/
	work = (int *)alloca((top-bot)*2*sizeof(int));
	if( *bot < 0) {
		negflag = 1;
		dsneg(top,bot);
	}

	/* figure out nine digits at a time by destructive division*/
	for(digitp = work; bot <= top; digitp++) {
		*digitp = dodiv(top,bot);
		if(*bot==0) bot += 1;
	}
	
	/* print them out */

	if(negflag) putc('-',useport);
	fprintf(useport,"%d",*--digitp);
	while ( digitp > work) fprintf(useport,"%.09d",*--digitp);
	Freexs();
}
EndOfFile
cat >  franz/vax/../divbig.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: divbig.c,v 1.4 83/11/26 12:10:16 sklower Exp $";
#endif

/*					-[Sat Jan 29 12:22:36 1983 by jkf]-
 * 	divbig.c				$Locker:  $
 * bignum division
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"

#define b 0x40000000
#define toint(p) ((int) (p))

divbig(dividend, divisor, quotient, remainder)
lispval dividend, divisor, *quotient, *remainder;
{
	register *ujp, *vip;
	int *alloca(), d, negflag = 0, m, n, carry, rem, qhat, j;
	int borrow, negrem = 0;
	long *utop = sp(), *ubot, *vbot, *qbot;
	register lispval work; lispval export();
	Keepxs();

	/* copy dividend */
	for(work = dividend; work; work = work ->s.CDR)
		stack(work->s.I);
	ubot = sp();
	if(*ubot < 0) {		/* knuth's division alg works only for pos
					bignums				*/
		negflag ^= 1;
		negrem = 1;
		dsmult(utop-1,ubot,-1);
	}
	stack(0);
	ubot = sp();

	
	/*copy divisor */
	for(work = divisor; work; work = work->s.CDR)
		stack(work->s.I);

	vbot = sp();
	stack(0);
	if(*vbot < 0) {
		negflag ^= 1;
		dsmult(ubot-1,vbot,-1);
	}

	/* check validity of data */
	n = ubot - vbot;
	m = utop - ubot - n - 1;
	if (n == 1) {
		/* do destructive division by  a single. */
		rem = dsdiv(utop-1,ubot,*vbot);
		if(negrem)
			rem = -rem;
		if(negflag)
			dsmult(utop-1,ubot,-1);
		if(remainder)
			*remainder = inewint(rem);
		if(quotient)
			*quotient = export(utop,ubot);
		Freexs();
		return;
	}
	if (m < 0) {
		if (remainder)
			*remainder = dividend;
		if(quotient)
			*quotient = inewint(0);
		Freexs();
		return;
	}
	qbot = alloca(toint(utop) + toint(vbot) - 2 * toint(ubot));
d1:
	d = b /(*vbot +1);
	dsmult(utop-1,ubot,d);
	dsmult(ubot-1,vbot,d);

d2:	for(j=0,ujp=ubot; j <= m; j++,ujp++) {

	d3:	
		qhat = calqhat(ujp,vbot);
	d4:
		if((borrow = mlsb(ujp + n, ujp, ubot, -qhat)) < 0) {
			adback(ujp + n, ujp, ubot);
			qhat--;
		}
		qbot[j] = qhat;
	}
d8:	if(remainder) {
		dsdiv(utop-1, utop - n, d);
		if(negrem) dsmult(utop-1,utop-n,-1);
		*remainder = export(utop,utop-n);
	}
	if(quotient) {
		if(negflag)
			dsmult(qbot+m,qbot,-1);
		*quotient = export(qbot + m + 1, qbot);
	}
	Freexs();
}
/*
 * asm code commented out due to optimizer bug
 * also, this file is now shared with the 68k version!
calqhat(ujp,v1p)
register int *ujp, *v1p;
{
asm("	cmpl	(r10),(r11)		# v[1] == u[j] ??");
asm("	beql	2f			");
asm("	# calculate qhat and rhat simultaneously,");
asm("	#  qhat in r0");
asm("	#  rhat in r1");
asm("	emul	(r11),$0x40000000,4(r11),r4 # u[j]b+u[j+1] into r4,r5");
asm("	ediv	(r10),r4,r0,r1		# qhat = ((u[j]b+u[j+1])/v[1]) into r0");
asm("					# (u[j]b+u[j+1] -qhat*v[1]) into r1");
asm("					# called rhat");
asm("1:");
asm("	# check if v[2]*qhat > rhat*b+u[j+2]");
asm("	emul	r0,4(r10),$0,r2		# qhat*v[2] into r3,r2");
asm("	emul	r1,$0x40000000,8(r11),r8 #rhat*b + u[j+2] into r9,r8");
asm("	# give up if r3,r2 <= r9,r8, otherwise iterate");
asm("	subl2	r8,r2			# perform r3,r2 - r9,r8");
asm("	sbwc	r9,r3");
asm("	bleq	3f			# give up if negative or equal");
asm("	decl	r0			# otherwise, qhat = qhat - 1");
asm("	addl2	(r10),r1		# since dec'ed qhat, inc rhat by v[1]");
asm("	jbr	1b");
asm("2:	");
asm("	# get here if v[1]==u[j]");
asm("	# set qhat to b-1");
asm("	# rhat is easily calculated since if we substitute b-1 for qhat in");
asm("	# the formula, then it simplifies to (u[j+1] + v[1])");
asm("	# ");
asm("	addl3	4(r11),(r10),r1		# rhat = u[j+1] + v[1]");
asm("	movl	$0x3fffffff,r0		# qhat = b-1");
asm("	jbr	1b");
asm("3:");
}
mlsb(utop,ubot,vtop,nqhat)
register int *utop, *ubot, *vtop;
register int nqhat;
{
asm("	clrl	r0");
asm("loop2:	addl2	(r11),r0");
asm("	emul	r8,-(r9),r0,r2");
asm("	extzv	$0,$30,r2,(r11)");
asm("	extv	$30,$32,r2,r0");
asm("	acbl	r10,$-4,r11,loop2");
}
adback(utop,ubot,vtop)
register int *utop, *ubot, *vtop;
{
asm("	clrl	r0");
asm("loop3:	addl2	-(r9),r0");
asm("	addl2	(r11),r0");
asm("	extzv	$0,$30,r0,(r11)");
asm("	extv	$30,$2,r0,r0");
asm("	acbl	r10,$-4,r11,loop3");
}
dsdiv(top,bot,div)
register int* bot;
{
asm("	clrl	r0");
asm("loop4:	emul	r0,$0x40000000,(r11),r1");
asm("	ediv	12(ap),r1,(r11),r0");
asm("	acbl	4(ap),$4,r11,loop4");
}
dsmult(top,bot,mult)
register int* top;
{
asm("	clrl	r0");
asm("loop5:	emul	12(ap),(r11),r0,r1");
asm("	extzv	$0,$30,r1,(r11)");
asm("	extv	$30,$32,r1,r0");
asm("	acbl	8(ap),$-4,r11,loop5");
asm("	movl	r1,4(r11)");
}
*/
lispval
export(top,bot)
register long *top, *bot;
{
	register lispval p;
	lispval result;

	top--; /* screwey convention matches original
		  vax assembler convenience */
	while(bot < top)
	{
		if(*bot==0)
			bot++;
		else if(*bot==-1)
			*++bot |= 0xc0000000;
		else break;
	}
	if(bot==top) return(inewint(*bot));
	result = p = newsdot();
	protect(p);
	p->s.I = *top--;
	while(top >= bot) {
		p = p->s.CDR = newdot();
		p->s.I = *top--;
	}
	p->s.CDR = 0;
	np--;
	return(result);
}

#define MAXINT 0x80000000L

Ihau(fix)
register int fix;
{
	register count;
	if(fix==MAXINT)
		return(32);
	if(fix < 0)
		fix = -fix;
	for(count = 0; fix; count++)
		fix /= 2;
	return(count);
}
lispval
Lhau()
{
	register count;
	register lispval handy;
	register dum1,dum2;
	lispval Labsval();

	handy = lbot->val;
top:
	switch(TYPE(handy)) {
	case INT:
		count = Ihau(handy->i);
		break;
	case SDOT:
		handy = Labsval();
		for(count = 0; handy->s.CDR!=((lispval) 0); handy = handy->s.CDR)
			count += 30;
		count += Ihau(handy->s.I);
		break;
	default:
		handy = errorh1(Vermisc,"Haulong: bad argument",nil,
			       TRUE,997,handy);
		goto top;
	}
	return(inewint(count));
}
lispval
Lhaipar()
{
	register lispval work;
	register n;
	register int *top = sp() - 1;
	register int *bot;
	int mylen;

	/*chkarg(2);*/
	work = lbot->val;
					/* copy data onto stack */
on1:
	switch(TYPE(work)) {
	case INT:
		stack(work->i);
		break;
	case SDOT:
		for(; work!=((lispval) 0); work = work->s.CDR)
			stack(work->s.I);
		break;
	default:
		work = errorh1(Vermisc,"Haipart: bad first argument",nil,
				TRUE,996,work);
		goto on1;
	}
	bot = sp();
	if(*bot < 0) {
		stack(0);
		dsmult(top,bot,-1);
		bot--;
	}
	for(; *bot==0 && bot < top; bot++);
				/* recalculate haulong internally */
	mylen = (top - bot) * 30 + Ihau(*bot);
				/* get second argument		  */
	work = lbot[1].val;
	while(TYPE(work)!=INT)
		work = errorh1(Vermisc,"Haipart: 2nd arg not int",nil,
				TRUE,995,work);
	n = work->i;
	if(n >= mylen || -n >= mylen)
		goto done;
	if(n==0) return(inewint(0));
	if(n > 0) {
				/* Here we want n most significant bits
				   so chop off mylen - n bits */
		stack(0);
		n = mylen - n;
		for(n; n >= 30; n -= 30)
			top--;
		if(top < bot)
			error("Internal error in haipart #1",FALSE);
		dsdiv(top,bot,1<<n);

	} else {
				/* here we want abs(n) low order bits */
		stack(0);
		bot = top + 1;
		for(; n <= 0; n += 30)
			bot--;
		n = 30 - n;
		*bot &= ~ (-1<<n);
	}
done:
	return(export(top + 1,bot));
}
#define STICKY 1
#define TOEVEN 2
lispval
Ibiglsh(bignum,count,mode)
lispval bignum, count;
{
	register lispval work;
	register n;
	register int *top = sp() - 1;
	register int *bot;
	int mylen, guard = 0, sticky = 0, round = 0;
	lispval export();

				/* get second argument		  */
	work = count;
	while(TYPE(work)!=INT)
		work = errorh1(Vermisc,"Bignum-shift: 2nd arg not int",nil,
				TRUE,995,work);
	n = work->i;
	if(n==0) return(bignum);
	for(; n >= 30; n -= 30) {/* Here we want to multiply by 2^n
				   so start by copying n/30 zeroes
				   onto stack */
		stack(0);
	}

	work = bignum;		/* copy data onto stack */
on1:
	switch(TYPE(work)) {
	case INT:
		stack(work->i);
		break;
	case SDOT:
		for(; work!=((lispval) 0); work = work->s.CDR)
			stack(work->s.I);
		break;
	default:
		work = errorh1(Vermisc,"Bignum-shift: bad bignum argument",nil,
				TRUE,996,work);
		goto on1;
	}
	bot = sp();
	if(n >= 0) {
		stack(0);
		bot--;
		dsmult(top,bot,1<<n);
	} else {
			/* Trimming will only work without leading
			   zeroes without my having to think
			   a lot harder about it, if the inputs
			   are canonical */
		for(n = -n; n > 30; n -= 30) {
			if(guard) sticky |= 1;
			guard = round;
			if(top > bot) {
				round = *top;
				top --;
			} else  {
				round = *top;
				*top >>= 30;
			}
		}
		if(n > 0) {
			if(guard) sticky |= 1;
			guard = round;
			round = dsrsh(top,bot,-n,-1<<n);
		}
		stack(0); /*so that dsadd1 will work;*/
		if (mode==STICKY) {
			if(((*top&1)==0) && (round | guard | sticky))
				dsadd1(top,bot);
		} else if (mode==TOEVEN) {
			int mask;

			if(n==0) n = 30;
			mask = (1<<(n-1));
			if(! (round & mask) ) goto chop;
			mask -= 1;
			if(  ((round&mask)==0)
			  && guard==0
			  && sticky==0
			  && (*top&1)==0 ) goto chop;
			dsadd1(top,bot);
		}
		chop:;
	}
	work = export(top + 1,bot);
	return(work);
}

/*From drb  Mon Jul 27 01:25:56 1981
To: sklower

The idea is that the answer/2
is equal to the exact answer/2 rounded towards - infinity.  The final bit
of the answer is the "or" of the true final bit, together with all true
bits after the binary point.  In other words, the 1's bit of the answer
is almost always 1.  THE FINAL BIT OF THE ANSWER IS 0 IFF n*2^i = THE
ANSWER RETURNED EXACTLY, WITH A 0 FINAL BIT.


To try again, more succintly:  the answer is correct to within 1, and
the 1's bit of the answer will be 0 only if the answer is exactly
correct. */

lispval
Lsbiglsh()
{
	register struct argent *mylbot = lbot;
	chkarg(2,"sticky-bignum-leftshift");
	return(Ibiglsh(lbot->val,lbot[1].val,STICKY));
}
lispval
Lbiglsh()
{
	register struct argent *mylbot = lbot;
	chkarg(2,"bignum-leftshift");
	return(Ibiglsh(lbot->val,lbot[1].val,TOEVEN));
}
lispval
HackHex() /* this is a one minute function so drb and kls can debug biglsh */
/* (HackHex i) returns a string which is the result of printing i in hex */
{
	register struct argent *mylbot = lbot;
	char buf[32];
	sprintf(buf,"%lx",lbot->val->i);
	return((lispval)inewstr(buf));
}
EndOfFile
cat >  franz/vax/../ffasl.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: ffasl.c,v 1.10 83/12/09 16:45:04 sklower Exp $";
#endif

/*					-[Mon Mar 21 19:37:21 1983 by jkf]-
 * 	ffasl.c				$Locker:  $
 * dynamically load C code
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <aout.h>
#define round(x,s) ((((x)-1) & ~((s)-1)) + (s))

char *stabf = 0, *strcpy(), *sprintf(), *Ilibdir();
extern int fvirgin;
static seed=0, mypid = 0;
static char myname[100];
lispval verify();

/* dispget - get discipline of function
 * this is used to handle the tricky defaulting of the discipline
 * field of such functions as cfasl and getaddress.
 * dispget is given the value supplied by the caller,
 *	the error message to print if something goes wrong,
 *	the default to use if nil was supplied.
 * the discipline can be an atom or string.  If an atom it is supplied
 * it must be lambda, nlambda or macro.  Otherwise the atoms pname
 * is used.
 */

lispval 
dispget(given,messg,defult)
lispval given,defult;
char *messg;
{
	int typ;

	while(TRUE)
	{
		if(given == nil) 
		   return(defult);
		if((typ=TYPE(given)) == ATOM)
		{  if(given == lambda ||
		      given == nlambda ||
		      given == macro) return(given);
		   else return((lispval) given->a.pname);
		} else if(typ == STRNG) return(given);

		given = errorh1(Vermisc,messg,nil,TRUE,0,given);
	}
}

lispval
Lcfasl(){
	register struct argent *mlbot = lbot;
	register lispval work;
	register int fildes, totsize;
	int readsize;
	lispval csegment();
	char *sbrk(), *currend, *tfile, cbuf[6000], *mytemp(), *gstab();
	char ostabf[128];
	struct exec header;
	char *largs;
	Savestack(4);

	switch(np-lbot) {
	   case 3: protect(nil);	/* no discipline given */
	   case 4: protect(nil);        /* no library given  */
	}
	chkarg(5,"cfasl");
	mlbot[0].val = verify(mlbot[0].val,"Incorrect .o file specification");
	mlbot[1].val = verify(mlbot[1].val,"Incorrect entry specification for cfasl");
	mlbot[3].val = dispget(mlbot[3].val,"Incorrect discipline specification for cfasl",(lispval)Vsubrou->a.pname);
	while(TYPE(mlbot[2].val)!= ATOM) 
	mlbot[2].val = errorh1(Vermisc,"Bad associated atom name for fasl",
						 nil,TRUE,0,mlbot[2].val);
	work = mlbot[4].val;
	if(work==nil)
		largs = 0;
	else 
		largs = (char *) verify(work,"Bad loader flags");

	/*
	 * Invoke loader.
	 */
	strcpy(ostabf,gstab());
	currend = sbrk(0);
#if (!os_vms) | EUNICE_UNIX_OBJECT_FILE_CFASL
			/*** UNIX cfasl code ***/
	tfile = mytemp();
	sprintf(cbuf,
		"%s/nld -N -x -A %s -T %x %s -e %s -o %s %s -lc",
		Ilibdir(),
		ostabf,
		currend,
		mlbot[0].val,
		mlbot[1].val,
		tfile,
		largs);
	/* if nil don't print cfasl/nld message */
	if ( Vldprt->a.clb != nil ) {
		printf(cbuf);
		putchar('\n'); fflush(stdout);
	}
	if(system(cbuf)!=0) {
		unlink(tfile);
		ungstab();
		fprintf(stderr,"Ld returns error status\n");
		Restorestack();
		return(nil);
	}
	if(fvirgin)
		fvirgin = 0;
	else
		unlink(ostabf);
	stabf = tfile;
	if((fildes = open(tfile,0))<0) {
		fprintf(stderr,"Couldn't open temporary file: %s\n",tfile);
		Restorestack();
		return(nil);
	}
	/*
	 * Read a.out header to find out how much room to
	 * allocate and attempt to do so.
	 */
	if(read(fildes,(char *)&header,sizeof(header)) <= 0) {
		close(fildes);
		Restorestack();
		return(nil);
	}
	readsize = round(header.a_text,4) + round(header.a_data,4);
	totsize  = readsize + header.a_bss;
	totsize  = round(totsize,512);
	/*
	 * Fix up system indicators, typing info, etc.
	 */
	currend = (char *)csegment(OTHER,totsize,FALSE);
	
	if(readsize!=read(fildes,currend,readsize))
		{close(fildes);Restorestack(); return(nil);}
	work = newfunct();
	work->bcd.start = (lispval (*)())header.a_entry;
	work->bcd.discipline = mlbot[3].val;
	close(fildes);
	Restorestack();
	return(mlbot[2].val->a.fnbnd = work);
#else
			/*** VMS cfasl code ***/
	{
	  int pid = getpid() & 0xffff;	/* Our process ID number */
	  char objfil[100];		/* Absolute object file name */
	  char symfil[100];		/* Old symbol table file */
	  char filename[100];		/* Random filename buffer */
	  int strlen();			/* String length function */
	  int cvt_unix_to_vms();	/* Convert UNIX to VMS filename */
	  lispval Lgetaddress(),matom();
	  struct stat stbuf;

	  if (largs == 0) largs = " ";
	  sprintf(objfil,"tmp:cfasl%d.tmp",pid);
	  symfil[cvt_unix_to_vms(ostabf,symfil)] = 0;
	  sprintf(cbuf,					/* Create link cmd. */
		"$ link/exe=%s/nom/syst=%%X%x/sym=tmp:sym%d.new %s,%s%s",
		objfil,
		currend,
		pid,
		mlbot[0].val,
		symfil,
		largs);
	  printf(					/* Echo link cmd. */
		"$ link/exe=%s/nomap/system=%%X%x/symbol_table=tmp:sym%d.new %s,%s%s\n",
		objfil,
		currend,
		pid,
		mlbot[0].val,
		symfil,
		largs);
	  fflush(stdout);
	  vms_system(cbuf,0);

	  if ((fildes = open(objfil,0)) < 0) /* Open abs file */
		{Restorestack(); return(nil);}
	  fstat(fildes,&stbuf);				/* Get its size */
	  readsize=stbuf.st_size;
	  currend = (char *)csegment(OTHER,readsize,FALSE);
	  readsize = read(fildes,currend,10000000);
	  close(fildes);
	  /*
	   * Delete the absolute object file
	   */
	  unlink(objfil);
	  /*
	   * Delete the old symbol table (if temporary)
	   */
	  unlink(sprintf(filename,"tmp:sym%d.stb",pid));
	  /*
	   * Rename the new symbol table so it is now the old symbol table
	   */
	  link(sprintf(symfil,"tmp:sym%d.new",pid),filename);
	  unlink(symfil);
	  sprintf(myname,"tmp:sym%d.stb",pid);
	  stabf = myname;
	  /*
	   * Return  Lgetaddress(entry,function_name,discipline)
	   */
	  {
	     struct argent *oldlbot, *oldnp;
	     lispval result;

	     oldlbot = lbot;
	     oldnp = np;
	     lbot = np;
	     np++->val = matom(mlbot[1].val);
	     np++->val = mlbot[2].val;
	     np++->val = matom(mlbot[3].val);
	     result = Lgetaddress();
	     lbot = oldlbot;
	     np = oldnp;
	     return(result);
	  }
	}
#endif
}
#ifdef os_vms
#define M 4
#else
#define M 1
#endif
#define oktox(n) \
	(0==stat(n,&stbuf)&&(stbuf.st_mode&S_IFMT)==S_IFREG&&0==access(n,M))
char *
gstab()
{
	register char *cp, *cp2; char *getenv();
	struct stat stbuf;
	extern char **Xargv;

	if(stabf==0) {
		cp = getenv("PATH");
		if(cp==0)
			cp=":/usr/ucb:/bin:/usr/bin";
		if(*cp==':'||*Xargv[0]=='/') {
			cp++;
			if(oktox(Xargv[0])) {
				strcpy(myname,Xargv[0]);
				return(stabf = myname);
			}
#ifdef	os_vms
			/*
			 *	Try Xargv[0] with ".stb" concatenated
			 */
			strcpy(myname,Xargv[0]);
			strcat(myname,".stb");
			if (oktox(myname)) return(stabf = myname);
			/*
			 *	Try Xargv[0] with ".exe" concatenated
			 */
			strcpy(myname,Xargv[0]);
			strcat(myname,".exe");
			if (oktox(myname)) return(stabf = myname);
#endif
		}
		for(;*cp;) {

			/* copy over current directory
			   and then append argv[0] */

			for(cp2=myname;(*cp)!=0 && (*cp)!=':';)
				*cp2++ = *cp++;
			*cp2++ = '/';
			strcpy(cp2,Xargv[0]);
			if(*cp) cp++;
#ifndef	os_vms
			if(!oktox(myname)) continue;
#else
			/*
			 *	Also try ".stb" and ".exe" in VMS
			 */
			if(!oktox(myname)) {
				char *end_of_name;
				end_of_name = cp2 + strlen(cp2);
				strcat(cp2,".stb");
				if(!oktox(myname)) {
					/*
					 *	Try ".exe"
					 */
					*end_of_name = 0;   /* Kill ".stb" */
					strcat(cp2,".exe");
					if (!oktox(myname)) continue;
				}
			}
#endif
			return(stabf = myname);
		}
		/* one last try for dual systems */
		strcpy(myname,Xargv[0]);
		if(oktox(myname)) return(stabf = myname);
		error("Could not find which file is being executed.",FALSE);
		/* NOTREACHED */
	} else return (stabf);
}
static char mybuff[40]; 
char *
mytemp()
{
	/*if(mypid==0) mypid = (getpid() & 0xffff);
	  fails if you do a dumplisp after doing a
	  cfasl */
	sprintf(mybuff,"/tmp/Li%d.%d",(getpid() & 0xffff),seed++);
	return(mybuff);
}
ungstab()
{
	seed--;
	sprintf(mybuff,"/tmp/Li%d.%d",(getpid() & 0xffff),seed-1);
	if(seed==0) {
		stabf = 0;
		fvirgin = 1;
	}
}
lispval
verify(in,error)
register lispval in;
char *error;
{
	for(EVER) {
		switch(TYPE(in)) {
		case STRNG:
			return(in);
		case ATOM:
			return((lispval)in->a.pname);
		}
		in = errorh1(Vermisc,error,nil,TRUE,0,in);
	}
}


/* extern	int fvirgin; */
			/* declared in ffasl.c tells if this is original
			 *	lisp symbol table.
			 * if fvirgin is 1 then we must copy the symbol
			 * 	table, else we can overwrite it, since
			 * 	it is a temporary file which only
			 *	one user could be using(was not created
			 *	as an original lisp or by a (dumplisp)
			 *	or a (savelisp)).
			 */

/* copy a block of data from one file to another of size size */
copyblock(f1,f2,size)
FILE *f1, *f2;
long size;
{
	char block[BUFSIZ];

	    while ( size > BUFSIZ ) {
		size -= BUFSIZ;
		fread(block,BUFSIZ,1,f1);
		fwrite(block,BUFSIZ,1,f2);
	    }
	    if (size > 0 ) {
		fread(block,(int)size,1,f1);
		fwrite(block,(int)size,1,f2);
	    }
}

/* removeaddress --
 *
 * (removeaddress '|_entry1| '|_entry2| ...)
 *
 * 	removes the given entry points from the run time symbol table,
 *		so that later cfasl'd files can have these label names.
 *
 */

lispval
Lrmadd(){
	register struct argent *mlbot = lbot;
	register struct nlist *q; 
	register int i;
	int numberofargs, strsize;
	char *gstab();
	char ostabf[128];
	char *nstabf,*mytemp();
	char *strtbl,*alloca();
	int i2, n, m, nargleft, savem;
	FILE *f, *fa;
	FILE *fnew;
	off_t savesymadd,symadd;		/* symbol address */
	struct exec buf;
	struct nlist nlbuf[BUFSIZ/sizeof (struct nlist)];
	int maxlen;
	int change;
	Keepxs();

	numberofargs = (np - lbot);
	nargleft = numberofargs;
	maxlen = 0;
	for ( i=0; i<numberofargs; i++,mlbot ++) {
		mlbot->val = verify(mlbot->val,"Incorrect entry specification.");
		n = strlen((char *)mlbot->val);
		if (n > maxlen)
			maxlen = n;
	}
	/* 
	 *  Must not disturb object file if it an original file which
	 *	other users can execute(signified by the variable fvirgin).
	 *	so the entire symbol table is copied to a new file.
	 */
	if (fvirgin) {
		strncpy(ostabf,gstab(),128);
		nstabf = mytemp();
		/*
		 * copy over symbol table into a temporary file first
		 *
		 */
		f = fopen(ostabf, "r");
		fnew = fopen(nstabf, "w");
		if (( f == NULL ) || (fnew == NULL)) {Freexs(); return( nil );}
		/* read exec header on file */
#ifndef	os_vms
		fread((char *)&buf, sizeof buf, 1, f);
#else	os_vms
		/*
		 *	Under VMS/EUNICE we have to try the 1st 512 byte
		 *	block and the 2nd 512 byte block (there may be
		 *	a VMS header in the 1st 512 bytes).
		 */
		get_aout_header(fileno(f),&buf);
#endif	os_vms

		/* Is this a legitimate a.out file? */
		if (N_BADMAG(buf)) {
			unlink(nstabf);
			ungstab();
			fclose(f);
			fclose(fnew);
			errorh1(Vermisc,"Removeaddress: Bad file",nil,FALSE,0,inewstr(ostabf));
			{Freexs(); return(nil);}
		}
		/* set pointer on read file to symbol table */
		/* must be done before the structure buf is reassigned 
		 * so that it will be accurate for the read file 
		 */
		fseek(f,(long)N_SYMOFF(buf),0);
		/* reset up exec header structure for new file */
		buf.a_magic = OMAGIC;
		buf.a_text = 0;
		buf.a_data = 0;
		buf.a_bss = 0;
		buf.a_entry = 0;
		buf.a_trsize = 0;
		buf.a_drsize = 0;
		fwrite((char *)&buf,
		       sizeof buf,1,fnew); 	/* write out exec header */
		copyblock(f,fnew,(long)buf.a_syms); /* copy symbol table */
#if ! (os_unisoft | os_unix_ts)
		fread((char *)&strsize,
		      sizeof (int),1,f); 	/* find size of string table */
		fwrite((char *)&strsize,
		      sizeof (int),1,fnew); 	/* find size of string table */
		strsize -= 4;
		strtbl = alloca(strsize);
		fread(strtbl,strsize,1,f);	/* read and save string table*/
		fwrite(strtbl,strsize,1,fnew);	/* copy out string table     */
#endif
		fclose(f);fclose(fnew);
	} else {
		nstabf = gstab();
	}

	/*
	 * now unset the external bits it the entry points specified.
	 */
	f = fopen(nstabf, "r");
	fa = fopen(nstabf, "a");
	if (( f == NULL ) || (fa == NULL)) {
		unlink(nstabf);
		ungstab();
		if (f != NULL ) fclose(f);
		if (fa != NULL ) fclose(fa);
		return ( nil );
	}

	/* read exec header on file */
#ifndef	os_vms
	fread((char *)&buf, sizeof buf, 1, f);
#else	os_vms
	/*
	 *	Under VMS/EUNICE we have to try the 1st 512 byte
	 *	block and the 2nd 512 byte block (there may be
	 *	a VMS header in the 1st 512 bytes).
	 */
	get_aout_header(fileno(f),&buf);
#endif	os_vms

	/* Is this a legitimate a.out file? */
	if (N_BADMAG(buf)) {
		if (fvirgin) {
			unlink(nstabf);
			ungstab();
		}
		fclose(f);
		fclose(fa);
		errorh1(Vermisc,"Removeaddress: Bad file",nil,FALSE,0,inewstr(ostabf));
		{Freexs(); return(nil);}
	} else {
		symadd = N_SYMOFF(buf);
#if ! (os_unisoft | os_unix_ts)
		/*
		 * read in string table if not done during copying
		 */
		if (fvirgin==0){
			fseek(f,(long)N_STROFF(buf),0);
			fread((char *)&strsize,sizeof (int),1,f);
			strsize -= 4;
			strtbl = alloca(strsize);
			fread(strtbl,strsize,1,f);
		}
#endif
		n = buf.a_syms;
		fseek(f, (long)symadd, 0);
		while (n) {
			m = sizeof (nlbuf);
			if (n < m)
				m = n;

			/* read next block of symbols from a.out file */
			fread((char *)nlbuf, m, 1, f);
			savem = m;
			savesymadd = symadd;
			symadd += m;
			n -= m;
			change = 0;

		/* compare block of symbols against list of entry point
		 *	names given, if a match occurs, clear the N_EXT bit
		 *	for that given symbol and signal a change.
		 */
			for (q = nlbuf; (m -= sizeof(struct nlist)) >= 0; q++) {

	       /* make sure it is external */
				if (
				    (q->n_type & N_EXT)==0
#if ! (os_unix_ts | os_unisoft)
				    || q->n_un.n_strx == 0 || q->n_type & N_STAB
#endif
				   )	continue;
			for (mlbot=lbot,i2 = 0;i2<numberofargs;i2++,mlbot++) {
#if ! (os_unix_ts | os_unisoft)
				if(strcmp((char *)mlbot->val,
					  strtbl+q->n_un.n_strx-4)!=0)
						continue;
#else
				if(strncmp((char *)mlbot->val,
					   q->n_name,8)!=0)
						continue;
#endif
				change = 1;
				q->n_type &= ~N_EXT;
				break;
			}
		}
		if ( change ) {
			fseek(fa,(long)savesymadd,0);
			fwrite((char *)nlbuf, savem, 1, fa);
			if (--nargleft == 0)
				goto alldone;
		}
		}
	}
alldone:
	fclose(f);
	fclose(fa);
	if(fvirgin)
		fvirgin = 0;
	stabf = nstabf;
	{Freexs(); return(tatom);}
}
char *
Ilibdir()
{
	register lispval handy;
tryagain:
	handy = Vlibdir->a.clb;
	switch(TYPE(handy)) {
	case ATOM:
		handy = (lispval) handy->a.pname;
	case STRNG:
		break;
	default:
		(void) error(
"cfasl or load: lisp-library-directory not bound to string or atom",
				TRUE);
		goto tryagain;
	}
	return((char *) handy);
}
EndOfFile
cat >  franz/vax/../fasl.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: fasl.c,v 1.10 85/03/24 11:03:34 sklower Exp $";
#endif

/*					-[Thu Jun  2 21:44:26 1983 by jkf]-
 * 	fasl.c				$Locker:  $
 * compiled lisp loader
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include <sys/types.h>
#include "lispo.h"
#include "chkrtab.h"
#include "structs.h"
#include "frame.h"

/* fasl  -  fast loader				j.k.foderaro
 * this loader is tuned for the lisp fast loading application
 * any changes in the system loading procedure will require changes
 * to this file
 *
 *  The format of the object file we read as input:
 *  text segment:
 *    1) program text - this comes first.
 *    2) binder table - one word entries, see struct bindage
 *			begins with symbol:  bind_org
 *    3) litterals - exploded lisp objects. 
 *			begins with symbol:  lit_org
 *		        ends with symbol:    lit_end
 * data segment:
 *	not used
 *
 *
 *  these segments are created permanently in memory:
 *	code segment - contains machine codes to evaluate lisp functions.
 *	linker segment - a list of pointers to lispvals.  This allows the
 *			compiled code to reference constant lisp objects.
 *		  	The first word of the linker segment is a gc link
 *			pointer and does not point to a literal.  The
 *			symbol binder is assumed to point to the second
 *			longword in this segment.  The last word in the
 *			table is -1 as a sentinal to the gc marker.
 *			The number of real entries in the linker segment 
 *			is given as the value of the linker_size symbol.  
 *			Taking into account the 2 words required for the
 *			gc, there are 4*linker_size + 8 bytes in this segment.
 *	transfer segment - this is a transfer table block.  It is used to
 *			allow compiled code to call other functions 
 *			quickly.  The number of entries in the transfer table is
 *			given as the value of the trans_size symbol.
 *
 *  the following segments are set up in memory temporarily then flushed
 *	binder segment -  a list of struct bindage entries.  They describe
 *			what to do with the literals read from the literal
 *			table.  The binder segment begins in the file
 *			following the bindorg symbol.
 *	literal segment - a list of characters which _Lread will read to 
 *			create the lisp objects.  The order of the literals
 *			is:
 *		         linker literals - used to fill the linker segment.
 *			 transfer table literals - used to fill the 
 *			   transfer segment
 *			 binder literals - these include names of functions
 *			   to bind interspersed with forms to evaluate.
 *			   The meanings of the binder literals is given by
 *			   the values in the binder segment.
 * 	string segment - this is the string table from the file.  We have
 *			 to allocate space for it in core to speed up
 *			 symbol referencing.
 *
 */


/* external functions called or referenced */

lispval qcons(),qlinker(),qget();
int _qf0(), _qf1(), _qf2(), _qf3(), _qf4(), _qfuncl(), svkludg(),qnewint();
int qnewdoub(),qoneplus(),qoneminus(), wnaerr();
lispval Lread(), Lcons(), Lminus(), Ladd1(), Lsub1(), Lplist(), Lputprop();
lispval Lprint(), Lpatom(), Lconcat(), Lget(), Lmapc(), Lmapcan();
lispval Llist(), Ladd(), Lgreaterp(), Lequal(), Ltimes(), Lsub(), Ipurcopy();
lispval Lncons(), Ibindvars(), Iunbindvars(),error();
int Inonlocalgo();
lispval Istsrch();
int mcount(), qpushframe();
extern int mcnts[],mcntp,doprof;

extern lispval *tynames[];
extern struct frame *errp;
extern char _erthrow[];

extern int initflag;		/* when TRUE, inhibits gc */

char *alloca();			/* stack space allocator */

/* mini symbol table, contains the only external symbols compiled code
   is allowed to reference
 */


struct ssym { char *fnam;	/* pointer to string containing name */
	      int  floc;	/* address of symbol */
	      int  ord;		/* ordinal number within cur sym tab */

	      } Symbtb[] 
		          = {
			     "trantb",	0,	-1,   /* must be first */
			     "linker",  0,	-1,   /* must be second */
			     "mcount",	  (int) mcount,   -1,
			     "mcnts",	  (int) mcnts,  -1,
			     "_wnaerr",   (int) wnaerr, -1,
			     "_qnewint",   (int) qnewint,  -1,
			     "_qnewdoub",   (int) qnewdoub,  -1,
			     "_qcons",	  (int) qcons,    -1,
			     "_qoneplus", (int) qoneplus, -1,
			     "_qoneminus", (int) qoneminus, -1,
			     "_typetable",  (int) typetable,  -1,
			     "_tynames",  (int) tynames,  -1,
			     "_qget",	  (int) qget,	  -1,
			     "_errp",     (int) &errp,     	-1,
			     "_Inonlocalgo",  (int) Inonlocalgo, -1,
			     "__erthrow",  (int) _erthrow,  	-1,
			     "_error",    (int) error,    	-1,
			     "_qpushframe",  (int) qpushframe,  -1,
			     "_retval",		(int)&retval,	-1,
			     "_lispretval",	(int)&lispretval,-1,
#ifndef NPINREG
			     "_np",	  (int) &np,	  -1,
			     "_lbot",	  (int) &lbot,	  -1,
#endif
#ifndef NILIS0
			     "_nilatom",  (int) &nilatom, -1,
#endif
			     "_bnp",	  (int) &bnp,	  -1,
			     "_Ibindvars", (int) Ibindvars, -1,
			     "_Iunbindvars", (int) Iunbindvars, -1
			     };

#define SYMMAX ((sizeof Symbtb) / (sizeof (struct ssym)))

struct nlist syml;		/* to read a.out symb tab */
extern int *bind_lists;		/* gc binding lists 	  */

/* bindage structure:
 *  the bindage structure describes the linkages of functions and name,
 *  and tells which functions should be evaluated.  It is mainly used 
 *  for the non-fasl'ing of files, we only use one of the fields in fasl
 */
struct bindage
{
     int     b_type;			/* type code, as described below */
};

/* the possible values of b_type
 * -1 - this is the end of the bindage entries
 * 0  - this is a lambda function
 * 1  - this is a nlambda function
 * 2  - this is a macro function
 * 99 - evaluate the string
 *
 */


extern struct trtab *trhead;	/* head of list of transfer tables	    */
extern struct trent *trcur;	/* next entry to allocate		    */
extern int trleft;		/* # of entries left in this transfer table */

struct trent *gettran();	/* function to allocate entries */

/* maximum number of functions */
#define MAXFNS 2000

lispval Lfasl()
{
	extern int holend,usehole;
	extern int uctolc;
	extern char *curhbeg;
	struct argent *svnp;
	struct exec exblk;	/* stores a.out header */
	FILE *filp, *p, *map, *fstopen(); 	/* file pointer */
	int domap,note_redef;
	lispval handy,debugmode;
	struct relocation_info reloc;
	struct trent *tranloc;
	int trsize;
	int i,j,times, *iptr;
	int  funloc[MAXFNS];	/* addresses of functions rel to txt org */
	int funcnt = 0;

	/* symbols whose values are taken from symbol table of .o file */
	int bind_org = 0;		/* beginning of bind table */
	int lit_org = 0;	/* beginning of literal table */
	int lit_end;		/* end of literal table  */
	int trans_size = 0;	/* size in entries of transfer table */
	int linker_size;	/* size in bytes   of linker table 
					(not counting gc ptr) */

       /* symbols which hold the locations of the segments in core and 
	* in the file
	*/
	char *code_core_org,	/* beginning of code segment */
	     *lc_org,  /* beginning of linker segment */
	     *lc_end,  /* last word in linker segment */
	     *literal_core_org, /* beginning of literal table   */
	     *binder_core_org,  /* beginning of binder table   */
	     *string_core_org;

	int /*string_file_org,	/* location of string table in file */
	    string_size,	/* number of chars in string table */
	    segsiz;		/* size of permanent incore segment */

	char *symbol_name;
	struct bindage *curbind;
	lispval rdform, *linktab;
	int ouctolc;
	int debug = 0;
	lispval currtab,curibase;
	char ch,*filnm,*nfilnm;
	char tempfilbf[100];
	char *strcat();
	long lseek();
	Keepxs();
	

	switch(np-lbot) {
	case 0:
		protect(nil);
	case 1:
		protect(nil);
	case 2:
		protect(nil);
	case 3:
		break;
	default:
		argerr("fasl");
	}
	filnm = (char *) verify(lbot->val,"fasl: non atom arg");


	domap = FALSE;
	/* debugging */
	debugmode = Istsrch(matom("debugging"))->d.cdr->d.cdr->d.cdr;
	if (debugmode != nil) debug = 1;
        /* end debugging */


	/* insure that the given file name ends in .o
	   if it doesnt, copy to a new buffer and add a .o
	   but Allow non .o file names (5mar80 jkf)
	*/
	tempfilbf[0] = '\0';
	nfilnm = filnm;		/* same file name for now */
	if( (i = strlen(filnm)) < 2 ||
	     strcmp(filnm+i-2,".o") != 0)
	{
		strncat(tempfilbf,filnm,96);
		strcat(tempfilbf,".o");
		nfilnm = tempfilbf;
	}

	if ( (filp = fopen(nfilnm,"r")) == NULL)
	   if ((filnm == nfilnm) || ((filp = fopen(filnm,"r")) == NULL))
	       errorh1(Vermisc,"Can't open file",nil,FALSE,9797,lbot->val);

	if ((handy = (lbot+1)->val) != nil )
	{
	    if((TYPE(handy) != ATOM )   ||
	       (map = fopen(handy->a.pname,
			    (Istsrch(matom("appendmap"))->d.cdr->d.cdr->d.cdr == nil 
				    ? "w" : "a")))  == NULL)
		error("fasl: can't open map file",FALSE);
	    else 
	    {	domap = TRUE;
		/* fprintf(map,"Map of file %s\n",lbot->val->a.pname); */
	    }
	}

	/* set the note redefinition flag */
	if((lbot+2)->val != nil) note_redef = TRUE;
	else    note_redef = FALSE;

	/* if nil don't print fasl message */
	if ( Vldprt->a.clb != nil ) {
		printf("[fasl %s]",filnm);
		fflush(stdout);
	}
	svnp = np;



	/* clear the ords in the symbol table */
	for(i=0 ; i < SYMMAX ; i++) Symbtb[i].ord = -1;

	if( read(fileno(filp),(char *)&exblk,sizeof(struct exec)) 
		!= sizeof(struct exec))
	  error("fasl: header read failed",FALSE);
	  
	/* check that the magic number is valid	*/

	if(exblk.a_magic != 0407)
	   errorh1(Vermisc,"fasl: file is not a lisp object file (bad magic number): ",
	   	nil,FALSE,0,lbot->val);

	/* read in string table */
	lseek(fileno(filp),(long)(/*string_file_org =*/N_STROFF(exblk)),0);
	if( read(fileno(filp), (char *)&string_size , 4) != 4)
	  error("fasl: string table read error, probably old fasl format", FALSE);
	
	lbot = np; 		/* set up base for later calls */
        /* allocate space for string table on the stack */
	string_core_org = alloca(string_size - 4);

	if( read(fileno(filp), string_core_org , string_size - 4)
		!= string_size -4) error("fasl: string table read error ",FALSE);
	/* read in symbol table and set the ordinal values */

	fseek(filp,(long) (N_SYMOFF(exblk)),0);

	times = exblk.a_syms/sizeof(struct nlist);
	if(debug) printf(" %d symbols in symbol table\n",times);

	for(i=0; i < times ; i++)
	{
	   if( fread((char *)&syml,sizeof(struct nlist),1,filp) != 1)
	       error("fasl: Symb tab read error",FALSE);
	
	   symbol_name = syml.n_un.n_strx - 4 + string_core_org;
	   if(debug) printf("symbol %s\n read\n",symbol_name);
	   if (syml.n_type == N_EXT) 
	   { 
	      for(j=0; j< SYMMAX; j++)
	      {
	         if((Symbtb[j].ord < 0) 
			  && strcmp(Symbtb[j].fnam,symbol_name)==0)
	         {    Symbtb[j].ord = i;
		      if(debug)printf("symbol %s ord is %d\n",symbol_name,i);
		      break;
	         };

	      };

	      if( j>=SYMMAX )  printf("Unknown symbol %s\n",symbol_name);
	   }
	   else if (((ch = symbol_name[0]) == 's')
		     || (ch == 'L')
		     || (ch == '.') )  ;		/* skip this */
	   else if (symbol_name[0] == 'F')
	   {
	       if(funcnt >= MAXFNS)
	       		error("fasl: too many function in file",FALSE);
	       funloc[funcnt++] = syml.n_value;		/* seeing function */
	   }
	   else if (!bind_org && (strcmp(symbol_name, "bind_org") == 0))
	     bind_org = syml.n_value;
	   else if (strcmp(symbol_name, "lit_org") == 0)
	     lit_org = syml.n_value;
	   else if (strcmp(symbol_name, "lit_end") == 0)
	     lit_end = syml.n_value;
	   else if (strcmp(symbol_name, "trans_size") == 0)
	     trans_size = syml.n_value;
	   else if (strcmp(symbol_name, "linker_size") == 0)
	     linker_size = syml.n_value;
	}

#if m_68k
	/* 68k only, on the vax the symbols appear in the correct order */
	{ int compar();
	  qsort(funloc,funcnt,sizeof(int),compar);
	}
#endif

	if (debug)
	  printf("lit_org %x,  lit_end %x, bind_org %x, linker_size %x\n",
		lit_org, lit_end, bind_org, linker_size);
	/* check to make sure we are working with the right format */
	if((lit_org == 0) || (lit_end == 0))
	   errorh1(Vermisc,"File not in new fasl format",nil,FALSE,0,lbot->val);

        /*----------------*/

	/* read in text segment  up to beginning of binder table */

	segsiz = bind_org + 4*linker_size + 8 + 3; /* size is core segment size
						 * plus linker table size
						 * plus 2 for gc list
						 * plus 3 to round up to word
						 */

	lseek(fileno(filp),(long)sizeof(struct exec),0);
	code_core_org = (char *) csegment(OTHER,segsiz,TRUE);
	if(read(fileno(filp),code_core_org,bind_org) != bind_org)
	    error("Read error in text ",FALSE);

  if(debug) {
	printf("Read %d bytes of text into 0x%x\n",bind_org,code_core_org);
	 printf(" incore segment size: %d (0x%x)\n",segsiz,segsiz);
	 }
	 
	/* linker table is 2 entries (8 bytes) larger than the number of
	 * entries given by linker_size .  There must be a gc word at
	 * the beginning and a -1 at the end
	 */
	lc_org = code_core_org + bind_org;
	lc_end = lc_org + 4*linker_size + 4; 
					/* address of gc sentinal last */

	if(debug)printf("lin_cor_org: %x, link_cor_end %x\n",
				      lc_org,
				      lc_end);
	Symbtb[1].floc = (int) (lc_org + 4);

	/* set the linker table to all -1's so we can put in the gc table */
	for( iptr = (int *)(lc_org + 4 ); 
	     iptr <= (int *)(lc_end); 
	     iptr++)
	  *iptr = -1;


	/* link our table into the gc tables */
	/* only do so if we will not purcopy these tables */
	if(Vpurcopylits->a.clb == nil)
	{
	    *(int *)lc_org = (int)bind_lists;	/* point to current */
	    bind_lists = (int *) (lc_org + 4); /* point to first
	    							item */
	}

	/* read the binder table and literals onto the stack */

	binder_core_org =  alloca(lit_end - bind_org);
	read(fileno(filp),binder_core_org,lit_end-bind_org);

	literal_core_org = binder_core_org + lit_org - bind_org;

	/* check if there is a transfer table required for this
	 * file, and if so allocate one of the necessary size
	 */

	if(trans_size > 0)
	{
	    tranloc = gettran(trans_size);
	    Symbtb[0].floc = (int) tranloc;
	}

	/* now relocate the necessary symbols in the text segment */

	fseek(filp,(long)(sizeof(struct exec) + exblk.a_text + exblk.a_data),0);
	times = (exblk.a_trsize)/sizeof(struct relocation_info);
		
	/* the only symbols we will relocate are references to  
		external symbols.  They are recognized by 
		extern and pcrel set.
	 */

        for( i=1; i<=times ; i++)
	    {
		if( fread((char *)&reloc,sizeof(struct relocation_info),1,filp) != 1)
		   error("Bad text reloc read",FALSE);
	     if(reloc.r_extern)
	     {
	        for(j=0; j < SYMMAX; j++)
		{

		   if(Symbtb[j].ord == reloc.r_symbolnum)  /* look for this sym */
		    {
#define offset(p) (((p).r_pcrel) ? ((int) code_core_org): 0)
		      if(debug && FALSE) printf("Relocating %d (ord %d) at %x\n",
					 j, Symbtb[j].ord, reloc.r_address);
			if (Symbtb[j].floc == (int)  mcnts) {
		            *(int *)(code_core_org+reloc.r_address) 
		               += mcntp - offset(reloc); 
			    if(doprof){
			     if (mcntp == (int) &mcnts[NMCOUNT-2])
				printf("Ran out of counters; increas NMCOUNT in fasl.c\n");
			     if (mcntp < (int) &mcnts[NMCOUNT-1])
			        mcntp += 4;
			    }
			} else
		            *(int *)(code_core_org+reloc.r_address) 
		               += Symbtb[j].floc - offset(reloc); 
			  
		        break;
		      
		      }
		 };
		 if( j >= SYMMAX) if(debug) printf("Couldnt find ord # %d\n",
						   reloc.r_symbolnum);
	     }

	    }
	
	if ( Vldprt->a.clb != nil ) {
		putchar('\n');
		fflush(stdout);
	}

	/* set up a fake port so we can read from core */
	/* first find a free port 	 	       */

	p = fstopen((char *) literal_core_org, lit_end - lit_org, "r");

	if(debug)printf("lit_org %d, charstrt  %d\n",lit_org, p->_base);
 	/* the first forms we wish to read are those literals in the 
	 * literal table, that is those forms referenced by an offset
	 * from r8 in  compiled code
	 */

	/* to read in the forms correctly, we must set up the read table
	 */
	currtab = Vreadtable->a.clb;
	Vreadtable->a.clb = strtab;		/* standard read table */
	curibase = ibase->a.clb;
	ibase->a.clb = inewint(10);		/* read in decimal */
	ouctolc = uctolc; 	/* remember value of uctolc flag */

	PUSHDOWN(gcdis,tatom);			/* turn off gc */

	i = 1;	
	linktab = (lispval *)(lc_org +4);
	while (linktab < (lispval *)lc_end)
	{
	   np = svnp;
	   protect(P(p));
	   uctolc = FALSE;
	   handy = (lispval)Lread();
	   if (Vpurcopylits->a.clb != nil) {
		handy = Ipurcopy(handy);
	   }
	   uctolc = ouctolc;
	   getc(p);			/* eat trailing blank */
	   if(debugmode != nil)
	   {   printf("form %d read: ",i++);
	       printr(handy,stdout); 
	       putchar('\n');
	       fflush(stdout);
	   }
	   *linktab++ = handy;
	}

	/* process the transfer table if one is used		*/
	trsize = trans_size;
	while(trsize--)
	{
	    np = svnp;
	    protect(P(p));
	    uctolc = FALSE;
	    handy = Lread();	    /* get function name */
	    uctolc = ouctolc;
	    getc(p);
	    tranloc->name = handy;
	    tranloc->fcn = qlinker;	/* initially go to qlinker */
	    tranloc++;
	}



	/* now process the binder table, which contains pointers to 
	   functions to link in and forms to evaluate.
	*/
	funcnt = 0;

	curbind = (struct bindage *) binder_core_org;
	for( ; curbind->b_type != -1 ; curbind++) 
	{
	    np = svnp;
	    protect(P(p));
	    uctolc = FALSE;		/* inhibit uctolc conversion */
	    rdform = Lread();
	    /* debugging */
	    if(debugmode != nil) { printf("link form read: ");
			printr(rdform,stdout);
			printf("  ,type: %d\n",
				 curbind->b_type);
			fflush(stdout);
		      }
	    /* end debugging */
	    uctolc = ouctolc;		/* restore previous state */
	    getc(p);			/* eat trailing null */
	    protect(rdform);
	    if(curbind->b_type <= 2)	/* if function type */
	    { 
	       handy = newfunct();
	       if (note_redef && (rdform->a.fnbnd != nil))
	       {
		   printr(rdform,stdout);
		   printf(" redefined\n");
	       }
	       rdform->a.fnbnd = handy;
	       handy->bcd.start = (lispval (*)())(code_core_org + funloc[funcnt++]);
	       handy->bcd.discipline =
		  (curbind->b_type == 0 ? lambda :
		       curbind->b_type == 1 ? nlambda :
			  macro);
	       if(domap) {
	           fprintf(map,"%s\n%x\n",rdform->a.pname,handy->bcd.start);
	       }
	    }
	    else {
		Vreadtable->a.clb = currtab;
		ibase->a.clb = curibase;

		/* debugging */
		if(debugmode != nil) {
			printf("Eval: ");
			printr(rdform,stdout);
			printf("\n");
			fflush(stdout);
		};
		/* end debugging */

		eval(rdform);		/* otherwise eval it */

		if(uctolc) ouctolc = TRUE; /* if changed by eval, remember */
		curibase = ibase->a.clb;
		ibase->a.clb = inewint(10);
		Vreadtable->a.clb = strtab;
	   }
	};
	      
	fclose(p);	/* give up file descriptor */

	POP;			/* restore state of gcdisable variable */

	Vreadtable->a.clb = currtab;
	chkrtab(currtab);
	ibase->a.clb = curibase;

	fclose(filp);
	if(domap) fclose(map);
	Freexs();
	return(tatom);
}

#if m_68k
/* function used in qsort for 68k version only */
compar(arg1,arg2)
int *arg1,*arg2;
{
	if(*arg1 < *arg2) return (-1);
        else if (*arg1 == *arg2) return (0);
	else return(1);
}
#endif

/* gettran :: allocate a segment of transfer table of the given size	*/

struct trent *
gettran(size)
{
	struct trtab *trp;
	struct trent *retv;
	int ousehole;
	extern int usehole;

	if(size > TRENTS)
	  error("transfer table too large",FALSE);
	
	if(size > trleft)
	{
	    /* allocate a new transfer table */
	    /* must not allocate in the hole or we cant modify it */
	    ousehole = usehole; /* remember old value */
	    usehole = FALSE;
	    trp = (struct trtab *)csegment(OTHER,sizeof(struct trtab),FALSE);
	    usehole = ousehole;

	    trp->sentinal = 0;		/* make sure the sentinal is 0 */
	    trp->nxtt = trhead;	/* link at beginning of table  */
	    trhead = trp;
	    trcur = &(trp->trentrs[0]);	/* begin allocating here	*/
	    trleft = TRENTS;
	}

	trleft = trleft - size;
	retv = trcur;
	trcur = trcur + size;
	return(retv);
}

/* clrtt :: clear transfer tables, or link them all up;
 * this has two totally opposite functions:
 * 1) all transfer tables are reset so that all function calls will go
 * through qlinker
 * 2) as many transfer tables are set up to point to bcd functions
 *    as possible
 */
clrtt(flag)
{
	/*  flag = 0 :: set to qlinker
	 *  flag = 1 :: set to function bcd binding if possible
	 */
	register struct trtab *temptt;
	register struct trent *tement;
	register lispval fnb;

	for (temptt = trhead; temptt != 0 ; temptt = temptt->nxtt)
	{ 
	    for(tement = &temptt->trentrs[0] ; tement->fcn != 0 ; tement++)
	    {   if(flag == 0 || TYPE(fnb=tement->name->a.fnbnd) != BCD
			     || TYPE(fnb->bcd.discipline) == STRNG)
		tement->fcn =  qlinker;
		else tement->fcn = fnb->bcd.start;
	    }
	}
}

/* chktt - builds a list of transfer table entries which don't yet have
  a function associated with them, i.e if this transfer table entry
  were used, an undefined function error would result
 */
lispval 
chktt()
{
	register struct trtab *temptt;
	register struct trent *tement;
	register lispval retlst,curv;
	Savestack(4);

	retlst = newdot();		/* build list of undef functions */
	protect(retlst);
	for (temptt = trhead; temptt != 0 ; temptt = temptt->nxtt)
	{ 
            for(tement = &temptt->trentrs[0] ; tement->fcn != 0 ; tement++)
	    {
	       if(tement->name->a.fnbnd == nil)
	       {
		  curv= newdot();
		  curv->d.car = tement->name;
		  curv->d.cdr = retlst->d.cdr;
		  retlst->d.cdr = curv;
		}
	     }
	 }
	 Restorestack();
	 return(retlst->d.cdr);
}
EndOfFile
cat >  franz/vax/../trace.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: /na/franz/franz/RCS/trace.c,v 1.2 83/08/19 09:50:34 jkf Exp $";
#endif

/*					-[Thu Aug 18 10:08:36 1983 by jkf]-
 * 	trace.c				$Locker:  $
 * evalhook evaluator
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
lispval
Leval1(){
    register struct nament *bindptr;
    register lispval handy;
    if (np-lbot == 2) {	/*if two arguments to eval */
	if (TYPE((lbot+1)->val) != INT)
	    error("Eval: 2nd arg not legal alist pointer", FALSE);
	bindptr = orgbnp + (lbot+1)->val->i;
	if (rsetsw == 0 || rsetatom->a.clb == nil)
	    error("Not in *rsetmode; second arg is useless - eval", TRUE);
	if (bptr_atom->a.clb != nil)
	    error("WARNING - Nesting 2nd args to eval will give spurious values", TRUE);
	if (bindptr < orgbnp || bindptr >bnplim)
	    error("Illegal pdl pointer as 2nd arg - eval", FALSE);
	handy = newdot();
	handy->d.car = (lispval)bindptr;
	handy->d.cdr = (lispval)bnp;
	PUSHDOWN(bptr_atom, handy); 
	handy = eval(lbot->val);
	POP;
	return(handy);
    } else {	/* normal case - only one arg */
	chkarg(1,"eval");
	handy = eval(lbot->val);
	return(handy);
    };
}

lispval
Levalhook()
{
    register lispval handy;
    register lispval funhval = CNIL;

    switch (np-lbot) 
    {
    case 2: break;
    case 3: funhval = (lbot+2)->val;
	    break;
    default: argerr("evalhook");
    }

    /* Don't do this check any longer
     * if (evalhsw == 0) 
     *	    error("evalhook called before doing sstatus-evalhook", TRUE);
     * if (rsetsw == 0 || rsetatom->a.clb == nil)
     *    error("evalhook called while not in *rset mode", TRUE);
     */
     
    if(funhval != CNIL) { PUSHDOWN(funhatom,funhval); }

    PUSHDOWN(evalhatom,(lispval)(lbot+1)->val);
    /* eval checks evalhcall to see if this is a LISP call to evalhook
	in which case it avoids call to evalhook function, but clobbers
	value to nil so recursive calls will check.  */
    evalhcallsw = TRUE;	
    handy = eval(lbot->val);
    POP;

    if(funhval != CNIL) { POP; }

    return(handy);
}


lispval
Lfunhook()
{
    register lispval handy;
    register lispval evalhval = CNIL;
    Savestack(2);


    switch (np-lbot) 
    {
    case 2: break;
    case 3: evalhval = (lbot+2)->val;
	    break;
    default: argerr("funcallhook");
    }

    /* Don't do this check any longer
     * if (evalhsw == 0) 
     *	    error("funcallhook called before doing sstatus-evalhook", TRUE);
     *if (rsetsw == 0 || rsetatom->a.clb == nil)
     *	    error("funcallhook called while not in *rset mode", TRUE);
     */
     
    handy = lbot->val;
    while (TYPE(handy) != DTPR) 
      handy = errorh1(Vermisc,"funcallhook: first arg must be a list",nil,TRUE,
					   0,handy);
    if(evalhval != CNIL) { PUSHDOWN(evalhatom,evalhval); }

    PUSHDOWN(funhatom,(lispval)(lbot+1)->val);
    /* funcall checks funcallhcall to see if this is a LISP call to evalhook
	in which case it avoids call to evalhook function, but clobbers
	value to nil so recursive calls will check.  */
    funhcallsw = TRUE;	
    /*
     * the first argument to funhook is a list of already evaluated expressions
     * which we just stack can call funcall on
     */
    lbot = np;		/* base of new args */
    for ( ; handy != nil ; handy = handy->d.cdr)
    {
	protect(handy->d.car);
    }
    handy = Lfuncal();
    POP;
    if(evalhval != CNIL) { POP;  }
    Restorestack();
    return(handy);
}


lispval
Lrset ()
    {
    chkarg(1,"rset");

    rsetsw = (lbot->val == nil) ? 0 : 1;
    rsetatom->a.clb = (lbot->val == nil) ? nil: tatom;
    evalhcallsw = FALSE;
    return(lbot->val);
}

EndOfFile
cat >  franz/vax/../evalf.c  << 'EndOfFile'
#ifndef lint
static char *sccsid = "%W% %G%";
#endif

#include "global.h"
#include "frame.h"

lispval
Levalf ()
{
    register struct frame *myfp;
    register lispval handy, result;
    struct frame *searchforpdl();
    int evaltype;
    Savestack(3);

    if(lbot==np) handy = nil;
    else if((np-lbot) == 1) handy = lbot->val;
    else argerr("evalf");

    if (handy == nil)  /* Arg of nil means start at the top */
    {
	myfp = searchforpdl(errp);	
	/* 
	 * myfp may be nil, if *rset t wasn't done. In that case we
	 * just return nil
	 */
	if(myfp == (struct frame *) 0) return(nil);
	/*
	 * myfp may point to the call to evalframe, in which case we
	 * want to go to the next frame down.  myfp will not point
	 * to the call to evalframe if for example the translink tables
	 * are turned on and the call came from compiled code
	 */
	if(    ((myfp->class == F_EVAL) 
	             && TYPE(myfp->larg1) == DTPR
	             && myfp->larg1->d.car == Vevalframe)
	    || ((myfp->class == F_FUNCALL)
		     && (myfp->larg1 = Vevalframe)))
	    
	   myfp = searchforpdl(myfp->olderrp);	/* advance to next frame */
    } 
    else 
    {
	if( TYPE(handy) != INT ) 
	    error("Arg to evalframe must be integer",TRUE);
	    /* 
	     * Interesting artifact: A pdl pointer will be an INT, but if
	     * read in, the Franz reader produces a bignum, thus giving some
	     * protection from being hacked. 
	     */
	    
	myfp = (struct frame *)(handy->i);
	vfypdlp(myfp);	/* make sure we are given valid pointer */
	myfp = searchforpdl(myfp);
        if (myfp == (struct frame *) 0 ) return(nil);	/* end of frames */
	myfp = searchforpdl(myfp->olderrp);	/* advance to next one */
    };


    if (myfp == (struct frame *) 0 ) return(nil);	/* end of frames */

    if(myfp->class == F_EVAL) evaltype = TRUE; else evaltype = FALSE;

    /* return ( <eval or apply> <fp> <exp being evaled> <bnp>) */
    protect(result = newdot());
    /* 
     * See maclisp manual for difference between eval frames and apply
     * frames, or else see the code below. 
     */
    result->d.car = matom (evaltype ? "eval" : "apply"); 
    result->d.cdr = (handy = newdot());
    handy->d.car = inewint(myfp); /* The frame pointer as a lisp int */
    handy->d.cdr = newdot();
    handy = handy->d.cdr;
    if (evaltype)
	handy->d.car = myfp->larg1;  /* eval type - simply the arg to eval */
    else 
    {  /*  
        * apply type ; must build argument list. The form will look like
	*
 	*	  (<function> (<evaled arg1> <evaled arg2> ....))
	*   i.e. the function name followed by a list of evaluated args 
	*/
	lispval form, arglist;
	struct argent *pntr;
	(form = newdot())->d.car = myfp->larg1;
	handy->d.car = form;			/* link in to save from gc */
	(form->d.cdr = newdot())->d.cdr = nil;
	for (arglist = nil, pntr = myfp->svlbot; pntr < myfp->svnp;  pntr++) 
	{
	    if(arglist == nil) 
	    {
		protect(arglist = newdot());
		form->d.cdr->d.car = arglist;	/* save from gc */
	    }
	    else arglist = (arglist->d.cdr = newdot());
	    arglist->d.car = pntr->val;
	};
    };
    handy->d.cdr = newdot();
    handy = handy->d.cdr;
	/* Next is index into bindstack lisp pseudo-array, for maximum
	    usefulness */
    handy->d.car = inewint( myfp->svbnp - orgbnp); 
    handy->d.cdr = newdot();
    handy = handy->d.cdr;
	
    handy->d.car = inewint(myfp->svnp - orgnp);	/* index of np in namestack*/
    handy->d.cdr = newdot();
    handy = handy->d.cdr;
    handy->d.car = inewint(myfp->svlbot - orgnp);/* index of lbot in namestack*/
    Restorestack();
    return(result);
}

struct frame *searchforpdl (myfp)
struct frame *myfp;
{
    /*
     * for safety sake, we verify that this is a real pdl pointer by
     * tracing back all pdl pointers from the start
     * then after we find it, we just advance to next F_EVAL or F_FUNCALL
     */
    vfypdlp(myfp);
    for(  ; myfp != (struct frame *)0 ; myfp= myfp->olderrp)
    {
	if((myfp->class == F_EVAL) || (myfp->class == F_FUNCALL))
	    return(myfp);
    }
    return((struct frame *)0);
}

/*
 * vfypdlp :: verify pdl pointer as existing,  do not return unless
 * it is valid
 */
vfypdlp(curfp)
register struct frame *curfp;
{
    register struct frame *myfp;

    for (myfp = errp; myfp != (struct frame *)0 ; myfp = myfp->olderrp)
	if(myfp == curfp) return;
    errorh1(Vermisc,"Invalid pdl pointer given: ",nil,FALSE,0,inewint(curfp));
}

lispval
Lfretn ()
{
    struct frame *myfp;	
    chkarg(2,"freturn");

    if( TYPE(lbot->val) != INT )
	error("freturn: 1st arg not pdl pointer",FALSE);

    myfp = (struct frame *) (lbot->val->i);
    vfypdlp(myfp);		/* make sure pdlp is valid */

    retval = C_FRETURN;		/* signal coming from freturn */
    lispretval = (lbot+1)->val;	/* value to return 	*/
    Iretfromfr(myfp);
    /* NOT REACHED */
}
EndOfFile
cat >  franz/vax/../frame.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: frame.c,v 1.2 83/05/07 23:46:38 jkf Exp $";
#endif

/*					-[Sat May  7 22:27:57 1983 by jkf]-
 * 	frame.c				$Locker: sklower $
 * non local goto handlers
 *
 * (c) copyright 1982, Regents of the University of California
 */


#include "global.h"
#include "frame.h"

/* 
 * This is a collection of routines for manipulating evaluation frames.
 * Such frames are generated to mark the state of execution at a certain
 * spot.  They are created upon entry to prog, do, catch, errset and
 * other misc. functions (such as eval when in *rset mode).
 *
 * As described in h/frame.h, each frame is identified by a class, which
 * says who created the frame.  The global variable errp points to the
 * first (newest) frame on the stack.  
 * The standard way to create a frame is to say
 *
 *   errp = Pushframe(class,arg1,arg2);	 /* create and link in new 
 *   					    frame of give class * /
 *
 * poping the frame must be done explicity if the routine was not exited by
 * a non-local goto.  This is done by 
 *   errp = Popframe();
 *
 * When a frame is created, it marks the current state on the runtime stack.
 * Execution will continues after the Pushframe call with the value of the
 * global variable 'retval' set to 0.  Some time later control may be thrown
 * up the stack and it will seem that Pushframe returned again.  This time
 * retval will contain a non-zero value indicating what caused the non-local
 * jump.  retval will have one of the values from C_???? in h/frame.h . 
 * It will not have just of the C_???? values, it will only have a value
 * which makes sense. For example, coming out of a Pushframe(F_CATCH,tag,nil);
 * retval will either be 0 (initially) or C_THROW, [and in addition it will
 * already have been determined that the tag of the catch matches the tag
 * being thrown, [[ this does not apply to GO's and PROG tags]] ].
 *
 * In doing throws, goto's, returns, or errors up the stack we are always
 * conscious of the possiblity of unwind-protect sitting between where 
 * control starts and where it wants to get.  Thus it may be necessary
 * to save the state of the non-local jump, give control to the unwind-protect
 * and have it continue the non-local jump. 
 */

 /*
  * Inonlocalgo(class, arg1, arg2) :: do a general non-local goto.
  *    	class - one of the C_???? in h/frame.h
  *	arg1 - tag in C_THROW, C_GO; value in C_RETURN
  *	arg2 - value in C_THROW;
  *  this handles GO's, THROW's, RETURN's  but not errors, which have more
  * state to throw and a lot of different things to do if there is no one
  * to catch the error.
  * 
  * This routine never returns.
  */

Inonlocalgo(class, arg1, arg2)
lispval arg1,arg2;
{
    struct frame *uwpframe, *Inlthrow();
    lispval handy;

    /* 
     * scan for something to match 'class', return if nothing found, or
     * if we must first handle an unwind protect.
     */
    while( uwpframe = Inlthrow(class,arg1,arg2) )
    {
	/* build error frame description to be use to continue this throw */
	protect(lispretval = handy = newdot());
    	handy->d.car = Veruwpt;
	handy = handy->d.cdr = newdot();
	handy->d.car = inewint(class);		/* remember type */
	handy = handy->d.cdr = newdot();
	handy->d.car = arg1;
	handy = handy->d.cdr = newdot();
	handy->d.car = arg2;
	retval = C_THROW;
	Iretfromfr(uwpframe);
	/* NOT REACHED */
    }

    /*
     * nothing to go to, signal the appropriate error
     */

    switch(class)
    {
    case C_GO: errorh1(Vermisc, "No prog to go to with this tag ",
			       nil,FALSE,0,arg1);
		/* NOT REACHED */

    case C_RET: errorh(Vermisc, "No prog to return from", nil, FALSE, 0);
		/* NOT REACHED */

    case C_THROW: errorh1(Vermisc, "No catch for this tag ", nil, FALSE , 0,
				  arg1);
		/* NOT REACHED */
    default: error("Internal  Inonlocalgoto error" ,FALSE);
		/* NOT REACHED */
    }
}

/*
 * Inlthrow(class,arg1,arg2) :: look up the stack for a form to handle
 * a value of 'class' being thrown.  If found, do the throw.  If an
 * unwind-protect must be done, then return a pointer to that frame
 * first.  If there is nothing to catch this throw, we return 0.
 */

struct frame *
Inlthrow(class, arg1, arg2)
lispval arg1, arg2;
{
    struct frame *uwpframe = (struct frame *)0;
    struct frame *curp;
    int pass = 1;

    restart:
	for(curp = errp; curp != (struct frame *) 0; curp = curp->olderrp)
	{
	    switch(curp->class)
	    {
	    case F_PROG: if(class == C_RET || class == C_GO)
			 {
			    if(pass == 2) return(uwpframe);
			    else 
			    {
				lispretval = arg1;
				retval = class;
				Iretfromfr(curp);
				/* NOT REACHED */
			    }
			  }
			  break;

	    case F_CATCH: if((pass == 1) && (curp->larg1 == Veruwpt))
			  {
				uwpframe = curp;
				pass = 2;
				goto restart;
			  }
			  else if(class == C_THROW 
					&& matchtags(arg1,curp->larg1))
			  {
			    if(pass == 2) return(uwpframe);
			    else 
			    {
				lispretval = arg2;	/* value thrown */
				retval = class;
				Iretfromfr(curp);
				/* NOT REACHED */
			    }
			   }
			   break;
	    
	    case F_RESET:  if(class == C_RESET)
			   {
				if(pass == 2) return(uwpframe);
				else
				{
				    retval = class;
				    Iretfromfr(curp);
				    /* NOT REACHED */
				}
			    }
			    break;

	    }
	}
	return((struct frame *)0);   /* nobody wants it */
}


Iretfromfr(fram)
register struct frame *fram;
{
    xpopnames(fram->svbnp);
    qretfromfr();	/* modified in sed script to point to real function */
    /* NOT REACHED */
}

/* matchtags :: return TRUE if there is any atom in common between the
 * two tags.  Either tag may be an atom or an list of atoms.
 */
matchtags(tag1,tag2)
lispval tag1, tag2;
{
    int repeat1 = FALSE;
    int repeat2 = FALSE;
    lispval temp1 = tag1;
    lispval temp2 = tag2;
    lispval t1,t2;

    if(TYPE(tag1) == ATOM) 
    {
	t1 = tag1;
    }
    else {
	t1 = tag1->d.car;
	repeat1 = TRUE;
    }

    if(TYPE(tag2) == ATOM)
    {
	t2 = tag2;
    }
    else {
	t2 = tag2->d.car;
	repeat2 = TRUE;
    }

loop:
    if(t1 == t2) return(TRUE);
    if(repeat2) 
    {
	if((temp2 = temp2->d.cdr) != nil)
	{
	    t2 = temp2->d.car;
	    goto loop;
	}
    }

    if(repeat1)
    {
        if((temp1 = temp1->d.cdr) != nil)
	{
	    t1 = temp1->d.car;
	    if(repeat2) 
	    {
	        temp2 = tag2;
		t2 = temp2->d.car;
		goto loop;
	    }
	    else t2 = tag2;
	    goto loop;
	 }
    }
    return(FALSE);
}

/*
 * framedump :: debugging routine to print the contents of the error 
 * frame
 *
 */
lispval
Lframedump()
{
    struct frame *curp;

    printf("Frame dump\n");
    for(curp = errp ; curp != (struct frame *)0 ; curp=curp->olderrp)
    {
	printf("at %x is ",curp);

	switch(curp->class) {
	case F_PROG: printf(" prog\n");
		     break;

	case F_CATCH:printf(" catching ");
		     printr(curp->larg1,stdout);
		     putchar('\n');
		     break;

	case F_RESET:printf(" reset \n");
		     break;

	case F_EVAL: printf(" eval: ");
		     printr(curp->larg1,stdout);
		     putchar('\n');
		     break;

	case F_FUNCALL: printf(" funcall: ");
		     printr(curp->larg1,stdout);
		     putchar('\n');
		     break;

	case F_TO_FORT: printf(" calling fortran:\n");
		     break;

	case F_TO_LISP: printf(" fortran calling lisp:\n");
		     break;

		
	default:
		     printf(" unknown: %d \n",curp->class);
	}
	fflush(stdout);
    }
    printf("End of stack\n");
    return(nil);
}

EndOfFile
cat >  franz/vax/../lamgc.c  << 'EndOfFile'
#ifndef lint
static char *rcsid =
   "$Header: lamgc.c,v 1.5 84/03/31 22:34:28 layer Exp $";
#endif

/*					-[Sat Jan 29 13:07:37 1983 by jkf]-
 * 	lamgc.c				$Locker:  $
 * file used to meter gc, not always loaded
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "gc.h"
#include <sys/types.h>
#ifdef METER
#include <sys/vtimes.h>
#endif

/* 
  this file  is temporary and will contain routines to meter 
  the garbage collector
 */

/* gcstat - temporary routine used to report on gc statistics.
   if this causes variables to be undefined,then it should be removed
*/

extern int *beginsweep,gensymcounter;
int gcstat;
int mrkdpcnt;
int gccount;
int conssame;
int consdiff;
int consnil;


/*
 *	gcstat  - initiate and record gc statistics
 * calls:
 *  	(gcstat 0) -- initiate gc statistics by creating gc.out
 *		      and writing header.
 *	(gcstat 1) -- finish off gc statistics file by writing typetable
 *		      and closing file.
 */
lispval
Lgcstat()
{
	register lispval handy;
	int nbytes;
	struct gchead hhh;

	chkarg(1,"gcstat");

	if(TYPE(handy=lbot->val) != INT)
	{	error("gcstat: non integer arg ",FALSE);
	}

	switch(handy->i)
	{
	    case 0:  if((gcstat = creat("gc.out",0644)) < 0)
		       error("cant open gc.out",FALSE);
		     hhh.version = 5;
		     hhh.lowdata = (int)beginsweep;
		     printf("writing %d bytes \n",sizeof(hhh));
		     write(gcstat,(char *)&hhh,sizeof(hhh));
		     gccount = 0;
		     return(tatom);

	    case 1:
		     /* first write out the type table */ 
		     nbytes = 0;
		     /* 0 means type table follows */
		     printf("gc's %d, writing %d bytes \n",gccount,
				  sizeof(nbytes));
		     write(gcstat,(char *)&nbytes,sizeof(nbytes));
		     write(gcstat,(char *)&typetable[ATOX(beginsweep)+1],
				nbytes = ((int)datalim - (int)beginsweep)>>9);
		     printf("writing %d bytes \n",nbytes+sizeof(nbytes));
		     write(gcstat,(char *)&nbytes,sizeof(nbytes));
		     close(gcstat);
		     gcstat = 0;
		     return(inewint(nbytes));
	    default:
		     error("Bad value to gcstat ",TRUE);
	}
	/* NOTREACHED */
}
extern int bitmapi[];		/* a bit of a lie it is really a double array*/
char *bitmapc = (char *)bitmapi;
/* called in the garbage collector after the bit maps have been made 
   only if gcstat is non zero */
gcdump()
{
#ifdef
	extern struct vtimes premark,presweep,alldone;
	int nbytes, recsize;
	/* 16 bytes/page in the bitmap */
	nbytes = (((int) datalim - (int) beginsweep) >> 9) * 16;
	recsize = nbytes + 6*sizeof(int) + 3*sizeof(struct vtimes);
	write(gcstat,(char *)&recsize,sizeof(recsize)); /* whole record size */
	write(gcstat,(char *)&premark,sizeof(premark));
	write(gcstat,(char *)&presweep,sizeof(presweep));
	write(gcstat,(char *)&alldone,sizeof(alldone));
	write(gcstat,(char *)&gensymcounter,sizeof(int));
	write(gcstat,(char *)&conssame,sizeof(int));
	write(gcstat,(char *)&consdiff,sizeof(int));
	write(gcstat,(char *)&consnil,sizeof(int));
	write(gcstat,(char *)&mrkdpcnt,sizeof(int));
	write(gcstat,(char *)&nbytes,sizeof(nbytes));	/* bit table size */
	write(gcstat,(char *)&bitmapc[ATOX(beginsweep) * 16],nbytes);
	printf("gc: %d, written %d bytes\n",++gccount,nbytes);
#endif
}
EndOfFile
cat >  franz/vax/tags  << 'EndOfFile'
EndOfFile
cat >  franz/68k/68k.c  << 'EndOfFile'
#include "global.h"
#include <signal.h>


mmuladd(a,b,c,m)
long a,b,c,m;
{
	long work[2]; char err;
	emul(a,b,c,work);
	ediv(work,m,err);
	return(work[0]);
}
/*mmuladd (a, b, c, m) 
int a, b, c, m;
{
	asm ("emul	4(ap),8(ap),12(ap),r0");
	asm ("ediv	16(ap),r0,r2,r0");
}

Imuldiv() {
asm("	emul	4(ap),8(ap),12(ap),r0");
asm("	ediv	16(ap),r0,*20(ap),*24(ap)");
}*/

Imuldiv(p1,p2,add,dv,quo,rem)
long p1, p2, add, dv;
long *quo, *rem;
{
	long work[2]; char err;

	emul(p1,p2,add,work);
	*quo = ediv(work,dv, &err);
	*rem = *work;
}
/*C library -- write
  nwritten = write(file, buffer, count);
  nwritten == -1 means error
*/
write(file, buffer, count)
char *buffer;
{
	register lispval handy;
	int retval;
	if((file != 1) || (Vcntlw->a.clb == nil)) goto top;
	/* since ^w is non nil, we do not want to print to the terminal,
	   but we must be sure to return a correct value from the write
	   in case there is no write to ptport
	*/
	retval = count;
	goto skipit;

top:

	retval = _write(file,buffer,count);

skipit:
    if(file==1) {
	handy = Vptport->a.clb;
	if(handy!=nil && TYPE(handy)==PORT && handy->p->_file!=1) {
		fflush(handy->p);
		file = handy->p->_file;
		goto top;
	}
    }
    return(retval);
}

/*
# C library -- read

# nread = read(file, buffer, count);
#
# nread ==0 means eof; nread == -1 means error
*/
#include <errno.h>
read(file,buffer,count)
{
	extern int errno;
	register int Size;
again:

	Size = _read(file,buffer,count);
	if ((Size >= 0) || (errno != EINTR)) return(Size);
	if(sigintcnt > 0) sigcall(SIGINT);
	goto again;
}

lispval
Lpolyev()
{
	register int count; 
	register double *handy, *base;
	register struct argent *argp;
	lispval result; int type;
	char *alloca();

	count = 2 * (((int) np) - (int) lbot);
	if(count == 0) 
		return(inewint(0));
	if(count == 8)
		return(lbot->val);
	base = handy = (double *) alloca(count);
	for(argp = lbot; argp < np; argp++) {
		while((type = TYPE(argp->val))!=DOUB && type!=INT)
			argp->val = (lispval) errorh2(Vermisc,"%%machine-polyev:non-real arg",nil,TRUE,73,lbot,argp->val);
		if(TYPE(argp->val)==INT) {
			*handy++ = argp->val->i;
		} else
			*handy++ = argp->val->r;
	}
	count = count/sizeof(double) - 2;
/*	asm("polyd	(r9),r11,8(r9)");
	asm("movd	r0,(r9)");*/
	result = newdoub();
	result->r = *base;
	return(result);
}

lispval
Lrot()
{
	register rot,val;		/* these must be the first registers */
	register struct argent *mylbot = lbot;

	chkarg(2,"rot");
	if((TYPE(mylbot->val) != INT) || (TYPE(mylbot[1].val) != INT))
		errorh2(Vermisc,
		       "Non ints to rot",
		       nil,FALSE,0,mylbot->val,mylbot[1].val);
	val = mylbot[0].val->i;
	rot = mylbot[1].val->i;
	rot = rot % 32 ;	/* bring it down below one byte in size */
	if(rot < 0) {
		rot = -rot;
		{asm("roll	d7,d6");}
	} else {asm("rorl	d7,d6");}
	return( inewint(val));
}

myfrexp() { error("myfrexp called", FALSE);}
#if os_unisoft | os_unix_ts
syscall() { error("vsyscall called", FALSE);}
#endif

#include "structs.h"
prunei(what)
register lispval what;
{
	extern struct types int_str;
	int gstart();
	if(((long)what) > ((long) gstart)) {
		--(int_items->i);
		what->i = (long) int_str.next_free;
		int_str.next_free = (char *) what;
	}
}
#include "68kframe.h"
/* new version of showstack,
	We will set fp to point where the register fp points.
	If we find that the saved pc is somewhere in the routine eval,
   then we print the first argument to that eval frame. This is done
   by looking on the stack.
*/
lispval
Lshostk()
{	lispval isho();
	return(isho(1));
}
static lispval
isho(f)
int f;
{
	register struct machframe *myfp; register lispval handy;
	int **fp;	/* this must be the first local */
	int virgin=1;
	lispval linterp(), Ifuncal();
	lispval _qfuncl(),tynames();	/* locations in qfuncl */
	extern int plevel,plength;

	if(TYPE(Vprinlevel->a.clb) == INT)
	{ 
	   plevel = Vprinlevel->a.clb->i;
	}
	else plevel = -1;
	if(TYPE(Vprinlength->a.clb) == INT)
	{
	    plength = Vprinlength->a.clb->i;
	}
	else plength = -1;

	if(f==1)
		printf("Forms in evaluation:\n");
	else
		printf("Backtrace:\n\n");

	myfp = (struct machframe *) (&fp +1);	/* point to current machframe */

	while(TRUE)
	{
	    if( (myfp->pc > eval  &&  		/* interpreted code */
		 myfp->pc < popnames)
		||
		(myfp->pc > Ifuncal &&		/* compiled code */
		 myfp->pc < Lfuncal)  )
	    {
	      { handy = (myfp->fp->ap[0]);
		if(f==1)
			printr(handy,stdout), putchar('\n');
		else {
			if(virgin)
				virgin = 0;
			else
				printf(" -- ");
			printr((TYPE(handy)==DTPR)?handy->d.car:handy,stdout);
		}
	      }

	    }

	    if(myfp > myfp->fp) break;	/* end of frames */
	    else myfp = myfp->fp;
	}
	putchar('\n');
	return(nil);
}

/*
 *
 *	(baktrace)
 *
 * baktrace will print the names of all functions being evaluated
 * from the current one (baktrace) down to the first one.
 * currently it only prints the function name.  Planned is a
 * list of local variables in all stack frames.
 * written by jkf.
 *
 */
lispval
Lbaktrace()
{
	isho(0);
}

/*
 * (int:showstack 'stack_pointer)
 * return
 *   nil if at the end of the stack or illegal
 *   ( expresssion . next_stack_pointer) otherwise
 *   where expression is something passed to eval
 * very vax specific
 */
lispval
LIshowstack()
{
    int **fp;	/* must be the first local variable */
    register lispval handy;
    register struct machframe *myfp;
    lispval retval, Ifuncal();
    Savestack(2);
    
    chkarg(1,"int:showstack");

    if((TYPE(handy=lbot[0].val) != INT) && (handy != nil))
        error("int:showstack non fixnum arg", FALSE);

    if(handy == nil)
        myfp = (struct machframe *) (&fp +1);
    else
        myfp = (struct machframe *) handy->i;
	
    if((int ***)myfp <= &fp) error("int:showstack illegal stack value",FALSE);
    while(myfp > 0)
    {
        if( (myfp->pc > eval  &&  		/* interpreted code */
            myfp->pc < popnames)
	    ||
	    (myfp->pc > Ifuncal &&		/* compiled code */
	    myfp->pc < Lfuncal)  )
        {
	    {
		handy = (lispval)(myfp->fp->ap[0]);	/* arg to eval */

		protect(retval=newdot());
		retval->d.car = handy;
		if(myfp > myfp->fp)
		    myfp = 0;	/* end of frames */
		else
		    myfp = myfp->fp;
		retval->d.cdr = inewint(myfp);
		return(retval);
	    }
	}
	if(myfp > myfp->fp)
	     myfp = 0;	/* end of frames */
	else
	     myfp = myfp->fp;

    }
    return(nil);
}
#include "frame.h"
/*
 * this code is very similar to ftolsp.
 * if it gets revised, so should this.
 */
lispval
dothunk(func,count)
lispval func;
long count;
{
	register long *arglist = (& count) + 3;
	lispval save;
	pbuf pb;
	Savestack(1);

	if(errp->class==F_TO_FORT)
		np = errp->svnp;
	errp = Pushframe(F_TO_LISP,nil,nil);
	lbot = np;
	np++->val = func;
	for(; count > 0; count--)
		np++->val = inewint(*arglist++);
	save = Lfuncal();
	errp = Popframe();
	Restorestack();
	return(save);
}
/*
_thcpy:
	movl	sp@,a0
	movl	a0@+,sp@-
	movl	a0@+,sp@-
	jsr	_dothunk
	lea	sp@(12),sp
	rts*/
static char fivewords[] = "01234567890123456789";

lispval
Lmkcth()
{
	register struct argent *mylbot = lbot;
	register struct thunk {
		short	nop;
		short 	jsri;
		char	*thcpy;
		long	count;
		lispval func;
	} *th;
	long handy = (long) pinewstr(fivewords);
	extern char thcpy[];

	chkarg(2,"make-c-thunk");
	handy = ((handy - 1 ) | 3) + 1;
	th = (struct thunk *) handy;
	th->nop = 0x4e71;
	th->jsri = 0x4eb9;
	th->thcpy = thcpy;
	th->func = mylbot->val;
	th->count = mylbot[1].val->i;

	return((lispval)th);
}
EndOfFile
cat >  franz/68k/adbig.c  << 'EndOfFile'
/*
 * $Header: adbig.c,v 1.2 83/11/26 12:12:37 sklower Exp $
 * $Locker:  $
 *
 * Copyright (c) 1982, Regents, University of California
 *
 */
#include "global.h"

struct s_dot	{ long I; struct s_dot *CDR; };
struct vl	{ long high; long low; };

struct s_dot *adbig(a,b)
struct s_dot *a, *b;
{
	int la = 1, lb = 1;
	long *sa, *sb, *sc, *base, *alloca();
	struct s_dot *export();
	register struct s_dot *p;
	register int *q, *r, *s;
	register carry = 0;
	Keepxs();

	/* compute lengths */
	
	for(p = a; p->CDR; p = p->CDR) la++;
	for(p = b; p->CDR; p = p->CDR) lb++;
	if(lb > la) la = lb;

	/* allocate storage areas on the stack */

	base = alloca((3*la+1)*sizeof(long));
	sc = base + la +1;
	sb = sc + la;
	sa = sb + la;
	q  = sa;

	/* copy s_dots onto stack */
	p = a;
	do { *--q = p->I; p = p->CDR; } while (p);
	while(q > sb) *--q = 0;
	p = b;
	do { *--q = p->I; p = p->CDR; } while (p);
	while(q > sc) *--q = 0;

	/* perform the addition */
	for(q = sa, r = sb, s = sc; q > sb;)
	{
		carry += *--q + *--r;
		*--s = carry & 0x3fffffff;
		carry >>= 30;
	}
	*--s = carry;

	p = export(sc,base);
	Freexs();
	return(p);
}
EndOfFile
cat >  franz/68k/calqhat.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */
struct vl	{ long high; long low; };
calqhat(uj,v1)
register long *uj, *v1;
{
	struct vl work1, work2;
	register handy, handy2;
	register qhat, rhat;
	char err;
	if(*v1==*uj) {
		/* set qhat to b-1
		 * rhat is easily calculated since if we substite b-1
		 * for qhat in the formula below, one gets (u[j+1] + v[1])
		 */
		 qhat = 0x3fffffff;
		 rhat = uj[1] + *v1;
	} else {
		/* work1 = u[j]b + u[j+1]; */
		handy2 = uj[1];
		handy = *uj;
		if(handy & 1) handy2 |= 0x40000000;
		if(handy & 2) handy2 |= 0x80000000;
		handy >>= 2;
		work1.low = handy2; work1.high = handy;
		qhat = ediv(&work1,*v1,&err);
		/* rhat = work1 - qhat*v[1]; */
		rhat = work1.high;
	}
again:
	/* check if v[2]*qhat > rhat*b+u[j+2] */
	emul(qhat,v1[1],0,&work1);
	/* work2 = rhat*b+u[j+2]; */
	{ handy2 = uj[2]; handy = rhat;
	if(handy & 1) handy2 |= 0x40000000;
	if(handy & 2) handy2 |= 0x80000000;
	handy >>= 2; work2.low = handy2; work2.high = handy; }
	vlsub(&work1,&work2);
	if(work1.high <= 0) return(qhat);
	qhat--; rhat += *v1;
	goto again;
}
EndOfFile
cat >  franz/68k/dodiv.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */

struct sdot	{ long I; struct sdot *CDR; };
struct vl	{ long high; long low; };

long dodiv(top,bottom)
long *top, *bottom; /* top least significant; bottom most */
{
	struct vl work;
	char error;
	long rem = 0, ediv();
	register long *p = bottom;

	for(;p <= top;p++)
	{
		emul(0x40000000,rem,*p,&work);
		*p = ediv(&work,1000000000,&error);
		rem = work.high;
	}
	return(rem);
}

long dsneg(top,bottom)
long *top, *bottom;
{
	register long *p = top;
	register carry = 0;
	register digit;

	while(p >= bottom)
	{
		digit = carry - *p;
		/* carry = digit >> 30; is slow on 68K */
		if(digit < 0) carry = -2;
		if(digit & 0x40000000) carry += 1;
		*p-- = digit & 0x3fffffff;
	}
}


EndOfFile
cat >  franz/68k/dsmult.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */
/*
 * $Header $
 *
 * dsmult(top,bot,mul) --
 * multiply an array of longs on the stack, by mul.
 * the element top through bot (inclusive) get changed.
 * if you expect a carry out of the most significant,
 * it is up to you to provide a space for it to overflow.
 */

struct vl	{ long high; long low; };
dsmult(top,bot,mul)
long *top, *bot, mul;
{
	register long *p;
	struct vl work;
	long add = 0;

	for(p = top; p >= bot; p--) {
		emul(*p,mul,add,&work); /* *p has 30 bits of info, mul has 32
					   yielding a 62 bit product. */
		*p = work.low & 0x3fffffff; /* the stack gets the low 30 bits */
		add = work.high;        /* we want add to get the next 32 bits.
					   on a 68k you might better be able to
					   do this by shifts and tests on the
					   carry but I don't know how to do this
					   from C, and the code generated here
					   will not be much worse.  Far less
					   bad than shifting work.low to the
					   right 30 bits just to get the top 2.
					   */
		add <<= 2;
		if(work.low < 0) add += 2;
		if(work.low & 0x40000000) add += 1;
	}
	p[1] = work.low;  /* on the final store want all 32 bits. */
}
EndOfFile
cat >  franz/68k/exarith.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */
struct vl	{ long high; long low; };

/*
 * $Header $
 * exarith(mul1,mul2,add,hi,lo)
 *
 * (hi,lo) gets 64 bit product + sum of mul1*mul2+add;
 * routine returns non-zero if product is bigger than 30 bits
 */

long exarith(mul1,mul2,add,hi,lo)
long *hi, *lo;
register long add;
{
	struct vl work;
	register long rlo;

	    emul(mul1,mul2,add,&work);
	    add = work.high;
	    add <<= 2;
	    if((rlo = work.low) < 0) add += 2;
	    if(rlo & 0x40000000) add += 1;
	    *lo = rlo &0x3fffffff;
	    (*hi = add);
	    if((add==0) || (add!=-1)) return(add);
	    *lo = rlo;
	    return(0);
}
EndOfFile
cat >  franz/68k/fixbits.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */
fixbits(from,to)
register char *from, *to;
{
	register char save;
	
	while(from <= to) {
		save = from[3];
		from[3] = from[0];
		from[0] = save;
		save = from[2];
		from[2] = from[1];
		from[1] = save;
		from += 4;
	}
}
EndOfFile
cat >  franz/68k/inewint.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */

extern int Fixzero[];
int *inewint(n)
{
	register int *ip;
	int *newint();
	if(n < 1024 && n >= -1024) return (Fixzero+n);
	ip = newint();
	*ip = n;
	return(ip);
}
blzero(where,howmuch)
register char *where;
{
	register char *p;
	for(p = where + howmuch; p > where; ) *--p = 0;
}
EndOfFile
cat >  franz/68k/mlsb.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */

struct vl	{ long high; long low; };
long
mlsb(utop,ubot,vtop,nqhat)
register long *utop, *ubot, *vtop;
register nqhat;
{
	register handy, carry;
	struct vl work;
	
	for(carry = 0; utop >= ubot; utop--) {
		emul(nqhat,*--vtop,carry+*utop,&work);
		carry = work.high;
		handy = work.low;
		*utop = handy & 0x3fffffff;
		carry <<= 2;
		if(handy & 0x80000000) carry += 2;
		if(handy & 0x40000000) carry += 1;
	}
	return(carry);
}
long
adback(utop,ubot,vtop)
register long *utop, *ubot, *vtop;
{
	register handy, carry;
	carry = 0;
	for(; utop >= ubot; utop--) {
		carry += *--vtop;
		carry += *utop;
		*utop = carry & 0x3fffffff;
		/* next junk is faster version of  carry >>= 30; */
		handy = carry;
		carry = 0;
		if(handy & 0x80000000) carry -= 2;
		if(handy & 0x40000000) carry += 1;
	}
	return(carry);
}
long dsdiv(top,bot,div)
register long *top, *bot;
register long div;
{
	struct vl work; char err;
	register long handy, carry = 0;
	for(carry = 0;bot <= top; bot++) {
		handy = *bot;
		if(carry & 1) handy |= 0x40000000;
		if(carry & 2) handy |= 0x80000000;
		carry >>= 2;
		work.low = handy;
		work.high = carry;
		*bot = ediv(&work,div,&err);
		carry = work.high;
	}
	return(carry);
}
dsadd1(top,bot)
long *top, *bot;
{
	register long *p, work, carry = 0;

	/*
	 * this assumes canonical inputs
	 */
	for(p = top; p >= bot; p--) {
		work = *p + carry;
		*p = work & 0x3fffffff;
		carry = 0;
		if (work & 0x40000000) carry += 1;
		if (work & 0x80000000) carry -= 2;
	}
	p[1] = work;
}
long
dsrsh(top,bot,ncnt,mask1)
long *top, *bot;
long ncnt, mask1;
{
	register long *p = bot;
	register r = -ncnt, l = 30+ncnt, carry = 0, work, save;
	long mask = -1 ^ mask1;

	while(p <= top) {
		save = work = *p; save &= mask; work >>= r;
		carry <<= l; work |= carry; *p++ = work;
		carry = save;
	}
	return(carry);
}
EndOfFile
cat >  franz/68k/mulbig.c  << 'EndOfFile'
/*
 * $Header: mulbig.c,v 1.2 83/11/26 12:13:29 sklower Exp $
 * $Locker:  $
 *
 * Copyright (c) 1982, Regents, University of California
 *
 */

#include "global.h"

struct s_dot	{ long I; struct s_dot *CDR; };
struct vl	{ long high; long low; };

struct s_dot *mulbig(a,b)
struct s_dot *a, *b;
{
	int la = 1, lb = 1;
	long *sa, *sb, *sc, *base, *alloca();
	struct s_dot *export();
	register struct s_dot *p;
	register int *q, *r, *s;
	long carry = 0, test;
	struct vl work;
	Keepxs();

	/* compute lengths */
	
	for(p = a; p->CDR; p = p->CDR) la++;
	for(p = b; p->CDR; p = p->CDR) lb++;

	/* allocate storage areas on the stack */

	base = alloca((la + la + lb + lb + 1)*sizeof(long));
	sc = base + la + lb + 1;
	sb = sc + lb;
	sa = sb + la;
	q  = sa;

	/* copy s_dots onto stack */
	p = a;
	do { *--q = p->I; p = p->CDR; } while (p);
	p = b;
	do { *--q = p->I; p = p->CDR; } while (p);
	while(q > base) *--q = 0;  /* initialize target */

	/* perform the multiplication */
	for(q = sb; q > sc; *--s = carry)
	    for((r = sa, s = (q--) - lb, carry = 0); r > sb;)
	    {
		    carry += *--s;
		    emul(*q,*--r,carry,&work);
		    test = work.low;
		    carry = work.high << 2;
		    if(test < 0) carry += 2;
		    if(test & 0x40000000) carry +=1;
		    *s = test & 0x3fffffff;
	    }

	p = export(sc,base);
	Freexs();
	return(p);
}
EndOfFile
cat >  franz/68k/nargs.c  << 'EndOfFile'
/* Copyright (c) 1982, Regents, University of California */
#define ADDQ 5
#define ADD 13
#define IMMED 074
/* These structures are here for looks, only */
struct add { short op:4, reg:3, mode:3, ea:6; } x;
struct addq { short op:4, data:3, size:3, ea:6; } y;
nargs(arg)
long arg; /* this is only here for address calculation */
{
	register long *a5;
	register handy;
	register char reg, mode, ea;
#define size mode
#define data reg

	a5 = (&arg) - 2; /* this points to old a6 */
	a5 = (long *) *a5; /* a5 now = my parents a6 */
	a5 = (long *) a5[1]; /* pick up return address into a5 */

	handy = * (short *)a5;
	ea = handy & 077; handy >>= 6;
	mode = handy & 07; handy >>= 3;
	reg = handy & 07; handy >>= 3;
	/* op = handy & 017; */
	switch(handy & 017) {
	case ADD:
		if(reg!=7)
			return(0); /* this instruction doesn't adjust the sp */
		if(ea!=IMMED)
			return(0); /* too hard to decode adjustment */
		handy = (long) (1 + (short *) a5);
		if(mode==03) {  /* addw #n,a7 */
			handy = *(short *)handy;
			return(handy >> 2);
		}
		if(mode==07) { /* addl #n,a7 */
			handy = *(long *)handy;
			return(handy >> 2);
		}
		else return(0); /* this was doing something to d7 */
	case ADDQ:
		if(ea!=017)
			return(0); /* this doesn't adjust a7 */
		if(size!=02)
			return(0); /* should complain -- we are doing
				      addq[bw] something,a7 */
		switch(data) {
		case 0: return(2);
		case 4: return(1);
		}
	}
	return(0);
}
EndOfFile
cat >  franz/68k/suncore.c  << 'EndOfFile'
/*
 *$Header: qfuncl.c,v 1.9 84/02/29 17:23:24 sklower Exp $
 *$Locker:  $
 *
 * Copyright (c) 1982, by the Regents, University of California
 *
 *			-[Tue Apr 10 08:32:07 1984 by jkf]-
 *
 * Interface to sun core graphics.
 *
 * 
 * 
 *
 */

int inquire_detectability();
int set_detectability();
int inquire_highlighting();
int set_highlighting();
int inquire_image_transformation_2();
int set_image_transformation_2();
int inquire_image_transformation_3();
int set_image_transformation_3();
int inquire_visibility();
int set_visibility();
int inquire_image_translate_2();
int set_image_translate_2();
int inquire_image_translate_3();
int set_image_translate_3();
int print_error();
int report_most_recent_error();
int initialize_core();
int terminate_core();
int set_pick_id();
int set_charup_2();
int set_charup_3();
int set_charjust();
int define_color_indices();
int set_primitive_attributes();
int set_marker_symbol();
int set_text_index();
int set_fill_index();
int set_rasterop();
int set_polygon_edge_style();
int set_linestyle();
int set_charspace();
int set_line_index();
int set_drag();
int set_polygon_interior_style();
int set_charsize();
int set_charprecision();
int set_charpath_2();
int set_linewidth();
int set_charpath_3();
int set_font();
int set_pen();
int inquire_pick_id();
int inquire_charup_2();
int inquire_charup_3();
int inquire_charjust();
int inquire_color_indices();
int inquire_primitive_attributes();
int inquire_marker_symbol();
int inquire_text_index();
int inquire_fill_index();
int inquire_rasterop();
int inquire_polygon_edge_style();
int inquire_linestyle();
int inquire_charspace();
int inquire_line_index();
int inquire_pen();
int inquire_polygon_interior_style();
int inquire_font();
int inquire_charsize();
int inquire_charprecision();
int inquire_charpath_2();
int inquire_linewidth();
int inquire_charpath_3();
int terminate_view_surface();
int deselect_view_surface();
int select_view_surface();
int initialize_view_surface();
int polymarker_abs_2();
int marker_abs_2();
int polymarker_abs_3();
int marker_abs_3();
int polymarker_rel_2();
int marker_rel_2();
int polymarker_rel_3();
int marker_rel_3();
int text();
int inquire_text_extent_2();
int inquire_text_extent_3();
int inquire_current_position_2();
int polyline_abs_2();
int move_abs_2();
int line_abs_2();
int polyline_rel_2();
int move_rel_2();
int line_rel_2();
int inquire_current_position_3();
int polyline_abs_3();
int move_abs_3();
int line_abs_3();
int polyline_rel_3();
int move_rel_3();
int line_rel_3();
int set_echo();
int await_pick();
int await_stroke_2();
int await_any_button();
int set_valuator();
int await_any_button_get_valuator();
int set_echo_surface();
int set_echo_position();
int set_stroke();
int set_locator_2();
int await_any_button_get_locator_2();
int set_echo_group();
int get_mouse_state();
int terminate_device();
int initialize_device();
int set_keyboard();
int await_keyboard();
int inquire_valuator();
int inquire_echo_surface();
int inquire_echo_position();
int inquire_locator_2();
int inquire_stroke();
int inquire_echo();
int inquire_keyboard();
int polygon_abs_2();
int polygon_rel_2();
int set_vertex_indices();
int polygon_abs_3();
int polygon_rel_3();
int set_shading_parameters();
int set_light_direction();
int set_vertex_normals();
int get_raster();
int put_raster();
int free_raster();
int allocate_raster();
int size_raster();
int raster_to_file();
int file_to_raster();
int set_zbuffer_cut();
int delete_all_retained_segments();
int rename_retained_segment();
int delete_retained_segment();
int set_image_transformation_type();
int close_retained_segment();
int close_temporary_segment();
int create_temporary_segment();
int create_retained_segment();
int inquire_segment_image_transformation_3();
int set_segment_image_transformation_3();
int inquire_segment_image_translate_3();
int set_segment_image_translate_3();
int set_segment_detectability();
int set_segment_highlighting();
int set_segment_image_transformation_2();
int set_segment_visibility();
int set_segment_image_translate_2();
int inquire_segment_detectability();
int inquire_segment_highlighting();
int inquire_segment_image_transformation_type();
int inquire_image_transformation_type();
int inquire_segment_image_transformation_2();
int inquire_segment_visibility();
int inquire_segment_image_translate_2();
int inquire_view_plane_normal();
int inquire_view_depth();
int inquire_retained_segment_names();
int inquire_viewing_control_parameters();
int inquire_viewing_parameters();
int inquire_projection();
int inquire_world_coordinate_matrix_2();
int inquire_world_coordinate_matrix_3();
int inquire_retained_segment_surfaces();
int inquire_ndc_space_2();
int inquire_ndc_space_3();
int inquire_view_reference_point();
int inquire_view_plane_distance();
int inquire_inverse_composite_matrix();
int inquire_viewport_2();
int inquire_viewport_3();
int inquire_window();
int inquire_view_up_2();
int inquire_view_up_3();
int inquire_open_temporary_segment();
int inquire_open_retained_segment();
int end_batch_of_updates();
int begin_batch_of_updates();
int new_frame();
int restore_segment();
int save_segment();
int set_view_plane_normal();
int set_view_depth();
int set_viewing_parameters();
int set_projection();
int set_window();
int set_ndc_space_2();
int set_ndc_space_3();
int set_view_reference_point();
int set_view_plane_distance();
int set_viewport_2();
int set_viewport_3();
int set_view_up_2();
int set_view_up_3();
int map_world_to_ndc_2();
int map_world_to_ndc_3();
int map_ndc_to_world_2();
int map_ndc_to_world_3();
int set_world_coordinate_matrix_2();
int set_world_coordinate_matrix_3();
int set_back_plane_clipping();
int set_front_plane_clipping();
int set_window_clipping();
int set_output_clipping();
int set_coordinate_system_type();

static char *disc = "c-function";
static struct cftab {
	char *name;
	int (*cfn)();
	char **discipline;
} corefuns[] = {
{"_inquire_detectability", inquire_detectability, &disc},
{"_set_detectability", set_detectability, &disc},
{"_inquire_highlighting", inquire_highlighting, &disc},
{"_set_highlighting", set_highlighting, &disc},
{"_inquire_image_transformation_2", inquire_image_transformation_2, &disc},
{"_set_image_transformation_2", set_image_transformation_2, &disc},
{"_inquire_image_transformation_3", inquire_image_transformation_3, &disc},
{"_set_image_transformation_3", set_image_transformation_3, &disc},
{"_inquire_visibility", inquire_visibility, &disc},
{"_set_visibility", set_visibility, &disc},
{"_inquire_image_translate_2", inquire_image_translate_2, &disc},
{"_set_image_translate_2", set_image_translate_2, &disc},
{"_inquire_image_translate_3", inquire_image_translate_3, &disc},
{"_set_image_translate_3", set_image_translate_3, &disc},
{"_print_error", print_error, &disc},
{"_report_most_recent_error", report_most_recent_error, &disc},
{"_initialize_core", initialize_core, &disc},
{"_terminate_core", terminate_core, &disc},
{"_set_pick_id", set_pick_id, &disc},
{"_set_charup_2", set_charup_2, &disc},
{"_set_charup_3", set_charup_3, &disc},
{"_set_charjust", set_charjust, &disc},
{"_define_color_indices", define_color_indices, &disc},
{"_set_primitive_attributes", set_primitive_attributes, &disc},
{"_set_marker_symbol", set_marker_symbol, &disc},
{"_set_text_index", set_text_index, &disc},
{"_set_fill_index", set_fill_index, &disc},
{"_set_rasterop", set_rasterop, &disc},
{"_set_polygon_edge_style", set_polygon_edge_style, &disc},
{"_set_linestyle", set_linestyle, &disc},
{"_set_charspace", set_charspace, &disc},
{"_set_line_index", set_line_index, &disc},
{"_set_drag", set_drag, &disc},
{"_set_polygon_interior_style", set_polygon_interior_style, &disc},
{"_set_charsize", set_charsize, &disc},
{"_set_charprecision", set_charprecision, &disc},
{"_set_charpath_2", set_charpath_2, &disc},
{"_set_linewidth", set_linewidth, &disc},
{"_set_charpath_3", set_charpath_3, &disc},
{"_set_font", set_font, &disc},
{"_set_pen", set_pen, &disc},
{"_inquire_pick_id", inquire_pick_id, &disc},
{"_inquire_charup_2", inquire_charup_2, &disc},
{"_inquire_charup_3", inquire_charup_3, &disc},
{"_inquire_charjust", inquire_charjust, &disc},
{"_inquire_color_indices", inquire_color_indices, &disc},
{"_inquire_primitive_attributes", inquire_primitive_attributes, &disc},
{"_inquire_marker_symbol", inquire_marker_symbol, &disc},
{"_inquire_text_index", inquire_text_index, &disc},
{"_inquire_fill_index", inquire_fill_index, &disc},
{"_inquire_rasterop", inquire_rasterop, &disc},
{"_inquire_polygon_edge_style", inquire_polygon_edge_style, &disc},
{"_inquire_linestyle", inquire_linestyle, &disc},
{"_inquire_charspace", inquire_charspace, &disc},
{"_inquire_line_index", inquire_line_index, &disc},
{"_inquire_pen", inquire_pen, &disc},
{"_inquire_polygon_interior_style", inquire_polygon_interior_style, &disc},
{"_inquire_font", inquire_font, &disc},
{"_inquire_charsize", inquire_charsize, &disc},
{"_inquire_charprecision", inquire_charprecision, &disc},
{"_inquire_charpath_2", inquire_charpath_2, &disc},
{"_inquire_linewidth", inquire_linewidth, &disc},
{"_inquire_charpath_3", inquire_charpath_3, &disc},
{"_terminate_view_surface", terminate_view_surface, &disc},
{"_deselect_view_surface", deselect_view_surface, &disc},
{"_select_view_surface", select_view_surface, &disc},
{"_initialize_view_surface", initialize_view_surface, &disc},
{"_polymarker_abs_2", polymarker_abs_2, &disc},
{"_marker_abs_2", marker_abs_2, &disc},
{"_polymarker_abs_3", polymarker_abs_3, &disc},
{"_marker_abs_3", marker_abs_3, &disc},
{"_polymarker_rel_2", polymarker_rel_2, &disc},
{"_marker_rel_2", marker_rel_2, &disc},
{"_polymarker_rel_3", polymarker_rel_3, &disc},
{"_marker_rel_3", marker_rel_3, &disc},
{"_text", text, &disc},
{"_inquire_text_extent_2", inquire_text_extent_2, &disc},
{"_inquire_text_extent_3", inquire_text_extent_3, &disc},
{"_inquire_current_position_2", inquire_current_position_2, &disc},
{"_polyline_abs_2", polyline_abs_2, &disc},
{"_move_abs_2", move_abs_2, &disc},
{"_line_abs_2", line_abs_2, &disc},
{"_polyline_rel_2", polyline_rel_2, &disc},
{"_move_rel_2", move_rel_2, &disc},
{"_line_rel_2", line_rel_2, &disc},
{"_inquire_current_position_3", inquire_current_position_3, &disc},
{"_polyline_abs_3", polyline_abs_3, &disc},
{"_move_abs_3", move_abs_3, &disc},
{"_line_abs_3", line_abs_3, &disc},
{"_polyline_rel_3", polyline_rel_3, &disc},
{"_move_rel_3", move_rel_3, &disc},
{"_line_rel_3", line_rel_3, &disc},
{"_set_echo", set_echo, &disc},
{"_await_pick", await_pick, &disc},
{"_await_stroke_2", await_stroke_2, &disc},
{"_await_any_button", await_any_button, &disc},
{"_set_valuator", set_valuator, &disc},
{"_await_any_button_get_valuator", await_any_button_get_valuator, &disc},
{"_set_echo_surface", set_echo_surface, &disc},
{"_set_echo_position", set_echo_position, &disc},
{"_set_stroke", set_stroke, &disc},
{"_set_locator_2", set_locator_2, &disc},
{"_await_any_button_get_locator_2", await_any_button_get_locator_2, &disc},
{"_set_echo_group", set_echo_group, &disc},
{"_get_mouse_state", get_mouse_state, &disc},
{"_terminate_device", terminate_device, &disc},
{"_initialize_device", initialize_device, &disc},
{"_set_keyboard", set_keyboard, &disc},
{"_await_keyboard", await_keyboard, &disc},
{"_inquire_valuator", inquire_valuator, &disc},
{"_inquire_echo_surface", inquire_echo_surface, &disc},
{"_inquire_echo_position", inquire_echo_position, &disc},
{"_inquire_locator_2", inquire_locator_2, &disc},
{"_inquire_stroke", inquire_stroke, &disc},
{"_inquire_echo", inquire_echo, &disc},
{"_inquire_keyboard", inquire_keyboard, &disc},
{"_polygon_abs_2", polygon_abs_2, &disc},
{"_polygon_rel_2", polygon_rel_2, &disc},
{"_set_vertex_indices", set_vertex_indices, &disc},
{"_polygon_abs_3", polygon_abs_3, &disc},
{"_polygon_rel_3", polygon_rel_3, &disc},
{"_set_shading_parameters", set_shading_parameters, &disc},
{"_set_light_direction", set_light_direction, &disc},
{"_set_vertex_normals", set_vertex_normals, &disc},
{"_get_raster", get_raster, &disc},
{"_put_raster", put_raster, &disc},
{"_free_raster", free_raster, &disc},
{"_allocate_raster", allocate_raster, &disc},
{"_size_raster", size_raster, &disc},
{"_raster_to_file", raster_to_file, &disc},
{"_file_to_raster", file_to_raster, &disc},
{"_set_zbuffer_cut", set_zbuffer_cut, &disc},
{"_delete_all_retained_segments", delete_all_retained_segments, &disc},
{"_rename_retained_segment", rename_retained_segment, &disc},
{"_delete_retained_segment", delete_retained_segment, &disc},
{"_set_image_transformation_type", set_image_transformation_type, &disc},
{"_close_retained_segment", close_retained_segment, &disc},
{"_close_temporary_segment", close_temporary_segment, &disc},
{"_create_temporary_segment", create_temporary_segment, &disc},
{"_create_retained_segment", create_retained_segment, &disc},
{"_inquire_segment_image_transformation_3", inquire_segment_image_transformation_3, &disc},
{"_set_segment_image_transformation_3", set_segment_image_transformation_3, &disc},
{"_inquire_segment_image_translate_3", inquire_segment_image_translate_3, &disc},
{"_set_segment_image_translate_3", set_segment_image_translate_3, &disc},
{"_set_segment_detectability", set_segment_detectability, &disc},
{"_set_segment_highlighting", set_segment_highlighting, &disc},
{"_set_segment_image_transformation_2", set_segment_image_transformation_2, &disc},
{"_set_segment_visibility", set_segment_visibility, &disc},
{"_set_segment_image_translate_2", set_segment_image_translate_2, &disc},
{"_inquire_segment_detectability", inquire_segment_detectability, &disc},
{"_inquire_segment_highlighting", inquire_segment_highlighting, &disc},
{"_inquire_segment_image_transformation_type", inquire_segment_image_transformation_type, &disc},
{"_inquire_image_transformation_type", inquire_image_transformation_type, &disc},
{"_inquire_segment_image_transformation_2", inquire_segment_image_transformation_2, &disc},
{"_inquire_segment_visibility", inquire_segment_visibility, &disc},
{"_inquire_segment_image_translate_2", inquire_segment_image_translate_2, &disc},
{"_inquire_view_plane_normal", inquire_view_plane_normal, &disc},
{"_inquire_view_depth", inquire_view_depth, &disc},
{"_inquire_retained_segment_names", inquire_retained_segment_names, &disc},
{"_inquire_viewing_control_parameters", inquire_viewing_control_parameters, &disc},
{"_inquire_viewing_parameters", inquire_viewing_parameters, &disc},
{"_inquire_projection", inquire_projection, &disc},
{"_inquire_world_coordinate_matrix_2", inquire_world_coordinate_matrix_2, &disc},
{"_inquire_world_coordinate_matrix_3", inquire_world_coordinate_matrix_3, &disc},
{"_inquire_retained_segment_surfaces", inquire_retained_segment_surfaces, &disc},
{"_inquire_ndc_space_2", inquire_ndc_space_2, &disc},
{"_inquire_ndc_space_3", inquire_ndc_space_3, &disc},
{"_inquire_view_reference_point", inquire_view_reference_point, &disc},
{"_inquire_view_plane_distance", inquire_view_plane_distance, &disc},
{"_inquire_inverse_composite_matrix", inquire_inverse_composite_matrix, &disc},
{"_inquire_viewport_2", inquire_viewport_2, &disc},
{"_inquire_viewport_3", inquire_viewport_3, &disc},
{"_inquire_window", inquire_window, &disc},
{"_inquire_view_up_2", inquire_view_up_2, &disc},
{"_inquire_view_up_3", inquire_view_up_3, &disc},
{"_inquire_open_temporary_segment", inquire_open_temporary_segment, &disc},
{"_inquire_open_retained_segment", inquire_open_retained_segment, &disc},
{"_end_batch_of_updates", end_batch_of_updates, &disc},
{"_begin_batch_of_updates", begin_batch_of_updates, &disc},
{"_new_frame", new_frame, &disc},
{"_restore_segment", restore_segment, &disc},
{"_save_segment", save_segment, &disc},
{"_set_view_plane_normal", set_view_plane_normal, &disc},
{"_set_view_depth", set_view_depth, &disc},
{"_set_viewing_parameters", set_viewing_parameters, &disc},
{"_set_projection", set_projection, &disc},
{"_set_window", set_window, &disc},
{"_set_ndc_space_2", set_ndc_space_2, &disc},
{"_set_ndc_space_3", set_ndc_space_3, &disc},
{"_set_view_reference_point", set_view_reference_point, &disc},
{"_set_view_plane_distance", set_view_plane_distance, &disc},
{"_set_viewport_2", set_viewport_2, &disc},
{"_set_viewport_3", set_viewport_3, &disc},
{"_set_view_up_2", set_view_up_2, &disc},
{"_set_view_up_3", set_view_up_3, &disc},
{"_map_world_to_ndc_2", map_world_to_ndc_2, &disc},
{"_map_world_to_ndc_3", map_world_to_ndc_3, &disc},
{"_map_ndc_to_world_2", map_ndc_to_world_2, &disc},
{"_map_ndc_to_world_3", map_ndc_to_world_3, &disc},
{"_set_world_coordinate_matrix_2", set_world_coordinate_matrix_2, &disc},
{"_set_world_coordinate_matrix_3", set_world_coordinate_matrix_3, &disc},
{"_set_back_plane_clipping", set_back_plane_clipping, &disc},
{"_set_front_plane_clipping", set_front_plane_clipping, &disc},
{"_set_window_clipping", set_window_clipping, &disc},
{"_set_output_clipping", set_output_clipping, &disc},
{"_set_coordinate_system_type", set_coordinate_system_type, &disc},
{0}
};
hookupcore() {mftab(corefuns);}
EndOfFile
cat >  franz/68k/callg.s  << 'EndOfFile'
| /* Copyright (c) 1982, Regents, University of California */
        .text
        .globl  _callg_
_callg_:
        link    a6,#0
        movl    a6@(12),a0
        movl    sp,a1
        movl    a0@+,d0
        asll    #2,d0
        subl    d0,a1
        tstb    a1@
	movl	a1,sp
.L13:
        subql   #4,d0
        blt     .L14
        movl    a0@+,a1@+
        bra     .L13
.L14:
        movl    a6@(8),a0
        jsr     a0@
        unlk    a6
        rts
EndOfFile
cat >  franz/68k/dmlad.s  << 'EndOfFile'
| /* Copyright (c) 1982, Regents, University of California */
	.data
	.text
	.globl	_dmlad
_dmlad:
	link	a6,#-.F1
	tstb	sp@(-132)
	moveml	#.S1,a6@(-.F1)
	movl	a6@(12),d7
	movl	a6@(16),d6
|l 8
	movl	a6@(8),a5
|e 8
.L15:
|l 12
	pea	a6@(0xfffffff8)
	movl	d6,sp@-
	movl	d7,sp@-
	movl	a5@,sp@-
	jsr	_emul
	addl	#16,sp
|e 12
|l 13
	movl	a6@(0xfffffff8),d6
|e 13
|l 14
	asll	#2,d6
|e 14
|l 15
	tstl	a6@(0xfffffffc)
	bge	.L17
|e 15
|l 15
	addql	#2,d6
|e 15
.L17:
|l 16
	movl	a6@(0xfffffffc),d0
	asll	#1,d0
	tstl	d0
	bge	.L18
|e 16
|l 16
	addql	#1,d6
|e 16
.L18:
|l 17
	movl	a6@(0xfffffffc),d0
	andl	#0x3fffffff,d0
	movl	d0,a5@
|e 17
|l 18
	tstl	a5@(4)
	bne	.L19
|e 18
	bra	.L14
.L19:
|l 19
	movl	a5@(4),a5
|e 19
.L13:
	bra	.L15
.L14:
|l 21
	tstl	d6
	beq	.L20
|e 21
|l 24
	cmpl	#0xffffffff,d6
	bne	.L22
|e 24
|l 25
	orl	#0xc0000000,a5@
|e 25
	bra	.L23
.L22:
|l 27
	jsr	_newdot
	movl	d0,a5@(4)
	movl	a5@(4),a5
|e 27
|l 28
	movl	d6,a5@
|e 28
|l 29
	clrl	a5@(4)
|e 29
.L23:
.L20:
|l 32
	movl	a6@(8),d0
|e 32
	bra	.L12
	bra	.L12
.L12:	moveml	a6@(-.F1),#0x20c0
	unlk	a6
	rts
.F1 = 20
.S1 = 0x20c0
| end
	.data
EndOfFile
cat >  franz/68k/ediv.s  << 'EndOfFile'
| /* Copyright (c) 1982, Regents, University of California */
	.text
	.globl	_ediv
_ediv:
	link	a6,#-.F1
	tstb	sp@(-132)
	moveml	#.S1,a6@(-.F1)
	movl	a6@(8),a5
	movl	a5@,d7
	movl	a5@(4),d6
	moveq	#0,d5
	moveq	#0,d4
	movl	a6@(0xc),d3
	clrb	a6@(0xfffffffd)
	clrb	a6@(0xfffffffb)
	movl	d7,a6@(0xfffffff4)
	jge	.L13
	eorb	#1,a6@(0xfffffffd)
	negl	d6
	negxl	d7
.L13:
	tstl	d3
	jge	.L16
	eorb	#1,a6@(0xfffffffd)
	negl	d3
.L16:
	tstl	d3
	jne	.L17
	clrl	a5@
	movl	a6@(0x10),a0
	movb	#1,a0@
	movl	d6,d0
	jra	.L12
.L17:
	movw	#0x20,a6@(0xfffffffe)
	jra	.L20
.L20001:
	lsll	#1,d3
	addqw	#1,a6@(0xfffffffe)
	addql	#1,d5
.L20:
	cmpl	#0x40000000,d3
	jcs	.L20001
	cmpl	d3,d7
	jcs	.L24
	subl	d3,d7
	addql	#1,d4
	jra	.L24
.L20003:
	lsll	#1,d6
	roxll	#1,d7
	asll	#1,d4
	cmpl	d3,d7
	jcs	.L26
	subl	d3,d7
	addql	#1,d4
.L26:
	tstl	d4
	jge	.L22
	movl	a6@(0x10),a0
	movb	#1,a0@
.L22:
	subqw	#1,a6@(0xfffffffe)
.L24:
	tstw	a6@(0xfffffffe)
	jne	.L20003
	lsrl	d5,d7
	tstl	a6@(0xfffffff4)
	jge	.L28
	negl	d7
.L28:
	movl	d7,a5@
	andl	#0x7fffffff,d4
	tstb	a6@(0xfffffffd)
	jeq	.L29
	negl	d4
.L29:
	movl	d4,d0
.L12:
	moveml	a6@(-.F1),#0x20f8
	unlk	a6
	rts
.F1 = 36
.S1 = 0x20f8
| end
	.data
EndOfFile
cat >  franz/68k/emul.s  << 'EndOfFile'
| /* Copyright (c) 1982, Regents, University of California */
|
| $Header: emul.s,v 1.2 83/11/26 12:13:45 sklower Exp $
| $Locker:  $
|
	.text
	.globl	_emul
_emul:
	link	a6,#-_F1
	moveml	#_S1,a6@(-_F1)
	movl	a6@(20),a5
| A1 = 24
	clrb	a6@(-9)
	clrb	a6@(-13)
	clrl	d7
	tstl	a6@(8)
	bge	.L13
	eorb	#1,a6@(-9)
	negl	a6@(8)
.L13:
	tstl	a6@(12)
	bge	.L14
	eorb	#1,a6@(-9)
	negl	a6@(12)
.L14:
	movw	a6@(10),d1
	mulu	a6@(14),d1
	movl	d1,a6@(-4)
	movw	a6@(8),d1
	mulu	a6@(12),d1
	movl	d1,a6@(-8)
	movw	a6@(8),d1
	mulu	a6@(14),d1
	addl	d1,a6@(-6)
	bcc	.L16
	addqw	#1,a6@(-8)
.L16:
	movw	a6@(10),d1
	mulu	a6@(12),d1
	addl	d1,a6@(-6)
	bcc	.L17
	addqw	#1,a6@(-8)
.L17:
	tstb	a6@(-9)
	beq	.L18
	negl	a6@(-4)
	negxl	a6@(-8)
.L18:
	tstl	a6@(16)
	bge	.L20
	moveq	#-1,d7
.L20:
	movl	a6@(-8),d1
	movl	a6@(16),d0
	addl	a6@(-4),d0
	addxl	d1,d7
	movl	d0,a5@(4)
	movl	d7,a5@
.L12:	moveml	a6@(-_F1),#8320
	unlk	a6
	rts
_F1 = 24
_S1 = 8320
| M1 = 0
EndOfFile
cat >  franz/68k/hack.s  << 'EndOfFile'
| /* Copyright (c) 1982, Regents, University of California */
	.text
	.globl	_stack
_stack:
	movl	sp@,a0
	jmp	a0@
	.globl	_unstack
_unstack:
	movl	sp@+,a0
	movl	sp@+,d0
	jmp	a0@
	.globl	_sp
_sp:
	movl	sp@+,a0
	movl	sp,d0
	jmp	a0@
EndOfFile
cat >  franz/68k/qfuncl.c  << 'EndOfFile'
/*
 *$Header: qfuncl.c,v 1.9 84/02/29 17:23:24 sklower Exp $
 *$Locker:  $
 *
 * Copyright (c) 1982, by the Regents, University of California
 *
 *			-[Tue Mar 22 15:42:27 1983 by layer]-
 *
 * "quick" functions file.
 *
 * This is written in assembler but must be passed through the C preprocessor
 * before being assembled.
 *
 */

#include "ltypes.h"
#include "config.h"
 
/* important offsets within data types for atoms */
#define Atomfnbnd 8

/*  for arrays */
#define Arrayaccfun 0

/* register defines */
#define FIXREG	d2

#ifdef NPINREG
#define _np a2
#define _lbot d3
#endif


#ifdef PROF
	.set	indx,0
#define Profile \
	lea	prbuf+indx,a0 \
	.set 	indx,indx+4 \
	jsr 	mcount 
#define Profile2 \
	movl	a0,sp@-
	lea	prbuf+indx,a0 \
	.set 	indx,indx+4 \
	jsr 	mcount 
	movl	sp@+,a0
#else
#define Profile
#define Profile2
#endif

#ifdef PORTABLE
#define	NILtest(p)	cmpl	#/**/OFFSET,p
#define	NILsub(p)	subl	#/**/OFFSET,p
#else
#define NILtest(p)
#define NILsub(p)
#endif


	.text
	
/*   transfer  table linkage routine  */
	.globl	_qlinker
_qlinker:
	Profile
	link	a6,#-28
	tstb	sp@(-132)
	moveml	#036000,a6@(-28)		|a(2,3,4,5)

	tstl	_exception	        	|any pending exceptions
	jeq	noexc
	tstl	_sigintcnt			|is it because of SIGINT
	jeq	noexc				|if not, just leave
	movl	#2,sp@-				|else push SIGINT
	jsr	_sigcall
noexc:
	movl	a6@(4),a4			|get return pc
	movl	a4@(-6),a4			|get pointer to table
	movl	a4@(4),a5			|get atom pointer
retry:						|come here after undeffunc err
	movl	a5@(8),a0			|get function binding
	cmpl	a0,d7				|if nil,
	jeq	nonex				|then leave
	tstl	2*4+_stattab			|see if linkin posble (Strans)
	jeq	nolink				|no, it isn't
	movl	a0,d0				|check type of function
	NILsub(d0)
	moveq	#9,d1
	asrl	d1,d0
	lea	_typetable+1,a3
	movb	a3@(0,d0:L),d1
	cmpb	#/**/BCD,d1
	jeq	linkin				|bcd, link it in!
	cmpb	#/**/ARRAY,d1			|how about array?
	jeq	doarray				|yep

nolink:
	movl	a5,sp@-				|non, bcd, call interpreter
	jsr	_Ifuncal
	moveml	a6@(-28),#036000
	unlk	a6
	rts

/*
 * handle arrays by pushing the array descriptor on the table and checking
 * for a bcd array handler
 */
doarray:
	movl	a0@(Arrayaccfun),d0		|get access func addr shifted
	NILsub(d0)
	movl	#9,d1
	asrl	d1,d0
	lea	_typetable+1,a3
	cmpb	#/**/BCD,a3@(0,d0:L)		|bcd??
	jne	nolink				|no, let funcal handle it
	movl	a0,a2@+				|store array header on stack
	movl	a2,_np
	movl	a0@,a0				|movl *(a0),a0 on VAX
	movl	a0@,a0
	jsr	a0@
	subql	#4,_np
	moveml	a6@(-28),#036000
	unlk	a6
	rts
	
	
linkin:	
	movl	a0@(4),d0			|check type of function discipline
	NILsub(d0)
	movl	#9,d1
	asrl	d1,d0
	lea	_typetable+1,a3
	cmpb	#/**/STRNG,a3@(0,d0:L)		|is it string?
	jeq	nolink				|yes, it is a c call,
						|so dont link in
	movl	a0@,a0				|get function addr
	movl	a0,a4@				|put fcn addr in table
	jbsr	a0@
	moveml	a6@(-28),#036000
	unlk	a6
	rts


nonex:	movl	a4,sp@-				|preserve table address
	movl	a5,sp@-				|non existant fcn
	jsr	_Undeff				|call processor
	movl	d0,a5				|back in r1
	addql	#4,sp
	movl	sp@+,a4				|restore table address
	jra	retry				|for the retry.


	.data
	.globl	__erthrow
__erthrow: 
	.asciz	"Uncaught throw from compiled code"
	.text

	.globl _tynames
_tynames:
	.long	_nilatom			|nothing here
	.long	20*4+_lispsys			|str_name
	.long	21*4+_lispsys			|atom_name
	.long	19*4+_lispsys			|int_name
	.long	23*4+_lispsys			|dtpr_name
	.long	22*4+_lispsys			|doub_name
	.long	58*4+_lispsys			|funct_name
	.long	103*4+_lispsys			|port_name
	.long	47*4+_lispsys			|array_name
	.long	_nilatom			|nothing here
	.long	50*4+_lispsys			|sdot_name
	.long	53*4+_lispsys			|val_nam

	.long	_nilatom			| hunk2_nam
	.long	_nilatom			| hunk4_nam
	.long	_nilatom			| hunk8_nam
	.long	_nilatom			| hunk16_nam
	.long	_nilatom			| hunk32_nam
	.long	_nilatom			| hunk64_nam
	.long	_nilatom			| hunk128_nam
	.long	124*4+_lispsys			|vector_nam
	.long	125*4+_lispsys			|vectori_nam

/*	Quickly allocate small fixnums  */

	.globl	_qnewint
_qnewint:
	Profile
	cmpl	#1024,FIXREG
	bge	alloc
	cmpl	#-1024,FIXREG
	bmi	alloc
	movl	FIXREG,d0
	asll	#2,d0
	addl	#_Fixzero,d0
	rts
alloc:
	movl	_int_str,a0			|move next cell addr to r0
	NILtest(a0)
	jmi	callnewi			|if no space, allocate
	movl	4*24+_lispsys,a1
	addql	#1,a1@				|inc count of ints
	movl	a0@,_int_str			|advance free list
	movl	FIXREG,a0@			|put baby to bed.
	movl	a0,d0
	rts
callnewi:
	movl	FIXREG,sp@-
	movl	a2,_np				|gc could occur
	movl	a2,_lbot
	jsr	_newint
	movl	d0,a0
	movl	sp@+,a0@
	rts

/*  _qoneplus adds one to the boxed fixnum in r0
 * and returns a boxed fixnum.
 */

	.globl	_qoneplus
_qoneplus:
	Profile
	movl	a0@,FIXREG
	addql	#1,FIXREG
	bra	_qnewint

/* _qoneminus  subtracts one from the boxes fixnum in r0 and returns a
 * boxed fixnum
 */
	.globl	_qoneminus
_qoneminus:
	Profile
	movl	a0@,FIXREG
	subql	#1,FIXREG
	bra	_qnewint

/*
 *	_qnewdoub quick allocation of a initialized double (float) cell.
 *	This entry point is required by the compiler for symmetry reasons.
 *	Passed to _qnewdoub in d0,d1 is a double precision floating point
 *	number.  This routine allocates a new cell, initializes it with
 *	the given value and then returns the cell.
 */

	.globl	_qnewdoub
    
_qnewdoub:
	Profile
	movl	_doub_str,a0			|move next cell addr to r0
	NILtest(a0)
	jmi	callnewd			|if no space, allocate
	|incl	*_lispsys+30*4			|inc count of doubs
	lea	30*4+_lispsys,a1
	addl	#1,a1@
	movl	a0@,_doub_str			|advance free list
strdb:
	movl	d0,a0@				|put baby to bed.
	movl	d1,a0@(4)			|put baby to bed.
	rts

callnewd:
	movl	d0,sp@-				|stack initial value
	movl	d1,sp@-				|stack initial value
	movl	a2,_np				|gc could occur
	movl	a2,_lbot
	jsr	_newdoub
	movl	d0,a0
	movl	sp@+,d1				|restore initial value
	movl	sp@+,d0				|restore initial value
	bra	strdb



/*
 * quick cons call, the car and cdr are stacked on the namestack
 * and this function is jsb'ed to.
 */
	.globl	_qcons
_qcons:
	Profile
	movl	_dtpr_str,a0			|move next cell addr to a0
	NILtest(a0)
	jmi	getnew				|if ran out of space jump
	movl	28*4+_lispsys,a1		|inc count of dtprs
	addql	#1,a1@
	movl	a0@,_dtpr_str			|advance free list
storit:	movl	a2@-,a0@			|store in cdr
	movl	a2@-,a0@(4)			|store in car
	movl	a0,d0
	rts

getnew:	movl	a2,_np
	jsr	_newdot				|must gc to get one
	jra	storit				|now initialize it.

/*
 * Fast equivalent of newdot, entered by jsb
 */

	.globl	_qnewdot
_qnewdot:
	Profile
	movl	_dtpr_str,a0			|mov next cell addr t0 r0
	NILtest(a0)
	jmi	mustallo			|if ran out of space

	movl	a0,sp@-
	movl	28*4+_lispsys,a0		|inc count of dtprs
	addql	#1,a0@
	movl	sp@+,a0

	movl	a0@,_dtpr_str			|advance free list
	clrl	a0@				|clrq (r0)
	clrl	a0@(4)
	rts
mustallo:
	movl	a2,_np				|gc could occur
	jsr	_newdot
	rts


/*
 * this is called exactly like popnames would be from C
 * but has been carefully improved so that it doesn't
 * have to alter the stack.
 */
	.globl	_qpopnames
_qpopnames:
	movl	_bnp,a1
	movl	sp,a0
	movl	a0@(4),d0
	jra	.L130
.L20001:
	movl	a1@(4),a0
	movl	a1@,a0@
.L130:
	subql	#8,a1
	cmpl	a1,d0
	jls	.L20001
	movl	a1,_bnp
	rts

/*
 * _qget : fast get subroutine
 *  (get 'atom 'ind)
 * called with a2@(-8) equal to the atom
 *	       a2@(-4) equal to the indicator
 * no assumption is made about _lbot
 * unfortunately, the atom may not in fact be an atom, it may
 * be a list or nil, which are special cases.
 * For nil, we grab the nil property list (stored in a special place)
 * and for lists we punt and call the C routine since it is  most likely
 * and error and we havent put in error checks yet.
 */

	.globl	_qget
_qget:
	Profile
	movl	a2@(-4),a1			|put indicator in a1
	movl	a2@(-8),a0			|and atom into a0
	cmpl	a0,d7
	jeq	nilpli				|jump if atom is nil
	movl	a0,d0				|check type
	NILsub(d0)
	movl	#9,d1
	asrl	d1,d0
	lea	_typetable+1,a5
	cmpb	#/**/ATOM,a5@(0,d0:L)		|is it a symbol??
	jne	notsymb				|nope
	movl	a0@(4),a0			|yes, put prop list in
						|	a0 to begin scan
	cmpl	a0,d7
	jeq	fail				|if no prop list,
						|	we lose right away
lp:	cmpl	a0@(4),a1			|is car of list = to indicator?
	jeq	good				|jump if so
	movl	a0@,a0				|else cddr
	movl	a0@,a0				|	down list
	cmpl	a0,d7
	jne	lp				|and jump if more list to go.

fail:	movl	a0,d0
	subql	#8,a2
	rts					|return with a0 eq to nil

good:	movl	a0@,a0				|return cadr of list
	movl	a0@(4),d0
	subql	#8,a2
	rts

nilpli:	movl	64*4+_lispsys,a0		|want nil prop list,
						|	get it specially
	cmpl	a0,d7
	jne	lp				|and process if anything there
	movl	a0,d0
	subql	#8,a2
	rts					|else fail
	
notsymb:
	lea	a2@(-8),a0			|set up lbot before callin
	movl	a0,_lbot
	movl	a2,_np
	jsr	_Lget				|not a symbol, call C routine
						|	to error check
	subql	#8,a2
	rts					|and return what it returned.


/*
 *  prunel  - return a list of dtpr cells to the free list
 * this is called by the pruneb after it has discarded the top bignum 
 * the dtpr cells are linked through their cars not their cdrs.
 * this returns with an rsb
 *
 * method of operation: the dtpr list we get is linked by car's so we
 * go through the list and link it by cdr's, then have the last dtpr
 * point to the free list and then make the free list begin at the
 * first dtpr.
 */
qprunel:
	movl	a0,d0				|remember first dtpr location
	movl	28*4+_lispsys,a1		|dec count of dtprs
rep:	
	subql	#1,a2@
	movl	a0@(4),a0@			|make cdr (forward lnk) == car
	jeq	endoflist			|if nil, then end of list
	movl	a0@,a0				|advance to next dtpr
	jra	rep				|and loop around
endoflist:
	movl	_dtpr_str,a0@			|make last 1 pnt to free list
	movl	d0,_dtpr_str			|& free list begin at 1st one
	rts

/*
 * qpruneb - called by the arithmetic routines to free an sdot and the dtprs
 * which hang on it.
 * called by
 *	pushl	sdotaddr
 *	jsb	_qpruneb
 */
	.globl	_qpruneb
_qpruneb:
	Profile
	movl	48*4+_lispsys,a0		|decr count of used sdots
	subql	#1,a0@
	movl	sp@(4),a0			|get address
	movl	_sdot_str,a0@			|have new sdot pnt to free lst
	movl	a0,_sdot_str			|strt free list at new sdot
	movl	a0@(4),a0			|get address of first dtpr
	jne	qprunel				|if exists, prune it
	rts					|else return.


/*
 * _qprunei 	 
 *	called by the arithmetic routines to free a fixnum cell
 * calling sequence
 *	pushl	fixnumaddr
 *	jsb	_qprunei
 */

	.globl	_qprunei
_qprunei:
	Profile
	movl	a1,sp@-
	movl	sp@(4),a0			|get address of fixnum
	cmpl	#4*1023+_Fixzero,a0		|is it a small fixnum
	jmi	skipit				|if so, leave
	movl	24*4+_lispsys,a1		|decr count of used ints
	subql	#1,a1@
	movl	_int_str,a0@			|link the fixnum into the
						|  free list
	movl	a0,_int_str
skipit:
	movl	sp@+,a1
	rts
Iclear:
	clrl	d0
	rts
	.text
	.globl	_Itstbt
_Itstbt:
	movl	a5,d1
	NILsub(d1)
	lsrl	#2,d1
	movl	d1,d0
	andl	#7,d0
	lsrl	#3,d1
	lea	_bitmapi,a0
	bset	d0,a0@(0,d1:L)
	beq	.L14
	moveq	#1,d0
	bra	.L12
.L14:
	clrl	d0
.L12:	rts

/*
 * this routine returns an assembly language entry pt.
 * it is put here to match the vax verison.
 */
	.globl	_gstart
	.globl	_proflush
_gstart:
	movl	#start,d0
_proflush:
	rts
/*
 * The definition of mcount must be present even when the C code
 * isn't being profiled, since lisp code may reference it.
 */
.globl _mcount
#ifdef SunGotItsActTogetherAboutTakingMcountOutOfCrt0 
.globl	mcount
#endif

_mcount:
mcount:
#ifdef PROF
	movl	a0@,a1
	jne	incr
	movl	_countbase,a1
	jeq	return
	addql	#8,_countbase
	movl	sp@,a1@+
	movl	a1,a0@
incr:
	addql	#1,a1@
return:
#endif
	rts

/*
 * pushframe : stack a frame 
 * When this is called, the optional arguments and class have already been
 * pushed on the stack as well as the return address (by virtue of the jsb)
 * , we push on the rest of the stuff (see h/frame.h)
 * for a picture of the save frame
 */
	.globl	_pushframe
	.globl	_qpushframe
	.globl	_Pushframe
_pushframe:
_qpushframe:
_Pushframe:
	movl	sp@,a0
	movl	_errp,sp@-
	movl	_bnp,sp@-
	movl	_np,sp@-
	movl	_lbot,sp@-
	movl	sp,d0		| return addr of lbot on stack
	subl	#56,sp
	moveml	#0x7cfc,sp@(12)	| save fp,a5-a2,d7-d2
	clrl	_retval		| set retval to C_INITIAL
#ifdef SPISFP
	subl	#8,sp
	movl	_xsp,sp@(16)	
	movl	sp,sp@(12)
#endif
	jmp	a0@		| return through return address

#ifdef SPISFP
/*
 * This is necessary on the sun-II beta testing version since the C
 * compiler makes refence to temporaries and restoring registers relative
 * to the stack pointer.  See explicative comments in ../vax/qfuncl.c
 * for Iretfrm and Ipushf
 */
	.globl	_Ipushf
_Ipushf:
	movl	sp@(16),a0
	addl	#96,a0
	movl	sp@(12),a0@-
	movl	sp@(8),a0@-
	movl	sp@(4),a0@-
	movl	sp@,a0@-
	movl	_errp,a0@-
	movl	_bnp,a0@-
	movl	_np,a0@-
	movl	_lbot,a0@-
	movl	a0,d0		| return addr of lbot on stack
	moveml	#0x7cfc,a0@(-44)	| save fp,a5-a2,d7-d2
	movl	_xsp,a0@(-48)
	movl	sp,a0@(-52)
	clrl	_retval		| set retval to C_INITIAL
	rts
#endif

/*
 * qretfromfr
 * called with frame to ret to in a5.  The popnames has already been done.
 * we must restore all registers, and jump to the ret addr. the popping
 * must be done without reducing the stack pointer since an interrupt
 * could come in at any time and this frame must remain on the stack.
 * thus we can't use popr.
 */

	.globl	_qretfromfr

_qretfromfr:
	movl	a5,d0			| return error frame location
	movl	a5,a0			| prepare to pop off
	moveml	a0@(-44),#0x7cfc	| restore registers
#ifndef SPISFP
	lea	a0@(-56),sp
	movl	a0@+,_lbot
	movl	a0@+,_np
	movl	a0@(8),a0		| return address
	jmp	a0@
#else
	movl	a0@(-52),sp
	movl	a0@(-48),_xsp
	movl	a0@+,_lbot
	movl	a0@+,_np
	movl	a0@(8),sp@		| return address
	rts
#endif

/*
 * Ancillary code for small thunks generated so that
 * c routines can be passed the address of something
 * to call which will pass onto lisp functions
 */
	.globl	_thcpy
_thcpy:
	movl	sp@,a0
	movl	a0@+,sp@-
	movl	a0@+,sp@-
	jsr	_dothunk
	lea	sp@(12),sp
	rts
#ifndef SPISFP
/* Copyright (c) 1982, Regents, University of California
   This is here because for the sun II beta test version, you
   can't do alloca */
	.text
	.globl	_alloca
_alloca:
	movl	sp@,d0
	movl	sp@(4),d1
	subl	#1,d1
	orl	#3,d1
	addl	#1,d1
	subl	d1,sp
	tstb	sp@(-132)
	movl	d0,sp@
	movl	sp,d0
	addl	#8,d0
	rts

#endif
	.globl	_vlsub
_vlsub:
	movl	sp@(4),a0
	addql	#8,a0
	movl	sp@(8),a1
	addql	#8,a1	| this should clear the carry bit.
#if sun_4_1c || sun_4_2beta
	subxl	a0@-,a1@-
	subxl	a0@-,a1@-
#else
	subxl	a1@-,a0@-	| This is the correct version
	subxl	a1@-,a0@-
#endif
	rts

/*
 * We want to be able to redefine read and write to check
 * certain lisp values.  Rather than have 4 variants, we
 * put the assembly language (obtained by adb rather than
 * violating source) here under ifdef control.
 */


.globl	__read
.globl	__write

#if sun_4_1c || sun_4_2beta || sun_4_2
.globl _vadvise
__read:
	pea     3:w
	jmp	_docall
__write:
	pea	4:w
_docall:
	trap    #0
	bcss   _bad
_vadvise:
#endif
#ifdef os_masscomp
__read:
	moveq    #0x3,d0
	jmp     _docall
__write:
	moveq    #0x4,d0
_docall:
	movl	a7@(4),d1
	movl	a7@(8),a0
	movl	a7@(12),a1
	trap	#0
	bcss	_bad
#endif
#ifdef os_unisoft || os_unix_ts
	.globl	_vfork
_vfork:
	jmp	_fork
__read:
	movw    #0x3,d0
	jmp     _docall
__write:
	movw    #0x4,d0
_docall:
	movl    a7@(4),a0
	movl    a7@(8),d1
	movl    a7@(12),a1
	trap	#0x0
	bcs	_bad
#endif
	rts
_bad:
	jmp	cerror

/* This must be at the end of the file.  If we are profiling, allocate
 * space for the profile buffer
 */
#ifdef PROF
	.data
	.comm	_countbase,4
	.lcomm	prbuf,indx+4
	.text
#endif
EndOfFile
cat >  franz/68k/Makefile  << 'EndOfFile'
# 
#$Header: Makefile,v 1.15 84/02/29 17:19:21 sklower Exp $
#
#$Locker:  $
#
#  Franz Lisp C coded kernel 
#
#-- Default Paths:
#  see ../../ReadMe for a explaination of what LibDir and CopyTo mean
#  D is the directory used for holding intermediate files during 
#    compilation
#-- Options:
#  there is one compile time options which can be set in this file
#  * do profiling (ala the unix prof(1) command)
#
#  The selection of this options is made below
#  Other options can be selected by editing ../h/config.h or via
#  ../../lispconf
#
LibDir = /usr/lib/lisp
ObjDir = /usr/ucb
CopyTo = /dev/null
Liszt = liszt
Lisp = lisp
# if you change this you must recompile rlc.c 
# (and change the value in ../Makefile)
#
HOLE=	2097152 

.DEFAULT: nlisp

MipSrc1= ../low.c ../lowaux.s
MipSrc2= ../alloc.c ../data.c
MipSrc3= ../rlc.c
MipSrc4= ../lisp.c ../eval.c ../eval2.c ../inits.c ../io.c ../error.c \
	 ../sysat.c ../lam1.c ../lam2.c ../lam3.c ../lam4.c ../lam5.c\
	 ../lam6.c  ../lam7.c ../lam8.c ../lam9.c ../lamr.c ../lamp.c \
	 ../fex1.c ../fex2.c ../fex3.c ../fex4.c ../fexr.c\
	 ../fpipe.c \
	 ../subbig.c ../pbignum.c ../divbig.c \
	 ../ffasl.c ../fasl.c \
	 ../trace.c ../evalf.c ../frame.c ../lamgc.c

MipSrc = ${MipSrc1} ${MipSrc2} ${MipSrc3} ${MipSrc4}

MipObj1= ../lowaux.o ../low.o
MipObj2= ../alloc.o ../data.o
HoleMipObj2 = ../Salloc.o ../Sdata.o
HoleMipObj3 = ../rlc.o
MipObj4= ../lisp.o ../eval.o ../eval2.o ../inits.o ../io.o ../error.o \
	 ../sysat.o ../lam1.o ../lam2.o ../lam3.o ../lam4.o ../lam5.o\
	 ../lam6.o  ../lam7.o ../lam8.o ../lam9.o ../lamr.o ../lamp.o \
	 ../fex1.o ../fex2.o ../fex3.o ../fex4.o ../fexr.o\
	 ../fpipe.o \
	 ../subbig.o ../pbignum.o ../divbig.o \
	 ../ffasl.o ../fasl.o \
	 ../trace.o ../evalf.o ../frame.o ../lamgc.o


# The order of loading of certain files is important.
# lowaux.o must be first and low.o second.
# 
BottomObj = ${MipObj1}

# Different objects are required depending on whether there is to be
# a hole between text and data space.
#
NoHoleObj = /lib/crt0.o ${MipObj2}
HoleObj   = /lib/hcrt0.o ${HoleMipObj2} ${HoleMipObj3}

M68kASrc = callg.s dmlad.s ediv.s emul.s hack.s \
	qfuncl.c
M68kCSrc = 68k.c adbig.c calqhat.c dodiv.c dsmult.c \
	exarith.c fixbits.c inewint.c \
	mlsb.c mulbig.c nargs.c suncore.c
M68kSrc = ${M68kCSrc} ${M68kASrc}

M68kObj = 68k.o adbig.o callg.o calqhat.o dmlad.o dodiv.o dsmult.o \
	ediv.o emul.o exarith.o fixbits.o hack.o inewint.o \
	mlsb.o mulbig.o nargs.o qfuncl.o

AllSrc = $(M68kSrc) Makefile first8.c fixregs.sed

CFLAGS = -O -I../h

#ifdef unisoft
#CFLAGS = -I../h
#endif

#ifdef sun
Libs = -lcore
OsObjs = suncore.o
#endif

#ifdef sunII
Libs = -lcore -lsunwindow -lpixrect
#endif

#ifdef mc500
#Libs = -lBSD
#endif

#ifdef unisys3botch
#N=
#else
N=-n
#endif

# on non-ucb systems it might be more
# polite to use temporary files rather than pipes
#
#ifdef unisoft
#.SUFFIXES : .c.l.s
#.s.o:
#	./first8.out < $< > $*.t; as -o $*.o $*.t; rm $*.t
#else
.SUFFIXES : .c.l
#endif
.c.o :
#ifdef npinreg
#	/lib/cpp -I../h $*.c | /lib/xcomp |\
#	sed -f fixregs.sed > /tmp/x.s; as -o $*.o /tmp/x.s
#else
	cc -c $(CFLAGS) $*.c;\
	mv `basename $*.o` x; mv x $*.o
#endif

.l.o :
	liszt $< > #resc
	@echo liszt $< done


../rlc.o: ../rlc.c 
	cc -c $(CFLAGS) -DHOLE=${HOLE} ../rlc.c 
	mv rlc.o .. < /dev/null

../Salloc.o: ../alloc.c
	(echo "# define HOLE"; cat ../alloc.c) > Salloc.c;\
	make Salloc.o; mv Salloc.o .. < /dev/null ; rm Salloc.c
	
../Sdata.o: ../data.c
	(echo "# define HOLE"; cat ../data.c) > Sdata.c;\
	make Sdata.o; mv Sdata.o .. < /dev/null  ; rm Sdata.c

first8.out: first8.c
	cc -I../h first8.c -o first8.out

../low.o: ../low.c
	cc -S $(CFLAGS) ../low.c; sed 's/data$$/text/' < low.s > Low.s
	as -o ../low.o Low.s; rm Low.s low.s

#ifdef unisoft
#qfuncl.o: qfuncl.c first8.out
#	cc -E $(CFLAGS) ${ProfFlag2} qfuncl.c |\
#	./first8.out | sed 's/^#/|/' > qfuncl.s
#	as -o qfuncl.o qfuncl.s
#	rm qfuncl.s
#
#else
qfuncl.o: qfuncl.c
	cc -I../h -E ${ProfFlag2} qfuncl.c > x.s; as -o qfuncl.o x.s; rm x.s
#endif

# rawlisp is the standard raw lisp system.

rawlisp: ${BottomObj} ${NoHoleObj} ${MipObj4} ${M68kObj} ${OsObjs}
	rm -f rawlisp
	ld $N -x -o rawlisp -e start ${BottomObj} ${NoHoleObj} \
				${M68kObj} ${MipObj4} ${OsObjs} \
				${Libs} -ltermcap -lm -lc
	ls -l rawlisp


# hlisp is a raw lisp system with a hole between text and data

rawhlisp: ${BottomObj} ${HoleObj} ${MipObj4} ${M68kObj} ${OsObjs}
	rm -f rawhlisp
	ld -x -H ${HOLE} -o rawhlisp -e hstart ${BottomObj}  ${HoleObj} \
				${M68kObj} ${MipObj4} ${OsObjs} \
				${Libs} -ltermcap -lm -lc
	ls -l rawhlisp


clean:
	rm -f *.o rawlisp rawhlisp nlisp snlisp

lint:
	lint ../h/*.h *.c

install: nlisp 
	-rm -f ${ObjDir}/lisp
	mv nlisp ${ObjDir}/lisp
	@echo lisp installed

nlisp: rawlisp ${LibDir}
	-rm -f nlisp
	(cd ${LibDir} ; make Liszt=${Liszt} required)
	echo "(progn (setq build:map 'map \
			   build:lisp-type 'franz \
		           lisp-library-directory '${LibDir} \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}) \
		     (load '${LibDir}/buildlisp)\
	             (dumplisp nlisp))" | ./rawlisp
	${LibDir}/tackon map nlisp
	@echo nlisp built


donlisp:
	-rm -f nlisp
	make LibDir=${LibDir} Liszt=${Liszt} ObjDir=${ObjDir} nlisp

#--- snlisp: create a totally interpreted lisp.
#	dump as snlisp
snlisp: rawlisp
	echo "(progn (setq build:load t		\
			   build:lisp-type 'franz \
			   build:dir '${LibDir} \
			   lisp-object-directory '${ObjDir}\
			   lisp-library-directory '${LibDir})\
		     (load '${LibDir}/buildlisp)\
		     (dumplisp snlisp))" | rawlisp


tags:	tags ${M68kCSrc} ${MipSrc}
	ctags ../h/*.h $(M68kCSrc) ${MipSrc}

#--- copysource : copy source files to another directory
#  called via   make CopyTo=/xx/yyy/zz copysource
# 
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@../../scriptcat . franz/68k ${AllSrc} tags
EndOfFile
cat >  franz/68k/first8.c  << 'EndOfFile'
#include <stdio.h>
#include "config.h"
char code[256];
#define FIRST 3
#define FOLLOW 2
#define ZERO 6
#define next() (((c = getc(si))==EOF)? exit(0):0)
#define copy() putc(c,so)
#define type() code[(unsigned char)c]
#if os_unix_ts
#define index strchr
#endif

init() {
	doit(FIRST,"ABCDEFGHIJKLMNOPQRSTUVWXYZ_");
	doit(FIRST,"0abcdefghijklmnopqrstuvwxyz_");
	doit(FOLLOW,"123456789");
}
doit(act,list)
register unsigned char *list;
{
	while(*list) {code[*list++]=act;}
}
main( )
{
	register FILE *si = stdin, *so = stdout;
	register c, count;

	init();
copying:
	do { next(); copy();} while(type()!=FIRST);
hexnum:
	if(c=='0') {
		next();
		if(c=='X'||c=='x') {
			do { copy(); next();}
			while (index("0123456789abcdefABCDEF",c&0x7f)>0);
		}
		ungetc(c,si); goto copying;
	}
counting:
	for(count = 0; count < 7; count++) {
		next();
		copy();
		if(!(type()&FOLLOW)) goto copying;
	}
squelch:
	do { next(); } while (type()&FOLLOW);
	copy();
	goto copying;
}
EndOfFile
cat >  franz/68k/fixregs.sed  << 'EndOfFile'
/_np,/s//a2,/
/_np$/s//a2/
/_lbot/s//d3/
EndOfFile
cat >  franz/68k/tags  << 'EndOfFile'
ATOLX	../alloc.c	/^# define ATOLX(p)	((((int)p)-OFFSET)>>7)$/
ATOX	../h/global.h	/^#define ATOX(a1)	((((int)(a1)) - OFFSET) >> 9)$/
CNTTYP	../lamr.c	/^CNTTYP() { return; \/* HI! COUNT ONE TYPE CALL! *\/ /
EVALATOM	../h/global.h	/^#define EVALATOM(x)	vtemp = x->a.clb;\\$/
FIDDLE	../sysat.c	/^#define FIDDLE(z,b,c,y) z->a.clb=newdot(); (z->a.c/
HUNKP	../h/global.h	/^#define	HUNKP(a1)	((TYPE(a1) >= 11) & (TYPE(a1) <=/
HUNKSIZE	../h/global.h	/^#define	HUNKSIZE(a1)	((TYPE(a1)+5) & 15)$/
HackHex	../divbig.c	/^HackHex() \/* this is a one minute function so drb /
ISNIL	../h/global.h	/^#define ISNIL(a)	(nil==a)$/
Iaddstat	../fex4.c	/^Iaddstat(name,readcode,setcode,valu)$/
Iarray	../eval2.c	/^Iarray(fun,args,evalp)$/
Ibalmod	../lam8.c	/^Ibalmod(invmodp)$/
Ibiglsh	../divbig.c	/^Ibiglsh(bignum,count,mode)$/
Ibindvars	../lam7.c	/^Ibindvars()$/
Iconcat	../lam2.c	/^Iconcat(unintern)$/
Iequal	../lam1.c	/^Iequal(first,second) $/
Ierrorh	../error.c	/^Ierrorh(type,message,valret,contuab,uniqid)$/
Ifcall	../eval2.c	/^Ifcall(a)$/
Ifclosure	../eval2.c	/^Ifclosure(clos,funcallp)$/
Iflatsi	../lam2.c	/^Iflatsi(current)$/
Ifloat	../lam5.c	/^Ifloat(handy)$/
Iget	../lam2.c	/^Iget(atm,ind)$/
Igetplist	../lam2.c	/^Igetplist(pptr,ind)$/
Igtpgsz	../fex3.c	/^Igtpgsz()$/
Ihau	../divbig.c	/^Ihau(fix)$/
Iimplode	../lam7.c	/^Iimplode(unintern)$/
Ilibdir	../ffasl.c	/^Ilibdir()$/
Imath	../lam8.c	/^lispval Imath(func)$/
Imkrtab	../lam6.c	/^Imkrtab(current)$/
Imuldiv	68k.c	/^Imuldiv(p1,p2,add,dv,quo,rem)$/
Inewvector	../lam8.c	/^Inewvector(class)$/
Inlthrow	../frame.c	/^Inlthrow(class, arg1, arg2)$/
Inonlocalgo	../frame.c	/^Inonlocalgo(class, arg1, arg2)$/
Ipntlen	../lam1.c	/^Ipntlen()$/
Ipurcopy	../lam8.c	/^Ipurcopy(handy)$/
Ipurep	../alloc.c	/^lispval $/
Iputprop	../lam2.c	/^Iputprop(atm,prop,ind)$/
Iratom	../io.c	/^Iratom()$/
Iretfromfr	../frame.c	/^Iretfromfr(fram)$/
Isstatus	../fex4.c	/^Isstatus(curnam,curval)$/
Istsrch	../fex4.c	/^lispval Istsrch(nam)$/
Iunbindvars	../lam7.c	/^Iunbindvars()$/
LDivide	../lam5.c	/^LDivide() {$/
LEmuldiv	../lam5.c	/^lispval LEmuldiv(){$/
LIfranzcall	../lam9.c	/^LIfranzcall()$/
LIfss	../eval2.c	/^LIfss()$/
LImemory	../alloc.c	/^LImemory()$/
LIshowstack	68k.c	/^LIshowstack()$/
LIvref	../lam8.c	/^LIvref()$/
LIvset	../lam8.c	/^LIvset()$/
LIvsize	../lam8.c	/^LIvsize()$/
LMakhunk	../lam8.c	/^LMakhunk()$/
Labsval	../lam3.c	/^Labsval()$/
Lacos	../lam8.c	/^lispval Lacos()$/
Ladd	../lam4.c	/^Ladd()$/
Ladd1	../lam3.c	/^Ladd1()$/
Lalfalp	../lam3.c	/^Lalfalp()$/
Lalloc	../lamr.c	/^Lalloc()$/
Larg	../lam6.c	/^Larg()$/
Largv	../lam5.c	/^Largv()$/
Larrayp	../lam1.c	/^Larrayp()$/
Larrayref	../lamr.c	/^Larrayref()$/
Lascii	../lam5.c	/^Lascii() $/
Lasin	../lam8.c	/^lispval Lasin()$/
Lassq	../lam6.c	/^Lassq()$/
Latan	../lam8.c	/^lispval Latan()$/
Latom	../lam1.c	/^Latom()$/
Lbaktrace	68k.c	/^Lbaktrace()$/
Lbcdad	../lam7.c	/^Lbcdad()$/
Lbcdp	../lam1.c	/^Lbcdp()$/
Lbiglsh	../divbig.c	/^Lbiglsh()$/
Lbigtol	../lam1.c	/^Lbigtol(){$/
Lboole	../lam5.c	/^Lboole(){$/
Lboundp	../lam6.c	/^Lboundp()$/
Lbreak	../lam5.c	/^lispval Lbreak() {$/
Lc02r	../lam1.c	/^Lc02r()$/
Lc03r	../lam1.c	/^Lc03r()$/
Lc04r	../lam1.c	/^Lc04r()$/
Lc12r	../lam1.c	/^Lc12r()$/
Lc13r	../lam1.c	/^Lc13r()$/
Lc14r	../lam1.c	/^Lc14r()$/
Lcaar	../lam1.c	/^Lcaar()$/
Lcadr	../lam1.c	/^Lcadr()$/
Lcar	../lam1.c	/^Lcar()$/
Lcdr	../lam1.c	/^Lcdr()$/
Lcfasl	../ffasl.c	/^Lcfasl(){$/
Lchdir	../lam5.c	/^lispval Lchdir(){$/
Lclose	../lam1.c	/^Lclose()$/
Lconcat	../lam2.c	/^Lconcat(){$/
Lcons	../lam1.c	/^Lcons()$/
Lcopyint	../lam6.c	/^Lcopyint()$/
Lcos	../lam8.c	/^lispval Lcos()$/
Lcprintf	../lam8.c	/^Lcprintf()$/
Lcpy1	../lam6.c	/^Lcpy1()$/
Lctcherr	../lam8.c	/^Lctcherr()$/
Lcxr	../lam8.c	/^Lcxr()$/
Ldbtofl	../lam4.c	/^Ldbtofl()$/
Lderef	../lamr.c	/^Lderef()$/
Ldiff	../lam3.c	/^Ldiff()$/
Ldrain	../lam1.c	/^Ldrain()$/
Ldtpr	../lam1.c	/^Ldtpr()$/
Leq	../lam1.c	/^Leq()$/
Lequal	../lam1.c	/^Lequal()$/
Lerr	../lam6.c	/^lispval Lerr()$/
Leval	../lam1.c	/^Leval()$/
Leval1	../trace.c	/^Leval1(){$/
Levalf	../evalf.c	/^Levalf ()$/
Levalhook	../trace.c	/^Levalhook()$/
Lexece	../lam7.c	/^Lexece()$/
Lexit	../lam7.c	/^Lexit()$/
Lexp	../lam8.c	/^lispval Lexp()$/
Lexplda	../lam5.c	/^Lexplda()$/
Lexpldc	../lam5.c	/^Lexpldc()$/
Lexpldn	../lam5.c	/^Lexpldn()$/
Lexpldx	../lam5.c	/^Lexpldx(kind,slashify)$/
Lfact	../lam5.c	/^Lfact()$/
Lfadd1	../lam4.c	/^lispval Lfadd1()$/
Lfake	../lamr.c	/^Lfake()$/
Lfd	../lam4.c	/^lispval Lfd()$/
Lfdopen	../lam7.c	/^Lfdopen()$/
Lfexpt	../lam4.c	/^lispval Lfexpt()$/
Lfileopen	../lam8.c	/^Lfileopen()$/
Lfix	../lam5.c	/^ lispval Lfix() $/
Lflatsi	../lam2.c	/^Lflatsi()$/
Lflessp	../lam4.c	/^lispval Lflessp()$/
Lfloat	../lam5.c	/^Lfloat()$/
Lfltodb	../lam4.c	/^Lfltodb()$/
Lfm	../lam4.c	/^lispval Lfm()$/
Lforget	../lamr.c	/^Lforget()$/
Lfork	../lam7.c	/^Lfork() {$/
Lfp	../lam4.c	/^lispval Lfp()$/
Lframedump	../frame.c	/^Lframedump()$/
Lfretn	../evalf.c	/^Lfretn ()$/
Lfrexp	../lam5.c	/^Lfrexp()$/
Lfseek	../lam8.c	/^Lfseek()$/
Lfsub1	../lam4.c	/^lispval Lfsub1()$/
Lft	../lam4.c	/^lispval Lft()$/
Lfunhook	../trace.c	/^Lfunhook()$/
Lgcstat	../lamgc.c	/^Lgcstat()$/
Lgensym	../lam7.c	/^Lgensym()$/
Lget	../lam2.c	/^Lget()$/
Lgeta	../lamr.c	/^Lgeta()$/
Lgetaddress	../fex3.c	/^Lgetaddress(){$/
Lgetaux	../lamr.c	/^Lgetaux()$/
Lgetd	../lam2.c	/^Lgetd()$/
Lgetdata	../lamr.c	/^Lgetdata()$/
Lgetdel	../lamr.c	/^Lgetdel()$/
Lgetdisc	../lamr.c	/^Lgetdisc()$/
Lgetentry	../lamr.c	/^Lgetentry()$/
Lgetenv	../lam6.c	/^Lgetenv()$/
Lgetl	../lamr.c	/^Lgetl()$/
Lgetlang	../lamr.c	/^Lgetlang()$/
Lgetloc	../lamr.c	/^Lgetloc()$/
Lgetparams	../lamr.c	/^Lgetparams()$/
Lgetsyntax	../lam3.c	/^Lgetsyntax()$/
Lgreaterp	../lam3.c	/^Lgreaterp()$/
Lhaipar	../divbig.c	/^Lhaipar()$/
Lhashst	../lam8.c	/^lispval Lhashst()$/
Lhau	../divbig.c	/^Lhau()$/
Lhtol	../lam8.c	/^Lhtol()$/
Lhunkp	../lam1.c	/^Lhunkp()$/
Lhunksize	../lam8.c	/^Lhunksize()$/
Limplode	../lam7.c	/^Limplode()$/
Linfile	../lam1.c	/^Linfile()$/
Lintern	../lam7.c	/^Lintern()$/
Lkilcopy	../lam6.c	/^Lkilcopy()$/
Llctrace	../lamr.c	/^Llctrace()$/
Llessp	../lam3.c	/^Llessp()$/
Llist	../lam1.c	/^Llist()$/
Lload	../lam2.c	/^Lload()$/
Llog	../lam8.c	/^lispval Llog()$/
Llsh	../lam8.c	/^Llsh()$/
Lmakertbl	../lam6.c	/^Lmakertbl()$/
Lmaknam	../lam7.c	/^Lmaknam()$/
Lmaknum	../lamr.c	/^Lmaknum()$/
Lmakunb	../lam8.c	/^Lmakunb()$/
Lmap	../lam2.c	/^Lmap()$/
Lmapc	../lam2.c	/^Lmapc()$/
Lmapcan	../lam2.c	/^Lmapcan()$/
Lmapcar	../lam2.c	/^Lmapcar()$/
Lmapcon	../lam2.c	/^Lmapcon()$/
Lmapcrx	../lam2.c	/^Lmapcrx(maptyp,join)$/
Lmapcx	../lam2.c	/^Lmapcx(maptyp)$/
Lmaplist	../lam2.c	/^Lmaplist()$/
Lmarray	../lamr.c	/^Lmarray()$/
Lmfunction	../lamr.c	/^Lmfunction()$/
Lminus	../lam3.c	/^Lminus()$/
Lmod	../lam3.c	/^Lmod()$/
Lmonitor	../lamp.c	/^Lmonitor()$/
Lncons	../lam3.c	/^Lncons()$/
Lnegp	../lam3.c	/^Lnegp()$/
Lnthelem	../lam1.c	/^Lnthelem()$/
Lnull	../lam1.c	/^Lnull()$/
Lnumberp	../lam1.c	/^Lnumberp()$/
Lnvec	../lam8.c	/^Lnvec()$/
Lnvecb	../lam8.c	/^Lnvecb()$/
Lnvecl	../lam8.c	/^Lnvecl()$/
Lnvecw	../lam8.c	/^Lnvecw()$/
Lnwritn	../lam1.c	/^Lnwritn()$/
Loblist	../lam3.c	/^Loblist()$/
Lod	../lamr.c	/^Lod()$/
Lonep	../lam3.c	/^Lonep()$/
Lopval	../lamr.c	/^lispval $/
Loutfile	../lam1.c	/^Loutfile()$/
Lpatom	../lam1.c	/^Lpatom()$/
Lpipe	../lam7.c	/^Lpipe()$/
Lplist	../lam6.c	/^Lplist()$/
Lpname	../lamr.c	/^Lpname()$/
Lpntlen	../lam1.c	/^Lpntlen()$/
Lpolyev	68k.c	/^Lpolyev()$/
Lportp	../lam1.c	/^Lportp()$/
Lprint	../lam1.c	/^Lprint()$/
Lprname	../lam7.c	/^Lprname()$/
Lprobef	../lam8.c	/^Lprobef()$/
Lprocess	../lam7.c	/^Lprocess()$/
Lptime	../lam6.c	/^Lptime(){$/
Lptr	../lamr.c	/^Lptr()$/
Lpurcopy	../lam8.c	/^Lpurcopy()$/
Lpurep	../lam8.c	/^Lpurep()$/
Lputa	../lamr.c	/^Lputa()$/
Lputaux	../lamr.c	/^Lputaux()$/
Lputd	../lam2.c	/^Lputd()$/
Lputdata	../lamr.c	/^Lputdata()$/
Lputdel	../lamr.c	/^Lputdel()$/
Lputdisc	../lamr.c	/^Lputdisc()$/
Lputl	../lamr.c	/^Lputl()$/
Lputlang	../lamr.c	/^Lputlang()$/
Lputloc	../lamr.c	/^Lputloc()$/
Lputparams	../lamr.c	/^Lputparams()$/
Lputprop	../lam2.c	/^Lputprop()$/
Lpvp	../lam8.c	/^Lpvp()$/
Lquo	../lam4.c	/^Lquo()$/
Lrandom	../lam8.c	/^Lrandom()$/
Lratom	../lam2.c	/^Lratom()$/
Lread	../lam2.c	/^Lread()$/
Lreadc	../lam2.c	/^Lreadc()$/
Lreadli	../lam6.c	/^Lreadli()$/
Lrematom	../lam7.c	/^Lrematom()$/
Lremprop	../lam7.c	/^Lremprop()$/
Lreplace	../lamr.c	/^Lreplace()$/
Lreturn	../lam1.c	/^Lreturn()$/
Lrmadd	../ffasl.c	/^Lrmadd(){$/
Lrot	68k.c	/^Lrot()$/
Lrplaca	../lam1.c	/^Lrplaca()$/
Lrplacd	../lam1.c	/^Lrplacd()$/
Lrplacx	../lam8.c	/^Lrplacx()$/
Lrset	../trace.c	/^Lrset ()$/
Lsbiglsh	../divbig.c	/^Lsbiglsh()$/
Lscons	../lam1.c	/^Lscons()$/
Lsegment	../lamr.c	/^Lsegment()$/
Lset	../lam1.c	/^Lset()$/
Lsetarg	../lam6.c	/^Lsetarg()$/
Lsetpli	../lam6.c	/^Lsetpli()$/
Lsetsyn	../lam3.c	/^Lsetsyn()$/
Lshostk	68k.c	/^Lshostk()$/
Lsignal	../lam6.c	/^Lsignal()$/
Lsimpld	../lamr.c	/^Lsimpld()$/
Lsin	../lam8.c	/^lispval Lsin()$/
Lsizeof	../lamr.c	/^Lsizeof()$/
Lslevel	../lamr.c	/^Lslevel()$/
Lsprintf	../lam8.c	/^Lsprintf()$/
Lsqrt	../lam8.c	/^lispval Lsqrt()$/
Lsstrn	../lam8.c	/^Lsstrn()$/
LstarMod	../lam8.c	/^LstarMod()$/
Lstarinvmod	../lam8.c	/^Lstarinvmod()$/
Lstarrpx	../lam8.c	/^Lstarrpx()$/
Lstringp	../lam7.c	/^Lstringp()$/
Lsub	../lam4.c	/^Lsub()$/
Lsub1	../lam3.c	/^Lsub1()$/
Lsubstring	../lam8.c	/^Lsubstring()$/
Lsymbolp	../lam7.c	/^Lsymbolp()$/
Lsyscall	../fex4.c	/^Lsyscall() {$/
Ltci	../lam9.c	/^Ltci()$/
Ltcx	../lam9.c	/^Ltcx()$/
Lterpr	../lam1.c	/^Lterpr()$/
Ltimes	../lam4.c	/^Ltimes()$/
Ltimestr	../lam7.c	/^Ltimestr()$/
Ltruename	../lam1.c	/^Ltruename()$/
Ltyi	../lam6.c	/^Ltyi()$/
Ltyipeek	../lam6.c	/^Ltyipeek()$/
Ltyo	../lam6.c	/^Ltyo()$/
Ltype	../lam1.c	/^Ltype()$/
Luconcat	../lam2.c	/^Luconcat(){$/
Luntyi	../lam6.c	/^Luntyi()$/
Lvaluep	../lamr.c	/^Lvaluep()$/
Lvectorp	../lam8.c	/^Lvectorp()$/
Lvprop	../lam8.c	/^Lvprop()$/
Lvsp	../lam8.c	/^Lvsp()$/
Lwait	../lam7.c	/^Lwait()$/
Lxcar	../lam1.c	/^Lxcar()$/
Lxcdr	../lam1.c	/^Lxcdr()$/
Lzapline	../lam3.c	/^Lzapline()$/
Lzerop	../lam3.c	/^Lzerop()$/
MARKVAL	../alloc.c	/^# define MARKVAL(v)	if(((int)v) >= (int)beginsweep/
MK	../sysat.c	/^#define MK(x,y,z) mfun(x,y,z)$/
Mlisp	../lisp.c	/^main(argc,argv,arge)$/
NOTNIL	../h/global.h	/^#define NOTNIL(a)	(nil!=a)$/
N_BADMAG	../h/aout.h	/^#define	N_BADMAG(x) \\$/
N_STROFF	../h/aout.h	/^#define	N_STROFF(x) \\$/
N_SYMOFF	../h/aout.h	/^#define N_SYMOFF(x) \\$/
N_TXTOFF	../h/aout.h	/^#define	N_TXTOFF(x) \\$/
Nand	../fex1.c	/^Nand()$/
Nbreak	../fex1.c	/^Nbreak()$/
Ncatch	../fex1.c	/^Ncatch()$/
Ncond	../fex1.c	/^Ncond()$/
Ndef	../fex1.c	/^Ndef() {$/
Ndo	../fex2.c	/^Ndo()$/
Ndumplisp	../fex3.c	/^Ndumplisp()$/
Nerrset	../fex1.c	/^lispval Nerrset()$/
Nevwhen	../fex4.c	/^Nevwhen()$/
Nexit	../fex1.c	/^Nexit()$/
Nfunction	../fex2.c	/^Nfunction()$/
Ngc	../alloc.c	/^Ngc()$/
Ngcafter	../fexr.c	/^lispval $/
Ngo	../fex1.c	/^Ngo() $/
Nopval	../fexr.c	/^lispval $/
Nor	../fex1.c	/^Nor()$/
Nprog	../fex1.c	/^Nprog() {$/
Nprog2	../fex2.c	/^Nprog2()$/
Nprogn	../fex2.c	/^Nprogn()$/
Nprogv	../fex2.c	/^Nprogv()$/
Nquote	../fex1.c	/^Nquote()$/
Nreset	../fex1.c	/^Nreset()$/
Nresetio	../fex1.c	/^Nresetio() {$/
Nsetq	../fex1.c	/^Nsetq()$/
Nsstatus	../fex4.c	/^Nsstatus()$/
Nstatus	../fex4.c	/^Nstatus()$/
Nsys	../fex1.c	/^Nsys()$/
Nthrow	../fex1.c	/^Nthrow()$/
Ntpl	../lisp.c	/^Ntpl()$/
P	../h/global.h	/^#define P(p)		((lispval) (xports +((p)-_iob)))$/
PN	../h/global.h	/^#define PN(p)		((int) ((p)-_iob))$/
PUSHDOWN	../h/global.h	/^#define PUSHDOWN(atom,value)\\$/
PUSHVAL	../h/global.h	/^#define PUSHVAL(atom,value)\\$/
Popframe	../h/global.h	/^#define Popframe() (errp->olderrp)$/
Restorestack	../h/global.h	/^#define Restorestack() (lbot = OLDlbot), np = OLDn/
SETTYPE	../h/global.h	/^#define SETTYPE(a1,b,c)   {if((itemp = ATOX(a1)) >/
SMALL	../h/global.h	/^#define SMALL(i)	((lispval)(Fixzero + i))$/
SP	../subbig.c	/^#define SP() ((int *)sp())$/
STASSGN	../fex3.c	/^#define STASSGN(p,q) strncpy(NTABLE[(p)].n_name,(q/
Savestack	../h/global.h	/^#define Savestack(n) struct argent *OLDlbot = lbot/
TYPE	../h/global.h	/^#define	TYPE(a1)	((typetable+1)[ATOX(a1)])$/
TYPL	../h/global.h	/^#define	TYPL(a1)	((typetable+1)[ATOX(a1)])$/
VALID	../h/global.h	/^#define VALID(a)	(a >= CNIL && a < datalim)$/
VecByteSize	../h/global.h	/^#define VecByteSize(x)	(x)$/
VecSize	../h/global.h	/^#define VecSize(x) 	((x) >> 2)$/
VecTotSize	../h/global.h	/^#define VecTotSize(x)  (((x)+3) >> 2)$/
VecTotToByte	../h/global.h	/^#define VecTotToByte(x) ((x) * sizeof(long))$/
VecWordSize	../h/global.h	/^#define VecWordSize(x)	((x) >> 1)$/
Zequal	../lam1.c	/^Zequal()$/
_dofpip	../fpipe.c	/^FILE *_dofpip(iodes)$/
adback	mlsb.c	/^adback(utop,ubot,vtop)$/
adbig	adbig.c	/^struct sdot *adbig(a,b)$/
alloc	../alloc.c	/^alloc(tname,npages)$/
argerr	../error.c	/^argerr(msg)$/
atomtoolong	../io.c	/^atomtoolong(copyto)$/
badcall	../alloc.c	/^badcall()$/
badmem	../error.c	/^badmem(n)$/
badmemr	../inits.c	/^badmemr(number)$/
bcopy	../eval2.c	/^bcopy(to,from,size)$/
binderr	../error.c	/^binderr()$/
blzero	inewint.c	/^blzero(where,howmuch)$/
bndchk	../lam8.c	/^bndchk()$/
calcnum	../io.c	/^calcnum(strbuf,name,base)$/
calhan	../error.c	/^calhan(limit,work,type,uniqid,contuab,message,hand/
calqhat	calqhat.c	/^calqhat(uj,v1)$/
cforget	../sysat.c	/^#define cforget(x) protect(x); Lforget(); unprot()/
cmpx	../lam3.c	/^cmpx(lssp)$/
copval	../fexr.c	/^lispval $/
copyblock	../ffasl.c	/^copyblock(f1,f2,size)$/
csegment	../alloc.c	/^csegment(typecode,nitems,useholeflag)$/
csizeof	../alloc.c	/^int csizeof(tname) lispval tname;$/
cxxr	../lam1.c	/^cxxr(as,ds)$/
delayoff	../inits.c	/^delayoff(){$/
dispget	../ffasl.c	/^lispval $/
divbig	../divbig.c	/^divbig(dividend, divisor, quotient, remainder)$/
dmpport	../io.c	/^dmpport(useport)$/
dodiv	dodiv.c	/^long dodiv(top,bottom)$/
dopow	../io.c	/^dopow(part2,base)$/
dosig	../inits.c	/^dosig()$/
dsadd1	mlsb.c	/^dsadd1(top,bot)$/
dsdiv	mlsb.c	/^long dsdiv(top,bot,div)$/
dsmult	dsmult.c	/^dsmult(top,bot,mul)$/
dsneg	dodiv.c	/^long dsneg(top,bottom)$/
dsrsh	mlsb.c	/^dsrsh(top,bot,ncnt,mask1)$/
dumpmydata	../eval2.c	/^dumpmydata(thing)$/
error	../error.c	/^error(mesg,contvl)$/
errorh	../error.c	/^errorh(type,message,valret,contuab,uniqid)$/
errorh1	../error.c	/^errorh1(type,message,valret,contuab,uniqid,arg1)$/
errorh2	../error.c	/^errorh2(type,message,valret,contuab,uniqid,arg1,ar/
exarith	exarith.c	/^long exarith(mul1,mul2,add,hi,lo)$/
export	../divbig.c	/^export(top,bot)$/
finatom	../io.c	/^finatom(name)$/
fixbits	fixbits.c	/^fixbits(from,to)$/
fpipe	../fpipe.c	/^FILE * fpipe(info)$/
franzexit	../lisp.c	/^franzexit(code)$/
from	../eval.c	/^    function from compiled code, we print out a me/
frstFI	../lam6.c	/^frstFI(p)$/
ftolsp_	../eval2.c	/^ftolsp_(arg1)$/
gc	../alloc.c	/^gc(type_struct)$/
gc1	../alloc.c	/^gc1()$/
gcdump	../lamgc.c	/^gcdump()$/
gcrebear	../alloc.c	/^gcrebear()$/
get_more_space	../alloc.c	/^get_more_space(type_struct,purep)                 /
getatom	../alloc.c	/^getatom()$/
gethspace	../alloc.c	/^gethspace(segsiz,type)$/
getnum	../io.c	/^getnum(name)$/
getvec	../alloc.c	/^getvec(size,typestr,purep)$/
gstab	../ffasl.c	/^gstab()$/
hashfcn	../alloc.c	/^hashfcn(symb)$/
imacrox	../io.c	/^imacrox(current,inlist)$/
inewint	../h/global.h	/^#define inewint(p) Inewint((long)(p))$/
inewstr	../alloc.c	/^char *inewstr(s) char *s;$/
inewval	../alloc.c	/^inewval(arg) lispval arg;$/
initial	../inits.c	/^initial()$/
invmod	../lam8.c	/^invmod (n,modulus)$/
isho	68k.c	/^isho(f)$/
lfltpr	../io.c	/^lfltpr(buf,val)		\/* lisp floating point printer *\//
lispend	../error.c	/^lispend(mesg)$/
locatevar	../eval2.c	/^locatevar(clos,foundc,rnp)$/
lookbit	../alloc.c	/^# define lookbit(p)	(bitmap[(int)p>>5] & bitmsk[((/
macrox	../io.c	/^macrox()$/
major	../h/types.h	/^#define	major(x)	(int)(((unsigned)x>>8)&0377)$/
makedev	../h/types.h	/^#define	makedev(x,y)	(dev_t)(((x)<<8) | (y))$/
makenv	../inits.c	/^makenv()$/
makevals	../sysat.c	/^makevals()$/
markdp	../alloc.c	/^markdp(p) register lispval p;$/
markit	../alloc.c	/^markit(p) lispval *p; { markdp(*p); }$/
mask	../inits.c	/^#define	mask(s)	(1 << ((s)-1))$/
matchtags	../frame.c	/^matchtags(tag1,tag2)$/
matom	../sysat.c	/^matom(string)$/
mfun	../sysat.c	/^lispval mfun(string,start,discip) char *string; li/
minor	../h/types.h	/^#define	minor(x)	(int)(x&0377)$/
mkstFI	../lam6.c	/^mkstFI(base,count,flag)$/
mlsb	mlsb.c	/^mlsb(utop,ubot,vtop,nqhat)$/
mmuladd	68k.c	/^mmuladd(a,b,c,m)$/
mstr	../sysat.c	/^lispval mstr(string) char *string;$/
mulbig	mulbig.c	/^struct sdot *mulbig(a,b)$/
myfrexp	68k.c	/^myfrexp() { error("myfrexp called", FALSE);}$/
myhook	../alloc.c	/^myhook(){}$/
mytemp	../ffasl.c	/^mytemp()$/
namerr	../error.c	/^namerr()$/
nargs	nargs.c	/^nargs(arg)$/
newarray	../alloc.c	/^newarray()$/
newatom	../alloc.c	/^newatom(pure) {$/
newdot	../alloc.c	/^newdot()$/
newdoub	../alloc.c	/^newdoub()$/
newfunct	../alloc.c	/^newfunct()$/
newhunk	../alloc.c	/^newhunk(hunknum)$/
newint	../alloc.c	/^newint()$/
newsdot	../alloc.c	/^newsdot()$/
newstr	../alloc.c	/^newstr(purep) {$/
newval	../alloc.c	/^newval()$/
newvec	../alloc.c	/^newvec(size)$/
next	../io.c	/^#define next() (((cc=getc(useport))!=EOF)?(stats =/
next_one	../alloc.c	/^next_one(type_struct)$/
next_pure_one	../alloc.c	/^next_pure_one(type_struct)$/
nveci	../alloc.c	/^nveci(size)$/
oLequal	../lam1.c	/^oLequal()$/
okport	../h/global.h	/^#define okport(arg,default) (vtemp = arg,((TYPE((v/
oktox	../ffasl.c	/^#define oktox(n) \\$/
pagenorm	../fex3.c	/^pagenorm() { vadvise(VA_NORM); }$/
pagerand	../fex3.c	/^pagerand() { vadvise(VA_ANOM); }$/
pageseql	../fex3.c	/^pageseql() { vadvise(VA_SEQL); }$/
pbignum	../pbignum.c	/^pbignum(current, useport)$/
peekc	../h/global.h	/^#define	peekc(p)	(p->_cnt>0? *(p)->_ptr&0377:_filb/
pinewstr	../alloc.c	/^char *pinewstr(s) char *s;$/
pnewdot	../alloc.c	/^pnewdot()$/
pnewdoub	../alloc.c	/^pnewdoub()$/
pnewhunk	../alloc.c	/^pnewhunk(hunknum)$/
pnewint	../alloc.c	/^pnewint()$/
pnewsdot	../alloc.c	/^pnewsdot()$/
pnewval	../alloc.c	/^pnewval()$/
pnewvec	../alloc.c	/^pnewvec(size)$/
pnveci	../alloc.c	/^pnveci(size)$/
printr	../io.c	/^printr(a,useport)$/
protect	../h/global.h	/^#define protect(p) (np++->val = (p))$/
pruneb	../alloc.c	/^pruneb(bignum)$/
prunei	68k.c	/^prunei(what)$/
r	../lam2.c	/^r(op)$/
ratomr	../io.c	/^ratomr(useport)$/
re_enable	../inits.c	/^re_enable(signo,handler)$/
read	68k.c	/^read(file,buffer,count)$/
readbit	../alloc.c	/^# define readbit(p)	((int)bitmap[r=(int)p>>5] & (s/
readchk	../alloc.c	/^# define readchk(p)	((int)bitfre[(int)p>>5] & bitm/
readr	../io.c	/^readr(useport)$/
readrx	../io.c	/^readrx(code)$/
rlc	../rlc.c	/^rlc()$/
round	../ffasl.c	/^#define round(x,s) ((((x)-1) & ~((s)-1)) + (s))$/
roundup	../alloc.c	/^# define roundup(x,l)	(((x - 1) | (l - 1)) + 1) $/
rpla	../lam1.c	/^rpla(what)$/
rpltab	../lam3.c	/^rpltab(cclass,addr)$/
rtaberr	../error.c	/^rtaberr()$/
s	../fasl.c	/^	   functions to link in and forms to evaluate.$/
saveonly	../h/global.h	/^#define saveonly(n)	asm("#save	n")$/
searchforpdl	../evalf.c	/^struct frame *searchforpdl (myfp)$/
setchk	../alloc.c	/^# define setchk(p)	{bitfre[(int)p>>5] |= bitmsk[((/
show	../lam9.c	/^show(option,line,colum)$/
sigcall	../inits.c	/^sigcall(which)$/
siginth	../inits.c	/^siginth(signo){$/
snpand	../h/global.h	/^#define snpand(n)	asm("#protect	n")$/
space_warn	../alloc.c	/^space_warn(g)$/
subbig	../subbig.c	/^subbig(pos,neg)$/
synclass	../h/chars.h	/^#define synclass(p) (p & 037)$/
syscall	68k.c	/^syscall() { error("vsyscall called", FALSE);}$/
toint	../divbig.c	/^#define toint(p) ((int) (p))$/
typenum	../alloc.c	/^int typenum(tname) lispval tname;$/
typred	../fex2.c	/^typred(typ,ptr)$/
ungstab	../ffasl.c	/^ungstab()$/
vectorpr	../io.c	/^vectorpr(vec,port)$/
verify	../ffasl.c	/^verify(in,error)$/
verifypdlp	../evalf.c	/^verifypdlp(curfp)$/
wnaerr	../error.c	/^wnaerr(fcn,wantargs)$/
write	68k.c	/^write(file, buffer, count)$/
xpopnames	../eval2.c	/^xpopnames(llimit)$/
xsbrk	../alloc.c	/^xsbrk(n)$/
ysbrk	../alloc.c	/^char *ysbrk(pages,type) int pages, type;$/
EndOfFile
cat >  liszt/Makefile  << 'EndOfFile'
#$Header: Makefile,v 1.12 83/09/12 15:26:36 layer Exp $
#
#makefile for misc things -- lxref and tags

DESTDIR =
ObjDir = /usr/ucb
Liszt = ${ObjDir}/liszt
XTR = /na/lbc/bin/extract

CTESrc = chead.l cmacros.l const.l

Src =	array.l datab.l decl.l expr.l fixnum.l funa.l funb.l func.l io.l \
	vector.l instr.l tlev.l util.l lversion.l

LxrefSrc = lxref.l

AllSrc =  Makefile ChangeLog cmake.l ${CTESrc} ${Src} ${LxrefSrc} ltags tags

.DEFAULT:lxref

xtra:	${DotSSrc}

doc:
	${XTR} -clE "(load 'const.l)(load 'chead.l)" $(CTESrc) $(Src) > doc

doc.n:
	${XTR} -cnlE "(load 'const.l)(load 'chead.l)" $(CTESrc) $(Src) > doc.n

index:
	${XTR} -cli\
	-E "(progn (chdir'vax)(load'../cmacros.l)(load'../chead.l)(chdir'..))"\
		$(CTESrc) $(Src) > index

index.n:
	${XTR} -cnli -T "Liszt Index" -p 8\
	-E "(progn (chdir'vax)(load'lisprc.l)(load'../cmacros.l)(load'../chead.l)(chdir'..))"\
	$(CTESrc) $(Src) > index.n

lxref:	lxref.l
	${Liszt} -xrq -o lxref lxref.l

install: lxref
	mv lxref ${DESTDIR}${ObjDir}/lxref

scriptcatall: ${DistSrc}
	@../scriptcat . liszt ${AllSrc}

copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))
EndOfFile
cat >  liszt/ChangeLog  << 'EndOfFile'
Fri Jan 13 15:05:29 1984 by jkf
	the 68k version will now record function argument
	counts for lambdas.  It still doesn't do lexprs (even those
	with &optional and &rest forms).
	
Wed Dec  7 16:13:08 1983 by sklower
	changed profiling code to refer to mcnts instead of
	mcounts so that the C variable could be so renamed
	to make sure that all names are distinguishable
	in the first 6 characters.  This change is invisible
	to users.

Tue Nov 22 08:59:34 1983 by jkf
	added the -W switch.  After compilation (but before assembly)
	it aborts the compilation with an error status if there were
	any warnings.
	(now: version 8.39)
	
Tue Oct 25 14:45:48 1983 by jkf
	fixed it so that if a lisp error occurs when compiling a function,
	the name of the function being compiled will be printed
	(now: version 8.38)
	
Mon Oct 10 07:42:54 1983 by jkf
	fixed bug in liszt (tlev)
	(now: version 8.37)
	
Sat Jul 30 15:37:40 1983 by layer
	open code vset.  Move all vector stuff to vector.l.
	Files: func.l, decl.l, vector.l, and cmake.l
	(now: version 8.33)
	
Mon Jul 25 21:29:54 PDT 1983 by layer
	fixed 'liszt' to mung object file header for the sun
	File: tlev.l
	(now: version 8.32)

Mon Jul 25 07:05:49 1983 by jkf
	fix bug whereby -mr would cause an 'comma not in backquote error'
	because the escape character was / instead of \ when reading
	/usr/lib/lisp/autorun.xxx
	(now: version 8.31)
	
Sat Jun 25 13:28:10 1983 by jkf
	Turn off uctolc converstion before printing bindtab.
	This is useful for liszt in opus 38.65 and greater since it
	will eliminate unnecessary |'s in the bindtab if uctolc
	is need to compile the file
	(now: version 8.29)
	
Thu Jun 16 21:52:59 1983 by jkf
	fixed compilation of &aux for vax version.  Now &aux (foo foo)
	will work if foo is special.
	(now: version 8.28)
	
Wed May  4 18:32:46 1983 by layer
	added sun autorun header to io.l
	(now: version 8.27)

Thu Mar 24 08:24:53 1983 by jkf
	-x file will now be placed in the same place as the output
	file (instead of the input file).
	(now: version 8.25)
	
Sat Mar 19 17:49:18 1983 by jkf
	mixed in the 68k liszt source.
	(now: version 8.24)
	
Mon Mar 14 13:14:26 1983 by jkf
	liszt used to open code 'times' if all operands were fixnums.
	Thus (times 256 256 256 256) would open code to a 0 fixnum.
	This is clearly wrong and liszt will now not convert times, add,
	etc to their fixnum equivalents.  If you want fixnum semantics
	then you must use fixnums.
	Another bug was fixed: d-functyp would return the wrong thing
	give a name bound to a foreign function.  now it returns 'lambda.
	files affected: datab.l decl.l
	(now: version 8.23)
	
Tue Feb 22 08:43:44 1983 by jkf
	force jump to vecindexerr to use 'jmp', since the object
	file might be large and the assembler is stupid
	(now: version 8.22)
	
Thu Feb 10 20:39:42 1983 by jkf
	open coded vectorp and vectorip, vsize-...
	(now: version 8.21)
	
Thu Jan 20 01:57:01 1983 by layer
	Added three features to liszt command line processing:
	-e <expr> evaluates <expr> before compilation.
	-i <filename> loads <filename> before compilation.
	-S -o filename names .s file.
	file: tlev.l
	(now: version 8.20)
	
Mon Jan 17 09:41:12 1983 by jkf
	added arg number checking and open coded &keywords.
	(now: version 8.19)
	
Sun Jan 16 10:05:01 1983 by jkf
	fixed nasty bug in d-exp which would show up if a macro
	returned a recursive call it itself
	(now: version 8.18)
	
Wed Jan 12 10:43:53 1983 by jkf
	added open coding of vref functions
	(now: version 8.17)
	
Wed Oct 27 20:24:47 1982 by jkf
	removed references to sys_ functions, replaced them with
	sys: functions so code will be more portable.
	file: tlev.l
	
Wed Oct 27 08:15:14 1982 by jkf
	discovered that making 'declare' a function is a bad idea because
	if the compiler executes an interpreted function with local
	declarations, those local declarations will seem like declarations
	for the function begin compiled.   Thus declare is no longer a
	special function in the compiler: it must be seen by the compiler
	to have an effect.  Added the user callable function liszt-declare
	which will have an effect just like declare used to: the compiler
	will recognize it when compiling and it can be evaluated by a
	user function.
	(now: version 8.16)
	
Mon Oct 25 22:55:37 1982 by jkf
	removed If macro definition from cmacros.l . It is now in
	the default franz.
	
Mon Oct 25 09:15:18 1982 by jkf
	catch the sigterm signal and die after removing the /tmp file.
	(now: version 8.15)
	
Tue Oct 19 15:56:07 1982 by jkf
	fixed bugin cc-arg wherein a (arg (foo)) would be compiled
	incorrectly (it was calling zerop on a non number).
	Added checks for cmacro and macro-autoload properties.
	When doing macro expansion, had it stop if the same car
	was returned.
	(now: version 8.14)
	
Mon Oct 18 23:27:14 1982 by layer
	Fixed bug in function cc-quote.  Parens in an If statement
	were messed up.
	
Sat Oct  9 04:35:23 PDT 1982 by layer
	Np-reg, Lbot-reg, oLbot-reg are now constants.  Changes
	made to expr.l and io.l.

Thu Oct  7 01:02:26 1982 by jkf
	fixed bug in the compiler.  The compiler had neglected to enforce
	the rule that 'macros' not be defined as local functions.
	Now that is checked (modification to tlev.l).
	
Wed Oct  6 22:53:36 1982 by jkf
	added check to make sure that a file doesn't declare a function
	to be local that has already had a compiled call made to it.
	This is done by placing a t under indicator g-stdref for all
	symbols called in the 'standard' way.
	(now: version 8.13)
	
Wed Oct  6 13:29:27 PDT 1982 by layer
	put the loading of chead.l (in array.l datab.l decl.l expr.l
	fixnum.l funa.l funb.l func.l io.l tlev.l util.l) under
	include-if control.  Also changed chead.l.

Tue Oct  5 23:36:09 PDT 1982 by layer
	removed function d-call from expr.l, since it isn't
	used anymore.

Tue Oct  5 23:00:09 PDT 1982 by layer
	added sccs'ed file scmake.l, so that an all interp'd
	version of the compiler can be made without deleting
	all the .o files.  Changes were also make to the Makefile.
	snliszt (formerly slownliszt) now depends on source
	files (like nliszt depends on .o files).

Tue Oct  5 22:22:59 1982 by jkf
	added argument checking.  This involved mods to expr.l to
	do the checking and to tlev.l to save argument number
	info while compiling.  The file /usr/lib/lisp/fcninfo.l
	contains a description of what is known about C functions.
	(now: version 8.12)
	
Mon Oct  4 14:23:29 1982 by jkf
	turn off [load ...] message when loading in lisztrc file
	
Tue Sep 28 09:30:36 1982 by jkf
	change tmp file name back to jkfnnnnn
	(now: version 8.11)
	
Wed Jul 21 13:43:56 PDT 1982 by layer
	function "liszt" in tlev.l now returns the true assembler exit
	status (if the compile goes that far).

Sat Jul  3 18:01:25 1982 by jkf
	open code  getaux and getaccess
	(now: version 8.10)
	
Wed Jun 30 18:58:32 1982 by jkf
	look for liszt rc files without extensions.  now we look in 
	12 places for the lisp init file:
	  { . , $HOME } { .lisztrc , lisztrc } { .o , .l , }
	(now: version 8.09)
	
Thu May 27 08:19:00 1982 by jkf
	fixed bug in d-fixnump which caused liszt to assume too often that
	arguments are all fixnums
	(now: version 8.08)
	
Wed May 12 13:46:03 1982 by jkf
	new declaration scheme died when the object being declared
	was a list. e.g (declare (fixnum (foo fixnum flonum)).
	Fixed declare-handler so that cases like this are ignored.
	(now: version 8.07)

Fri May  7 19:28:04 1982 by jkf
	allow (function (nlambda ()...)) and (function (lambda () ..))
	(now: version 8.06)

Thu May  6 15:03:50 1982 by jkf
	support local declarations.  They are stacked on g-decls.
	localf and macarray don't fit in too well, they should
	be fixed.  
	fixnum declarations now have meaning.  They will allow the
	compiler to convert from functions like 'add1' to 1+.
	'declare' is now a function in the compiler so declarations
	may be fasl'ed in. [this was removed Oct 27, 1982]

Thu Apr 22 20:48:25 1982 by jkf
	#' returns a symbol now, instead of the getd of the symbol.
	This was required for maclisp compatibility.
	(now: version 8.05)

Wed Apr 21 07:50:41 1982 by jkf
	load in init file before compiling.  look in . first, then $HOME.
	look for .liszt.o, .lisztrc.l, lisztrc.o, lisztrc.l
	
	Upon interrupt, remove temp file and exit
	(now: version 8.04)

Mon Apr 12 23:22:37 1982 by jkf
	open code 'function'.  Now it will cause another function to be
	  generated and compiled and the function call returns the
	  bcd header for the newly created function
	liszt-process-forms may be filled with forms to compile while 
	  compiling a form.  Unlike liszt-eof-forms, liszt-process-forms
	  are compiled at the next opportunity.
	(now: version 8.03)
	
Wed Mar 31 08:47:46 1982 by jkf
	fixed bug in which (> (or nil 9) 0) would return true. cc-eq
	now rebinds g-trueop and g-falseop. (now: version 8.02)
	
Wed Mar 31 08:24:27 1982 by jkf
	added a new file to liszt: lversion.l   It is not sccsed and it 
	just contains the version number.  This will allow the version
    	number to be changed with ease whenever a modification is made.
	start it at 8.01  (now: version 8.01)

Fri Mar 19 11:17:12 1982 by jkf
	did distribution. (now: version 8.00)

Fri Feb 19 09:56:50 1982 by jkf
	fixed e-docomment so that newlines in the comment will not
	cause assembler problems [io.l]

Wed Feb 17 12:46:24 1982 by jkf
	to version 8.0 (to correspond with Opus 38)
	
Wed Feb 10 21:28:41 1982 by jkf
	fixed a bug in the return function and a possible bug in go.
	both bugs have to do with returning or going through a
	catch or errset, which is a pretty strange thing to do anyway.
	The fix was to keep track of the number of catches and errsets
	before the prog to be returned from or gone into.
	I modified d-pushframe to always push 3 args, so we can know
	how long each frame we pop will be.
Sat Dec  5 11:58:36 1981 by jkf
	open coded boole (mods to decl.l and funa.l).  used the open
	coding capability of fixnums.
	Added three internal functions fixnum-BitXor, fixnum-BitAndNot
	fixnum-BitOr, which are the three functions which the vax
	can do.
Mon Oct 26 21:15:36 1981 by jkf
	fixed bug in d-supercxr (funa.l) which made this function
	(cond ((setq y (cxr n zip)) (print 'hi))
	      (t (print 'lo)))
	always prints 'hi'.  The problem was that only jump on true was
	checked if the value of a cxr was stored somewhere.  In the case
	above we want to jump on nil.
	
Sat Oct 24 16:41:03 1981 by jkf
	-*- to version 7.1 -*-
	Added the 'a' option to liszt, which if set will cause a 
	special form to be output after a function is defined. that special
	form will put a 'fcn-info' property on the function's property 
	list.  the form of the fcn-info property is
	 (argdesc compileinfo)
	argdesc may be nil or (x . y), the later meaning that there are a 
	minumum of x args required and a maximum of y.  Currently lexprs
	just put 'nil' there, but soon I will introduce a way to declare
	min and max args for lexprs via a declare.  The compileinfo
	is a string saying what file this came from and when it was
	compiled.
	
Wed Oct 21 20:19:53 1981 by jkf
	added functions <&, =&, and >& which are fixnum only
	versions of <,= and >.  
	
Tue Oct 20 22:14:41 1981 by jkf
	fix < and > compiling so that they are only open coded if
	we can be sure that both operands are fixnums.  For now this
	amounts to checking that one of the operands is a fixnum.
	We should augment to this check also for type declarations.
	
Sat Oct 17 11:47:50 1981 by jkf
	since most fixnums are in the range 0 to 1023 we can probably
	win by doing inline checking in that range.  Thus I've added
	the function d-fixnumbox which does an inline reboxing if
	the number is between 0 and 1023 and otherwise calls qnewint.
	The file changed was fixnum.l
	
Thu Oct  8 23:35:34 1981 by jkf
	added cc-= to open code = if possible.  It looks for a fixnum
	as one of the arguments and converts the = expression to 
	(eq (cdr ..) (cdr ..)) which should do the trick.
	
EndOfFile
cat >  liszt/cmake.l  << 'EndOfFile'
; file which loads in all the object files and dumps them

; $Header: cmake.l,v 1.6 83/08/14 01:45:39 layer Exp $

;				-[Sat Aug 13 18:03:38 1983 by layer]-

;--- genl :: generate liszt
; args are unevalated.  first arg is the name of the liszt to build
; other args [optional]:  slow		- build interpreted.
;
(defun genl fexpr (args)
   (let ((dumpname (car args))
	 (slowp (memq 'slow (cdr args))))
      (load 'fcninfo)	; in /usr/lib/lisp (not normally in lisp)
      (if slowp then (load '../cmacros.l))
      (mapc '(lambda (name)
		(if slowp
		   then ; lisp source is in ..
			(load (concat "../" name ".l"))
		   else ; objects are in .
			(load name)))
	    '(decl array vector datab expr io funa funb func tlev
		   instr fixnum util lversion))
      (allocate 'list 400)
      (allocate 'fixnum 10)
      (allocate 'symbol 50)
      (sstatus translink on)
      (if slowp then (setq displace-macros t))
      (sstatus nofeature for-vax) ; remove memory of what it was compiled for
      (sstatus nofeature for-68k)
      ;indicate type of compiler (np and lbot in global registers)
      (setq $global-reg$ (not (status feature no-global-reg)))
      (putprop 'chead nil 'version)  ; so the compiler can compile itself
      (setq ER%tpl 'break-err-handler) ; in case we are using another tpl
      ; this is a temporary measure
      (apply 'dumplisp (list dumpname))))
EndOfFile
cat >  liszt/chead.l  << 'EndOfFile'
;;; ----	c h e a d		header file for inclusion

;$Header: chead.l,v 1.8 83/11/22 10:12:27 jkf Exp $
;
;			-[Tue Nov 22 08:32:26 1983 by jkf]-

; Copyright (c) 1982 ,  The Regents of the University of California.
; Copyright (c) 1980 ,  The Regents of the University of California.
; All rights reserved.  

; authors: John K. Foderaro and Kevin Layer

(putprop 'chead t 'version)	; flag that this file has been loaded

;--- build vax by default
;
(cond ((not (or (status feature for-vax) (status feature for-68k)))
       (sstatus feature for-vax)))

; global franz special variables
(declare (special $gcprint 	; t means print stats when  gc occurs.
		  $ldprint	; t means print fasl messages
		  $gccount$	; incremented every gc
		  $global-reg$	; t means that np and lbot are in global regs
		  float-format	; printf string used to print flonums
		  lisp-library-directory ; contains as assembler
		  lisp-object-directory  ; contains lisp for -r option
		  franz-minor-version-number ; just what it says
		  ))

; keep 'em sorted please!
(declare (special
	     Liszt-file-names
	     arithequiv
	     bnp-sym
	     ch-newline
	     compiler-name
	     er-fatal		;; # of fatal erros
	     er-warn		;; # of warnings
	     fl-anno
	     fl-asm
	     fl-comments
	     fl-inter
	     fl-macl
	     fl-profile
	     fl-tran
	     fl-tty
	     fl-verb
	     fl-vms
	     fl-warn
	     fl-xref
	     formsiz
	     g-allf
	     g-arginfo
	     g-args
	     g-arrayspecs
	     g-bindloc
	     g-bindtype
	     g-calltype
	     g-cc
	     g-comments
	     g-compfcn			; t if compiling a function
	     g-complrname
	     g-current
	     g-currentargs
	     g-decls
	     g-didvectorcode
	     g-dropnpcnt
	     g-falseop
	     g-flocal
	     g-fname
	     g-ftype
	     g-funcs
	     g-functype
	     g-ignorereg
	     g-labs
	     g-litcnt
	     g-lits
	     g-loc
	     g-localf
	     g-loccnt
	     g-locs
	     g-masklab
	     g-optionalp
	     g-reflst
	     g-refseen
	     g-regmaskvec
	     g-reguse
	     g-ret
	     g-skipcode
	     g-spec
	     g-stackspace
	     g-stdref
	     g-topsym
	     g-tran
	     g-tranloc
	     g-trancnt
	     g-trueloc
	     g-trueop
	     g-vartype
	     ibase
	     in-line-lambda-number
	     internal-macros
	     k-ftype
	     liszt-eof-forms
	     liszt-file-name
	     liszt-process-forms
	     liszt-root-name
	     macros
	     old-declare-fcn
	     old-top-level
	     original-readtable
	     piport
	     poport
	     readtable
	     special
	     twa-list
	     user-top-level
	     v-form
	     v-ifile
	     v-sfile
	     v-xfile
	     vms-pointers
	     vns-include
	     vp-sfile
	     vp-xfile
	     vps-include))

(eval-when (compile eval)
   (or (get 'const 'loaded) (load '../const.l)))

; load in the macro files if compiling or interpreting.
;
(eval-when (compile eval)
   (or (get 'cmacros 'version) (load 'cmacros)))
EndOfFile
cat >  liszt/cmacros.l  << 'EndOfFile'
;----------- macros for the compiler -------------

(setq RCS-cmacros
   "$Header: cmacros.l,v 1.13 83/11/22 10:12:22 jkf Exp $")

(declare (macros t))			; compile and save macros

; If we are making an interpreted version, then const.l hasn't been
; loaded yet...
(eval-when (compile eval)
   (or (get 'const 'loaded) (load '../const.l)))

;--- comp-err
;    comp-warn
;    comp-note
;    comp-gerr
; these are the compiler message producing macros.  The form is
; (comp-xxxx val1 val2 val3 ... valn) , all values are printed according
;  to this scheme. If vali is an atom, it is patomed, if vali is a
;  list, it is evaluated and printed. If vali is N a newline is printed
; 
; furthermore
;    the name of the current function is printed first
;    after comp-err prints the message, it does a throw to Comp-err .
;    errors are preceeded by Error: 
;	warnings by %Warning: and
;	notes by %Note:
;     The message is sent to the message file
;
(def comp-err
   (macro (l)
	  `(progn (comp-msg "?Error: " v-ifile ": " g-fname ": "
			    ,@(cdr l) )
		  (setq er-fatal (1+ er-fatal))
		  (throw nil Comp-error))))

(def comp-warn
   (macro (l)
	  `(progn (setq er-warn (1+ er-warn))
		  (cond (fl-warn
			    (comp-msg "%Warning: " v-ifile ": "  g-fname ": "
				      ,@(cdr l)))))))

(def comp-note
   (macro (l)
	  `(progn (cond (fl-verb
			    (comp-msg "%Note: " v-ifile ": "  ,@(cdr l)))))))

(def comp-gerr
   (macro (l)
	  `(progn (comp-msg
		      "?Error: " v-ifile ": " g-fname ": ",@(cdr l))
		  (setq er-fatal (1+ er-fatal)))))

;--- comp-msg - port
;	      - lst
;  prints the lst to the given port.  The lst is printed in the manner
; described above, that is atoms are patomed, and lists are evaluated
; and printed, and N prints a newline.   The output is always drained.
;
(def comp-msg
   (macro (lis)
	  (do ((xx (cdr lis) (cdr xx))
	       (res nil))
	      ((null xx)
	       `(progn ,@(nreverse (cons '(terpri) res))))
	      (setq res
		    (cons (cond ((atom (car xx))
				 (cond ((eq (car xx) 'N) '(terpr))
				       ((stringp (car xx)) `(patom ,(car xx)))
				       (t `(niceprint ,(car xx)))))
				(t `(niceprint ,(car xx))))
			  res)))))

(def niceprint
   (macro (l)
	  `((lambda (float-format) (patom ,(cadr l))) "%.2f")))

;--- standard push macro
; (Push stackname valuetoadd)

(defmacro Push (atm val)
  `(setq ,atm (cons ,val ,atm)))

;--- unpush macro - like pop except top value is thrown away
(defmacro unpush (atm)
  `(setq ,atm (cdr ,atm)))

;--- and an increment macro
(defmacro incr (atm)
  `(setq ,atm (1+ ,atm)))

(defmacro decr (atm)
  `(setq ,atm (1- ,atm)))

;--- add a comment
(defmacro makecomment (arg)
  `(cond (fl-comments (setq g-comments (cons ,arg g-comments)))))

;--- add a comment irregardless of the fl-comments flag
(defmacro forcecomment (arg)
  `(setq g-comments (cons ,arg g-comments)))

;--- write to the .s file
(defmacro sfilewrite (arg)
  `(patom ,arg vp-sfile))

(defmacro sfilewriteln (arg)
  `(msg (P vp-sfile) ,arg N))

;--- Liszt-file  :: keep track of rcs info regarding part of Liszt
;  This is put at the beginning of a file which makes up the lisp compiler.
; The form used is   (Liszt-file name rcs-string)
; where name is the name of this file (without the .l) and rcs-string.
;
(defmacro Liszt-file (name rcs-string)
   `(cond ((not (boundp 'Liszt-file-names))
	   (setq Liszt-file-names (ncons ,rcs-string)))
	  (t (setq Liszt-file-names
		   (append1 Liszt-file-names ,rcs-string)))))

(eval-when (compile eval load)
   (defun immed-const (x)
	  (get_pname (concat #+for-vax "$" #+for-68k "#" x))))

; Indicate that this file has been loaded, before
(putprop 'cmacros t 'version)

;-------- Instruction Macros

#+for-vax
(defmacro e-add (src dst)
   `(e-write3 'addl2 ,src ,dst))

#+for-vax
(defmacro e-sub (src dst)
   `(e-write3 'subl2 ,src ,dst))

#+for-vax
(defmacro e-cmp (src dst)
   `(e-write3 'cmpl ,src ,dst))

(defmacro e-tst (src)
   `(e-write2 'tstl ,src))

(defmacro e-quick-call (what)
   `(e-write2 #+for-vax "jsb" #+for-68k "jbsr" ,what))

;--- e-add3 :: add from two sources and store in the dest
;--- e-sub3 :: subtract from two sources and store in the dest

; WARNING:  if the destination is an autoincrement addressing mode, then
;	this will not work for the 68000, because multiple instructions
;	are generated:
;		(e-add3 a b "sp@+")
;	is
;		movl b,sp@+
;		addl a,sp@+	(or addql)
#+for-vax
(defmacro e-add3 (s1 s2 dest)
   `(e-write4 'addl3 ,s1 ,s2 ,dest))

#+for-68k
(defmacro e-add3 (s1 s2 dest)
   `(progn
       (e-write3 'movl ,s2 ,dest)
       (e-add ,s1 ,dest)))

#+for-vax
(defmacro e-sub3 (s1 s2 dest)
   `(e-write4 'subl3 ,s1 ,s2 ,dest))

#+for-68k
(defmacro e-sub3 (s1 s2 dest)
   `(progn
       (e-write3 'movl ,s2 ,dest)
       (e-sub ,s1 ,dest)))

(defmacro d-cmp (arg1 arg2)
  `(e-cmp (e-cvt ,arg1) (e-cvt ,arg2)))

(defmacro d-tst (arg)
  `(e-tst (e-cvt ,arg)))

;--- d-cmpnil :: compare an IADR to nil
;
(defmacro d-cmpnil (iadr)
   #+for-vax `(d-tst ,iadr)
   #+for-68k `(d-cmp 'Nil ,iadr))

(defmacro e-cmpnil (eiadr)
   #+for-vax `(break 'e-cmpnil)
   #+for-68k `(e-cmp (e-cvt 'Nil) ,eiadr))

(defmacro e-call-qnewint ()
   `(e-quick-call '_qnewint))

(defmacro C-push (src)
   #+for-68k `(e-move ,src '#.Cstack)
   #+for-vax `(e-write2 'pushl ,src))

(defmacro L-push (src)
   `(e-move ,src '#.np-plus))

(defmacro C-pop (dst)
   `(e-move '#.unCstack ,dst))

(defmacro L-pop (dst)
   `(e-move '#.np-minus ,dst))
EndOfFile
cat >  liszt/const.l  << 'EndOfFile'

;;; ----	c o n s t		header file for inclusion

;
;$Header: const.l,v 1.3 83/08/28 17:47:20 layer Exp $
;

(putprop 'const t 'loaded)	; flag that this file has been loaded

;--- parameters: these must be evaluated at compile time so readmacros will
; work
(eval-when (compile eval)
   (setq np-sym "_np"
	 lbot-sym "_lbot"
	 bnp-sym "_bnp"
	 ch-newline (ascii #\lf))
   #+for-vax
   (setq np-reg 'r6
	 lbot-reg 'r7
	 bind-reg 'r8
	 np-plus '(+ r6)
	 np-minus '(- r6)
	 bnp-reg 'r5
	 fixnum-reg 'r5
	 olbot-reg 'r10
	 nil-reg "*** this should never be used ***"
	 comment-char "#"
	 Cstack "-(sp)"
	 unCstack "(sp)+"
	 Nilatom "$0")
   #+for-68k
   (setq bnp-reg 'a1
	 np-reg 'a2
	 lbot-reg 'd3		; only for hacked version of 68k lisp
	 bind-reg 'a3
	 olbot-reg 'a4
	 fixnum-reg 'd2
	 nil-reg 'd7
	 np-plus '(+ a2)
	 np-minus '(- a2)
	 Nilatom "#_nilatom"
	 comment-char "|"
	 Cstack "sp@-"
	 unCstack "sp@+"))

;--- evaluation frame parameters.  These must correspond to what is 
; in h/frame.h in the C system
;
(eval-when (compile load eval)
  (setq C_GO 1   	C_RET 2   	C_THROW 3   	C_RESET 4)
  (setq F_PROG 1 	F_CATCH 2 	F_RESET 3))

; offsets in frame
(setq OF_olderrp 12)	; 12 bytes from base of error frame
EndOfFile
cat >  liszt/array.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file array
   "$Header: array.l,v 1.7 83/08/28 17:12:39 layer Exp $")

;;; ----	a r r a y			array referencing
;;;
;;;				-[Sat Aug  6 23:59:45 1983 by layer]-


;--- d-handlearrayref :: general array handler
; this function is called from d-exp when the car is an array (declare macarray)
; In the current array scheme, stores look like array references with one
; extra argument. Thus we must determine if we are accessing or storing in
; the array.
; Note that we must turn g-loc to reg and g-cc to nil since, even though
; d-supercxr handles g-loc and g-cc, d-superrplacx does not and we cannot
; know ahead of time which one we will use.  If this seems important,
; we can beef up d-superrplacx
;
(defun d-handlearrayref nil
  (let ((spec (get (car v-form) g-arrayspecs))
	expr
	(g-loc 'reg)  g-cc)

       (makecomment '(array ref))
       (if (eq (1+ (length (cdr spec))) (length (cdr v-form)))
	   then (d-dostore spec (cadr v-form) (cddr v-form))
	   else (setq expr (d-arrayindexcomp (cdr v-form) (cdr spec)))

	        (let ((v-form `(cxr ,expr (getdata (getd ',(car v-form))))))
		     (d-supercxr (car spec) nil)))))


;--- d-dostore :: store value in array.
;	spec - array descriptor from declare, e.g. (foo t 12 3 4)
;	value - expression to calculate value to be stored.
;	indexes - list of expressions which are the actual indicies.
;
(defun d-dostore (spec value indexes)
  (let (expr gen)
       (makecomment '(doing store))
       ; create an expression for doing index calculation.
       (setq expr (d-arrayindexcomp indexes (cdr spec))
	     gen  (gensym))

       ; calculate value to store and stack it.
       (d-pushargs (ncons value))
       (rplaca g-locs gen)	; name just stacked varib

       ; do the store operation.
       (let ((v-form `(rplacx ,expr (getdata (getd ',(car v-form)))
			      ,gen)))
	    (d-superrplacx (car spec)))

       ; move the value we stored into r0
       (d-move 'unstack 'reg)
       (setq g-locs (cdr g-locs))
       (decr g-loccnt)))




(defun d-arrayindexcomp (actual formal)
  (if (null (cdr actual))
      then (car actual)	; always allow one arg
   elseif  (eq (length actual) (length formal))
      then (do ((ac actual (cdr ac))
		(fo formal (cdr fo))
		(res))
	       ((null ac) (cons '+ res))
	       (setq res (cons (if (null (cdr fo)) then (car ac)
				   else `(* ,(car ac) ,(apply 'times (cdr fo))))
			       res)))
   else (comp-err "Wrong number of subscripts to array " actual)))
EndOfFile
cat >  liszt/datab.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file datab
   "$Header: datab.l,v 1.5 83/08/28 17:14:27 layer Exp $")

;;; ----	d a t a b			data base
;;;
;;;				-[Sat Aug  6 23:59:11 1983 by layer]-

;--- d-tranloc :: locate a function in the transfer table
;
; return the offset we should use for this function call
;
(defun d-tranloc (fname)
   (cond ((get fname g-tranloc))
	 (t (Push g-tran fname)
	    (let ((newval (* 8 g-trancnt)))
		(putprop fname newval g-tranloc)
		(incr g-trancnt)
		newval))))


;--- d-loc :: return the location of the variable or value in IADR form 
;	- form : form whose value we are to locate
;
; if we are given a xxx as form, we check yyy;
;	xxx		yyy
;     --------	     ---------
;	nil	     Nil is always returned
;	symbol	     return the location of the symbols value, first looking
;		     in the registers, then on the stack, then the bind list.
;		     If g-ingorereg is t then we don't check the registers.
;		     We would want to do this if we were interested in storing
;		     something in the symbol's value location.
;	number	     always return the location of the number on the bind
;		     list (as a (lbind n))
;	other	     always return the location of the other on the bind
;		     list (as a (lbind n))
;
(defun d-loc (form)
   (if (null form) then 'Nil
    elseif (numberp form) then
	 (if (and (fixp form) (greaterp form -1025) (lessp form 1024))
	     then `(fixnum ,form)		; small fixnum
	     else (d-loclit form nil))
    elseif (symbolp form) 
       then (if (and (null g-ignorereg) (car (d-bestreg form nil))) thenret
		else (if (d-specialp form) then (d-loclit form t)
			 else (do ((ll g-locs (cdr ll))	; check stack
				   (n g-loccnt))
				  ((null ll)
				   (comp-warn (or form)
					      " declared special by compiler")
				   (d-makespec form)
				   (d-loclit form t))
				  (if (atom (car ll))
				      then (if (eq form (car ll))
					       then (return `(stack ,n))
					       else (setq n (1- n)))))))
       else (d-loclit form nil)))


;--- d-loclit :: locate or add litteral to bind list
;	- form : form to check for and add if not present
;	- flag : if t then if we are given a symbol, return the location of
;		 its value, else return the location of the symbol itself
;
; scheme: we share the locations of atom (symbols,numbers,string) but always
;	 create a fresh copy of anything else.
(defun d-loclit (form flag)
   (prog (loc onplist symboltype)
       (if (null form) 
	   then (return 'Nil)
	elseif (symbolp form)
	   then (setq symboltype t)
		(cond ((setq loc (get form g-bindloc))
		       (setq onplist t)))
	elseif (atom form)
	   then (do ((ll g-lits (cdr ll))	; search for atom on list
		     (n g-litcnt (1- n)))
		    ((null ll))
		    (if (eq form (car ll))
			then (setq loc n)	; found it
			     (return))))	; leave do
       (if (null loc)
	   then (Push g-lits form)
		(setq g-litcnt (1+ g-litcnt)
		      loc g-litcnt)
		(cond ((and symboltype (null onplist))
		       (putprop form loc g-bindloc))))

       (return (if (and flag symboltype) then `(bind ,loc)
		   else `(lbind ,loc)))))
			     


;--- d-locv :: find the location of a value cell, and dont return a register
;
(defun d-locv (sm)
  (let ((g-ignorereg t))
       (d-loc sm)))


;--- d-simple :: see of arg can be addresses in one instruction
; we define simple and really simple as follows
;  <rsimple> ::= number
;		 quoted anything
;		 local symbol
;		 t
;		 nil
;  <simple>  ::= <rsimple>
;		 (cdr <rsimple>)
;		 global symbol
;
(defun d-simple (arg)
   (let (tmp)
       (if (d-rsimple arg) thenret
	elseif (atom arg) then (d-loc arg)
	elseif (and (memq (car arg) '(cdr car cddr cdar))
		    (setq tmp (d-rsimple (cadr arg))))
	   then (if (eq 'Nil tmp) then tmp
		 elseif (atom tmp)
		    then #+for-vax
			 (if (eq 'car (car arg))
			     then `(racc 4 ,tmp)
			  elseif (eq 'cdr (car arg))
			     then `(racc 0 ,tmp)
			  elseif (eq 'cddr (car arg))
			     then `(racc * 0 ,tmp)
			  elseif (eq 'cdar (car arg))
			     then `(racc * 4 ,tmp))
			 #+for-68k
			 (if (eq 'car (car arg))
			     then `(racc 4 ,tmp)
			  elseif (eq 'cdr (car arg))
			     then `(racc 0 ,tmp))
		 elseif (not (eq 'cdr (car arg)))
		    then nil
		 elseif (eq 'lbind (car tmp))
		    then `(bind ,(cadr tmp))
		 elseif (eq 'stack (car tmp))
		    then `(vstack ,(cadr tmp))
		 elseif (eq 'fixnum (car tmp))
		    then `(immed ,(cadr tmp))
		 elseif (atom (car tmp))
		    then `(0 ,(cadr tmp))
		    else (comp-err "bad arg to d-simple: " (or arg))))))

(defun d-rsimple (arg)
   (if (atom arg) then
       (if (null arg) then 'Nil
	elseif (eq t arg) then 'T
	elseif (or (numberp arg)
		   (memq arg g-locs)) 
	   then (d-loc arg)
	   else (car (d-bestreg arg nil)))
    elseif (eq 'quote (car arg)) then (d-loclit (cadr arg) nil)))

;--- d-specialp :: check if a variable is special
; a varible is special if it has been declared as such, or if
; the variable special is t
(defun d-specialp (vrb)
  (or special
      (eq 'special (d-findfirstprop vrb 'bindtype))   ; local special decl
      (eq 'special (get vrb g-bindtype))))

(defun d-fixnump (vrb)
   (and (symbolp vrb)
	(or (eq 'fixnum (d-findfirstprop vrb 'vartype))
	    (eq 'fixnum (get vrb g-vartype)))))

;--- d-functyp :: return the type of function
;	- name : function name
;
; If name had a macro function definition, we return `macro'.  Otherwise
; we see if name as a declared type, if so we return that.  Otherwise
; we see if name is defined and we return that if so, and finally if
; we have no idea what this function is, we return lambda.
;   This is not really satisfactory, but will handle most cases.
;
; If macrochk is nil then we don't check for the macro case.  This
; is important to prevent recursive macroexpansion.
;
(defun d-functyp (name macrochk)
   (let (func ftyp)
      (if (atom name) 
	 then
	      (setq func (getd name))
	      (setq ftyp (if (and macrochk (get name 'cmacro)) ;compiler macro
			    then 'cmacro
			  elseif (bcdp func)
			    then (let ((type (getdisc func)))
				    (if (memq type '(lambda nlambda macro))
				       then type
				     elseif (stringp type)
				       then 'lambda	; foreign function
				       else (comp-warn
					       "function "
					       name
					       " has a strange discipline "
					       type)
					    'lambda	; assume lambda
				    ))
			  elseif (dtpr func)
			    then (car func)
			  elseif (and macrochk (get name 'macro-autoload))
			    then 'macro))
	      (if (memq ftyp '(macro cmacro)) then ftyp
	       elseif (d-findfirstprop name 'functype) thenret
	       elseif (get name g-functype) thenret  ; check if declared first
	       elseif ftyp thenret
		 else 'lambda)
	 else 'lambda)))		; default is lambda

;--- d-allfixnumargs :: check if all forms are fixnums
; make sure all forms are fixnums or symbols whose declared type are fixnums
;
(defun d-allfixnumargs (forms)
   (do ((xx forms (cdr xx))
	(arg))
       ((null xx) t)
       (cond ((and (fixp (setq arg (car xx))) (not (bigp arg))))
	     ((d-fixnump arg))
	     (t (return nil)))))

	      
(defun d-findfirstprop (name type)
   (do ((xx g-decls (cdr xx))
	(rcd))
       ((null xx))
       (if (and (eq name (caar xx))
		(get (setq rcd (cdar xx)) type))
	  then (return rcd))))

	      


EndOfFile
cat >  liszt/decl.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file decl
   "$Header: decl.l,v 1.8 83/08/28 17:13:00 layer Exp $")

;;; ----	d e c l		declaration handling
;;;
;;;				-[Sat Aug  6 23:58:35 1983 by layer]-


(setq original-readtable readtable)
(setq raw-readtable (makereadtable t))

;--- compile-fcn  :: declare a open coded function
; name - name of the function
; fcnname - function to be funcall'ed to handle the open coding
; indicator -  describes what the fcnname will do, one of
;		fl-expr : will compile the expression and leave the
;			result in r0.  Will ignore g-cc and g-loc
;		fl-exprcc: will compile the expression and leave the
;			result in g-loc.  Will handle g-cc
;		fl-exprm: will just return another form to be d-exp'ed
; args - (optional) description of the arguments to this function.
;	form: (min-args . max-args) .  If max-args is nil, then there is
;		no max.  This is usually done in /usr/lib/lisp/fcninfo.l.
;
(defmacro compile-fcn (name fcnname indicator &optional (args nil args-p))
   `(progn (putprop ',name ',fcnname ',indicator)
	   ;; don't do this here, done in fcn-info
	   ,@(cond (args-p `((putprop ',name (list ',args) 'fcn-info))))))

	   
;--- special handlers
(compile-fcn and	cc-and		fl-exprcc)
(compile-fcn arg  	cc-arg		fl-exprcc)
(compile-fcn assq 	cm-assq		fl-exprm)
(compile-fcn atom 	cc-atom		fl-exprcc)
(compile-fcn bigp	cc-bigp		fl-exprcc)
(compile-fcn bcdcall	c-bcdcall	fl-expr)
(compile-fcn Internal-bcdcall c-Internal-bcdcall fl-expr)
(compile-fcn bcdp	cc-bcdp		fl-exprcc)
#+for-vax
(compile-fcn boole 	c-boole		fl-expr)
(compile-fcn *catch	c-*catch 	fl-expr)
(compile-fcn comment	cc-ignore	fl-exprcc)
(compile-fcn cond	c-cond  	fl-expr)
(compile-fcn cons	c-cons		fl-expr)
(compile-fcn cxr 	cc-cxr		fl-exprcc)
(compile-fcn declare	c-declare	fl-expr)
(compile-fcn do		c-do     	fl-expr)
(compile-fcn liszt-internal-do 	c-do   	fl-expr)
(compile-fcn dtpr	cc-dtpr		fl-exprcc)
(compile-fcn eq		cc-eq    	fl-exprcc)
(compile-fcn equal 	cc-equal	fl-exprcc)
(compile-fcn errset 	c-errset 	fl-expr)
(compile-fcn fixp	cc-fixp		fl-exprcc)
(compile-fcn floatp	cc-floatp	fl-exprcc)
(compile-fcn funcall	c-funcall 	fl-expr)
(compile-fcn function	cc-function 	fl-exprcc)
(compile-fcn get	c-get		fl-expr)
(compile-fcn getaccess  cm-getaccess    fl-exprm)
(compile-fcn getaux	cm-getaux 	fl-exprm)
(compile-fcn getd 	cm-getd 	fl-exprm)
(compile-fcn getdata	cm-getdata 	fl-exprm)
(compile-fcn getdisc	cm-getdisc 	fl-exprm)
(compile-fcn go		c-go	  	fl-expr)
(compile-fcn list	c-list	  	fl-expr)
(compile-fcn map	cm-map	  	fl-exprm)
(compile-fcn mapc	cm-mapc  	fl-exprm)
(compile-fcn mapcan 	cm-mapcan 	fl-exprm)
(compile-fcn mapcar 	cm-mapcar 	fl-exprm)
(compile-fcn mapcon	cm-mapcon 	fl-exprm)
(compile-fcn maplist	cm-maplist 	fl-exprm)
(compile-fcn memq	cc-memq		fl-exprcc)
(compile-fcn ncons	cm-ncons	fl-exprm)
(compile-fcn not	cc-not   	fl-exprcc)
(compile-fcn null	cc-not   	fl-exprcc)
(compile-fcn numberp	cc-numberp	fl-exprcc)
(compile-fcn or		cc-or    	fl-exprcc)
(compile-fcn prog	c-prog   	fl-expr)
(compile-fcn progn	cm-progn 	fl-exprm)
(compile-fcn prog1 	cm-prog1	fl-exprm)
(compile-fcn prog2	cm-prog2 	fl-exprm)
(compile-fcn progv 	c-progv		fl-expr)
(compile-fcn quote	cc-quote 	fl-exprcc)
(compile-fcn return 	c-return 	fl-expr)
(compile-fcn rplaca 	c-rplaca 	fl-expr)
(compile-fcn rplacd 	c-rplacd 	fl-expr)
(compile-fcn rplacx 	c-rplacx 	fl-expr)
(compile-fcn *rplacx 	c-rplacx 	fl-expr)
(compile-fcn setarg 	c-setarg	fl-expr)
(compile-fcn setq	cc-setq  	fl-exprcc)
(compile-fcn stringp 	cc-stringp 	fl-exprcc)
(compile-fcn symbolp 	cc-symbolp	fl-exprcc)
(compile-fcn symeval 	cm-symeval	fl-exprm)
(compile-fcn *throw 	c-*throw 	fl-expr)
(compile-fcn typep   	cc-typep	fl-exprcc)
(compile-fcn vectorp   	cc-vectorp	fl-exprcc)
(compile-fcn vectorip  	cc-vectorip	fl-exprcc)
(compile-fcn vset	cc-vset 	fl-exprcc)
(compile-fcn vseti-byte cc-vseti-byte 	fl-exprcc)
(compile-fcn vseti-word cc-vseti-word 	fl-exprcc)
(compile-fcn vseti-long cc-vseti-long 	fl-exprcc)
(compile-fcn vref	cc-vref 	fl-exprcc)
(compile-fcn vrefi-byte cc-vrefi-byte 	fl-exprcc)
(compile-fcn vrefi-word cc-vrefi-word 	fl-exprcc)
(compile-fcn vrefi-long cc-vrefi-long 	fl-exprcc)
(compile-fcn vsize	c-vsize		fl-expr)
(compile-fcn vsize-byte	c-vsize-byte	fl-expr)
(compile-fcn vsize-word	c-vsize-word	fl-expr)

(compile-fcn zerop   	cm-zerop	fl-exprm)
; functions which expect fixnum operands 


(compile-fcn + c-fixnumop  fl-expr)
#+for-vax (putprop '+ 'addl3 'fixop)
#+for-68k (putprop '+ 'addl 'fixop)

(compile-fcn - c-fixnumop fl-expr)
#+for-vax (putprop '- 'subl3 'fixop)
#+for-68k (putprop '- 'subl 'fixop)

#+for-vax
(progn 'compile
   (compile-fcn * c-fixnumop fl-expr)
   (putprop '* 'mull3 'fixop)

   (compile-fcn / c-fixnumop fl-expr)
   (putprop '/ 'divl3 'fixop))

;-- boole's derivatives
#+for-vax
(progn 'compile
   (compile-fcn fixnum-BitOr c-fixnumop fl-expr)
   (putprop 'fixnum-BitOr 'bisl3 'fixop)

   (compile-fcn fixnum-BitAndNot c-fixnumop fl-expr)
   (putprop 'fixnum-BitAndNot 'bicl3 'fixop)

   (compile-fcn fixnum-BitXor c-fixnumop fl-expr)
   (putprop 'fixnum-BitXor 'xorl3 'fixop))

(compile-fcn 1+ 	cc-oneplus  fl-exprcc)
(compile-fcn 1-		cc-oneminus fl-exprcc)

#+for-vax
(compile-fcn \\	c-\\	fl-expr)   ; done in the old way, should be modified

; these have typically fixnum operands, but not always 


; these without the & can be both fixnum or both flonum
;
(compile-fcn 	< 	cm-< 	fl-exprm)
(compile-fcn 	<& 	cc-<& 	fl-exprcc)

(compile-fcn 	> 	cm-> 	fl-exprm)
(compile-fcn 	>& 	cc->& 	fl-exprcc)

(compile-fcn 	= 	cm-=		fl-exprm)
(compile-fcn 	=&	cm-=&		fl-exprm)

; functions which can only be compiled
(compile-fcn assembler-code c-assembler-code fl-expr)
(compile-fcn fixnum-cxr cm-fixnum-cxr fl-exprm)
(compile-fcn internal-fixnum-box c-internal-fixnum-box fl-expr)
(compile-fcn offset-cxr cc-offset-cxr fl-exprcc)
(compile-fcn internal-bind-vars c-internal-bind-vars fl-expr)
(compile-fcn internal-unbind-vars c-internal-unbind-vars fl-expr)

; functions which can be converted to fixnum functions if
; proper declarations are done
(mapc
   '(lambda (arg) (putprop (car arg) (cdr arg) 'if-fixnum-args))
   '((lessp . <&) (greaterp . >&) (= . =&) (equal . =&)))
     

;--- doevalwhen, process evalwhen directive. This is inadequate.
;
(def doevalwhen 
      (lambda (v-f)
	      (prog (docom dolod)
		    (setq docom (memq 'compile (cadr v-f))
			  
			  dolod (memq 'load (cadr v-f)))
		    (mapc '(lambda (frm) (cond (docom (eval frm)))
					 (cond (dolod 
						((lambda (internal-macros) 
							 (liszt-form frm))
						 t))))
			  (cddr v-f)))))


;---- declare - the compiler version of the declare function
;	process the declare forms given. We evaluate each arg
;
(defun liszt-declare fexpr (forms)
   (cond ((status feature complr)
	  (do ((i forms (cdr i)))
	      ((null i))
	      (cond ((and (atom (caar i))
			  (getd (caar i)))
		     (eval (car i))) ; if this is a function
		    (t (comp-warn "Unknown declare attribute: " (car i))))))))

;---> handlers for declare forms
; declaration information for declarations which occur outside of
; functions is stored on the property list for rapid access.
; The indicator to look under is the value of one of the symbols:
;	g-functype, g-vartype, g-bindtype, or g-calltype
;  The value of the property is the declared function, declaration, binding
;	or call type for that variable.
; For local declarations, the information is kept on the g-decls stack.
; It is an assq list, the car of which is the name of the variable or
; function name, the cdr of which is the particular type.  To tell
; whether the particular type is a function type declaration, check the
; property list of the particular type for a 'functype' indicator.
; Likewise, to see if a particular type is a variable declaration, look
; for a 'vartype' indicator on the particular type's property list.
;
(defmacro declare-handler (args name type toplevind)
   `(mapc '(lambda (var)
	      (cond ((symbolp var)
		     (cond (g-compfcn	; if compiling a function
			      (Push g-decls (cons var ',name)))
			   (t          ; if at top level
			      (putprop var ',name ,toplevind))))))
	  ,args))

   
(defun *fexpr fexpr (args)
   (declare-handler args nlambda functype g-functype))

(defun nlambda fexpr (args)
   (declare-handler args nlambda functype g-functype))

(defun *expr fexpr (args)
   (declare-handler args lambda functype g-functype))

(defun lambda fexpr (args)
   (declare-handler args lambda functype g-functype))

(defun *lexpr fexpr (args)
   (declare-handler args lexpr functype g-functype))

(defun special fexpr (args)
   (declare-handler args special bindtype g-bindtype))

(defun unspecial fexpr (args)
   (declare-handler args unspecial bindtype g-bindtype))

(defun fixnum fexpr (args)
   (declare-handler args fixnum vartype g-vartype))

(defun flonum fexpr (args)
   (declare-handler args flonum vartype g-vartype))

(defun notype fexpr (args)
   (declare-handler args notype vartype g-vartype))



;--- special case, this is only allowed at top level.  It will
; be removed when vectors are fully supported
(def macarray 
  (nlambda (v-l)
	   (mapc '(lambda (x)
			  (if (dtpr x)
			      then (putprop (car x) (cdr x) g-arrayspecs)
				   (putprop (car x) 'array  g-functype)
			      else (comp-err "Bad macerror form" x)))
		 v-l)))


(def macros 
  (nlambda (args) (setq macros (car args))))

(def specials
  (nlambda (args) (setq special (car args))))

;--- *args
; form is (declare (*args minargs maxargs))
; this must occur within a function definition or it is an error
;
(def *args
   (nlambda (args)
	    (if (not g-compfcn)
	       then (comp-err
		       " *args declaration not given within a function definition "
		       args))
	    (let (min max)
	       (if (not (= (length args) 2))
		  then (comp-err " *args declaration must have two args: "
				 args))
	       (setq min (car args) max (cadr args))
	       (if (not (and (or (null min) (fixp min))
			     (or (null max) (fixp max))))
		  then (comp-err " *args declaration has illegal values: "
				 args))
	       (setq g-arginfo (cons min max))
	       (putprop g-fname (list g-arginfo) 'fcn-info))))

;--- *arginfo
; designed to be used at top level, but can be used within  function
; form: (declare (*arginfo (append 2 nil) (showstack 0 1)))
;
(def *arginfo
   (nlambda (args)
      (do ((xx args (cdr xx))
	   (name)
	   (min)
	   (max))
	  ((null xx))
	  (if (and (dtpr (car xx))
		   (eq (length (car xx)) 3))
	     then (setq name (caar xx)
			min  (cadar xx)
			max  (caddar xx))
		  (if (not (and (symbolp name)
				(or (null min) (fixp min))
				(or (null max) (fixp max))))
		     then (comp-err " *arginfo, illegal declaration "
				    (car xx))
		     else (putprop name (list (cons min max)) 'fcn-info))))))
						    
   
;--- another top level only.
;
(def localf
  (nlambda (args)
     (mapc '(lambda (ar)
	       (if (null (get ar g-localf))
		  then (putprop ar
				(cons (d-genlab) -1)
				g-localf))
	       (if (get ar g-stdref)
		  then (comp-err
			 "function " ar " is being declared local" N
		       " yet it has already been called in a non local way")))
	   args)))

; g-decls is a stack of forms like
;  ((foo . special) (bar . fixnum) (pp . nlambda))
; there are 4 types of cdr's:
;	function types (lambda, nlambda, lexpr)
;	variable types (fixnum, flonum, notype)
;	call types     (localf, <unspecified>)
;	bind types     (special, unspecial)
;
(mapc '(lambda (x) (putprop x t 'functype)) '(lambda nlambda lexpr))
(mapc '(lambda (x) (putprop x t 'vartype))  '(fixnum flonum notype))
(mapc '(lambda (x) (putprop x t 'calltype)) '(localf))
(mapc '(lambda (x) (putprop x t 'bindtype)) '(special unspecial))

;---> end declare form handlers






;--- d-makespec :: declare a variable to be special
;
(defun d-makespec (vrb)
  (putprop vrb 'special g-bindtype))
EndOfFile
cat >  liszt/expr.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file expr
   "$Header: expr.l,v 1.12 83/09/06 21:46:46 layer Exp $")

;;; ----	e x p r				expression compilation
;;;
;;;				-[Fri Sep  2 22:10:20 1983 by layer]-


;--- d-exp :: compile a lisp expression
;	v-form : a lisp expression to compile
; returns an IADR which tells where the value was located.
;

(defun d-exp (v-form)
  (prog (first resloc tmp ftyp nomacrop)
    begin
	(if (atom v-form)
	    then (setq tmp (d-loc v-form))		;locate vrble
		 (if (null g-loc)
		     then (if g-cc then (d-cmpnil tmp))
		    else (d-move tmp g-loc)
			 #+for-68k (if g-cc then (d-cmpnil tmp)))
		 (d-handlecc)
		 (return tmp)

	 elseif (atom (setq first (car v-form)))
	   then ; the form (*no-macroexpand* <expr>)
		; turns into <expr>, and prevents <expr> from
		; being macroexpanded (at the top level)
		(if (eq '*no-macroexpand* first)
		   then (setq v-form (cadr v-form)
			      nomacrop t)
			(go begin))
		(if (and fl-xref (not (get first g-refseen)))
		     then (Push g-reflst first)
			  (putprop first t g-refseen))
	         (setq ftyp (d-functyp first (if nomacrop then nil
						else 'macros-ok)))
		 ; if nomacrop is t, then under no circumstances
		 ; permit the form to be macroexpanded
		 (if (and nomacrop (eq ftyp 'macro))
		     then (setq ftyp 'lambda))
		 ; If the resulting form is type macro or cmacro,
		 ; then call the appropriate function to macro-expand
		 ; it.
		 (if (memq ftyp '(macro cmacro))
		    then (setq tmp v-form)	; remember original form
			 (if (eq 'macro ftyp)
			     then (setq v-form (apply first v-form))
			   elseif (eq 'cmacro ftyp)
			     then (setq v-form (apply (get first 'cmacro)
						      v-form)))
			  ; If the resulting form is the same as
			  ; the original form, then we don't want to
			  ; macro expand again.  We call d-functyp and tell
			  ; it that we want a second opinion
			  (if (and (eq (car v-form) first)
				   (equal tmp v-form))
			     then (setq ftyp (d-functyp first nil))
			     else (go begin))) ; retry with what we have

		 (if (and (setq tmp (get first 'if-fixnum-args))
			      (d-allfixnumargs (cdr v-form)))
		    then (setq v-form (cons tmp (cdr v-form)))
			 (go begin)
		  elseif (setq tmp (get first 'fl-exprcc))
		    then (d-argnumchk 'hard)
			 (return (funcall tmp))
		  elseif (setq tmp (get first 'fl-exprm))
		    then (d-argnumchk 'hard)
			 (setq v-form (funcall tmp))
			 (go begin)
		  elseif (setq tmp (get first 'fl-expr))
		    then (d-argnumchk 'hard)
			 (funcall tmp)
		  elseif (setq tmp (or (and (eq 'car first)
					    '( a ))
				       (and (eq 'cdr first)
					    '( d ))
				       (d-cxxr first)))
		    then (d-argcheckit '(1 . 1) (length (cdr v-form)) 'hard)
			 (return (cc-cxxr (cadr v-form) tmp))
		   elseif (eq 'nlambda ftyp)
		    then (d-argnumchk 'soft)
			 (d-callbig first `(',(cdr v-form)) nil)
		   elseif (or (eq 'lambda ftyp) (eq 'lexpr ftyp))
		     then (setq tmp (length v-form))
		     	  (d-argnumchk 'soft)
			  (d-callbig first (cdr v-form) nil)
		   elseif (eq 'array ftyp)
		    then (d-handlearrayref)
		  elseif (eq 'macro ftyp)
		    then (comp-err "infinite macro expansion " v-form)
		    else (comp-err "internal liszt err in d-exp" v-form))

	 elseif (eq 'lambda (car first))
	    then (c-lambexp)

	 elseif (or (eq 'quote (car first)) (eq 'function (car first)))
	    then (comp-warn "bizzare function name " (or first))
		 (setq v-form (cons (cadr first) (cdr v-form)))
		 (go begin)
		
	 else (comp-err "bad expression" (or v-form)))

	(if (null g-loc)
	    then (if g-cc then (d-cmpnil 'reg))
	 elseif (memq g-loc '(reg #+for-vax r0 #+for-68k d0))
	    then (if g-cc then (d-cmpnil 'reg))
	   else (d-move 'reg g-loc)
		#+for-68k (if g-cc then (d-cmpnil 'reg)))
	(if g-cc then (d-handlecc))))

;--- d-exps :: compile a list of expressions
;	- exps : list of expressions
; the last expression is evaluated according to g-loc and g-cc, the others
; are evaluated with g-loc and g-cc nil.
;
(defun d-exps (exps)
  (d-exp (do ((ll exps (cdr ll))
	      (g-loc nil)
	      (g-cc  nil)
	      (g-ret nil))
	     ((null (cdr ll)) (car ll))
	     (d-exp (car ll)))))


;--- d-argnumchk :: check that the correct number of arguments are given
; v-form (global) contains the expression to check
; class: hard or soft, hard means that failure is an error, soft means
;	warning
(defun d-argnumchk (class)
   (let ((info (car (get (car v-form) 'fcn-info)))
	 (argsize (length (cdr v-form))))
      (if info then (d-argcheckit info argsize class))))

;--- d-argcheckit
; info - arg information form:  (min# . max#)  max# of nil means no max
; numargs - number of arguments given
; class - hard or soft
; v-form(global) - expression begin checked
;
(defun d-argcheckit (info numargs class)
   (if (and (car info) (< numargs (car info)))
      then (if (eq class 'hard)
	      then (comp-err
		      (difference (car info) numargs)
		      " too few argument(s) given in this expression:" N
		      v-form)
	      else (comp-warn
		      (difference (car info) numargs)
		      " too few argument(s) given in this expression:" N
		      v-form))
    elseif (and (cdr info) (> numargs (cdr info)))
      then (if (eq class 'hard)
	      then (comp-err
		      (difference numargs (cdr info))
		      " too many argument(s) given in this expression:" N
		      v-form)
	      else (comp-warn
		      (difference numargs (cdr info))
		      " too many argument(s) given in this expression:" N
		      v-form))))

;--- d-pushargs :: compile and push a list of expressions
;	- exps : list of expressions
; compiles and stacks a list of expressions
;
(defun d-pushargs (args)
   (if args then
       (do ((ll args (cdr ll))
	    (g-loc 'stack)
	    (g-cc nil)
	    (g-ret nil))
	   ((null ll))
	   (d-exp (car ll))
	   (push nil g-locs)
	   (incr g-loccnt))))

;--- d-cxxr :: split apart a cxxr function name
;	- name : a possible cxxr function name
; returns the a's and d's between c and r in reverse order, or else
;  returns nil if this is not a cxxr name
;
(defun d-cxxr (name)
  (let ((expl (explodec name)))
       (if (eq 'c (car expl))			; must begin with c
	   then (do ((ll (cdr expl) (cdr ll))
		     (tmp)
		     (res))
		    (nil)
		    (setq tmp (car ll))
		    (if (null (cdr ll))	
			then (if (eq 'r tmp)	; must end in r
				 then (return res)
				 else (return nil))
		     elseif (or (eq 'a tmp)	; and contain only a's and d's
				(eq 'd tmp))
			then (setq res (cons tmp res))
		     else (return nil))))))


;--- d-callbig :: call a local, global or bcd  function	
;
; name is the name of the function we are to call
; args are the arguments to evaluate and call the function with
; if bcdp is t then we are calling through a binary object and thus
; name is ingored.
;
#+for-vax
(defun d-callbig (name args bcdp)
  (let ((tmp (get name g-localf))
	c)
       (forcecomment `(calling ,name))
       (if (d-dotailrecursion name args) thenret
        elseif tmp then ;-- local function call
		    (d-pushargs args)
		    (e-quick-call (car tmp))
		    (setq g-locs (nthcdr (setq c (length args)) g-locs))
		    (setq g-loccnt (- g-loccnt c))
	else (if bcdp 		;-- bcdcall
		 then (d-pushargs args)
		      (setq c (length args))
		      (d-bcdcall c)
	       elseif fl-tran	;-- transfer table linkage
	         then (d-pushargs args)
		    (setq c (length args))
		    (d-calltran name c)
		    (putprop name t g-stdref)	; remember we've called this
	       else ;--- shouldn't get here
		    (comp-err " bad args to d-callbig : "
			      (or name args)))
	     (setq g-locs (nthcdr c g-locs))
	     (setq g-loccnt (- g-loccnt c)))
       (d-clearreg)))

#+for-68k
(defun d-callbig (name args bcdp)
  (let ((tmp (get name g-localf))
	c)
       (forcecomment `(calling ,name))
       (if (d-dotailrecursion name args)
	   thenret
        elseif tmp then ;-- local function call
		    (d-pushargs args)
		    (setq c (length args))
		    (if (null $global-reg$) then
			(e-write3 'lea `(,(* -4 c) #.np-reg) 'a5)
			(e-move 'a5 '#.lbot-sym)
			(e-move '#.np-reg '#.np-sym))
		    (e-quick-call (car tmp))
		    (setq g-locs (nthcdr c g-locs))
		    (setq g-loccnt (- g-loccnt c))
	else (if bcdp 		;-- bcdcall
		 then (d-pushargs args)
		      (setq c (length args))
		      (d-bcdcall c)
	       elseif fl-tran	;-- transfer table linkage
	         then (d-pushargs args)
		    (setq c (length args))
		    (d-calltran name c)
		    (putprop name t g-stdref)	; remember we've called this
	       else ;--- shouldn't get here
		    (comp-err " bad args to d-callbig : "
			      (or name args)))
	     (setq g-locs (nthcdr c g-locs))
	     (setq g-loccnt (- g-loccnt c)))
       (d-clearreg)))

;--- d-calltran :: call a function through the transfer table
;  name - name of function to call
;  c - number of arguments to the function
;
#+for-vax
(defun d-calltran (name c)
   (if $global-reg$
       then (e-write3 'movab `(,(* -4 c) #.np-reg) '#.lbot-reg)
       else (e-write3 'movab `(,(* -4 c) #.np-reg) '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-write3 'calls '$0 (concat "*trantb+" (d-tranloc name)))
   (if $global-reg$
       then (e-move '#.lbot-reg '#.np-reg)
       else (e-write3 'movab `(,(* -4 c) #.np-reg) '#.np-reg)))

#+for-68k
(defun d-calltran (name c)
   (if $global-reg$
       then (e-write3 'lea `(,(* -4 c) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-reg)
       else (e-write3 'lea `(,(* -4 c) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-move (concat "trantb+" (d-tranloc name)) 'a5)
   (e-quick-call '(0 a5))
   (if $global-reg$
       then (e-move '#.lbot-reg '#.np-reg)
       else (e-write3 'lea `(,(* -4 c) #.np-reg) '#.np-reg)))

;--- d-calldirect :: call a function directly
;
;  name - name of a function in the C code (known about by fasl)
;    c  - number of args
;
#+for-vax
(defun d-calldirect (name c)
   (if $global-reg$
       then (e-write3 'movab `(,(* -4 c) #.np-reg) '#.lbot-reg)
       else (e-write3 'movab `(,(* -4 c) #.np-reg) '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-write3 'calls '$0  name)
   (if $global-reg$
       then (e-move '#.lbot-reg '#.np-reg)
       else (e-write3 'movab `(,(* -4 c) #.np-reg) '#.np-reg)))

#+for-68k
(defun d-calldirect (name c)
   (if $global-reg$
       then (e-write3 'lea `(,(* -4 c) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-reg)
       else (e-write3 'lea `(,(* -4 c) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-quick-call name)
   (if $global-reg$
       then (e-move '#.lbot-reg '#.np-reg)
       else (e-write3 'lea `(,(* -4 c) #.np-reg) '#.np-reg)))

;--- d-bcdcall :: call a function through a binary data object
;  
; at this point the stack contains n-1 arguments and a binary object which
; is the address of the compiled lambda expression to go to.  We set
; up lbot right above the binary on the stack and call the function.
;
#+for-vax
(defun d-bcdcall (n)
   (if $global-reg$
       then (e-write3 'movab `(,(* -4 (- n 1)) #.np-reg) '#.lbot-reg)
       else (e-write3 'movab `(,(* -4 (- n 1)) #.np-reg) '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-move  `(* ,(* -4 n) #.np-reg) 'r0)    ;get address to call to
   (e-write3 'calls '$0 "(r0)")
   (if $global-reg$
       then (e-write3 'movab '(-4 #.lbot-reg) '#.np-reg)
       else (e-write3 'movab `(,(* -4 n) #.np-reg) '#.np-reg)))

#+for-68k
(defun d-bcdcall (n)
   (if $global-reg$
       then (e-write3 'lea `(,(* -4 (- n 1)) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-reg)
       else (e-write3 'lea `(,(* -4 (- n 1)) #.np-reg) 'a5)
	    (e-move 'a5 '#.lbot-sym)
	    (e-move '#.np-reg '#.np-sym))
   (e-move `(,(* -4 n) #.np-reg) 'a5)	; get address to call to
   (e-move `(0 a5) 'a5)
   (e-quick-call '(0 a5))
   (if $global-reg$
       then (e-move '#.lbot-reg 'a5)
	    (e-write3 'lea '(-4 a5) '#.np-reg)
       else (e-write3 'lea `(,(* -4 n) #.np-reg) '#.np-reg)))

;--- d-dotailrecursion :: do tail recursion if possible
; name - function name we are to call
; args - arguments to give to function
;
; return t iff we were able to do tail recursion
; We can do tail recursion if:
;  g-ret is set indicating that the result of this call will be returned
;	 as the value of the function we are compiling
;  the function we are calling, name, is the same as the function we are
;	 compiling, g-fname
;  there are no variables shallow bound, since we would have to unbind
;	 them, which may cause problems in the function.
;
(defun d-dotailrecursion (name args)
   (prog (nargs lbot)
       (if (null (and g-ret
		      (eq name g-fname)
		      (do ((loccnt 0)
			   (ll g-locs (cdr ll)))
			  ((null ll) (return t))
			  (if (dtpr (car ll))
			      then (if (or (eq 'catcherrset (caar ll))
					   (greaterp (cdar ll) 0))
				       then (return nil))
			      else (incr loccnt)))))
	   then (return nil))

       (makecomment '(tail merging))
       (comp-note g-fname ": Tail merging being done: " v-form)

       (setq nargs (length args))
       
       ; evalate the arguments, putting them above the arguments to the
       ; function we are executing...
       (let ((g-locs g-locs)
	     (g-loccnt g-loccnt))
	   (d-pushargs args))

       (if $global-reg$
	   then (setq lbot #+for-68k 'a5 #+for-vax '#.lbot-reg)
		#+for-68k (e-move '#.lbot-reg lbot)
	   else (setq lbot #+for-68k 'a5 #+for-vax '#.fixnum-reg)
		(e-move '#.lbot-sym lbot))

       ; setup lbot-reg to point to the bottom of the original
       ;args...
       (if (eq 'lexpr g-ftype)
	   then #+for-vax
		(e-write4 'ashl '($ 2) '(* -4 #.olbot-reg) lbot)
		#+for-68k
		(progn
		 (d-regused 'd6)
		 (e-move '(* -4 #.olbot-reg) 'd6)
		 (e-write3 'asll '($ 2) 'd6)
		 (e-move 'd6 lbot))
		(e-sub lbot '#.olbot-reg)
		(e-sub3 '($ 4) '#.olbot-reg lbot)
	   else (e-move '#.olbot-reg lbot))

       ; copy the new args down into the place of the original ones...
       (do ((i nargs (1- i))
	    (off-top (* nargs -4) (+ off-top 4))
	    (off-bot 0 (+ off-bot 4)))
	   ((zerop i))
	   (e-move `(,off-top #.np-reg) `(,off-bot ,lbot)))

       ; setup np for the coming call...
       (e-add3 `($ ,(* 4 nargs)) lbot '#.np-reg)

       (e-goto g-topsym)
       ;return t to indicate that tailrecursion was successful
       (return t)))
EndOfFile
cat >  liszt/fixnum.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file fixnum
   "$Header: fixnum.l,v 1.14 83/08/28 17:13:38 layer Exp $")

;;; ----	f i x n u m		fixnum compilation
;;;
;;;				-[Fri Aug 26 14:07:53 1983 by layer]-

;  There are a few functions in lisp which are only permitted to take
; fixnum operands and produce fixnum results.  The compiler recognizes
; these functions and open codes them.
;

;--- d-fixnumexp :: compute a fixnum from an expression
;	x - a lisp expression which must return a fixnum
;
; This is an almost equivalent to d-exp, except that
; 1] it will do clever things if the expression can be open coded in a 
;    fixnum way.
; 2] the result must be a fixnum, and is left in r5 unboxed.
;
(defun d-fixnumexp (x)
  (d-fixnumcode (d-fixexpand x)))


;--- c-fixnumop :: compute a fixnum result
;  This is the extry point into this code from d-exp.  The form to evaluate
; is in v-form.  The only way we could get here is if the car of v-form
; is a function which we've stated is a fixnum returning function. 
;
(defun c-fixnumop nil
  (d-fixnumexp v-form)
  (d-fixnumbox))

;--- d-fixnumbox :: rebox a fixnum in r5
;
#+for-vax
(defun d-fixnumbox ()
   (let (x)
	(e-write3 'moval (concat "*$5120[" '#.fixnum-reg "]") 'r0)
	(e-sub3 '($ 1024) '#.fixnum-reg 'r1)
	(e-write2 'blssu (setq x (d-genlab)))
	(e-call-qnewint)
	(e-writel x)
	(d-clearreg)))

#+for-68k
(defun d-fixnumbox ()
   (let (x)
	(d-regused '#.fixnum-reg)
	(e-move '#.fixnum-reg 'd0)
	(e-write3 'asll '($ 2) 'd0)
	; add onto the base of the fixnums
	(e-add (e-cvt '(fixnum 0)) 'd0)
	(e-move '#.fixnum-reg 'd1) 
	(e-sub '($ 1024) 'd1)
	(e-write2 'jcs (setq x (d-genlab)))	;branch carry set
	(e-call-qnewint)
	(e-writel x)
	(d-clearreg)))

;--- d-fixexpand  :: pass over a fixnum expression doing local optimizations
; 
; This code gets the first look at the operands of a fixnum expression.
; It handles the strange cases, like (+) or (/ 3), and it also insures
; that constants are folded (or collapsed as we call it here).
; 
; things to watch out for:
; (+ x y z) we can fold x,y,z , likewise in the case of *
; (- x y z) we can only fold y and z since they are negated but x is not,
;	    likewise for /
(defun d-fixexpand (x)
  (prog nil
	(setq x (d-macroexpand x))
    loop
	(if (and (dtpr x) (symbolp (car x)) (get (car x) 'fixop))
	    then (if (memq (car x) '(+ *))
		     then  (setq x (cons (car x)
					 (d-collapse (cdr x) (car x))))
		     else  (setq x
				 (cons (car x)
				       (cons (cadr x)
					     (d-collapse (cddr x) (car x))))))
	         (if (null (cdr x))
		     then  ; (- or +) => 0 (* or /) => 1
		         (setq x
			       (cdr (assq (car x)
					  '((+ . 0) (- . 0)
					    (* . 1) (/ . 1)))))
		         (go loop)
		  elseif (null (cddr x)) then
		           ; (+ n) => n, (- n) => (- 0 n), (* n) => n,
			   ; (/ n) => (/ 1 n)
			  (setq x
				(if (memq (car x) '(* +))
				    then (cadr x)
				 elseif (eq (car x) '-)
				    then `(- 0 ,(cadr x))
				 elseif (eq (car x) '/)
				    then `(/ 1 ,(cadr x))
				    else (comp-err
					     "Internal fixexpand error ")))
			  (go loop)))
	(return x)))

;--- d-toplevmacroexpand :: expand top level form if macro
; a singe level of macro expansion is done.  this is a nice general
; routine and should be used by d-exp.
;**** out of date **** will be removed soon
(defun d-toplevmacroexpand (x)
  (let ((fnbnd (and (dtpr x) (symbolp (car x)) (getd (car x)))))
       (if (and fnbnd (or (and (bcdp fnbnd) (eq (getdisc fnbnd) 'macro))
			  (and (dtpr fnbnd) (eq (car fnbnd) 'macro))))
	   then (d-toplevmacroexpand (apply fnbnd x))
	   else x)))


;--- d-collapse :: collapse (fold) constants
; 
; this is used to reduce the number of operations. since we know that
; fixnum operations are commutative.
;
(defun d-collapse (form op)
  (let (const res conlist)
       ; generate list of constants (conlist) and non constants (res)
       (do ((xx form (cdr xx)))
	   ((null xx))
	   (if (numberp (car xx))
	       then (if (fixp (car xx))
			then (setq conlist (cons (car xx) conlist))
			else (comp-err "Illegal operand in fixnum op " 
				       (car xx)))
	       else (setq res (cons (car xx) res))))

       ; if no constants found thats ok, but if we found some,
       ; then collapse and return the form with the collapsed constant
       ; at the end.

       (if (null conlist)
	   then form 	; no change
	   else (setq res (nreverse 
		 (cons (apply (cond ((or (eq op '/) (eq op '*)) 'times)
				    (t 'plus)) 
			      (cons (cond ((or (eq op '/) (eq op '*)) 1)
					  (t 0))
				    conlist))
		       res))))))


;---- d-fixnumcode :: emit code for prescanned fixnum expression
;	expr -  a expression which should return an unboxed fixnum value 
;		in r5.
;  This function checks if the expression is indeed a guaranteed fixnum 
; arithmetic expression, and if so , generates code for the operation.
; If the expression is not a fixnum operation, then a normal evaluation
; of the cdr of the expression is done, which will grab the fixnum value
; and put it in r5.
;
#+for-vax
(defun d-fixnumcode (expr)
  (let ((operator (and (dtpr expr) 
		       (symbolp (car expr)) 
		       (get (car expr) 'fixop)))
	(g-ret nil)
	tmp)
       ; the existance of a fixop property on a function says that it is a
       ; special fixnum only operation.
       (if (null operator) 
	   then (let ((g-loc '#.fixnum-reg) g-cc) ; non fixnum op, do normal
		     (d-exp `(cdr ,expr)))	; eval to get unboxed number
	   else (do ((xx (cdr expr) (cdr xx))	; fixnum op, scan all args
		     (lop) (rop) (res) (opnd))
		    ((null xx))
		    (setq opnd (car xx))
		    (if (fixp opnd) 
			then (setq rop `(immed ,opnd))
	   	     elseif (and (symbolp opnd) 
				 (setq rop (d-simple `(cdr ,opnd))))
			    thenret
			else (if (and lop (not (eq lop '#.unCstack)))
				 then (C-push (e-cvt lop))
				 (setq lop '#.unCstack))
			     (d-fixnumcode (d-fixexpand opnd))
			     (setq rop 'r5))
		    (if (null lop) 
			then (if (cdr xx) 
				 then (setq lop rop)
				 else (e-move (e-cvt rop) 'r5))
			else (if (cdr xx) 
				 then (setq res '#.Cstack)
				 else (setq res 'r5))
			     (if (setq tmp (d-shiftcheck operator rop))
				 then (e-write4 'ashl 
						(e-cvt (list 'immed tmp))
						(e-cvt lop)
						(e-cvt res))
				 else (e-write4 operator (e-cvt rop) 
						(e-cvt lop) 
						(e-cvt res)))
			     (if (cdr xx) 
				 then (setq lop '#.unCstack)
				 else (setq lop "r5")))))))

#+for-68k
(defun d-fixnumcode (expr)
   (let ((operator (and (dtpr expr)
			(symbolp (car expr))
			(get (car expr) 'fixop)))
	 (g-ret nil)
	 tmp)
       ; the existance of a fixop property on a function says that it is a
       ; special fixnum only operation.
       (makecomment `(d-fixnumcode ,expr))
       (if (null operator) 
	   then (let ((g-loc '#.fixnum-reg) g-cc) ; non fixnum op, do normal
		    (d-exp `(cdr ,expr)))	  ; eval to get unboxed number
		(d-regused '#.fixnum-reg)
	   else (do ((xx (cdr expr) (cdr xx))	  ; fixnum op, scan all args
		     (lop) (rop) (res) (opnd))
		    ((null xx))
		    (setq opnd (car xx))
		    (if (fixp opnd) 
			then (setq rop `(immed ,opnd))
		     elseif (and (symbolp opnd)
				 (setq rop (d-simple `(cdr ,opnd))))
			thenret
			else (if (and lop (not (eq lop '#.unCstack)))
				 then (C-push (e-cvt lop))
				      (setq lop '#.unCstack))
			     (d-fixnumcode (d-fixexpand opnd))
			     (setq rop '#.fixnum-reg))
		    (if (null lop) 
			then (if (cdr xx) 
				 then (setq lop rop)
				 else (e-move
						(e-cvt rop)
						'#.fixnum-reg))
			else (if (cdr xx) 
				 then (setq res '#.Cstack)
				 else (setq res '#.fixnum-reg))
			     (if (setq tmp (d-shiftcheck operator rop))
				 then (d-asll tmp (e-cvt lop) (e-cvt res))
				 else (e-move (e-cvt lop) 'd0)
				      (e-write3 operator (e-cvt rop) 'd0)
				      (e-move 'd0 (e-cvt res)))
			     (if (cdr xx) 
				 then (setq lop '#.unCstack)
				 else (setq lop '#.fixnum-reg)))))
       (makecomment '(d-fixnumcode done))))

;--- d-shiftcheck	:: check if we can shift instead of multiply
; return t if the operator is a multiply and the operand is an
; immediate whose value is a power of two.
(defun d-shiftcheck (operator operand)
   (and (eq operator #+for-vax 'lmul
	    	     #+for-68k 'mull3)
	(dtpr operand)
	(eq (car operand) 'immed)
	(cdr (assoc (cadr operand) arithequiv))))

; this table is incomplete 
;
(setq arithequiv '((1 . 0) (2 . 1) (4 . 2) (8 . 3) (16 . 4) (32 . 5)
		   (64 . 6) (128 . 7) (256 . 8) (512 . 9) (1024 . 10)
		   (2048 . 11) (4096 . 12) (8192 . 13) (16384 . 14)
		   (32768 . 15) (65536 . 16) (131072 . 17)))


;--- cc-oneplus  :: compile 1+ form			= cc-oneplus =
;  1+ increments a fixnum only. We generate code to check if the number
; to be incremented is a small fixnum less than or equal to 1022.  This
; check is done by checking the address of the fixnum's box.  If the
; number is in that range, we just increment the box pointer by 4.
; otherwise we call we call _qoneplus which does the add and calls
; _qnewint
;
#+for-vax
(defun cc-oneplus nil
  (if (null g-loc)
      then (if (car g-cc) then (e-goto (car g-cc)))
      else (let ((argloc (d-simple (cadr v-form)))
		 (lab1 (d-genlab))
		 (lab2 (d-genlab)))
		(if (null argloc) 
		    then (let ((g-loc 'r0) g-cc g-ret)
			      (d-exp (cadr v-form)))
			 (setq argloc 'reg))
		(e-cmp (e-cvt argloc) '($ #.(+ 5120 (* 4 1022))))
		(e-write2 'jleq lab1)
		(if (not (eq argloc 'r0)) then (d-move argloc 'reg))
		(e-quick-call '_qoneplus)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc)
		    then (e-goto (car g-cc))
		    else (e-goto lab2))
		(e-label lab1)
		(e-add3 '($ 4) (e-cvt argloc) (e-cvt g-loc))
		(if (car g-cc) then (e-goto (car g-cc)))
		(e-label lab2))))

#+for-68k
(defun cc-oneplus nil
   (if (null g-loc)
       then (if (car g-cc) then (e-goto (car g-cc)))
       else (let ((argloc (d-simple (cadr v-form)))
		  (lab1 (d-genlab))
		  (lab2 (d-genlab)))
		(if (null argloc) 
		    then (let ((g-loc 'areg) g-cc g-ret)
			     (d-exp (cadr v-form)))
			 (setq argloc 'areg))
		; ($ (+ Fixzero (* 4 1022))
		(d-cmp argloc '(fixnum 1022))
		(e-write2 'jle lab1)
		(if (not (eq argloc 'areg)) then (d-move argloc 'areg))
		(e-quick-call '_qoneplus)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc)
		    then (e-goto (car g-cc))
		    else (e-goto lab2))
		(e-label lab1)
		(if (not (eq argloc 'reg))
		    then (d-move argloc 'reg))
		(e-write3 'addql "#4" 'd0)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc) then (e-goto (car g-cc)))
		(e-label lab2))))
			


;--- cc-oneminus :: compile the 1- form
; just like 1+ we check to see if we are decrementing an small fixnum.
; and if we are we just decrement the pointer to the fixnum and save
; a call to qinewint.  The valid range of fixnums we can decrement are
; 1023 to -1023.  This requires two range checks (as opposed to one for 1+).
;
#+for-vax
(defun cc-oneminus nil
  (if (null g-loc)
      then (if (car g-cc) then (e-goto (car g-cc)))
      else (let ((argloc (d-simple (cadr v-form)))
		 (lab1 (d-genlab))
		 (lab2 (d-genlab))
		 (lab3 (d-genlab)))
		(if (null argloc) 
		    then (let ((g-loc 'r0) g-cc)
			      (d-exp (cadr v-form)))
		         (setq argloc 'reg))
		(e-cmp (e-cvt argloc) '($ #.(- 5120 (* 4 1024))))
		(e-write2 'jleq lab1)	; not within range
		(e-cmp (e-cvt argloc) '($ #.(+ 5120 (* 4 1023))))
		(e-write2 'jleq lab2)	; within range
		; not within range, must do it the hard way.
		(e-label lab1)
		(if (not (eq argloc 'r0)) then (d-move argloc 'reg))
		(e-quick-call '_qoneminus)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc)
		    then (e-goto (car g-cc))
		    else (e-goto lab3))
		(e-label lab2)
		; we are within range, just decrement the pointer by the
		; size of a word (4 bytes).
		(e-sub3 '($ 4) (e-cvt argloc) (e-cvt g-loc))
		(if (car g-cc) then (e-goto (car g-cc)))
		(e-label lab3))))

#+for-68k
(defun cc-oneminus nil
  (if (null g-loc)
      then (if (car g-cc) then (e-goto (car g-cc)))
      else (let ((argloc (d-simple (cadr v-form)))
		 (lab1 (d-genlab))
		 (lab2 (d-genlab))
		 (lab3 (d-genlab)))
		(if (null argloc) 
		    then (let ((g-loc 'areg) g-cc)
			      (d-exp (cadr v-form)))
		         (setq argloc 'areg))
		; ($ (- Fixzero (* 4 1024)))
		(d-cmp argloc '(fixnum -1024))
		(e-write2 'jle lab1)	; not within range
		(d-cmp argloc '(fixnum 1023))
		(e-write2 'jle lab2)	; within range
		; not within range, must do it the hard way.
		(e-label lab1)
		(if (not (eq argloc 'areg)) then (d-move argloc 'areg))
		(e-quick-call '_qoneminus)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc)
		    then (e-goto (car g-cc))
		    else (e-goto lab3))
		(e-label lab2)
		; we are within range, just decrement the pointer by the
		; size of a word (4 bytes).
		(if (not (eq argloc 'reg))
		    then (d-move argloc 'reg))
		(e-sub '($ 4) 'd0)
		(if (and g-loc (not (eq g-loc 'reg)))
		    then (d-move 'reg g-loc))
		(if (car g-cc) then (e-goto (car g-cc)))
		(e-label lab3))))

;--- cm-<  :: compile a < expression
; 
; the operands to this form can either be fixnum or flonums but they
; must be of the same type.
;
; We can compile the form just like an eq form since all we want is
; a compare and a jump.  The comparisons are inverted since that is
; the way eq expects it.

(defun cm-< nil
   (if (not (= 2 (length (cdr v-form))))
      then (comp-err "incorrect number of arguments to < " v-form))
   ; only can do fixnum stuff if we know that one of the args is
   ; a fixnum.
   ;
   (if (or (fixp (cadr v-form)) (fixp (caddr v-form)))
      then `(<& ,(cadr v-form) ,(caddr v-form))
      else `(lessp ,(cadr v-form) ,(caddr v-form))))

;--- c-<& :: fixnum <
;
; We can compile the form just like an eq form since all we want is
; a compare and a jump.  The comparisons are inverted since that is
; the way eq expects it.

(defun cc-<& nil
   (let ((g-trueop  #+for-vax 'jgeq #+for-68k 'jpl)
	 (g-falseop #+for-vax 'jlss #+for-68k 'jmi)
	 (v-form `(eq (cdr ,(cadr v-form)) (cdr ,(caddr v-form)))))
      (cc-eq)))

;--- cm->  :: compile a > expression
;
; the operands to this form can either be fixnum or flonums but they
; must be of the same type.  
; We can compile the form just like an eq form since all we want is
; a compare and a jump.  The comparisons are inverted since that is
; the way eq expects it.
(defun cm-> nil
   (if (not (= 2 (length (cdr v-form))))
      then (comp-err "incorrect number of arguments to > " v-form))
   ; only can do fixnum stuff if we know that one of the args is
   ; a fixnum.
   ;
   (if (or (fixp (cadr v-form)) (fixp (caddr v-form)))
      then `(>& ,(cadr v-form) ,(caddr v-form))
      else `(greaterp ,(cadr v-form) ,(caddr v-form))))

;--- cc->& :: compile a fixnum > function
;
; We can compile the form just like an eq form since all we want is
; a compare and a jump.  The comparisons are inverted since that is
; the way eq expects it.
(defun cc->& nil
   (let ((g-trueop  #+for-vax 'jleq #+for-68k 'jle)
	 (g-falseop #+for-vax 'jgtr #+for-68k 'jgt)
	 (v-form `(eq (cdr ,(cadr v-form)) (cdr ,(caddr v-form)))))
      (cc-eq)))

;--- cm-=  : compile an = expression
;  The = function is a strange one.  It can compare two fixnums or two
; flonums which is fine on a pdp-10 where they are the same size, but
; is a real pain on a vax where they are different sizes.
; We thus can see if one of the arguments is a fixnum and assume that
; the other one is and then  call =&, the fixnum equal code.
;
(defun cm-= nil
   (if (not (= 2 (length (cdr v-form))))
      then (comp-err "incorrect number of arguments to = : " v-form))
   (if (or (fixp (cadr v-form)) (fixp (caddr v-form)))
      then `(=& ,(cadr v-form) ,(caddr v-form))
      else `(equal ,(cadr v-form) ,(caddr v-form))))

;--- cm-=&
;
; if the number is within the small fixnum range, we can just
; do pointer comparisons.
;
(defun cm-=& nil
   (if (or (and (fixp (cadr v-form))
		(< (cadr v-form) 1024)
		(> (cadr v-form) -1025))
	   (and (fixp (caddr v-form))
		(< (caddr v-form) 1024)
		(> (caddr v-form) -1025)))
      then `(eq ,(cadr v-form) ,(caddr v-form))
      else `(eq (cdr ,(cadr v-form)) (cdr ,(caddr v-form)))))

; this should be converted
#+for-vax
(defun c-\\ nil
   (d-fixop 'ediv  'remainder))

#+for-vax
(defun d-fixop (opcode lispopcode)
   (prog (op1 op2 rop1 rop2 simpleop1)
       (if (not (eq 3 (length v-form))) ; only handle two ops for now
	   then (d-callbig lispopcode (cdr v-form) nil)
	   else (setq op1 (cadr v-form)
		      op2 (caddr v-form))
		(if (fixp op1)
		    then (setq rop1 `($ ,op1)  ; simple int
			       simpleop1 t)	    
		    else (if (setq rop1 (d-simple `(cdr ,op1)))
			     then (setq rop1 (e-cvt rop1))
			     else (let ((g-loc 'reg) g-cc g-ret)
				      (d-exp op1))
				  (setq rop1 '(0 r0))))
		(if (fixp op2)
		    then (setq rop2 `($ ,op2))
		    else (if (setq rop2 (d-simple `(cdr ,op2)))
			     then (setq rop2 (e-cvt rop2))
			     else (C-push rop1)
				  (setq rop1 '#.unCstack)
				  (let ((g-loc 'reg)
					g-cc g-ret)
				      (d-exp op2))
				  (setq rop2 '(0 r0))))
		(if (eq opcode 'ediv)
		    then (if (not simpleop1)
			     then (e-move rop1 'r2)  ; need quad
				  (e-write4 'ashq '$-32 'r1 'r1)
				  (setq rop1 'r1))      ; word div.
			 (e-write5 'ediv rop2 rop1 'r0 'r5)
		    else (e-write4 opcode rop2 rop1 'r5))
		(d-fixnumbox)
		(d-clearreg))))
EndOfFile
cat >  liszt/funa.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file funa
   "$Header: funa.l,v 1.11 83/08/28 17:14:35 layer Exp $")

;;; ----	f u n a				function compilation
;;;
;;;				-[Mon Aug 22 22:01:01 1983 by layer]-


;--- cc-and :: compile an and expression
; We evaluate forms from left to right as long as they evaluate to
; a non nil value.  We only have to worry about storing the value of
; the last expression in g-loc.
;
(defun cc-and nil
  (let ((finlab (d-genlab))
	(finlab2)
	(exps (if (cdr v-form) thenret else '(t))))	; (and) ==> t
       (if (null (cdr g-cc))
	   then (d-exp (do ((g-cc (cons nil finlab))
			    (g-loc)
			    (g-ret)
			    (ll exps (cdr ll)))
			   ((null (cdr ll)) (car ll))
			   (d-exp (car ll))))
		(if g-loc
		    then (setq finlab2 (d-genlab))
			 (e-goto finlab2)
			 (e-label finlab)
			 (d-move 'Nil g-loc)
			 (e-label finlab2)
		    else (e-label finlab))
	   else ;--- cdr g-cc is non nil, thus there is
		; a quick escape possible if one of the
		; expressions evals to nil

		(if (null g-loc) then (setq finlab (cdr g-cc)))
	        (d-exp (do ((g-cc (cons nil finlab))
			    (g-loc)
			    (g-ret)
			    (ll exps (cdr ll)))
			   ((null (cdr ll)) (car ll))
			   (d-exp (car ll))))
		; if g-loc is non nil, then we have evaled the and
		; expression to yield nil, which we must store in
		; g-loc and then jump to where the cdr of g-cc takes us
		(if g-loc
		    then (setq finlab2 (d-genlab))
			 (e-goto finlab2)
			 (e-label finlab)
			 (d-move 'Nil g-loc)
			 (e-goto (cdr g-cc))
			 (e-label finlab2))))
  (d-clearreg))	 ; we cannot predict the state of the registers

;--- cc-arg  :: get the nth arg from the current lexpr
;
; the syntax for Franz lisp is (arg i)
; for interlisp the syntax is (arg x i) where x is not evaluated and is
; the name of the variable bound to the number of args.  We can only handle
; the case of x being the variable for the current lexpr we are compiling
;
(defun cc-arg nil
   (prog (nillab finlab)
       (setq nillab (d-genlab)
	     finlab (d-genlab))
       (if (not (eq 'lexpr g-ftype)) 
	   then (comp-err " arg only allowed in lexprs"))
       (if (and (eq (length (cdr v-form)) 2) fl-inter)
	   then (if (not (eq (car g-args) (cadr v-form)))
		    then (comp-err " arg expression is for non local lexpr "
				   v-form)
		    else (setq v-form (cdr v-form))))
       (if (and (null g-loc) (null g-cc))
	   then ;bye bye, wouldn't do anything
		(return nil))
       (if (and (fixp (cadr v-form)) (>& (cadr v-form) 0))
	   then ; simple case (arg n) for positive n
		(d-move `(fixnum ,(cadr v-form)) 'reg)
		#+for-68k
		(progn
		    (e-sub `(-4 #.olbot-reg) 'd0)
		    (if g-loc
			then (e-move '(% -8 #.olbot-reg d0) (e-cvt g-loc)))
		    (if g-cc then (e-cmpnil '(% -8 #.olbot-reg d0))))
		#+for-vax
		(progn
		    (e-sub3 '(* -4 #.olbot-reg) '(0 r0) 'r0)
		    (if g-loc
			then (e-move '(-8 #.olbot-reg r0) (e-cvt g-loc))
		     elseif g-cc
			then (e-tst '(-8 #.olbot-reg r0))))
		(d-handlecc)
	elseif (or (null (cadr v-form))
		   (and (fixp (cadr v-form)) (=& 0 (cadr v-form))))
	   then ;---the form is: (arg nil) or (arg) or (arg 0).
		;   We have a private copy of the number of args right
		; above the arguments on the name stack, so that
		; the user can't clobber it... (0 olbot) points
		; to the user setable copy, and (-4 olbot) to our
		; copy.
		(if g-loc then (e-move '(-4 #.olbot-reg) (e-cvt g-loc)))
		;   Will always return a non nil value, so
		; don't even test it.
		(if (car g-cc) then (e-goto (car g-cc)))
	   else ; general (arg <form>)
		(let ((g-loc 'reg)
		      (g-cc (cons nil nillab))
		      (g-ret))
		    (d-exp (cadr v-form)))  ;boxed fixnum or nil
		; (arg 0) returns nargs (compiler only!)
		(d-cmp 'reg '(fixnum 0))
		(e-gotonil nillab)
		
		; ... here we are doing (arg <number>), <number> != 0
		#+for-68k
		(progn
		    (e-sub '(-4 #.olbot-reg) 'd0)
		    (if g-loc
			then (e-move '(% -8 #.olbot-reg d0) (e-cvt g-loc)))
		    (if g-cc then (e-cmpnil '(% -8 #.olbot-reg d0))))
		#+for-vax
		(progn
		    (e-sub3 `(* -4 #.olbot-reg) '(0 r0) 'r0)
		    (if g-loc
			then (e-move '(-8 #.olbot-reg r0) (e-cvt g-loc))
		     elseif g-cc
			then (e-tst '(-8 #.olbot-reg r0))))
		(d-handlecc)
		(e-goto finlab)
		(e-label nillab)
		; here we are doing (arg nil) which
		; returns the number of args
		; which is always true if anyone is testing
		(if g-loc
		    then (e-move '(-4 #.olbot-reg) (e-cvt g-loc))
			 #+for-68k (if g-cc then (e-cmpnil '(-4 #.olbot-reg)))
			 (d-handlecc)
		 elseif (car g-cc)
		    then (e-goto (car g-cc))) ;always true
		(e-label finlab))))

;--- c-assembler-code
; the args to assembler-code are a list of assembler language 
; statements.  This statements are put directly in the code
; stream produced by the compiler.  Beware: The interpreter cannot
; interpret the assembler-code function.
;
(defun c-assembler-code nil
  (setq g-skipcode nil)		; turn off code skipping
  (makecomment '(assembler code start))
  (do ((xx (cdr v-form) (cdr xx)))
      ((null xx))
      (e-write1 (car xx)))
  (makecomment '(assembler code end)))

;--- cm-assq :: assoc with eq for testing
;
; form: (assq val list)
;
(defun cm-assq nil
  `(do ((xx-val ,(cadr v-form))
	(xx-lis ,(caddr v-form) (cdr xx-lis)))
       ((null xx-lis))
       (cond ((eq xx-val (caar xx-lis)) (return (car xx-lis))))))

;--- cc-atom :: test for atomness
;
(defun cc-atom nil
  (d-typecmplx (cadr v-form)
	       #.(immed-const (plus 1_0 1_1 1_2 1_4 1_5 1_6 1_7 1_9 1_10))))

;--- c-bcdcall :: do a bcd call
;
; a bcdcall is the franz equivalent of the maclisp subrcall.
; it is called with
; (bcdcall 'b_obj 'arg1 ...)
;  where b_obj must be a binary object. no type checking is done.
;
(defun c-bcdcall nil
  (d-callbig 1 (cdr v-form) t))

;--- cc-bcdp :: check for bcdpness
;
(defun cc-bcdp nil
  (d-typesimp (cadr v-form) #.(immed-const 5)))

;--- cc-bigp :: check for bignumness
;
(defun cc-bigp nil
  (d-typesimp (cadr v-form) #.(immed-const 9)))

;--- c-boole :: compile
;
#+for-vax
(progn 'compile
(defun c-boole nil
   (cond ((fixp (cadr v-form))
	  (setq v-form (d-boolexlate (d-booleexpand v-form)))))
   (cond ((eq 'boole (car v-form)) 	;; avoid recursive calls to d-exp
	  (d-callbig 'boole (cdr v-form) nil))
	 (t (let ((g-loc 'reg) (g-cc nil) (g-ret nil))  ; eval answer
	       (d-exp v-form)))))

;--- d-booleexpand :: make sure boole only has three args
;  we use the identity (boole k x y z) == (boole k (boole k x y) z)
; to make sure that there are exactly three args to a call to boole
;
(defun d-booleexpand (form)
   (if (and (dtpr form) (eq 'boole (car form)))
       then (if (< (length form) 4)
		then (comp-err "Too few args to boole : " form)
	     elseif (= (length form) 4)
		then form
		else (d-booleexpand
			 `(boole ,(cadr form)
				  (boole ,(cadr form)
					  ,(caddr form)
					  ,(cadddr form))
				  ,@(cddddr form))))
       else form))

(declare (special x y))
(defun d-boolexlate (form)
   (if (atom form)
       then form
    elseif (and (eq 'boole (car form))
		(fixp (cadr form)))
       then (let ((key (cadr form))
		  (x (d-boolexlate (caddr form)))
		  (y (d-boolexlate (cadddr form)))
		  (res))
		(makecomment `(boole key = ,key))
		(if (eq key 0) 		;; 0
		    then `(progn ,x ,y 0)
		 elseif (eq key 1) 	;; x * y
		    then `(fixnum-BitAndNot ,x (fixnum-BitXor ,y -1))
		 elseif (eq key 2) 	;; !x * y
		    then `(fixnum-BitAndNot (fixnum-BitXor ,x -1)
					    (fixnum-BitXor ,y -1))
		 elseif (eq key 3) 	;; y
		    then `(progn ,x ,y)
		 elseif (eq key 4)	;; x * !y
		    then `(fixnum-BitAndNot ,x ,y)
		 elseif (eq key 5) 	;; x
		    then `(prog1 ,x ,y)
		 elseif (eq key 6)        ;; x xor y
		    then `(fixnum-BitXor ,x ,y)
		 elseif (eq key 7) 	;; x + y
		    then `(fixnum-BitOr ,x ,y)
		 elseif (eq key 8)	;; !(x xor y)
		    then `(fixnum-BitXor (fixnum-BitOr ,x ,y) -1)
		 elseif (eq key 9) 	;; !(x xor y)
		    then `(fixnum-BitXor (fixnum-BitXor ,x ,y) -1)
		 elseif (eq key 10) 	;; !x
		    then `(prog1 (fixnum-BitXor ,x -1) ,y)
		 elseif (eq key 11) 	;; !x + y
		    then `(fixnum-BitOr (fixnum-BitXor ,x -1) ,y)
		 elseif (eq key 12) 	;; !y
		    then `(progn ,x (fixnum-BitXor ,y -1))
		 elseif (eq key 13) 	;; x + !y
		    then `(fixnum-BitOr ,x (fixnum-BitXor ,y -1))
		 elseif (eq key 14) 	;; !x + !y
		    then `(fixnum-BitOr (fixnum-BitXor ,x -1)
					(fixnum-BitXor ,y -1))
		 elseif (eq key 15) 	;; -1
		    then `(progn ,x ,y -1)
		    else form))
       else form))

(declare (unspecial x y))
) ;; end for-vax


;--- c-*catch :: compile a *catch expression
;
; the form of *catch is (*catch 'tag 'val)
; we evaluate 'tag and set up a catch frame, and then eval 'val
;
(defun c-*catch nil
   (let ((g-loc 'reg)
	 (g-cc nil)
	 (g-ret nil)
	 (finlab (d-genlab))
	 (beglab (d-genlab)))
       (d-exp (cadr v-form))		; calculate tag into 'reg
       (d-pushframe #.F_CATCH 'reg 'Nil) ; the Nil is a don't care
       (push nil g-labs)		; disallow labels
       ; retval will be non 0 if we were thrown to, in which case the value
       ; thrown is in _lispretval.
       ; If we weren't thrown-to the value should be calculated in r0.
       (e-tst '_retval)
       (e-write2 #+for-vax 'jeql #+for-68k 'jeq beglab)
       (e-move '_lispretval (e-cvt 'reg))
       (e-write2 #+for-vax 'jbr #+for-68k 'jra finlab)
       (e-label beglab)
       (d-exp (caddr v-form))
       (e-label finlab)
       (d-popframe)	; remove catch frame from stack
       (unpush g-locs)	; remove (catcherrset . 0)
       (unpush g-labs)  ; allow labels again
       (d-clearreg)))

;--- d-pushframe :: put an evaluation frame on the stack
;
; This is equivalant in the C system to 'errp = Pushframe(class,arg1,arg2);'
; We stack a frame which describes the class (will always be F_CATCH)
; and the other option args.
; 2/10/82 - it is a bad idea to stack a variable number of arguments, since
; this makes it more complicated to unstack frames.  Thus we will always
; stack the maximum --jkf
(defun d-pushframe (class arg1 arg2)
  (C-push (e-cvt arg2))
  (C-push (e-cvt arg1))
  (C-push `($ ,class))
  (if (null $global-reg$)
      then (e-move '#.np-reg '#.np-sym)
	   (e-move '#.np-reg '#.lbot-sym))
  (e-quick-call '_qpushframe)
  (e-move (e-cvt 'reg) '_errp)
  (push '(catcherrset . 0) g-locs))

;--- d-popframe :: remove an evaluation frame from the stack
;
; This is equivalent in the C system to 'errp = Popframe();'
;  n is the number of arguments given to the pushframe which
; created this frame.  We have to totally remove this frame from
; the stack only if we are in a local function, but for now, we just
; do it all the time.
;
(defun d-popframe ()
   (let ((treg #+for-vax 'r1 #+for-68k 'a5))
       (e-move '_errp treg)
       (e-move `(#.OF_olderrp ,treg) '_errp)
       ; there are always 3 arguments pushed, and the frame contains 5
       ; longwords.  We should make these parameters into manifest
       ; constants --jkf
       (e-add3 `($ ,(+ (* 3 4) (* 5 4))) treg 'sp)))

;--- c-cond :: compile a "cond" expression
;
; not that this version of cond is a 'c' rather than a 'cc' . 
; this was done to make coding this routine easier and because
; it is believed that it wont harm things much if at all
;
(defun c-cond nil
  (makecomment '(beginning cond))
  (do ((clau (cdr v-form) (cdr clau))
       (finlab (d-genlab))
       (nxtlab)
       (save-reguse)
       (seent))
      ((or (null clau) seent)
       ; end of cond
       ; if haven't seen a t must store a nil in `reg'
       (if (null seent)  then (d-move 'Nil 'reg))
       (e-label finlab))

      ; case 1 - expr
      (if (atom (car clau))
	  then (comp-err "bad cond clause " (car clau))
      ; case 2 - (expr)
       elseif (null (cdar clau))
	  then (let ((g-loc (if (or g-cc g-loc) then 'reg))
		     (g-cc (cons finlab nil))
		     (g-ret (and g-ret (null (cdr clau)))))
		    (d-exp (caar clau)))
      ; case 3 - (t expr1 expr2 ...)
       elseif (or (eq t (caar clau))
		  (equal ''t (caar clau)))
	  then (let ((g-loc (if (or g-cc g-loc) then 'reg))
		     g-cc)
		    (d-exps (cdar clau)))
	       (setq seent t)
      ; case 4 - (expr1 expr2 ...)
       else (let ((g-loc nil)
		  (g-cc (cons nil (setq nxtlab (d-genlab))))
		  (g-ret nil))
		 (d-exp (caar clau)))
	    (setq save-reguse (copy g-reguse))
	    (let ((g-loc (if (or g-cc g-loc) then 'reg))
		  g-cc)
		 (d-exps (cdar clau)))
	    (if (or (cdr clau) (null seent)) then (e-goto finlab))
	    (e-label nxtlab)
	    (setq g-reguse save-reguse)))
  
  (d-clearreg))
	      
;--- c-cons :: do a cons instruction quickly
;
(defun c-cons nil
  (d-pushargs (cdr v-form))		; there better be 2 args
  (e-quick-call '_qcons)
  (setq g-locs (cddr g-locs))
  (setq g-loccnt (- g-loccnt 2))
  (d-clearreg))

;--- c-cxr :: compile a cxr instruction
; 
;
(defun cc-cxr nil
  (d-supercxr t nil))

;--- d-supercxr :: do a general struture reference
;  	type - one of fixnum-block,flonum-block,<other-symbol>
; the type is that of an array, so <other-symbol> could be t, nil
; or anything else, since anything except *-block is treated the same
;
; the form of a cxr is (cxr index hunk) but supercxr will handle
; arrays too, so hunk could be (getdata (getd 'arrayname))
;
; offsetonly is t if we only care about the offset of this element from
; the beginning of the data structure.  If offsetonly is t then type
; will be nil.
;
; Note: this takes care of g-loc and g-cc 

#+for-vax
(defun d-supercxr (type offsetonly)
  (let ((arg1 (cadr v-form))
	(arg2 (caddr v-form))
	lop rop semisimple)

       (if (fixp arg1) then (setq lop `(immed ,arg1))
	   else (d-fixnumexp arg1)	; calculate index into r5
		(setq lop 'r5))		; and remember that it is there

       ; before we calculate the second expression, we may have to save
       ; the value just calculated into r5.  To be safe we stack away
       ; r5 if the expression is not simple or semisimple.
       (if (not (setq rop (d-simple arg2)))	
	   then (if (and (eq lop 'r5) 
			 (not (setq semisimple (d-semisimple arg2))))
		    then (C-push (e-cvt lop)))
	        (let ((g-loc 'reg) g-cc)
		     (d-exp arg2))
	        (setq rop 'r0)

		(if (and (eq lop 'r5) (not semisimple))
		    then (C-pop (e-cvt lop))))

       (if (eq type 'flonum-block)
	  then (setq lop (d-structgen lop rop 8))
	       (e-write3 'movq lop 'r4)
	       (e-quick-call '_qnewdoub)	; box number
	       (d-clearreg)			; clobbers all regs
	       (if (and g-loc (not (eq g-loc 'reg)))
		  then (d-move 'reg g-loc))
	       (if (car g-cc) then (e-goto (car g-cc)))
	  else (setq lop (d-structgen lop rop 4)
		     rop (if g-loc then
			     (if (eq type 'fixnum-block) then 'r5 
				else (e-cvt g-loc))))
	       (if rop 
		  then (if offsetonly
			  then (e-write3 'moval lop rop)
			  else (e-move lop rop))
		       (if (eq type 'fixnum-block) 
			   then (e-call-qnewint)
				(d-clearreg)
				(if (not (eq g-loc 'reg))
				    then (d-move 'reg g-loc))
				; result is always non nil.
				(if (car g-cc) then (e-goto (car g-cc)))
			   else (d-handlecc))
		elseif g-cc 
		  then (if (eq type 'fixnum-block)
			  then (if (car g-cc) 
				  then (e-goto (car g-cc)))
			  else (e-tst lop)
				(d-handlecc))))))

#+for-68k
(defun d-supercxr (type offsetonly)
   (let ((arg1 (cadr v-form))
	 (arg2 (caddr v-form))
	 lop rop semisimple)
       (makecomment `(Starting d-supercxr: vform: ,v-form))
       (if (fixp arg1) then (setq lop `(immed ,arg1))
	   else (d-fixnumexp arg1)	  ; calculate index into fixnum-reg
		(d-regused '#.fixnum-reg)
		(setq lop '#.fixnum-reg)) ; and remember that it is there
       ;
       ; before we calculate the second expression, we may have to save
       ; the value just calculated into fixnum-reg. To be safe we stack away
       ; fixnum-reg if the expression is not simple or semisimple.
       (if (not (setq rop (d-simple arg2)))	
	   then (if (and (eq lop '#.fixnum-reg)
			 (not (setq semisimple (d-semisimple arg2))))
		    then (C-push (e-cvt lop)))
		(let ((g-loc 'areg) g-cc)
		    (d-exp arg2))
		(setq rop 'a0)
		;
		(if (and (eq lop '#.fixnum-reg) (not semisimple))
		    then (C-pop (e-cvt lop))))
       ;
       (if (eq type 'flonum-block)
	   then (setq lop (d-structgen lop rop 8))
		(break " d-supercxr : flonum stuff not done.")
		(e-write3 'movq lop 'r4)
		(e-quick-call '_qnewdoub)	; box number
		(d-clearreg)			; clobbers all regs
		(if (and g-loc (not (eq g-loc 'areg)))
		    then (d-move 'areg g-loc))
		(if (car g-cc) then (e-goto (car g-cc)))
	   else (if (and (dtpr rop) (eq 'stack (car rop)))
		    then (e-move (e-cvt rop) 'a1)
			 (setq rop 'a1))
		(setq lop (d-structgen lop rop 4)
		      rop (if g-loc then
			      (if (eq type 'fixnum-block)
				  then '#.fixnum-reg 
				  else (e-cvt g-loc))))
		(if rop 
		    then (if offsetonly
			     then (e-write3 'lea lop 'a5)
				  (e-move 'a5 rop)
			     else (e-move lop rop))
			 (if (eq type 'fixnum-block) 
			     then (e-call-qnewint)
				  (d-clearreg)
				  (if (not (eq g-loc 'areg))
				      then (d-move 'areg g-loc))
				  ; result is always non nil.
				  (if (car g-cc) then (e-goto (car g-cc)))
			     else (e-cmpnil lop)
				  (d-handlecc))
		 elseif g-cc 
		    then (if (eq type 'fixnum-block)
			     then (if (car g-cc) 
				      then (e-goto (car g-cc)))
			     else (if g-cc
				      then (e-cmpnil lop)
					   (d-handlecc)))))
       (makecomment "Done with d-supercxr")))

;--- d-semisimple :: check if result is simple enough not to clobber r5
; currently we look for the case of (getdata (getd 'foo))
; since we know that this will only be references to r0.
; More knowledge can be added to this routine.
;
(defun d-semisimple (form)
  (or (d-simple form)
      (and (dtpr form) 
	   (eq 'getdata (car form))
	   (dtpr (cadr form))
	   (eq 'getd (caadr form))
	   (dtpr (cadadr form))
	   (eq 'quote (caadadr form)))))

;--- d-structgen :: generate appropriate address for indexed access
;	index - index address, must be (immed n) or r5 (which contains int)
;	base  - address of base
;	width - width of data element
; want to calculate appropriate address for base[index]
; may require emitting instructions to set up registers
; returns the address of the base[index] suitable for setting or reading
;
; the code sees the base as a stack value as a special case since it
; can generate (perhaps) better code for that case.

#+for-vax
(defun d-structgen (index base width)
  (if (and (dtpr base) (eq (car base) 'stack))
      then (if (dtpr index)	; i.e if index = (immed n)
	       then (d-move index 'r5))	; get immed in register
	   ;  the result is always *n(r6)[r5]
	   (append (e-cvt `(vstack ,(cadr base))) '(r5))
      else (if (not (atom base))	; i.e if base is not register
	       then (d-move base 'r0)	; (if nil gets here we will fail)
		    (d-clearreg 'r0)
		    (setq base 'r0))
	   (if (dtpr index) then `(,(* width (cadr index)) ;immed index
				    ,base)
			    else `(0 ,base r5))))

#+for-68k
(defun d-structgen (index base width)
   (if (and (dtpr base) (eq (car base) 'stack))
       then (break "d-structgen: bad args(1)")
       else (if (not (atom base))	; i.e if base is not register
		then (d-move base 'a0)	; (if nil gets here we will fail)
		     (d-clearreg 'a0)
		     (setq base 'a0))
	    (if (dtpr index)
		then `(,(* width (cadr index)) ,base)
		else (d-regused 'd6)
		     (e-move index 'd6)
		     (e-write3 'asll '($ 2) 'd6)
		     `(% 0 ,base d6))))

;--- c-rplacx :: complile a rplacx expression
;
;  This simple calls the general structure hacking function, d-superrplacx
;  The argument, hunk, means that the elements stored in the hunk are not
;  fixum-block or flonum-block arrays.
(defun c-rplacx nil
  (d-superrplacx 'hunk))

;--- d-superrplacx :: handle general setting of things in structures
;	type - one of fixnum-block, flonum-block, hunk
; see d-supercxr for comments
; form of rplacx is (rplacx index hunk valuetostore)
#+for-vax
(defun d-superrplacx (type)
	 (let ((arg1 (cadr v-form))
	       (arg2 (caddr v-form))
	       (arg3 (cadddr v-form))
	       lop rop semisimple)
	      
	      ; calulate index and put it in r5 if it is not an immediate
	      ; set lop to the location of the index
	      (if (fixp arg1) then (setq lop `(immed ,arg1))
		  else (d-fixnumexp arg1)
		       (setq lop 'r5))	
	      
	      ; set rop to the location of the hunk.  If we have to 
	      ; calculate the hunk, we may have to save r5.
	      ; If we are doing a rplacx (type equals hunk) then we must
	      ; return the hunk in r0.
	      (if (or (eq type 'hunk) (not (setq rop (d-simple arg2))))
		  then (if (and (eq lop 'r5) 
				(not (setq semisimple (d-semisimple arg2))))
			   then (d-move lop '#.Cstack))
		       (let ((g-loc 'r0) g-cc)
			    (d-exp arg2))
		       (setq rop 'r0)
		  
		       (if (and (eq lop 'r5) (not semisimple))
			   then (d-move '#.unCstack lop)))

	      ; now that the index and data block locations are known, we 
	      ; caclulate the location of the index'th element of hunk
	      (setq rop
		    (d-structgen lop rop
				 (if (eq type 'flonum-block) then 8 else 4)))

	      ; the code to calculate the value to store and the actual
	      ; storing depends on the type of data block we are storing in.
	      (if (eq type 'flonum-block) 
		  then (if (setq lop (d-simple `(cdr ,arg3)))
			   then (e-write3 'movq (e-cvt lop) rop)
			   else ; preserve rop since it may be destroyed
				; when arg3 is calculated
				(e-write3 'movaq rop '#.Cstack)
				(let ((g-loc 'r0) g-cc)
				     (d-exp arg3))
				(d-clearreg 'r0)
				(e-write3 'movq '(0 r0) "*(sp)+"))
	       elseif (and (eq type 'fixnum-block)
			   (setq arg3 `(cdr ,arg3))
			   nil)
		      ; fixnum-block is like hunk except we must grab the
		      ; fixnum value out of its box, hence the (cdr arg3)
		   thenret
	       else (if (setq lop (d-simple arg3))
			then (e-move (e-cvt lop) rop)
			else ; if we are dealing with hunks, we must save
			     ; r0 since that contains the value we want to
			     ; return.
			     (if (eq type 'hunk) then (d-move 'reg 'stack)
						      (Push g-locs nil)
						      (incr g-loccnt))
			     (e-write3 'moval rop '#.Cstack)
			     (let ((g-loc "*(sp)+") g-cc)
				  (d-exp arg3))
			     (if (eq type 'hunk) then (d-move 'unstack 'reg)
						      (unpush g-locs)
						      (decr g-loccnt))
			     (d-clearreg 'r0)))))

#+for-68k
(defun d-superrplacx (type)
   (let ((arg1 (cadr v-form))
	 (arg2 (caddr v-form))
	 (arg3 (cadddr v-form))
	 lop rop semisimple)
       (makecomment `(starting d-superrplacx ,type :: v-form = ,v-form))
       ;
       ; calulate index and put it in '#.fixnum-reg if it is not an immediate
       ; set lop to the location of the index
       (if (fixp arg1) then (setq lop `(immed ,arg1))
	   else (d-fixnumexp arg1)
		(d-regused '#.fixnum-reg)
		(setq lop '#.fixnum-reg))
       ;
       ; set rop to the location of the hunk.  If we have to
       ; calculate the hunk, we may have to save '#.fixnum-reg.
       ; If we are doing a rplacx (type equals hunk) then we must
       ; return the hunk in d0.
       (if (or (eq type 'hunk) (not (setq rop (d-simple arg2))))
	   then (if (and (eq lop '#.fixnum-reg)
			 (not (setq semisimple (d-semisimple arg2))))
		    then (d-move lop '#.Cstack))
		(let ((g-loc 'a0) g-cc)
		    (d-exp arg2))
		(setq rop 'a0)
		(if (and (eq lop '#.fixnum-reg) (not semisimple))
		    then (d-move '#.unCstack lop)))
       ;
       ; now that the index and data block locations are known, we
       ; caclulate the location of the index'th element of hunk
       (setq rop
	     (d-structgen lop rop
			  (if (eq type 'flonum-block) then 8 else 4)))
       ;
       ; the code to calculate the value to store and the actual
       ; storing depends on the type of data block we are storing in.
       (if (eq type 'flonum-block) 
	   then (break "flonum stuff not in yet")
		(if (setq lop (d-simple `(cdr ,arg3)))
		    then (e-write3 'movq (e-cvt lop) rop)
		    else ; preserve rop since it may be destroyed
			 ; when arg3 is calculated
			 (e-write3 'movaq rop '#.Cstack)
			 (let ((g-loc 'd0) g-cc)
			     (d-exp arg3))
			 (d-clearreg 'd0)
			 (e-write3 'movq '(0 d0) "*(sp)+"))
	elseif (and (eq type 'fixnum-block)
		    (setq arg3 `(cdr ,arg3))
		    nil)
	     ; fixnum-block is like hunk except we must grab the
	     ; fixnum value out of its box, hence the (cdr arg3)
	   thenret
	   else (if (setq lop (d-simple arg3))
		    then (e-move (e-cvt lop) rop)
		    else ; if we are dealing with hunks, we must save
			 ; d0 since that contains the value we want to
			 ; return.
			 (if (eq type 'hunk)
			     then (L-push 'a0)
				  (push nil g-locs)
				  (incr g-loccnt))
			 (e-write3 'lea rop 'a5)
			 (C-push 'a5)
			 (let ((g-loc '(racc * 0 sp)) g-cc)
			     (d-exp arg3))
			 (if (eq type 'hunk)
			     then (L-pop 'd0)
				  (unpush g-locs)
				  (decr g-loccnt))))
       (makecomment '(d-superrplacx done))))
			    
;--- cc-cxxr :: compile a "c*r" instr where *
;		is any sequence of a's and d's
;	- arg : argument of the cxxr function
;	- pat : a list of a's and d's in the reverse order of that
;			which appeared between the c and r
;
#+for-vax
(defun cc-cxxr (arg pat)
  (prog (resloc loc qloc sofar togo keeptrack)
	; check for the special case of nil, since car's and cdr's
	; are nil anyway
	(if (null arg)
	    then (if g-loc then (d-move 'Nil g-loc)
		     (d-handlecc)
		  elseif (cdr g-cc) then (e-goto (cdr g-cc)))
		 (return))
				      
	(if (and (symbolp arg) (setq qloc (d-bestreg arg pat)))
	    then (setq resloc (car qloc)
		       loc   resloc
		       sofar  (cadr qloc)
		       togo   (caddr qloc))
	    else (setq resloc
		       (if (d-simple arg)
			   thenret
			   else (let ((g-loc 'reg)
				      (g-cc nil)
				      (g-ret nil))
				    (d-exp arg))
				'r0))
	       (setq sofar nil togo pat))

	(if (and arg (symbolp arg)) then (setq keeptrack t))

       ; if resloc is a global variable, we must move it into a register
       ; right away to be able to do car's and cdr's
       (if (and (dtpr resloc) (or (eq (car resloc) 'bind)
				  (eq (car resloc) 'vstack)))
	   then (d-move resloc 'reg)
		(setq resloc 'r0))

       ; now do car's and cdr's .  Values are placed in r0. We stop when
       ; we can get the result in one machine instruction.  At that point
       ; we see whether we want the value or just want to set the cc's.
       ; If the intermediate value is in a register, 
       ; we can do : car cdr cddr cdar
       ; If the intermediate value is on the local vrbl stack or lbind
       ; we can do : cdr
       (do ((curp togo newp)
	    (newp))
	   ((null curp) (if g-loc then (d-movespec loc g-loc)
			    elseif g-cc then (e-tst loc))
	                (d-handlecc))
	   (if (symbolp resloc)
	       then (if (eq 'd (car curp))
			then (if (or (null (cdr curp))
				     (eq 'a (cadr curp)))
				 then (setq newp (cdr curp)   ; cdr
					    loc `(0 ,resloc)
					    sofar (append sofar (list 'd)))
				 else (setq newp (cddr curp)  ; cddr
					    loc `(* 0 ,resloc)
					    sofar (append sofar
							  (list 'd 'd))))
			else (if (or (null (cdr curp))
				     (eq 'a (cadr curp)))
				 then (setq newp (cdr curp)   ; car
					    loc `(4 ,resloc)
					    sofar (append sofar (list 'a)))
				 else (setq newp (cddr curp)  ; cdar
					    loc `(* 4 ,resloc)
					    sofar (append sofar
							  (list 'a 'd)))))
	       elseif (and (eq 'd (car curp))
			   (not (eq '* (car (setq loc (e-cvt resloc))))))
		 then (setq newp (cdr curp)	; (cdr <local>)
			    loc (cons '* loc)
			    sofar (append sofar (list 'd)))
	       else  (setq loc (e-cvt resloc)
			   newp curp))
	   (if newp			; if this is not the last move
	       then (setq resloc
			  (d-allocreg (if keeptrack then nil else 'r0)))
		    (d-movespec loc resloc)
		    (if keeptrack then (d-inreg resloc (cons arg sofar)))))))

#+for-68k
(defun cc-cxxr (arg pat)
   (prog (resloc loc qloc sofar togo keeptrack)
       (makecomment '(starting cc-cxxr))
       ; check for the special case of nil, since car's and cdr's
       ; are nil anyway
       (if (null arg)
	   then (if g-loc then (d-move 'Nil g-loc))
		(if (cdr g-cc) then (e-goto (cdr g-cc)))
		(return))
       (if (and (symbolp arg) (setq qloc (d-bestreg arg pat)))
	   then (setq resloc (car qloc)
		      loc   resloc
		      sofar  (cadr qloc)
		      togo   (caddr qloc))
	   else (setq resloc
		      (if (d-simple arg) thenret
			  else (d-clearreg 'a0)
			       (let ((g-loc 'areg)
				     (g-cc nil)
				     (g-ret nil))
				   (d-exp arg))
			       'a0))
		(setq sofar nil togo  pat))
       (if (and arg (symbolp arg)) then (setq keeptrack t))
       ;
       ; if resloc is a global variable, we must move it into a register
       ; right away to be able to do car's and cdr's
       (if (and (dtpr resloc) (or (eq (car resloc) 'bind)
				  (eq (car resloc) 'vstack)))
	   then (d-move resloc 'areg)
		(setq resloc 'a0))
       ; now do car's and cdr's .  Values are placed in a0. We stop when
       ; we can get the result in one machine instruction.  At that point
       ; we see whether we want the value or just want to set the cc's.
       ; If the intermediate value is in a register,
       ; we can do : car cdr cddr cdar
       ; If the intermediate value is on the local vrbl stack or lbind
       ; we can do : cdr
       (do ((curp togo newp)
	    (newp))
	   ((null curp)
	    (if g-loc then (d-movespec loc g-loc))
	    ;
	    ;;;important: the below kludge is needed!!
	    ;;;consider the compilation of the following:
	    ;
	    ;;; (cond ((setq c (cdr c)) ...))
	    ;;; the following instructions are generated:
	    ;;; movl  a4@(N),a5    ; the setq
	    ;;; movl  a5@,a4@(N)
	    ;;; movl  a4@,a5	   ; the last two are generated if g-cc
	    ;;; cmpl  a5@,d7       ; is non-nil
	    ;
	    ;;; observe that the original value the is supposed to set
	    ;;; the cc's is clobered in the operation!!
	    ;(msg "g-loc: " (e-cvt g-loc) N "loc: " loc N)
	    (if g-cc
		then (if (and (eq '* (car loc))
			      (equal (caddr loc) (cadr (e-cvt g-loc))))
			 then (e-cmpnil '(0 a5))
			 else (e-cmpnil loc)))
	    (d-handlecc))
	   (if (symbolp resloc)
	       then (if (eq 'd (car curp))
			then (if (or (null (cdr curp))
				     (eq 'a (cadr curp)))
				 then (setq newp (cdr curp)   ; cdr
					    loc `(0 ,resloc)
					    sofar (append sofar (list 'd)))
				 else (setq newp (cddr curp)  ; cddr
					    loc `(* 0 ,resloc)
					    sofar (append sofar
							  (list 'd 'd))))
			else (if (or (null (cdr curp))
				     (eq 'a (cadr curp)))
				 then (setq newp (cdr curp)   ; car
					    loc `(4 ,resloc)
					    sofar (append sofar (list 'a)))
				 else (setq newp (cddr curp)  ; cdar
					    loc `(* 4 ,resloc)
					    sofar (append sofar
							  (list 'a 'd)))))
	    elseif (and (eq 'd (car curp))
			(not (eq '* (car (setq loc (e-cvt resloc))))))
	       then (setq newp (cdr curp)	; (cdr <local>)
			  loc (cons '* loc)
			  sofar (append sofar (list 'd)))
	       else  (setq loc (e-cvt resloc)
			   newp curp))
	   (if newp			; if this is not the last move
	       then (setq resloc
			  (d-alloc-register 'a
					    (if keeptrack then nil else 'a1)))
		    (d-movespec loc resloc)
		    ;(if keeptrack then (d-inreg resloc (cons arg sofar)))
		    ))
       (makecomment '(done with cc-cxxr))))
EndOfFile
cat >  liszt/funb.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file funb
   "$Header: funb.l,v 1.12 83/08/28 17:14:58 layer Exp $")

;;; ----	f u n b				function compilation
;;;
;;;				-[Wed Aug 24 17:14:56 1983 by layer]-

;--- c-declare :: handle the "declare" form
; if a declare is seen inside a function definition, we just 
; ignore it.  We probably should see what it is declareing, as it
; might be declaring a special.
;
(defun c-declare nil nil)

;--- c-do :: compile a "do" expression
;
; a do has this form:
;  (do vrbls tst . body)
; we note the special case of tst being nil, in which case the loop
; is evaluated only once, and thus acts like a let with labels allowed.
; The do statement is a cross between a prog and a lambda. It is like
; a prog in that labels are allowed. It is like a lambda in that
; we stack the values of all init forms then bind to the variables, just
; like a lambda expression (that is the initial values of even specials
; are stored on the stack, and then copied into the value cell of the
; atom during the binding phase. From then on the stack location is
; not used).
;
(defun c-do nil
   (let (b-vrbls b-tst b-body chklab bodylab x-repeat x-vrbs x-fst
		 g-loc g-cc oldreguse (g-decls g-decls))
       (forcecomment '(beginning do))
       (setq g-loc 'reg  chklab (d-genlab)   bodylab (d-genlab))

       (if (and (cadr v-form) (atom (cadr v-form)))
	   then (setq v-form (d-olddo-to-newdo (cdr v-form))))

       (push (cons 'do 0) g-locs)		; begin our frame

       (setq b-vrbls (cadr v-form)
	     b-tst   (caddr v-form)
	     b-body  (cdddr v-form))

       (d-scanfordecls b-body)

       ; push value of init forms on stack
       (d-pushargs (mapcar '(lambda (x)
				(if (atom x)
				    then nil ; no init form => nil
				    else (cadr x)))
			   b-vrbls))

       ; now bind to  the variables in the vrbls form
       (d-bindlamb (mapcar '(lambda (x)
				(if (atom x) then x
				    else (car x)))
			   b-vrbls))

       ; search through body for all labels and assign them gensymed labels
       (push (cons (d-genlab)
		   (do ((ll b-body (cdr ll))
			(res))
		       ((null ll) res)
		       (if (and (car ll) (symbolp (car ll)))
			   then (Push res
				      (cons (car ll) (d-genlab))))))
	     g-labs)

       ; if the test is non nil, we do the test
       ; another strange thing, a test form of (pred) will not return
       ; the value of pred if it is not nil! it will return nil -- in this
       ; way, it is not like a cond clause
       (d-clearreg)
       (if b-tst then (e-label chklab)
	   (let ((g-cc (cons nil bodylab)) g-loc g-ret)
	       (d-exp (car b-tst)))	; eval test
	   ; if false, do body
	   (if (cdr b-tst) 
	       then (setq oldreguse (copy g-reguse))
		    (d-exps (cdr b-tst))
		    (setq g-reguse oldreguse)
	       else  (d-move 'Nil 'reg))
	   (e-goto (caar g-labs))		; leave do
	   (e-label bodylab))		; begin body

       ; process body
       (do ((ll b-body (cdr ll))
	    (g-cc) (g-loc)(g-ret))
	   ((null ll))
	   (if (or (null (car ll)) (not (symbolp (car ll))))
	       then (d-exp (car ll))
	       else (e-label (cdr (assoc (car ll) (cdar g-labs))))
		    (d-clearreg)))

       (if b-tst
	   then ; determine all repeat forms which must be
		; evaluated, and all the variables affected.
		; store the results in x-repeat and  x-vrbs
		; if there is just one repeat form, we calculate
		; its value directly into where it is stored,
		; if there is more than one, we stack them
		; and then store them back at once.
		(do ((ll b-vrbls (cdr ll)))
		    ((null ll))
		    (if (and (dtpr (car ll)) (cddar ll))
			then (Push x-repeat (caddar ll))
			     (Push x-vrbs   (caar ll))))
		(if x-vrbs 
		    then (if (null (cdr x-vrbs))  ; if just one repeat
			     then (let ((g-loc (d-locv (car x-vrbs)))
					(g-cc nil))
				      (d-exp (car x-repeat)))
			     else (setq x-fst (car x-repeat))
				  (d-pushargs (nreverse
						  (cdr x-repeat)))
				  (let ((g-loc (d-locv (car x-vrbs)))
					(g-cc)
					(g-ret))
				      (d-exp x-fst))
				  (do ((ll (cdr x-vrbs) (cdr ll)))
				      ((null ll))
				      (d-move 'unstack
					      (d-locv (car ll)))
				      (setq g-locs (cdr g-locs))
				      (decr g-loccnt))))
		(e-goto chklab))

       (e-label (caar g-labs))			; end of do label
       (d-clearreg)
       (d-unbind)
       (setq g-labs (cdr g-labs))))

;--- d-olddo-to-newdo  :: map old do to new do
;
; form of old do is  (do var tst . body)
; where var is a symbol, not nil
;
(defun d-olddo-to-newdo (v-l)
  `(do ((,(car v-l) ,(cadr v-l) ,(caddr v-l)))
       (,(cadddr v-l))
       ,@(cddddr v-l)))

;--- cc-dtpr :: check for dtprness
;
(defun cc-dtpr nil
  (d-typesimp (cadr v-form) #.(immed-const 3)))

;--- cc-eq :: compile an "eq" expression
;
(defun cc-eq nil
   (let ((arg1 (cadr v-form))
	 (arg2 (caddr v-form))
	 arg1loc
	 arg2loc)
       (if (setq arg2loc (d-simple arg2))
	   then (if (setq arg1loc (d-simple arg1))
		    then ; eq <simple> <simple>
			 (d-cmp arg1loc arg2loc)
		    else ; eq <nonsimple> <simple>
			 (let ((g-loc 'reg)	; put <nonsimple> in reg
			       ; must rebind because
			       ; cc->& may have modified
			       (g-trueop #+for-vax 'jneq #+for-68k 'jne)
			       (g-falseop #+for-vax 'jeql #+for-68k 'jeq)
			       g-cc
			       g-ret)
			     (d-exp arg1))
			 (d-cmp 'reg arg2loc))
	   else ; since second is nonsimple, must stack first
		; arg out of harms way
		(let ((g-loc 'stack)
		      (g-trueop #+for-vax 'jneq #+for-68k 'jne)
		      (g-falseop #+for-vax 'jeql #+for-68k 'jeq)
		      g-cc
		      g-ret)
		    (d-exp arg1)
		    (push nil g-locs)
		    (incr g-loccnt)
		    (setq g-loc 'reg)		; second arg to reg
		    (d-exp arg2))
		(d-cmp 'unstack 'reg)
		(setq g-locs (cdr g-locs))
		(decr g-loccnt)))
   (d-invert))

;--- cc-equal :: compile `equal'
;
(defun cc-equal nil
  (let ((lab1 (d-genlab))
	(lab11 (d-genlab))
	lab2)
       (d-pushargs (cdr v-form))
       (e-cmp '(-8 #.np-reg) '(-4 #.np-reg))
       (e-gotonil lab1)
       (d-calltran 'equal '2)		 ; not eq, try equal.
       (d-clearreg)
       #+for-vax (e-tst (e-cvt 'reg))
       #+for-68k (e-cmpnil (e-cvt 'reg))
       (e-gotot lab11)		
       (if g-loc then (d-move 'Nil g-loc))
       (if (cdr g-cc) then (e-goto (cdr g-cc))
	   else (e-goto (setq lab2 (d-genlab))))
       (e-writel lab1)
       (e-dropnp 2)
       (e-writel lab11)
       (if g-loc then (d-move 'T g-loc))
       (if (car g-cc) then (e-goto (car g-cc)))
       (if lab2 then (e-writel lab2))
       (setq g-locs (cddr g-locs))
       (setq g-loccnt (- g-loccnt 2))))

;--- c-errset :: compile an errset expression
;
; the errset has this form: (errset 'value ['tag])
; where tag defaults to t.
;
(defun c-errset nil
  (let ((g-loc 'reg)
	(g-cc nil)
	(g-ret nil)
	(finlab (d-genlab))
	(beglab (d-genlab)))
       (d-exp (if (cddr v-form) then (caddr v-form) else t))
       (d-pushframe #.F_CATCH (d-loclit 'ER%all nil) 'reg)
       (push nil g-labs)		; disallow labels
       ; If retval is non zero then an error has throw us here so we 
       ; must recover the value thrown (from _lispretval) and leave
       ; If retval is zero then we shoud calculate the expression 
       ; into r0  and put a cons cell around it
       (e-tst '_retval)
       (e-write2 #+for-vax 'jeql #+for-68k 'jeq beglab)
       (e-move '_lispretval (e-cvt 'reg))
       (e-write2 #+for-vax 'jbr #+for-68k 'jra finlab)
       (e-label beglab)
       (let ((g-loc 'stack)
	     (g-cc nil))
	    (d-exp (cadr v-form)))
       (d-move 'Nil 'stack)	; haven't updated g-loc, g-loccnt but it
				; shouldn't hurt (famous last words)
       (e-quick-call '_qcons)
       (e-label finlab)
       (d-popframe)
       (unpush g-locs)		; remove (catcherrset . 0)
       (unpush g-labs)		; remove nil
       (d-clearreg)))

;--- cm-fixnum-cxr :: open code a fixnum-cxr expression.
; 
; fixnum-cxr is a compile only hacky function which accesses an element
; of a fixnum space and boxes the resulting fixnum.  It can be used
; for rapid access to user defined structures.
;
(defun cm-fixnum-cxr ()
  `(internal-fixnum-box (cxr ,@(cdr v-form))))

(defun c-internal-fixnum-box ()
  (let ((g-cc nil)
	(g-ret nil)
	(g-loc '#.fixnum-reg))
       #+for-68k (d-regused '#.fixnum-reg)
       (d-exp (cadr v-form))
       (e-call-qnewint)))

;--- cc-offset-cxr
; return a pointer to the address of the object instead of the object.
;
(defun cc-offset-cxr nil
  (d-supercxr nil t))

;--- cc-fixp :: check for a fixnum or bignum
;
(defun cc-fixp nil
  (d-typecmplx (cadr v-form) 
	       '#.(immed-const (plus 1_2 1_9))))

;--- cc-floatp :: check for a flonum
;
(defun cc-floatp nil
  (d-typesimp (cadr v-form) #.(immed-const 4)))

;--- c-funcall :: compile a funcall
;
; we open code a funcall the resulting object is a compiled lambda.
; We don't open code nlambda and macro funcalls since they are
; rarely used and it would waste space to check for them
(defun c-funcall nil
   (if (null (cdr v-form))
      then (comp-err "funcall requires at least one argument " v-form))
   (let ((g-locs g-locs)
	 (g-loccnt g-loccnt)
	 (args (length (cdr v-form)))
	 (g-loc nil)
	 (g-ret nil)
	 (g-cc nil))
      (d-pushargs (cdr v-form))
      (rplaca (nthcdr (1- args) g-locs) 'funcallfcn)

      (d-exp '(cond ((and (symbolp funcallfcn)
			  (getd funcallfcn))
		     (setq funcallfcn (getd funcallfcn)))))
	     
      (d-exp `(cond ((and (bcdp funcallfcn) (eq 'lambda (getdisc funcallfcn)))
			(Internal-bcdcall ,args t))
		       (t (Internal-bcdcall  ,args nil))))))

;--- c-Internal-bcdcall
; this is a compiler internal function call.  when this occurs, there
;  are argnum objects stacked, the first of which is a function name
;  or bcd object.  If dobcdcall is t then we want to do a bcdcall of
;  the first object stacked.  If it is not true then we want to
;  call the interpreter funcall function to handle it.
;
(defun c-Internal-bcdcall nil
   (let ((argnum (cadr v-form))
	 (dobcdcall (caddr v-form)))
      (cond (dobcdcall (d-bcdcall argnum))
	    (t (d-calltran 'funcall argnum)))))

;--- cc-function :: compile a function function
;
; function is an nlambda, which the interpreter treats as 'quote'
; If the argument is a lambda expression, then Liszt will generate
; a new function and generate code to return the name of
; that function.  If the argument is a symbol, then 'symbol
; is compiled.   It would probably be better to return the function
; cell of the symbol, but Maclisp returns the symbol and it
; would cause compatibility problems.
;
(defun cc-function nil
   (if (or (null (cdr v-form))
	   (cddr v-form))
      then (comp-err "Wrong number of arguments to 'function': " v-form))
   (let ((arg (cadr v-form)))
      (if (symbolp arg)
	 then (d-exp `',arg)
       elseif (and (dtpr arg)
		   (memq (car arg) '(lambda nlambda lexpr)))
	 then (let ((newname (concat "in-line-lambda:"
				     (setq in-line-lambda-number
					   (add1 in-line-lambda-number)))))
		 (Push liszt-process-forms
		       `(def ,newname ,arg))
		 (d-exp `',newname))
	 else (comp-err "Illegal argument to 'function': " v-form))))

;--- c-get :: do a get from the prop list
;
(defun c-get nil
  (if (not (eq 2 (length (cdr v-form))))
      then (comp-err "Wrong number of args to get " v-form))
  (d-pushargs (cdr v-form))		; there better be 2 args
  (e-quick-call '_qget)
  (d-clearreg)
  (setq g-locs (cddr g-locs))
  (setq g-loccnt (- g-loccnt 2)))

;--- cm-getaccess :: compile a getaccess instruction
;
(defun cm-getaccess nil `(cdr ,(cadr v-form)))

;--- cm-getaux :: compile a getaux instruction
;
(defun cm-getaux  nil `(car ,(cadr v-form)))

;--- cm-getd :: compile a getd instruction
;
; the getd function is open coded to look in the third part of a symbol
; cell
;
(defun cm-getd nil `(cxr 2 ,(cadr v-form)))

;--- cm-getdata :: compile a getdata instruction
;
; the getdata function is open coded to look in the third part of an 
; array header.
(defun cm-getdata nil `(cxr 2 ,(cadr v-form)))

;--- cm-getdisc  :: compile a getdisc expression
; getdisc accessed the discipline field of a binary object.
;
(defun cm-getdisc nil `(cxr 1 ,(cadr v-form)))

;--- c-go :: compile a "go" expression
;
; we only compile the (go symbol)type expression, we do not
; allow symbol to be anything by a non null symbol.
;
(defun c-go nil
   ; find number of frames we have to go down to get to the label
   (do ((labs g-labs (cdr labs))
	(locs g-locs)
	(locals 0)
	(specials 0)
	(catcherrset 0)
	(label))
       ((null labs)
	(comp-err "go label not found for expression: " (or v-form)))

       (if (car labs) 		; if we have a set of labels to look at...
	   then (if (setq label
			  (do ((lbs (cdar labs) (cdr lbs)))
			      ((null lbs))
			      (if (eq (caar lbs) (cadr v-form))
				  then (return (cdar lbs)))))
		    then (if (not (eq labs g-labs))
			     then (comp-note g-fname ": non local go used : "
					     (or v-form)))
			 ; three stack to pop: namestack, bindstack
			 ;   and execution stack
			 (e-pop locals)
			 (if (greaterp specials 0)
			     then (e-unshallowbind specials))
			 (if (greaterp catcherrset 0)
			     then (comp-note g-fname
					     ": Go through a catch or errset "
					     v-form)
				  (do ((i 0 (1+ i)))
				      ((=& catcherrset i))
				      (d-popframe)))
			 (e-goto label)
			 (return)))
       ; tally all locals, specials and catcherrsets used in this frame
       (do ()
	   ((dtpr (car locs))
	    (if (eq 'catcherrset (caar locs))
	       then (incr catcherrset)
	     elseif (eq 'progv (caar locs))
	       then (comp-err "Attempt to 'go' through a progv"))
	    (setq specials (+ specials (cdar locs))
		  locs (cdr locs)))
	   (setq locs (cdr locs))
	   (incr locals))))
			
;--- cc-ignore :: just ignore this code
;
(defun cc-ignore nil
  nil)

;--- c-lambexp :: compile a lambda expression
;
(defun c-lambexp nil
  (let ((g-loc (if (or g-loc g-cc) then 'reg))
	(g-cc nil)
	(g-locs (cons (cons 'lambda 0) g-locs))
	(g-labs (cons nil g-labs)))
       (d-pushargs (cdr v-form))		; then push vals
       (d-lambbody (car v-form))
       (d-clearreg)))

;--- d-lambbody :: do a lambda body
;	- body : body of lambda expression, eg (lambda () dld)
;
(defun d-lambbody (body)
   (let ((g-decls g-decls))
      (d-scanfordecls (cddr body))		; look for declarations
      (d-bindlamb (cadr body))		; bind locals
      (d-clearreg)
      (d-exp (do ((ll (cddr body) (cdr ll))
		  (g-loc)
		  (g-cc)
		  (g-ret))
		 ((null (cdr ll)) (car ll))
		 (d-exp (car ll))))

      (d-unbind)))				; unbind this frame

;--- d-bindlamb :: bind  variables in lambda list
;	- vrbs : list of lambda variables, may include nil meaning ignore
;
(defun d-bindlamb (vrbs)
  (let ((res (d-bindlrec (reverse vrbs) g-locs 0 g-loccnt)))
       (if res then (e-setupbind)
		    (mapc '(lambda (vrb) (e-shallowbind (car vrb) (cdr vrb)))
			  res)
		    (e-unsetupbind))))
  
;--- d-bindlrec :: recusive routine to bind lambda variables
;	- vrb : list of variables yet to bind
;	- locs : current location in g-loc
;	- specs : number of specials seen so far
;	- lev  : how far up from the bottom of stack we are.
; returns: list of elements, one for each special, of this form:
;		(<specialvrbname> stack <n>)
;	where specialvrbname is the name of the special variable, and n is
;	the distance from the top of the stack where its initial value is 
;	located
; also: puts the names of the local variables in the g-locs list, as well
;	as placing the number of special variables in the lambda header.
;
(defun d-bindlrec (vrb locs specs lev)
   (if vrb 
       then (let ((spcflg (d-specialp (car vrb)))
		  retv)
		(if spcflg then (setq specs (1+ specs)))

		(if (cdr vrb)		; if more vrbls to go ...
		    then (setq retv (d-bindlrec (cdr vrb)
						(cdr locs)
						specs
						(1- lev)))
		    else (rplacd (cadr locs)
				 specs))	; else fix up lambda hdr

		(if (not spcflg) then (rplaca locs (car vrb))
		    else (Push retv `(,(car vrb) stack ,lev)))

		retv)))

;--- d-scanfordecls
; forms - the body of a lambda, prog or do.
;  we look down the form for 'declare' forms.  They should be at the
;  beginning, but there are macros which may unintentionally put forms
;  in front of user written forms.  Thus we check a little further than
;  the first form.
(defun d-scanfordecls (forms)
   ; look for declarations in the first few forms
   (do ((count 3 (1- count)))
       ((= 0 count))
       (cond ((and (dtpr (car forms))
		   (eq 'declare (caar forms))
		   (apply 'liszt-declare (cdar forms)))))
       (setq forms (cdr forms))))

;--- c-list :: compile a list expression
;
; this is compiled as a bunch of conses with a nil pushed on the
; top for good measure
;
(defun c-list nil
  (prog (nargs)
	(setq nargs (length (cdr v-form)))
	(makecomment '(list expression))
	(if (zerop nargs)
	    then (d-move 'Nil 'reg)	; (list) ==> nil
		 (return))
	(d-pushargs (cdr v-form))
	#+for-vax (e-write2 'clrl '#.np-plus)	; stack one nil
	#+for-68k (L-push (e-cvt 'Nil))

       ; now do the consing
       (do ((i (max 1 nargs) (1- i)))
	   ((zerop i))
	   (e-quick-call '_qcons)
	   (d-clearreg)
	   (if (> i 1) then (L-push (e-cvt 'reg))))

       (setq g-locs (nthcdr nargs g-locs)
	     g-loccnt (- g-loccnt nargs))))

;--- d-mapconvert - access : function to access parts of lists
;		  - join	 : function to join results
;		  - resu	 : function to apply to result
;		  - form	 : mapping form
;	This function converts maps to an equivalent do form.
;
;  in this function, the variable vrbls contains a list of forms, one form
;  per list we are mapping over.  The form of the form is 
;    (dummyvariable  realarg  (cdr dummyvariable))
; realarg may be surrounded by (setq <variable which holds result> realarg)
; in the case that the result is the list to be mapped over (this only occurs
; with the function mapc).
;
(defun d-mapconvert (access join resu form )
   (prog (vrbls finvar acc accform compform
		tmp testform tempvar lastvar)

       (setq finvar (gensym 'X)   ; holds result

	     vrbls
	     (reverse
		 (maplist '(lambda (arg)
			       ((lambda (temp)
				    (cond ((or resu (cdr arg))
					   `(,temp ,(car arg)
					      (cdr ,temp)))
					  (t `(,temp
						(setq ,finvar
						       ,(car arg))
						(cdr ,temp)))))
				(gensym 'X)))
			  (reverse (cdr form))))

	     ; the access form will either be nil or car.  If it is
	     ; nil, then we are doing something like a maplist,
	     ; if the access form is car, then we are doing something
	     ; like a mapcar.
	     acc (mapcar '(lambda (tem)
			      (cond (access `(,access ,(car tem)))
				    (t (car tem))))
			 vrbls)

	     accform (cond ((or (atom (setq tmp (car form)))
				(null (setq tmp (d-macroexpand tmp)))
				(not (member (car tmp) '(quote function))))
			    `(funcall ,tmp ,@acc))
			   (t `(,(cadr tmp) ,@acc)))

	     ; the testform checks if any of the lists we are mapping
	     ; over is nil, in which case we quit.
	     testform (cond ((null (cdr vrbls)) `(null ,(caar vrbls)))
			    (t `(or ,@(mapcar '(lambda (x)
						   `(null ,(car  x)))
					      vrbls)))))

       ; in the case of mapcans and mapcons, you need two
       ; extra variables to simulate the nconc.
       ; testvar gets intermediate results and lastvar
       ; points to then end of the list
       (if (eq join 'nconc)
	   then (setq tempvar (gensym 'X)
		      lastvar (gensym 'X)
		      vrbls `((,tempvar) (,lastvar) ,@vrbls)))

       (return
	   `((lambda
		 (,finvar)
		 (liszt-internal-do
		     ( ,@vrbls)
		     (,testform)
		     ,(cond ((eq join 'nconc)
			     `(cond ((setq ,tempvar ,accform)
				     (cond (,lastvar
					     (liszt-internal-do
						 ()
						 ((null (cdr ,lastvar)))
						 (setq ,lastvar
						       (cdr ,lastvar)))
					     (rplacd ,lastvar ,tempvar))
					   (t (setq ,finvar
						     (setq ,lastvar
							   ,tempvar)))))))
			    (join `(setq ,finvar (,join ,accform ,finvar)))
			    (t accform)))
		 ,(cond ((eq resu 'identity) finvar)
			(resu `(,resu ,finvar))
			(t finvar)))
	     nil ))))

; apply to successive elements, return second arg
(defun cm-mapc nil
	  (d-mapconvert 'car nil nil (cdr v-form)))

; apply to successive elements, return list of results
(defun cm-mapcar nil
	  (d-mapconvert 'car 'cons 'nreverse (cdr v-form)))

; apply to successive elements, returned nconc of results
(defun cm-mapcan nil
	  (d-mapconvert 'car 'nconc 'identity (cdr v-form)))

; apply to successive sublists, return second arg
(defun cm-map nil
	  (d-mapconvert nil nil nil (cdr v-form)))

; apply to successive sublists, return list of results
(defun cm-maplist nil
	  (d-mapconvert nil 'cons 'reverse (cdr v-form)))

; apply to successive sublists, return nconc of results
(defun cm-mapcon nil
	  (d-mapconvert nil 'nconc 'identity (cdr v-form)))

;--- cc-memq :: compile a memq expression
;
#+for-vax
(defun cc-memq nil
  (let ((loc1 (d-simple (cadr v-form)))
	(loc2 (d-simple (caddr v-form)))
	looploc finlab)
       (if loc2
	   then (d-clearreg 'r1)
		(if loc1
		    then (d-move loc1 'r1)
		    else (let ((g-loc 'r1)
			       g-cc
			       g-ret)
			     (d-exp (cadr v-form))))
		(d-move loc2 'reg)
	   else (let ((g-loc 'stack)
		      g-cc
		      g-ret)
		    (d-exp (cadr v-form)))
		(push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'reg)
		      g-cc
		      g-ret)
		    (d-exp (caddr v-form)))
		(L-pop 'r1)
		(d-clearreg 'r1)
		(unpush g-locs)
		(decr g-loccnt))
       ; now set up the jump addresses
       (if (null g-loc)
	   then (setq loc1 (if (car g-cc) thenret else (d-genlab))
		      loc2 (if (cdr g-cc) thenret else (d-genlab)))
	   else (setq loc1 (d-genlab)
		      loc2 (d-genlab)))

       (setq looploc (d-genlab))
       (e-tst 'r0)
       (e-write2 'jeql loc2)
       (e-label looploc)
       (e-cmp 'r1 '(4 r0))
       (e-write2 'jeql loc1)
       (e-move '(0 r0) 'r0)
       (e-write2 'jneq looploc)
       (if g-loc
	   then (e-label loc2)		; nil result
		(d-move 'reg g-loc)
		(if (cdr g-cc)
		    then (e-goto (cdr g-cc))
		    else (e-goto (setq finlab (d-genlab))))
	   else (if (cdr g-cc)
		    then (e-goto (cdr g-cc))
		    else (e-label loc2)))
       (if g-loc
	   then (e-label loc1)		; non nil result
		(d-move 'reg g-loc)
		(if (car g-cc) then (e-goto (car g-cc)))
	   else (if (null (car g-cc)) then (e-label loc1)))
       (if finlab then (e-label finlab))))

#+for-68k
(defun cc-memq nil
   (let ((loc1 (d-simple (cadr v-form)))
	 (loc2 (d-simple (caddr v-form)))
	 looploc finlab
	 (tmp-data-reg (d-alloc-register 'd nil)))
       (d-clearreg tmp-data-reg)
       (d-clearreg 'a0)
       (if loc2
	   then (if loc1
		    then (d-move loc1 tmp-data-reg)
		    else (let ((g-loc tmp-data-reg)
			       g-cc
			       g-ret)
			     (d-exp (cadr v-form))))
		(d-move loc2 'reg)
	   else (let ((g-loc 'stack)
		      g-cc
		      g-ret)
		    (d-exp (cadr v-form)))
		(push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'reg)
		      g-cc
		      g-ret)
		    (d-exp (caddr v-form)))
		(L-pop tmp-data-reg)
		(unpush g-locs)
		(decr g-loccnt))
       ; now set up the jump addresses
       (if (null g-loc)
	   then (setq loc1 (if (car g-cc) thenret else (d-genlab))
		      loc2 (if (cdr g-cc) thenret else (d-genlab)))
	   else (setq loc1 (d-genlab)
		      loc2 (d-genlab)))
       (setq looploc (d-genlab))
       (e-cmpnil 'd0)
       (e-write2 'jeq loc2)
       (e-move 'd0 'a0)
       (e-label looploc)
       (e-cmp tmp-data-reg '(4 a0))
       (e-write2 'jeq loc1)
       (e-move '(0 a0) 'a0)
       (e-cmpnil 'a0)
       (e-write2 'jne looploc)
       (e-move 'a0 'd0)
       (if g-loc
	   then (e-label loc2)			; nil result
		(d-move 'reg g-loc)
		(if (cdr g-cc)
		    then (e-goto (cdr g-cc))
		    else (e-goto (setq finlab (d-genlab))))
	   else (if (cdr g-cc)
		    then (e-goto (cdr g-cc))
		    else (e-label loc2)))
       (if g-loc
	   then (e-label loc1)			; non nil result
		(d-move 'a0 g-loc)		;a0 was cdr of non-nil result
		(if (car g-cc) then (e-goto (car g-cc)))
	   else (if (null (car g-cc)) then (e-label loc1)))
       (if finlab then (e-label finlab))))
EndOfFile
cat >  liszt/func.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file func
   "$Header: func.l,v 1.13 84/10/18 12:36:57 jkf Exp $")

;;; ----	f u n c				function compilation
;;;
;;;			-[Wed Aug 24 10:51:11 1983 by layer]-

; cm-ncons :: macro out an ncons expression
;
(defun cm-ncons nil
  `(cons ,(cadr v-form) nil))

; cc-not :: compile a "not" or "null" expression
;
(defun cc-not nil
  (makecomment '(beginning not))
  (if (null g-loc)
      then (let ((g-cc (cons (cdr g-cc) (car g-cc)))
		 (g-ret nil))
		(d-exp (cadr v-form)))
      else (let ((finlab (d-genlab))
		 (finlab2 (d-genlab))
		 (g-ret nil))
		; eval arg and jump to finlab if nil
		(let ((g-cc (cons finlab nil))
		      g-loc)
		     (d-exp (cadr v-form)))
		; didn't jump, answer must be t
		(d-move 'T g-loc)
		(if (car g-cc)
		    then (e-goto (car g-cc))
		    else (e-goto finlab2))
		(e-label finlab)
		; answer is nil
		(d-move 'Nil g-loc)
		(if (cdr g-cc) then (e-goto (cdr g-cc)))
		(e-label finlab2))))

;--- cc-numberp :: check for numberness
;
(defun cc-numberp nil
  (d-typecmplx (cadr v-form) 
	       '#.(immed-const (plus 1_2 1_4 1_9))))

;--- cc-or :: compile an "or" expression
;
(defun cc-or nil
  (let ((finlab (d-genlab))
	(finlab2)
	(exps (if (cdr v-form) thenret else '(nil)))) ; (or) => nil
       (if (null (car g-cc))
	   then (d-exp (do ((g-cc (cons finlab nil))
			    (g-loc (if g-loc then 'reg))
			    (g-ret nil)
			    (ll exps (cdr ll)))
			   ((null (cdr ll)) (car ll))
			   (d-exp (car ll))))
		(if g-loc
		    then (setq finlab2 (d-genlab))
			 (e-goto finlab2)
			 (e-label finlab)
			 (d-move 'reg g-loc)
			 (e-label finlab2)
		    else (e-label finlab))
	   else (if (null g-loc) then (setq finlab (car g-cc)))
		(d-exp (do ((g-cc (cons finlab nil))
			    (g-loc (if g-loc then 'reg))
			    (g-ret nil)
			    (ll exps (cdr ll)))
			   ((null (cdr ll)) (car ll))
			   (d-exp (car ll))))
		(if g-loc
		    then (setq finlab2 (d-genlab))
			 (e-goto finlab2)
			 (e-label finlab)
			 (d-move 'reg g-loc)
			 (e-goto (car g-cc))	; result is t
			 (e-label finlab2)))
       (d-clearreg)))  ;we are not sure of the state due to possible branches.
			       
;--- c-prog :: compile a "prog" expression
;
; for interlisp compatibility, we allow the formal variable list to
; contain objects of this form (vrbl init) which gives the initial value
; for that variable (instead of nil)
;
(defun c-prog nil
   (let ((g-decls g-decls))
      (let (g-loc g-cc seeninit initf
	    (p-rettrue g-ret) (g-ret nil)
	    ((spcs locs initsv . initsn) (d-classify (cadr v-form))))

	 (e-pushnil (length locs))	; locals initially nil
	 (d-bindprg spcs locs)		; bind locs and specs

	 (cond (initsv (d-pushargs initsv)
		       (mapc '(lambda (x)
				 (d-move 'unstack (d-loc x))
				 (decr g-loccnt)
				 (unpush g-locs))
			     (nreverse initsn))))

	 ; determine all possible labels
	 (do ((ll (cddr v-form) (cdr ll))
	      (labs nil))
	     ((null ll) (setq g-labs `((,(d-genlab) ,@labs)
				       ,@g-labs)))
	     (if (and (car ll) (symbolp (car ll)))
		then (if (assq (car ll) labs)
			then (comp-err "label is mulitiply defined " (car ll))
			else (setq labs (cons (cons (car ll) (d-genlab))
					      labs)))))

	 ; compile each form which is not a label
	 (d-clearreg)		; unknown state after binding
	 (do ((ll (cddr v-form) (cdr ll)))
	     ((null ll))
	     (if (or (null (car ll)) (not (symbolp (car ll))))
		then (d-exp (car ll))
		else (e-label (cdr (assq (car ll) (cdar g-labs))))
		     (d-clearreg))))		; dont know state after label

      ; result is nil if fall out and care about value
      (if (or g-cc g-loc) then (d-move 'Nil 'reg))

      (e-label (caar g-labs))		; return to label
      (setq g-labs (cdr g-labs))
      (d-unbind)))			; unbind our frame

;--- d-bindprg :: do binding for a prog expression
;	- spcs : list of special variables
;	- locs : list of local variables
;	- specinit : init values for specs (or nil if all are nil)
;
(defun d-bindprg (spcs locs)
   ; place the local vrbls and prog frame entry on the stack
   (setq g-loccnt (+ g-loccnt (length locs))
	 g-locs (nconc locs `((prog . ,(length spcs)) ,@g-locs)))

   ; now bind the specials, if any, to nil
   (if spcs then (e-setupbind)
       (mapc '(lambda (vrb)
		  (e-shallowbind vrb 'Nil))
	     spcs)
       (e-unsetupbind)))

;--- d-unbind :: remove one frame from g-locs
;
(defun d-unbind nil
   (do ((count 0 (1+ count)))
       ((dtpr (car g-locs))
	(if (not (zerop (cdar g-locs)))
	    then (e-unshallowbind (cdar g-locs)))
	(cond ((not (zerop count))
	       (e-dropnp count)

	       (setq g-loccnt (- g-loccnt count))))
	(setq g-locs (cdr g-locs)))
       (setq g-locs (cdr g-locs))))
	
;--- d-classify :: seperate variable list into special and non-special
;	- lst : list of variables
; returns ( xxx yyy zzz . aaa) 
;		where xxx is the list of special variables and
;		yyy is the list of local variables
;		zzz are the non nil initial values for prog variables
;		aaa are the names corresponding to the values in zzz
;
(defun d-classify (lst)
   (do ((ll lst (cdr ll))
	(locs) (spcs) (init) (initsv) (initsn)
	(name))
       ((null ll) (cons spcs (cons locs (cons initsv initsn))))
       (if (atom (car ll))
	   then (setq name (car ll))
	   else (setq name (caar ll))
		(push name initsn)
		(push (cadar ll) initsv))
       (if (d-specialp name)
	   then (push name spcs)
	   else (push name locs))))

; cm-progn :: compile a "progn" expression
;
(defun cm-progn nil
  `((lambda nil ,@(cdr v-form))))

; cm-prog1 :: compile a "prog1" expression
;
(defun cm-prog1 nil
  (let ((gl (d-genlab)))
       `((lambda (,gl) 
		 ,@(cddr v-form)
		 ,gl)
	 ,(cadr v-form))))

; cm-prog2 :: compile a "prog2" expression
;
(defun cm-prog2 nil
   (let ((gl (d-genlab)))
       `((lambda (,gl)
	     ,(cadr v-form)
	     (setq ,gl ,(caddr v-form))
	     ,@(cdddr v-form)
	     ,gl)
	 nil)))

;--- cm-progv :: compile a progv form
;  a progv form looks like (progv 'l-vars 'l-inits 'g-exp1 ... 'g-expn)
; l-vars should be a list of variables, l-inits a list of initial forms
; We cannot permit returns and go-s through this form.
;
; we stack a (progv . 0) form on g-locs so that return and go will know
; not to try to go through this form.
;
(defun c-progv nil
   (let ((gl (d-genlab))
	 (g-labs (cons nil g-labs))
	 (g-locs (cons '(progv . 0) g-locs)))
       (d-exp `((lambda (,gl)
		    (prog1 (progn ,@(cdddr v-form))
			   (internal-unbind-vars ,gl)))
		(internal-bind-vars ,(cadr v-form) ,(caddr v-form))))))

(defun c-internal-bind-vars nil
   (let ((g-locs g-locs)
	 (g-loccnt g-loccnt))
       (d-pushargs (cdr v-form))
       (d-calldirect '_Ibindvars (length (cdr v-form)))))

(defun c-internal-unbind-vars nil
   (let ((g-locs g-locs)
	 (g-loccnt g-loccnt))
       (d-pushargs (cdr v-form))
       (d-calldirect '_Iunbindvars (length (cdr v-form)))))

;--- cc-quote : compile a "quote" expression
; 
; if we are just looking to set the ; cc, we just make sure 
; we set the cc depending on whether the expression quoted is
; nil or not.
(defun cc-quote nil
   (let ((arg (cadr v-form))
	 argloc)
       (if (null g-loc) 
	   then (if (and (null arg) (cdr g-cc))
		    then (e-goto (cdr g-cc))
		 elseif (and arg (car g-cc))
		    then (e-goto (car g-cc))
		 elseif (null g-cc)
		    then (comp-warn "losing the value of this expression "
				    (or v-form)))
	   else (d-move (d-loclit arg nil) g-loc)
		(d-handlecc))))

;--- c-setarg :: set a lexpr's arg
; form is (setarg index value)
;
(defun c-setarg nil
   (if (not (eq 'lexpr g-ftype))
       then (comp-err "setarg only allowed in lexprs"))
   (if (and fl-inter (eq (length (cdr v-form)) 3))	; interlisp setarg
       then (if (not (eq (cadr v-form) (car g-args)))
		then (comp-err "setarg: can only compile local setargs "
			       v-form)
		else (setq v-form (cdr v-form))))
   ; compile index into fixnum-reg, was (d-pushargs (list (cadr v-form)))
   (let ((g-cc) (g-ret)
	 (g-loc '#.fixnum-reg))
       (d-exp (cadr v-form)))
   (let ((g-loc 'reg)
	 (g-cc nil)
	 (g-ret nil))
       (d-exp (caddr v-form)))
   #+for-vax
   (progn
       (e-sub3 `(* -4 #.olbot-reg) '(0 #.fixnum-reg) '#.fixnum-reg)
       (e-move 'r0 '(-8 #.olbot-reg #.fixnum-reg)))
   #+for-68k
   (progn
       (e-sub `(-4 #.olbot-reg) '#.fixnum-reg)
       (e-write3 'lea '(% -8 #.olbot-reg #.fixnum-reg) 'a5)
       (e-move 'd0 '(0 a5))))

;--- cc-stringp :: check for string ness
;
(defun cc-stringp nil
  (d-typesimp (cadr v-form) #.(immed-const 0)))

;--- cc-symbolp :: check for symbolness
;
(defun cc-symbolp nil
  (d-typesimp (cadr v-form) #.(immed-const 1)))

;--- c-return :: compile a "return" statement
;
(defun c-return nil
   ; value is always put in reg
   (let ((g-loc 'reg)
	 g-cc
	 g-ret)
       (d-exp (cadr v-form)))

   ; if we are doing a non local return, compute number of specials to unbind
   ; and locals to pop
   (if (car g-labs)
       then (e-goto (caar g-labs))
       else (do ((loccnt 0)		;; locals
		 (speccnt 0)		;; special
		 (catcherrset 0)		;; catch/errset frames
		 (ll g-labs (cdr ll))
		 (locs g-locs))
		((null ll) (comp-err "return used not within a prog or do"))
		(if (car ll)
		    then  (comp-note g-fname ": non local return used ")
			 ; unbind down to but not including
			 ; this frame.
			 (if (greaterp loccnt 0)
			     then (e-pop loccnt))
			 (if (greaterp speccnt 0)
			     then (e-unshallowbind speccnt))
			 (if (greaterp catcherrset 0)
			     then (comp-note
				      g-fname
				      ": return through a catch or errset"
				      v-form)
				  (do ((i 0 (1+ i)))
				      ((=& catcherrset i))
				      (d-popframe)))
			 (e-goto (caar ll))
			 (return)
		    else ; determine number of locals and special on
			 ; stack for this frame, add to running
			 ; totals
			 (do ()
			     ((dtpr (car locs))
			      (if (eq 'catcherrset (caar locs)) ; catchframe
				  then (incr catcherrset)
			       elseif (eq 'progv (caar locs))
				  then (comp-err "Attempt to 'return' through a progv"))
			      (setq speccnt (+ speccnt (cdar locs))
				    locs (cdr locs)))
			     (incr loccnt)
			     (setq locs (cdr locs)))))))
	 
; c-rplaca :: compile a "rplaca" expression
;
#+for-vax
(defun c-rplaca nil
  (let ((ssimp (d-simple (caddr v-form)))
	(g-ret nil))
       (let ((g-loc (if ssimp then 'reg else 'stack))
	     (g-cc nil))
	    (d-exp (cadr v-form)))
       (if (null ssimp)
	   then (push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'r1)
		      (g-cc nil))
		    (d-exp (caddr v-form)))
		(d-move 'unstack 'reg)
		(unpush g-locs)
		(decr g-loccnt)
		(e-move 'r1 '(4 r0))
	   else (e-move (e-cvt ssimp)  '(4 r0)))
       (d-clearreg)))		; cant tell what we are clobbering

#+for-68k
(defun c-rplaca nil
   (let ((ssimp (d-simple (caddr v-form)))
	 (g-ret nil))
       (makecomment `(c-rplaca starting :: v-form = ,v-form))
       (let ((g-loc (if ssimp then 'areg else 'stack))
	     (g-cc nil))
	   (d-exp (cadr v-form)))
       (if (null ssimp)
	   then (push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'd1)
		      (g-cc nil))
		    (d-exp (caddr v-form)))
		(d-move 'unstack 'areg)
		(unpush g-locs)
		(decr g-loccnt)
		(e-move 'd1 '(4 a0))
	   else (e-move (e-cvt ssimp)  '(4 a0)))
       (e-move 'a0 'd0)
       (d-clearreg)
       (makecomment `(c-rplaca done))))

; c-rplacd :: compile a "rplacd" expression
;
#+for-vax
(defun c-rplacd nil
  (let ((ssimp (d-simple (caddr v-form)))
	(g-ret nil))
       (let ((g-loc (if ssimp then 'reg else 'stack))
	     (g-cc nil))
	    (d-exp (cadr v-form)))
       (if (null ssimp)
	   then (push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'r1)
		      (g-cc nil))
		    (d-exp (caddr v-form)))
		(d-move 'unstack 'reg)
		(unpush g-locs)
		(decr g-loccnt)
		(e-move 'r1 '(0 r0))
	   else (e-move (e-cvt ssimp)  '(0 r0)))
       (d-clearreg)))

#+for-68k
(defun c-rplacd nil
   (let ((ssimp (d-simple (caddr v-form)))
	 (g-ret nil))
       (makecomment `(c-rplacd starting :: v-form = ,v-form))
       (let ((g-loc (if ssimp then 'areg else 'stack))
	     (g-cc nil))
	   (d-exp (cadr v-form)))
       (if (null ssimp)
	   then (push nil g-locs)
		(incr g-loccnt)
		(let ((g-loc 'd1)
		      (g-cc nil))
		    (d-exp (caddr v-form)))
		(d-move 'unstack 'areg)
		(unpush g-locs)
		(decr g-loccnt)
		(e-move 'd1 '(0 a0))
	   else (e-move (e-cvt ssimp) '(0 a0)))
       (e-move 'a0 'd0)
       (d-clearreg)
       (makecomment `(d-rplacd done))))

;--- cc-setq :: compile a "setq" expression
;
(defun cc-setq nil
  (prog nil
  (let (tmp tmp2)
       (if (null (cdr v-form)) 
	    then (d-exp nil)  ; (setq) 
		 (return)
        elseif (oddp (length (cdr v-form)))
	   then (comp-err "wrong number of args to setq "
			  (or v-form))
	elseif (cdddr v-form)		; if multiple setq's
	   then (do ((ll (cdr v-form) (cddr ll))
		     (g-loc)
		     (g-cc nil))
		    ((null (cddr ll)) (setq tmp ll))
		    (setq g-loc (d-locv (car ll)))
		    (d-exp (cadr ll))
		    (d-clearuse (car ll)))
	else (setq tmp (cdr v-form)))

       ; do final setq
       (let ((g-loc (d-locv (car tmp)))
	     (g-cc (if g-loc then nil else g-cc))
	     (g-ret nil))
	    (d-exp (cadr tmp))
	    (d-clearuse (car tmp)))
       (if g-loc
	   then (d-move (setq tmp2 (d-locv (car tmp))) g-loc)
		(if g-cc
		    then #+for-68k (d-cmpnil tmp2)
			 (d-handlecc))))))

; cc-typep :: compile a "typep" expression
; 
; this returns the type of the expression, it is always non nil
;
#+for-vax
(defun cc-typep nil
  (let ((argloc (d-simple (cadr v-form)))
	(g-ret))
       (if (null argloc)
	   then (let ((g-loc 'reg) g-cc)
		    (d-exp (cadr v-form)))
		(setq argloc 'reg))
       (if g-loc
	   then (e-write4 'ashl '($ -9) (e-cvt argloc) 'r0)
		(e-write3 'cvtbl "_typetable+1[r0]" 'r0)
		(e-move "_tynames+4[r0]" 'r0)
		(e-move '(0 r0) (e-cvt g-loc)))
       (if (car g-cc) then (e-goto (car g-cc)))))

#+for-68k
(defun cc-typep nil
  (let ((argloc (d-simple (cadr v-form)))
	(g-ret))
       (if (null argloc) 
	   then (let ((g-loc 'reg) g-cc)
		    (d-exp (cadr v-form)))
		(setq argloc 'reg))
       (if g-loc
	   then (e-move (e-cvt argloc) 'd0)
		(e-sub '#.nil-reg 'd0)
		(e-write3 'moveq '($ 9) 'd1)
		(e-write3 'asrl 'd1 'd0)
		(e-write3 'lea '"_typetable+1" 'a5)
		(e-add 'd0 'a5)
		(e-write3 'movb '(0 a5) 'd0)
		(e-write2 'extw 'd0)
		(e-write2 'extl 'd0)
		(e-write3 'asll '($ 2) 'd0)
		(e-write3 'lea "_tynames+4" 'a5)
		(e-add 'd0 'a5)
		(e-move '(0 a5) 'a5)
		(e-move '(0 a5) (e-cvt g-loc)))
       (if (car g-cc) then (e-goto (car g-cc)))))

; cm-symeval :: compile a symeval expression.
; the symbol cell in franz lisp is just the cdr.
;
(defun cm-symeval nil
  `(cdr ,(cadr v-form)))

; c-*throw :: compile a "*throw" expression
;
; the form of *throw is (*throw 'tag 'val) .
; we calculate and stack the value of tag, then calculate val 
; we call Idothrow to do the actual work, and only return if the
; throw failed.
;
(defun c-*throw nil
  (let ((arg2loc (d-simple (caddr v-form)))
	g-cc
	g-ret
	arg1loc)
       ; put on the C runtime stack value to throw, and
       ; tag to throw to.
       (if arg2loc
	   then (if (setq arg1loc (d-simple (cadr v-form)))
		    then (C-push (e-cvt arg2loc))
			 (C-push (e-cvt arg1loc))
		    else (let ((g-loc 'reg))
			     (d-exp (cadr v-form))	; calc tag
			     (C-push (e-cvt arg2loc))
			     (C-push (e-cvt 'reg))))
	   else (let ((g-loc 'stack))
		    (d-exp (cadr v-form))	; calc tag to stack
		    (push nil g-locs)
		    (incr g-loccnt)
		    (setq g-loc 'reg)
		    (d-exp (caddr v-form))	; calc value into reg
		    (C-push (e-cvt 'reg))
		    (C-push (e-cvt 'unstack))
		    (unpush g-locs)
		    (decr g-loccnt)))
       ; now push the type of non local go we are doing, in this case
       ; it is a C_THROW
       (C-push '($ #.C_THROW))
       #+for-vax
       (e-write3 'calls '$3 '_Inonlocalgo)
       #+for-68k
       (e-quick-call '_Inonlocalgo)))

;--- cm-zerop ::  convert zerop to a quick test
; zerop is only allowed on fixnum and flonum arguments.  In both cases,
; if the value of the first 32 bits is zero, then we have a zero.
; thus we can define it as a macro:
#+for-vax
(defun cm-zerop nil
  (cond ((atom (cadr v-form))
	 `(and (null (cdr ,(cadr v-form))) (not (bigp ,(cadr v-form)))))
	(t (let ((gnsy (gensym)))
		`((lambda (,gnsy)
			  (and (null (cdr ,gnsy)) 
				(not (bigp ,gnsy))))
		  ,(cadr v-form))))))

#+for-68k
(defun cm-zerop nil
   (cond ((atom (cadr v-form))
	  `(and (=& 0 ,(cadr v-form))	;was (cdr ,(cadr v-form))
		(not (bigp ,(cadr v-form)))))
	 (t (let ((gnsy (gensym)))
		`((lambda (,gnsy)
		      (and (=& 0 ,gnsy)		;was (cdr ,gnsy)
			   (not (bigp ,gnsy))))
		  ,(cadr v-form))))))
EndOfFile
cat >  liszt/io.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file io
   "$Header: io.l,v 1.16 83/12/06 15:50:22 sklower Exp $")

;;; ---- 	i o				input output
;;;
;;;				-[Fri Sep  2 21:37:05 1983 by layer]-


;--- d-prelude :: emit code common to beginning of all functions
;
(defun d-prelude nil
   (let ((loada-op #+for-vax 'movab #+for-68k 'lea)
	 (sub2-op #+for-vax 'subl2 #+for-68k 'subl)
	 (add2-op #+for-vax 'addl2 #+for-68k 'addl)
	 (temp-reg #+for-68k 'a5 #+for-vax '#.fixnum-reg))
       #+for-68k (setq g-stackspace (d-genlab) g-masklab (d-genlab))
       (if g-flocal
	   then (C-push '#.olbot-reg)
		(e-write3 loada-op
			  `(,(* -4 g-currentargs) #.np-reg) '#.olbot-reg)
		(e-writel g-topsym)
	   else #+for-vax (e-write2 '".word" '0x5c0)
		#+for-68k
		(progn
		    (e-write3 'link 'a6 (concat "#-" g-stackspace))
		    (e-write2 'tstb '(-132 sp))
		    (e-write3 'moveml `($ ,g-masklab)
			      (concat "a6@(-" g-stackspace ")"))
		    (e-move '#.Nilatom '#.nil-reg))
		(if fl-profile
		    then (e-write3 loada-op 'mcnts
				   #+for-vax 'r0 #+for-68k 'a0)
			 (e-quick-call 'mcount))
		(e-write3 loada-op 'linker '#.bind-reg)
		(if (eq g-ftype 'lexpr)
		    then ; Here is the method:
			 ;  We push the number of arguments, nargs,
			 ; on the name stack twice, setting olbot-reg
			 ; to point to the second one, so that the user
			 ; has a copy that he can set, and we have
			 ; one that we can use for address calcs.
			 ;  So, the stack will look like this, after
			 ; the setup:
			 ;np    ->
			 ;olbot -> nargs (II)
			 ;      -> nargs (I)
			 ;      -> (arg nargs)
			 ;      -> (arg nargs-1)
			 ;...
			 ;      -> (arg 1)
			 ;
			 (if (null $global-reg$)
			     then (e-move '#.np-sym '#.np-reg))
			 (e-writel g-topsym)
			 (e-move '#.np-reg temp-reg)
			 (e-write3 sub2-op
				   (if $global-reg$
				       then '#.lbot-reg
				       else '#.lbot-sym) temp-reg)
			 (e-write3 add2-op (e-cvt '(fixnum 0)) temp-reg)
			 (L-push temp-reg)
			 (e-move '#.np-reg '#.olbot-reg)
			 (L-push temp-reg)
		    else ;   Set up old lbot register, base reg for variable
			 ; references, and make sure the np points where
			 ; it should since the caller might
			 ; have given too few or too many args.
			 (e-move
				   (if $global-reg$
				       then '#.lbot-reg
				       else '#.lbot-sym)
				   '#.olbot-reg)
			 #+for-68k
			 (e-write3 loada-op
				   `(,(* 4 g-currentargs) #.olbot-reg)
				   '#.np-reg)
			 (e-writel g-topsym)))))

;--- d-fini :: emit code  at end of function
;
(defun d-fini nil
   (if g-flocal
       then (C-pop '#.olbot-reg)
	    (e-write1 #+for-vax 'rsb #+for-68k 'rts)
       else #+for-68k
	    (progn
		(e-write3 'moveml (concat "a6@(-" g-stackspace ")")
			  `($ ,g-masklab))
		(e-write2 'unlk 'a6))
	    (e-return)))

;--- d-bindtab :: emit binder table when all functions compiled
;
(defun d-bindtab nil
  (setq g-skipcode nil)	  ; make sure this isnt ignored	
  (e-writel "bind_org")
  #+for-vax
  (progn
      (e-write2 ".set linker_size," (length g-lits))
      (e-write2 ".set trans_size," (length g-tran)))
  #+for-68k
  (progn
      (e-write2 "linker_size = " (length g-lits))
      (e-write2 "trans_size = " (length g-tran)))
  (do ((ll (setq g-funcs (nreverse g-funcs)) (cdr ll)))
      ((null ll))
      (if (memq (caar ll) '(lambda nlambda macro eval))
	  then (e-write2 '".long"
			 (cdr (assoc (caar ll)
				     '((lambda . 0) (nlambda . 1)
				       (macro . 2) (eval . 99)))))
	  else (comp-err " bad type in lit list " (car ll))))
  
  (e-write1 ".long -1")
  (e-writel "lit_org")
  (d-asciiout (nreverse g-lits))
  (if g-tran then (d-asciiout (nreverse g-tran)))
  (d-asciiout (mapcar '(lambda (x) (if (eq (car x) 'eval)
				       then (cadr x)
				       else (caddr x)))
		      g-funcs))
  (e-writel "lit_end"))

;--- d-asciiout :: print a list of asciz strings
;
(defun d-asciiout (args)
       (do ((lits args (cdr lits))
	    (form))
	   ((null lits))
	   (setq form (explode (car lits))
		 formsiz (length form))
	   (do ((remsiz formsiz)
		(curform form)
		(thissiz))
	       ((zerop remsiz))
	       (if (greaterp remsiz 60) then (sfilewrite '".ascii \"")
		   else (sfilewrite '".asciz \""))
	       (setq thissiz (min 60 remsiz))
	       (do ((count thissiz (1- count)))
		   ((zerop count)
		    (sfilewrite (concat '\" (ascii 10)))
		    (setq remsiz (difference remsiz thissiz)))
		   (if (eq '#.ch-newline (car curform))
		       then (sfilewrite '\\012)
		    else (if (or (eq '\\ (car curform))
				 (eq '\" (car curform)))
			     then (sfilewrite '\\))
			 (sfilewrite (car curform)))
		   (setq curform (cdr curform))))))

;--- d-autorunhead
;
; Here is the C program to generate the assembly language:
;	(after some cleaning up)
;
;main(argc,argv,arge)
;register char *argv[];
;register char **arge;
;{
;	*--argv = "-f";
;	*--argv = "/usr/ucb/lisp";
;	execve("/usr/ucb/lisp",argv,arge);
;	exit(0);
;}
;
(defun d-printautorun nil
   (let ((readtable (makereadtable t))	; in raw readtable
	 tport ar-file)
      (setsyntax #/; 'vsplicing-macro 'zapline)
      (setq ar-file (concat lisp-library-directory
			    #+for-vax "/autorun/vax"
			    #+for-68k "/autorun/68k"))
      (if (null (errset (setq tport (infile ar-file))))
	 then (comp-err "Can't open autorun header file " ar-file))
      (do ((x (read tport '<eof>) (read tport '<eof>)))
	  ((eq '<eof> x) (close tport))
	  (sfilewrite x))))

(defun e-cvt (arg)
   (if     (eq 'reg arg) then #+for-vax 'r0 #+for-68k 'd0
    elseif (eq 'areg arg) then #+for-vax 'r0 #+for-68k 'a0
    elseif (eq 'Nil arg) then #+for-vax '($ 0) #+for-68k '#.nil-reg
    elseif (eq 'T arg)
       then (if g-trueloc
		thenret
		else (setq g-trueloc (e-cvt (d-loclit t nil))))
    elseif (eq 'stack arg) then '(+ #.np-reg)
    elseif (eq 'unstack arg) then '(- #.np-reg)
    elseif (or (atom arg) (symbolp arg)) then arg
    elseif (dtpr arg)
       then (caseq (car arg)
		   (stack	`(,(* 4 (1- (cadr arg))) #.olbot-reg))
		   (vstack	`(* ,(* 4 (1- (cadr arg))) #.olbot-reg))
		   (bind	`(* ,(* 4 (1- (cadr arg))) #.bind-reg))
		   (lbind	`(,(* 4 (1- (cadr arg))) #.bind-reg))
		   (fixnum	`(\# ,(cadr arg)))
		   (immed	`($ ,(cadr arg)))
		   (racc	(cdr arg))
		   (t		(comp-err " bad arg to e-cvt : "
					  (or arg))))
       else  (comp-warn "bad arg to e-cvt : " (or arg))))

;--- e-uncvt :: inverse of e-cvt, used for making comments pretty
;
(defun e-uncvt (arg)
   (if (atom arg)
       then (if (eq 'Nil arg)
		then nil
		else arg)
    elseif (eq 'stack (car arg))
       then (do ((i g-loccnt)
		 (ll g-locs))
		((and (equal i (cadr arg)) (atom (car ll))) (car ll))
		(if (atom (car ll))
		    then (setq ll (cdr ll)
			       i (1- i))
		    else (setq ll (cdr ll))))
    elseif (or (eq 'bind (car arg)) (eq 'lbind (car arg)))
       then (do ((i g-litcnt (1- i))
		 (ll g-lits (cdr ll)))
		((equal i (cadr arg))
		 (cond ((eq 'lbind (car arg))
			(list 'quote (car ll)))
		       (t (car ll)))))
       else arg))

;--- e-cvtas :: convert an EIADR to vax unix assembler fmt and print it
;	- form : an EIADR form
;
#+for-vax
(defun e-cvtas (form)
  (if (atom form)
      then (sfilewrite form)
      else (if (eq '* (car form))
	       then (if (eq '\# (cadr form))
			then (setq form `($ ,(caddr form)))
			else (sfilewrite "*")
			     (setq form (cdr form))))
	   (if (numberp (car form))
	       then (sfilewrite (car form))
		    (sfilewrite "(")
		    (sfilewrite (cadr form))
		    (sfilewrite ")")
		    (if (caddr form)
			then (sfilewrite "[")
			     (sfilewrite (caddr form))
			     (sfilewrite "]"))
	    elseif (eq '+ (car form))
	       then (sfilewrite '"(")
		    (sfilewrite (cadr form))
		    (sfilewrite '")+")
	    elseif (eq '- (car form))
	       then (sfilewrite '"-(")
		    (sfilewrite (cadr form))
		    (sfilewrite '")")
	    elseif (eq '\# (car form))	; 5120 is base of small fixnums
	       then (sfilewrite (concat "$" (+ (* (cadr form) 4) 5120)))
	    elseif (eq '$ (car form))
	       then (sfilewrite '"$")
		    (sfilewrite (cadr form)))))

#+for-68k
(defun e-cvtas (form)
   (if (atom form)
       then (sfilewrite form)
       else (if (eq '* (car form))
		then (if (eq '\# (cadr form))
			 then (setq form `($ ,(caddr form)))))
	    (if (numberp (car form))
		then (sfilewrite (cadr form))
		     (sfilewrite "@")
		     (if (not (zerop (car form)))
			 then (sfilewrite "(")
			      (sfilewrite (car form))
			      (sfilewrite ")"))
	    elseif (eq '% (car form))
	       then (setq form (cdr form))
		    (sfilewrite (cadr form))
		    (sfilewrite "@(")
		    (sfilewrite (car form))
		    (sfilewrite ",")
		    (sfilewrite (caddr form))
		    (sfilewrite ":L)")
	     elseif (eq '+ (car form))
		then (sfilewrite (cadr form))
		     (sfilewrite '"@+")
	     elseif (eq '- (car form))
		then (sfilewrite (cadr form))
		     (sfilewrite '"@-")
	     elseif (eq '\# (car form))
		then (sfilewrite (concat '#.Nilatom "+0x1400"
					 (if (null (signp l (cadr form)))
					     then "+" else "")
					 (* (cadr form) 4)))
	     elseif (eq '$ (car form))
		then (sfilewrite '"#")
		     (sfilewrite (cadr form))
	       else (comp-err " bad arg to e-cvtas : " (or form)))))

;--- e-docomment :: print any comment lines
;
(defun e-docomment nil
  (if g-comments
      then (do ((ll (nreverse g-comments) (cdr ll)))
	       ((null ll))
	       (sfilewrite "	")
	       (sfilewrite #.comment-char)
	       (do ((ll (exploden (car ll)) (cdr ll)))
		   ((null ll))
		   (tyo (car ll) vp-sfile)
		   (cond ((eq #\newline (car ll))
			  (sfilewrite #.comment-char))))
	       (terpr vp-sfile))
	   (setq g-comments nil)
     else (terpr vp-sfile)))

;--- e-goto :: emit code to jump to the location given
;
(defun e-goto (lbl)
  (e-jump lbl))

;--- e-gotonil :: emit code to jump if nil was last computed
;
(defun e-gotonil (lbl)
  (e-write2 g-falseop lbl))

;--- e-gotot :: emit code to jump if t was last computed
(defun e-gotot (lbl)
  (e-write2  g-trueop lbl))

;--- e-label :: emit a label
(defun e-label (lbl)
  (setq g-skipcode nil)
  (e-writel lbl))

;--- e-pop :: pop the given number of args from the stack
; g-locs is not! fixed
;
(defun e-pop (nargs)
  (if (greaterp nargs 0)
      then (e-dropnp nargs)))

;--- e-pushnil :: push a given number of nils on the stack
;
#+for-vax
(defun e-pushnil (nargs)
   (do ((i nargs))
       ((zerop i))
       (if (>& i 1)
	   then (e-write2 'clrq '#.np-plus)
		(setq i (- i 2))
	elseif (equal i 1)
	   then (e-write2 'clrl '#.np-plus)
		(setq i (1- i)))))

#+for-68k
(defun e-pushnil (nargs)
  (do ((i nargs))
      ((zerop i))
      (L-push '#.nil-reg)
      (setq i (1- i))))

;--- e-setupbind :: setup for shallow binding
;
(defun e-setupbind nil
  (e-move '#.bnp-sym '#.bnp-reg))

;--- e-unsetupbind :: restore temp value of bnp to real loc
;
(defun e-unsetupbind nil
  (e-move '#.bnp-reg '#.bnp-sym))

;--- e-shallowbind :: shallow bind value of variable and initialize it
;	- name : variable name
;	- val : IADR value for variable
;
(defun e-shallowbind (name val)
  (let ((vloc (d-loclit name t)))
       (e-move (e-cvt vloc) '(+ #.bnp-reg))	; store old val
       (e-move (e-cvt `(lbind ,@(cdr vloc)))
		       '(+ #.bnp-reg))		; now name
       (d-move val vloc)))		

;--- e-unshallowbind :: un shallow bind n variable from top of stack
;
#+for-vax
(defun e-unshallowbind (n)
  (e-setupbind)		; set up binding register
  (do ((i 1 (1+ i)))
      ((greaterp i n))
      (e-move `(,(* -8 i) #.bnp-reg) `(* ,(+ 4 (* -8 i)) #.bnp-reg)))
  (e-sub3 `($ ,(* 8 n)) '#.bnp-reg '#.bnp-sym))

#+for-68k
(defun e-unshallowbind (n)
  (makecomment "e-unshallowbind begin...")
  (e-setupbind)		; set up binding register
  (do ((i 1 (1+ i)))
      ((greaterp i n))
      (e-move `(,(* -8 i) #.bnp-reg) `(* ,(+ 4 (* -8 i)) #.bnp-reg)))
  (e-move '#.bnp-reg '#.bnp-sym)
  (e-sub `($ ,(* 8 n)) '#.bnp-sym)
  (makecomment "...end e-unshallowbind"))

;----------- very low level routines
; all output to the assembler file goes through these routines.
; They filter out obviously extraneous instructions as well as 
; combine sequential drops of np.

;--- e-dropnp :: unstack n values from np.
; rather than output the instruction now, we just remember that it
; must be done before any other instructions are done.  This will
; enable us to catch sequential e-dropnp's
;
(defun e-dropnp (n)
  (if (not g-skipcode)
      then (setq g-dropnpcnt (+ n (if g-dropnpcnt thenret else 0)))))

;--- em-checknpdrop :: check if we have a pending npdrop
; and do it if so.
;
(defmacro em-checknpdrop nil
   `(if g-dropnpcnt
	then (let ((dr g-dropnpcnt))
		 (setq g-dropnpcnt nil)
		 (e-sub `($ ,(* dr 4)) '#.np-reg))))

;--- em-checkskip :: check if we are skipping this code due to jump
;
(defmacro em-checkskip nil
  '(if g-skipcode then (sfilewrite #.comment-char)))


;--- e-jump :: jump to given label
; and set g-skipcode so that all code following until the next label
; will be skipped.
;
(defun e-jump (l)
  (em-checknpdrop)
  (e-write2 #+for-vax 'jbr #+for-68k 'jra l)
  (setq g-skipcode t))

;--- e-return :: do return, and dont check for np drop
;
(defun e-return nil
  (setq g-dropnpcnt nil)  ; we dont need to worry about nps
  #+for-vax (e-write1 'ret)
  #+for-68k (progn  (e-write1 'rts)
		    (sfilewrite
		       (concat g-masklab " = " (d-makemask) '#.ch-newline))
		    (sfilewrite
		       (concat g-stackspace " = "
			       (Cstackspace) '#.ch-newline))))

;--- e-writel :: write out a label
;
(defun e-writel (label)
  (setq g-skipcode nil)
  (em-checknpdrop)
  (sfilewrite label)
  (sfilewrite ":")
  (e-docomment))

;--- e-write1 :: write out one litteral
;
(defun e-write1 (lit)
  (em-checkskip)
  (em-checknpdrop)
  (sfilewrite "	")
  (sfilewrite lit)
  (e-docomment))

;--- e-write2 :: write one one litteral, and one operand
;
#+for-vax
(defun e-write2 (lit frm)
  (em-checkskip)
  (em-checknpdrop)
  (sfilewrite "	")
  (sfilewrite lit)
  (sfilewrite "	")
  (e-cvtas frm)
  (e-docomment))

#+for-68k
(defun e-write2 (lit frm)
  (em-checkskip)
  (em-checknpdrop)
  (if (and (dtpr frm) (eq (car frm) '*))
      then (e-move (cdr frm) 'a5)
	   (sfilewrite "	")
	   (sfilewrite lit)
	   (sfilewrite '"	")
	   (e-cvtas '(0 a5))
      else (sfilewrite "	")
	   (sfilewrite lit)
	   (sfilewrite '"	")
	   (e-cvtas frm))
  (e-docomment))

;--- e-write3 :: write one one litteral, and two operands
;
#+for-vax
(defun e-write3 (lit frm1 frm2)
  (em-checkskip)
  (em-checknpdrop)
  (sfilewrite "	")
  (sfilewrite lit)
  (sfilewrite "	")
  (e-cvtas frm1)
  (sfilewrite ",")
  (e-cvtas frm2)
  (e-docomment))

#+for-68k
(defun e-write3 (lit frm1 frm2)
   (em-checkskip)
   (em-checknpdrop)
   (if (and (dtpr frm1) (eq (car frm1) '*)
	    (not (and (dtpr frm2) (eq (car frm2) '*))))
       then (e-move (cdr frm1) 'a5)
	    (sfilewrite "	")
	    (sfilewrite lit)
	    (sfilewrite '"	")
	    (e-cvtas '(0 a5))
	    (sfilewrite '",")
	    (e-cvtas frm2)
	    (e-docomment)
    elseif (and (not (and (dtpr frm1) (eq (car frm1) '*)))
		(dtpr frm2) (eq (car frm2) '*))
       then (e-move (cdr frm2) 'a5)
	    (sfilewrite "	")
	    (sfilewrite lit)
	    (sfilewrite '"	")
	    (e-cvtas frm1)
	    (sfilewrite '",")
	    (e-cvtas '(0 a5))
	    (e-docomment)
    elseif (and (dtpr frm1) (eq (car frm1) '*)
		(dtpr frm2) (eq (car frm2) '*))
       then (d-regused 'd6)
	    (e-move (cdr frm1) 'a5)
	    (e-move '(0 a5) 'd6)
	    (e-move (cdr frm2) 'a5)
	    (sfilewrite "	")
	    (sfilewrite lit)
	    (sfilewrite '"	")
	    (e-cvtas 'd6)
	    (sfilewrite '",")
	    (e-cvtas '(0 a5))
	    (e-docomment)
       else (sfilewrite "	")
	    (sfilewrite lit)
	    (sfilewrite '"	")
	    (e-cvtas frm1)
	    (sfilewrite '",")
	    (e-cvtas frm2)
	    (e-docomment)))

;--- e-write4 :: write one one litteral, and three operands
;
#+for-vax
(defun e-write4 (lit frm1 frm2 frm3)
  (em-checkskip)
  (em-checknpdrop)
  (sfilewrite "	")
  (sfilewrite lit)
  (sfilewrite "	")
  (e-cvtas frm1)
  (sfilewrite ",")
  (e-cvtas frm2)
  (sfilewrite ",")
  (e-cvtas frm3)
  (e-docomment))


;--- e-write5 :: write one one litteral, and four operands
;
#+for-vax
(defun e-write5 (lit frm1 frm2 frm3 frm4)
  (em-checkskip)
  (em-checknpdrop)
  (sfilewrite "	")
  (sfilewrite lit)
  (sfilewrite "	")
  (e-cvtas frm1)
  (sfilewrite ",")
  (e-cvtas frm2)
  (sfilewrite ",")
  (e-cvtas frm3)
  (sfilewrite ",")
  (e-cvtas frm4)
  (e-docomment))

;--- d-printdocstuff
;
; describe this version
;
(defun d-printdocstuff nil
   (sfilewrite (concat ".data "
		       #.comment-char
		       " this is just for documentation "))
   (terpr vp-sfile)
   (sfilewrite (concat ".asciz \"@(#)Compiled by " compiler-name
                " on " (status ctime) '\"))
   (terpr vp-sfile)
   (do ((xx Liszt-file-names (cdr xx)))
       ((null xx))
       (sfilewrite (concat ".asciz \"" (car xx) '\"))
       (terpr vp-sfile)))
EndOfFile
cat >  liszt/vector.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file vector
   "$Header: vector.l,v 1.11 83/11/22 10:13:48 jkf Exp $")

;;; ----	v e c t o r			vector referencing
;;;
;;;				-[Fri Nov 11 22:35:50 1983 by jkf]-


(defun cc-vset ()
   ;;  Set a vector created via 'vector'.
   (d-vset 'lisp))

(defun cc-vref ()
   ;;  Reference a vector created via 'vector'.
   (d-vref 'lisp))

(defun cc-vseti-byte ()
   ;;  Set a vector created via 'vectori-byte'.
   (d-vset 'byte))

(defun cc-vrefi-byte ()
   ;;  Reference a vector created via 'vectori-byte'.
   (d-vref 'byte))

(defun cc-vseti-word ()
   ;;  Set a vector created via 'vectori-word'.
   (d-vset 'word))

(defun cc-vrefi-word ()
   ;;  Reference a vector created via 'vectori-word'.
   (d-vref 'word))

(defun cc-vseti-long ()
   ;;  Set a vector created via 'vectori-long'.
   (d-vset 'long))

(defun cc-vrefi-long ()
   ;;  Reference a vector created via 'vectori-long'.
   (d-vref 'long))

;--- d-vset :: handle all types of vset's
(defun d-vset (type)
   ;;  Generic vector store.  Type is either 'lisp', 'byte', 'word',
   ;; or 'long'.
   (let ((vect (cadr v-form))
	 (index (caddr v-form))
	 (val (cadddr v-form))
	 (vect-addr) (index-addr)
	 (vect-val) (fetchval)
	 (temp) (size)
	 (vec-reg #+for-vax 'r0 #+for-68k 'a0)
	 (val-reg #+for-vax 'r1 #+for-68k 'd1)
	 (index-reg '#.fixnum-reg)
	 (temp-reg #+for-vax 'r4 #+for-68k 'd0)
	 (temp-areg #+for-vax 'bogus! #+for-68k 'a1)
	 (oklab (d-genlab))
	 (needlowcheck t))		; t if must check lower index bounds

       #+for-68k (d-regused '#.fixnum-reg)
       (makecomment `(doing vec set type ,type))
       (if (fixp index)
	   then (if (<& index 0)
		    then (comp-err "vector index less than 0 " v-form))
		(setq needlowcheck nil))

       ; Compute the value to be stored...
       ;
       ; If we are doing an immediate vector, then get the value
       ; instead of the boxed fixnum (in the case of byte), or
       ; word/long.
       (if (null (eq 'lisp type)) then (setq val `(cdr ,val)))

       (if (null (setq vect-val (d-simple val)))
	   then (let ((g-loc val-reg) g-cc g-ret)
		    (d-exp val))
		(setq vect-val val-reg)
	   else (setq vect-val (e-cvt vect-val)))

       ; make sure that we are not going to clobber val-reg...
       (if (not (and (d-simple vect) (d-simple index)))
	   then ; val-reg could be clobbered when we do the
		; fetching of the vector or index values
		(setq fetchval t)
		(e-move vect-val (e-cvt 'stack)))

       ; Compute the index...
       ;
       (if (setq index-addr (d-simple index))
	   then (let ((g-loc vec-reg) g-cc g-ret)
		    (d-exp vect))
		(setq vect-addr vec-reg)	; the vector op is in vec-reg
		; we really want the cdr of index (the actual number).
		; if we can do that simply, great.  otherwise we
		; bring the index into index-reg and then do the cdr ourselves
		(if (setq temp (d-simple `(cdr ,index)))
		    then (d-move temp index-reg)
		    else (d-move index-addr index-reg)
			 #+for-vax
			 (e-move `(0 ,index-reg) index-reg)
			 #+for-68k
			 (progn
			     (e-move index-reg 'a5)
			     (e-move '(0 a5) index-reg)))
		(setq index-addr index-reg)
	   else ; the index isn't computable simply, so we must
		; stack the vector location to keep it safe
		(let ((g-loc 'stack) g-cc g-ret)
		    (d-exp vect))
		(push nil g-locs)
		(incr g-loccnt)
		; compute index's value into index-reg
		(d-fixnumexp index)
		; now put vector address into vec-reg
		(d-move 'unstack vec-reg)
		(decr g-loccnt)
		(pop g-locs)
		(setq vect-addr vec-reg
		      index-addr index-reg)
		; must be sure that the cc's reflect the value of index-reg
		(e-tst index-reg))

       ;   At this point, vect-addr (always vec-reg) contains the location of
       ; the start of the vector,  index-addr (always index-reg) contains
       ; the index value.
       ;   The condition codes reflect the value of the index.
       ; First we insure that the index is non negative
       ; test must use a jmp in case the object file is large
       ;
       (if needlowcheck
	   then (e-write2 #+for-vax 'jgeq #+for-68k 'jpl oklab)
		(e-write2 'jmp 'vecindexerr)
		(e-label oklab)
		(setq oklab (d-genlab)))
       ;; now, we compare against the size of the vector
       ;; the size of the vector is in bytes, we may want to shift this
       ;; to reflect the size in words or longwords, depending on the
       ;; type of reference
       (if (eq type 'byte)
	   then ; can compare right away
		(e-cmp index-addr `(-8 ,vect-addr))
	   else ; shift size into temp-reg
		(setq size (if (eq type 'word) then 1 else 2))
		#+for-vax
		    (e-write4 'ashl (concat '$- size)
			      `(-8 ,vect-addr) temp-reg)
		#+for-68k
		(progn
		    (e-move `(-8 ,vect-addr) temp-reg)
		    (e-write3 'asrl `($ ,size) temp-reg))
		(e-cmp index-addr temp-reg)
		(d-clearreg temp-reg))
       ;; size is the number of objects, the index is 0 based so
       ;; it must be less than the vector size
       (e-write2 #+for-vax 'jlss #+for-68k 'jmi oklab)
       (e-write2 'jmp 'vecindexerr)
       (e-label oklab)

       (if fetchval
	   then ; unstack the value to store...
		(e-move (e-cvt 'unstack) val-reg)
		(setq vect-val val-reg))

       ;; if we get here then the access is in bounds
       (if (eq type 'lisp)
	   then #+for-vax
		(e-move vect-val `(0 ,vect-addr ,index-addr))
		#+for-68k
		(progn
		    (e-move index-addr temp-reg)
		    (e-write3 'asll '($ 2) temp-reg)
		    (e-add vect-addr temp-reg)
		    (e-move temp-reg temp-areg)
		    (e-move vect-val `(0 ,temp-areg)))
		(if g-loc (e-move vect-val (e-cvt g-loc)))
		(if g-cc then (d-handlecc))
	   else (setq temp (cadr (assq type '((byte movb)
					      (word movw)
					      (long movl)))))
		#+for-vax
		(e-write3 temp vect-val `(0 ,vect-addr ,index-addr))
		#+for-68k
		(progn
		    (e-move index-addr temp-reg)
		    (caseq type
			(word (e-write3 'asll '($ 1) temp-reg))
			(long (e-write3 'asll '($ 2) temp-reg)))
		    (e-write3 'lea `(% 0 ,vec-reg ,temp-reg) temp-areg)
		    (if (eq type 'long)
			then (e-write3 temp vect-val `(0 ,temp-areg))
			else (e-move vect-val 'd1)
			     (e-write3 temp 'd1 `(0 ,temp-areg))))
		(if g-loc
		    then (if (eq type 'byte)
			     then ; all bytes values are within the fixnum
				  ; range, we convert them to immediate
				  ; fixum with ease.
				  #+for-vax
				  (progn
				      (e-write4 'ashl '($ 2)
						index-reg index-reg)
				      (e-write3 'movab
						`(5120 ,index-reg)
						(e-cvt g-loc)))
				  #+for-68k
				  (progn
				      (e-move index-reg temp-reg)
				      (e-write3 'asll '($ 2) temp-reg)
				      (e-move temp-reg temp-areg)
				      (e-move
						(e-cvt '(fixnum 0))
						temp-reg)
				      (e-write3 'lea
						`(% 0 ,temp-areg ,temp-reg)
						temp-areg)
				      (e-move
						temp-areg
						(e-cvt g-loc)))
			     else ; must convert the hard way
				  (e-call-qnewint)
				  (d-clearreg)
				  (if (not (eq g-loc 'reg))
				      then (d-move 'reg g-loc)))
			 ; result is always non nil
			 (if (car g-cc) then (e-goto (car g-cc)))
		 elseif (car g-cc) then (e-goto (car g-cc))))
       (d-vectorindexcode)))

;--- d-vref :: handle all types of vref's
(defun d-vref (type)
   ;;  Generic vector reference.  Type is either 'lisp', 'byte', 'word',
   ;; or 'long'.
   (let ((vect (cadr v-form))
	 (index (caddr v-form))
	 (vect-addr) (index-addr) (temp) (size)
	 (vec-reg #+for-vax 'r0 #+for-68k 'a0)
	 (index-reg '#.fixnum-reg)
	 (temp-reg #+for-vax 'r4 #+for-68k 'd0)
	 (temp-areg #+for-vax 'rX #+for-68k 'a1)
	 (oklab (d-genlab))
	 (needlowcheck t))  ; t if must check lower index bounds

       #+for-68k (d-regused '#.fixnum-reg)
       (makecomment `(doing vec ref type ,type))
       (if (fixp index)
	   then (if (<& index 0)
		    then (comp-err "vector index less than 0 " v-form))
		(setq needlowcheck nil))

       (if (setq index-addr (d-simple index))
	   then (let ((g-loc vec-reg) g-cc g-ret)
		    (d-exp vect))
		(setq vect-addr vec-reg)	; the vector op is in vec-reg
		; we really want the cdr of index (the actual number).
		; if we can do that simply, great.  otherwise we
		; bring the index into index-reg and then do the cdr ourselves
		(if (setq temp (d-simple `(cdr ,index)))
		    then (d-move temp index-reg)
		    else (d-move index-addr index-reg)
			 #+for-vax
			 (e-move `(0 ,index-reg) index-reg)
			 #+for-68k
			 (progn
			     (e-move index-reg 'a5)
			     (e-move '(0 a5) index-reg)))
		(setq index-addr index-reg)
	   else ; the index isn't computable simply, so we must
		; stack the vector location to keep it safe
		(let ((g-loc 'stack) g-cc g-ret)
		    (d-exp vect))
		(push nil g-locs)
		(incr g-loccnt)
		; compute index's value into index-reg
		(d-fixnumexp index)
		; now put vector address into vec-reg
		(d-move 'unstack vec-reg)
		(decr g-loccnt)
		(pop g-locs)
		(setq vect-addr vec-reg
		      index-addr index-reg)
		; must be sure that the cc's reflect the value of index-reg
		(e-tst index-reg))
       
       ; at this point, vect-addr (always vec-reg) contains the location of
       ; the start of the vector,  index-addr (always index-reg) contains
       ; the index value.  the condition codes reflect the value of
       ; the index
       ; First we insure that the index is non negative
       ; test must use a jmp in case the object file is large
       (if needlowcheck
	   then (e-write2 #+for-vax 'jgeq #+for-68k 'jpl oklab)
		(e-write2 'jmp 'vecindexerr)
		(e-label oklab)
		(setq oklab (d-genlab)))

       ; now, we compare against the size of the vector
       ; the size of the vector is in bytes, we may want to shift this
       ; to reflect the size in words or longwords, depending on the
       ; type of reference
       (if (eq type 'byte)
	   then ; can compare right away
		(e-cmp index-addr `(-8 ,vect-addr))
	   else ; shift size into temp-reg
		(setq size (if (eq type 'word) then 1 else 2))
		#+for-vax
		(e-write4 'ashl (concat '$- size) `(-8 ,vect-addr) temp-reg)
		#+for-68k
		(progn
		    (e-move `(-8 ,vect-addr) temp-reg)
		    (e-write3 'asrl `($ ,size) temp-reg))
		(e-cmp index-addr temp-reg)
		(d-clearreg temp-reg))
       ; size is the number of objects, the index is 0 based so
       ; it must be less than the vector size
       (e-write2 #+for-vax 'jlss #+for-68k 'jmi oklab)
       (e-write2 'jmp 'vecindexerr)
       (e-label oklab)

       ;; if we get here then the access is in bounds
       (if g-loc
	   then ; we care about the value.
		; if the value is one of the fixnum types, then we
		; move the value to index-reg so it can be fixnum converted
		(if (eq type 'lisp)
		    then #+for-vax
			 (e-move `(0 ,vect-addr ,index-addr)
				   (e-cvt g-loc))
			 #+for-68k
			 (progn
			     (e-move index-addr temp-reg)
			     (e-write3 'asll '($ 2) temp-reg)
			     (e-add vect-addr temp-reg)
			     (e-move temp-reg temp-areg)
			     (e-move `(0 ,temp-areg) (e-cvt g-loc)))
			 (if g-cc then (d-handlecc))
		    else #+for-vax
			 (progn
			     (setq temp (cadr (assq type '((byte cvtbl)
							   (word cvtwl)
							   (long movl)))))
			     (e-write3 temp
				       `(0 ,vect-addr ,index-addr)
				       index-reg))
			 #+for-68k
			 (progn
			     (setq temp
				   (cadr (assq type '((byte movb)
						      (word movw)
						      (long movl)))))
			     (caseq type
				    (word (e-write3 'asll '($ 1) index-reg))
				    (long (e-write3 'asll '($ 2) index-reg)))
			     (e-write3 'lea `(% 0 ,vec-reg ,index-reg)
				       temp-areg)
			     (if (memq type '(byte word))
				 then (e-write2 'clrl index-reg))
			     (e-write3 temp `(0 ,temp-areg) index-reg))
			 (if (eq type 'byte)
			     then ; all bytes values are within the fixnum
				  ; range, we convert them to immediate
				  ; fixum with ease.
				  #+for-vax
				  (progn
				      (e-write4 'ashl '($ 2)
						index-reg index-reg)
				      (e-write3 'movab
						`(5120 ,index-reg)
						(e-cvt g-loc)))
				  #+for-68k
				  (progn
				      (e-write3 'asll '($ 2) index-reg)
				      (e-move index-reg temp-areg)
				      (e-move
						'($ _nilatom+0x1400)
						temp-reg)
				      (e-write3 'lea
						`(% 0 ,temp-areg ,temp-reg)
						temp-areg)
				      (e-move
						temp-areg
						(e-cvt g-loc)))
			     else ; must convert the hard way
				  (e-call-qnewint)
				  (d-clearreg)
				  (if (not (eq g-loc 'reg))
				      then (d-move 'reg g-loc)))
			 ; result is always non nil
			 (if (car g-cc) then (e-goto (car g-cc))))
	elseif g-cc
	     ; we dont care about the value, just whether it nil
	   then (if (eq type 'lisp)
		    then #+for-vax
			 (e-tst `(0 ,vect-addr ,index-addr))
			 #+for-68k
			 (progn
			     (e-move index-addr temp-reg)
			     (e-write3 'asll '($ 2) temp-reg)
			     (e-add vect-addr temp-reg)
			     (e-move temp-reg temp-areg)
			     (e-cmpnil `(0 ,temp-areg)))
			 (d-handlecc)
		    else ; if fixnum, then it is always true
			 (if (car g-cc) then (e-goto (car g-cc)))))
       (d-vectorindexcode)))

;--- d-vectorindexcode :: put out code to call the vector range error.
; At this point the vector is in r0, the index an immediate fixnum in r5
; we call the function int:vector-range-error with two arguments, the
; vector and the index.
;
(defun d-vectorindexcode ()
   (if (null g-didvectorcode)
      then (let ((afterlab (d-genlab)))
	      (e-goto afterlab)
	      (e-label 'vecindexerr)
	      (d-move #+for-vax 'r0 #+for-68k 'a0 'stack)
	      (e-call-qnewint)
	      (d-move 'reg 'stack)
	      (d-calltran 'int:vector-range-error 2)
	      ; never returns
	      (e-label afterlab))
	   (setq g-didvectorcode t)))


;------------------------ vector access functions

;--- cc-vectorp :: check for vectorness
;
(defun cc-vectorp nil
  (d-typesimp (cadr v-form) #.(immed-const 18)))

;--- cc-vectorip :: check for vectoriness
;
(defun cc-vectorip nil
  (d-typesimp (cadr v-form) #.(immed-const 19)))

;--- c-vsize :: extract vsize
;
(defun c-vsize nil
   (d-vectorsize (cadr v-form) '2))

(defun c-vsize-byte nil
   (d-vectorsize (cadr v-form) '0))

(defun c-vsize-word nil
   (d-vectorsize (cadr v-form) '1))

(defun d-vectorsize (form shift)
   (let ((g-loc #+for-vax 'reg #+for-68k 'a0)
	 g-cc
	 g-ret)
       (d-exp form))
   ; get size into `fixnum-reg' for fixnum boxing
   (if (zerop shift)
       then (e-move '(-8 #+for-vax r0 #+for-68k a0) '#.fixnum-reg)
       else #+for-vax
	    (e-write4 'ashl (concat '$- shift) '(-8 r0) '#.fixnum-reg)
	    #+for-68k
	    (progn
		(e-move '(-8 a0) '#.fixnum-reg)
		(e-write3 'asrl `($ ,shift) '#.fixnum-reg)))
   (e-call-qnewint))
EndOfFile
cat >  liszt/instr.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file instr
   "$Header: instr.l,v 1.7 84/01/05 18:40:55 jkf Exp $")

;;; ----	i n s t r		emulate machine instructions
;;;
;;;				-[Thu Jan  5 18:40:50 1984 by jkf]-


;  The routines in this file emulate instructions, usually VAX-11
; ones.  Routines names with the prefix "e-" take EIADR's, and
; those with "d-" take IADR's as arguments.
;  Some of the simple routines are accually macros, and can be found in
; ../cmacros.l


;--- d-add :: emit an add intruction
; 68000 has a quick add for $1 - $8
;
; (the one for the vax is a macro in cmacros.l)
#+for-68k
(defun e-add (src dst)
  (if (and (dtpr src)
	   (eq '$ (car src))
	   (and (>& (cadr src) 0) (<& (cadr src) 9)))
      then (e-write3 'addql src dst)
      else (e-write3 'addl src dst)))

;--- e-sub :: emit an add intruction (check for quick add: (immed 1 - 8))
;
#+for-68k
(defun e-sub (src dst)
   (if (and (dtpr src)
	    (eq '$ (car src))
	    (zerop (cadr src)))
       thenret
    elseif (and (dtpr src)
		(numberp (cadr src))
		(and (>& (cadr src) 0) (<& (cadr src) 9)))
       then (e-write3 'subql src dst)
       else (e-write3 'subl src dst)))

; NOTE: The cmp routines emis instructions to test the condition codes
;	by arg1 - arg2 (ie, arg1 is subtracted from arg2).  On the
;	68000 the args must be reversed.

;--- e-cmp :: compare two EIADR values
;
; NOTE: for 68000, this does "cmpl dst,src"
;
#+for-68k
(defun e-cmp (src dst)
   (if (and (symbolp src)
	    (memq src '(d0 d7 a0 a1 a2 d3 d1 d2 a3 a4 a5 sp d6 a6 d4 d5)))
       then ; the form is "cmp <ea>,Rx"
	    (e-write3 'cmpl dst src)
    elseif (and (dtpr dst)
		(or (memq (car dst) '($ \#))
		    (and (eq '* (car dst))
			 (eq '\# (cadr dst)))))
       then ; the form is "cmp #const,<ea>"
	    (if (and (dtpr src)
		     (or (memq (car src) '($ \#))
			 (and (eq '* (car src))
			      (eq '\# (cadr src)))))
		then ; we have "cmp #n,#m"
		     ; and we can't do it in one cmp
		     (d-regused 'd6)
		     (e-write3 'movl src 'd6)
		     (e-write3 'cmpl dst 'd6)
		else ; we have "cmp #n,<ea>"
		     (e-write3 'cmpl dst src))
    elseif (and (dtpr src)
		(dtpr dst)
		(eq '+ (car src))
		(eq '+ (car dst)))
       then ; the form is "cmp An@+,Am@+"
	    (e-write3 'cmpml dst src)
       else ; addressing modes are too complicated to
	    ; do in 1 instruction...
	    (d-regused 'd6)
	    (e-write3 'movl src 'd6)
	    (e-write3 'cmpl dst 'd6)))

;--- e-move :: move value from one place to anther
; this corresponds to d-move except the args are EIADRS
;
(defun e-move (from to)
   (if (and (dtpr from)
	    (eq '$ (car from))
	    (eq 0 (cadr from)))
       then (e-write2 'clrl to)
       else (e-write3 'movl from to)))

;--- d-move :: emit instructions to move value from one place to another
;
(defun d-move (from to)
  (makecomment `(from ,(e-uncvt from) to ,(e-uncvt to)))
  #+for-vax
  (cond ((eq 'Nil from) (e-write2 'clrl (e-cvt to)))
	(t (e-move (e-cvt from) (e-cvt to))))
  #+for-68k
  (let ((froma (e-cvt from))
	(toa (e-cvt to)))
       (if (and (dtpr froma)
		(eq '$ (car froma))
	        (and (>& (cadr froma) -1) (<& (cadr froma) 65))
		(atom toa)
		(eq 'd (nthchar toa 1)))
           then ;it's a mov #immed,Dn, where 0 <= immed <= 64
		;  i.e., it's a quick move
	        (e-write3 'moveq froma toa)
           else (cond ((eq 'Nil froma) (e-write3 'movl '#.nil-reg toa))
		      (t (e-write3 'movl froma toa))))))

;--- d-movespec :: move from loc to loc where the first addr given is
;	           an EIADR
;	- from : EIADR 
;	- to   : IADR
;
(defun d-movespec (from to)
  (makecomment `(fromspec ,from to ,(e-uncvt to)))
  (e-move from (e-cvt to)))

;--- d-ashl :: emit shift code (don't know what direction to shift)
#+for-68k
(defun d-ashl (count src dst)
  (let ((genlab1 (d-genlab))
	(genlab2 (d-genlab)))
       (e-write3 'movl src dst)
       (e-write2 'tstl count)
       (e-write2 'bmi genlab1)
       (e-write3 'asll count dst)
       (e-write2 'bra genlab2)
       (e-label genlab1)
       (e-write3 'asrl count dst)
       (e-writel genlab2)))

;--- d-asrl :: emit shift right code
#+for-68k
(defun d-asrl (count src dst)
   (e-write3 'movl src dst)
   (if (and (numberp count) (greaterp count 8))
       then (e-write3 'moveq (concat "#" count) 'd0)
	    (e-write3 'asrl 'd0 dst)
       else (e-write3 'asrl (concat "#" count) dst)))

;--- d-asll :: emit shift left code
#+for-68k
(defun d-asll (count src dst)
  (e-write3 'movl src dst)
  (if (and (numberp count) (greaterp count 8))
      then (e-write3 'moveq `($ ,count) 'd0)
           (e-write3 'asll 'd0 dst)
      else (e-write3 'asll `($ ,count) dst)))
EndOfFile
cat >  liszt/tlev.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file tlev
   "$Header: tlev.l,v 1.16 84/01/13 15:06:43 jkf Exp $")

;;; ----	t l e v				top level interface
;;;
;;;				-[Tue Nov 22 09:21:27 1983 by jkf]-

;--- lisztinit : called upon compiler startup. If there are any args
;	       on the command line, we build up a call to liszt, which
;	       will do the compile. Afterwards we exit.
;
(def lisztinit
   (lambda nil
      (setq fl-asm nil)		; insure it as correct value in case of int
      (let ((args (command-line-args)))
	 (if args
	    then (signal 2 'liszt-interrupt-signal)  ; die on int
		 (signal 15 'liszt-interrupt-signal)  ; die on sigterm
		 (setq user-top-level nil)
		 (exit (apply 'liszt args))
	    else (patom compiler-name)
		 (patom " [")(patom franz-minor-version-number)(patom "]")
		 (terpr poport)
		 (setq user-top-level nil)))))

(setq user-top-level 'lisztinit)

;--- liszt - v-x : list containing file name to compile and optionaly
;		 and output file name for the assembler source.
;
(def liszt
  (nlambda (v-x)
	   (prog (piport v-root v-ifile v-sfile v-ofile 
			 vp-ifile vp-sfile vps-crap
			 vps-include vns-include
			 asm-exit-status ntem temgc temcp
			 rootreal g-arrayspecs out-path
			 g-decls g-stdref pre-eval include-files
			 g-fname g-trueop g-falseop g-didvectorcode
			 tem temr starttime startptime startgccount
			 fl-asm fl-warn fl-warnfatal fl-verb fl-inter
			 fl-xref fl-uci fl-run fl-case fl-anno g-optionalp
			 liszt-process-forms in-line-lambda-number
			 g-skipcode g-dropnpcnt g-complrname g-fname)

		 ;in case "S" switch given, set asm-exit-status
		 ;  to 0 (so garbage won't be returned).
		 (setq asm-exit-status 0)

		 ; turn on monitoring if it exists
		 #+monitoring
		 (errset (progn (monitor t)	; turn it on
				(print 'monitor-on)
				(terpr))
			 nil)
		 (setq starttime (sys:time)   ; real time in seconds
		       startptime (ptime)
		       startgccount $gccount$)
		 (setq in-line-lambda-number (sys:time))
		 (cond ((null (boundp 'internal-macros))
			(setq internal-macros nil)))
		 (cond ((null (boundp 'macros))
			(setq macros nil)))
		 (setq er-fatal 0  er-warn 0)
		 (setq vps-include nil  
		       vns-include nil)  ;stack of ports and names
		 (setq twa-list nil)
		 (setq liszt-eof-forms nil)

		 ; look for lisztrc file and return if error occured
		 ; in reading it
		 (cond ((eq (do-lisztrc-check) 'error)
			(return 1)))
		 
		 ; set up once only g variables
		 (setq g-comments nil
		       g-current nil		; current function name
		       g-funcs nil
		       g-lits nil
		       g-trueloc nil
		       g-tran nil
		       g-allf nil		; used in xrefs
		       g-reguse #+for-vax (copy '((r4 0 . nil) (r3 0 . nil)
						  (r2 0 . nil); (r7 0 . nil)
						  (r1 0 . nil)))
		       		#+for-68k (copy '((a0 0 . nil) (a1 0 . nil)
						  (d1 0 . nil) (d2 0 . nil)
						  (d4 0 . nil) (d5 0 . nil)))
		       g-trancnt 0
		       g-ignorereg nil
		       g-trueop  #+for-vax 'jneq	; used in e-gotot
		       	 	 #+for-68k 'jne
		       g-falseop #+for-vax 'jeql	; used in e-gotonil
		       		 #+for-68k 'jeq
		       g-compfcn nil
		       g-litcnt 0)
		 (setq g-spec (gensym 'S))	; flag for special atom
		 (setq g-fname "")		; no function yet
		 (setq special nil)		; t if all vrbs are special
		 (setq g-functype (gensym)
		       g-vartype  (gensym)
		       g-bindtype (gensym)
		       g-calltype (gensym)
		       g-bindloc  (gensym)
		       g-localf   (gensym)
		       g-arrayspecs (gensym)
		       g-tranloc  (gensym)
		       g-stdref   (gensym)
		       g-optionalp (gensym))

		 ; declare these special

		 (sstatus feature complr)
		 (d-makespec 't)		; always special

		 ; process input form
		 (setq fl-asm t		; assembler file assembled
		       fl-warn t	; print warnings
		       fl-warnfatal nil	; warnings are fatal
		       fl-verb t	; be verbose
		       fl-macl nil	; compile maclisp file
		       fl-anno nil	; annotate 
		       fl-inter nil	; do interlisp compatablity
		       fl-tty nil	; put .s on tty
		       fl-comments nil    ; put in comments
		       fl-profile nil	; profiling
		       fl-tran	  t	; use transfer tables
		       fl-vms	nil	; vms hacks
		       fl-case  nil	; trans uc to lc
		       fl-xref	nil	; xrefs
		       fl-run	nil	; autorun capability
		       fl-uci   nil	; uci lisp compatibility
		       )

		 ; look in the environment for a LISZT variable
		 ; if it exists, make it the first argument 
		 (if (not (eq '|| (setq tem (getenv 'LISZT))))
		     then (setq v-x (cons (concat "-" tem) v-x)))

		 (do ((i v-x (cdr i)))	; for each argument
		     ((null i))
		     (setq tem (aexplodec (car i)))

		     (cond ((eq '- (car tem))	; if switch
			    (do ((j (cdr tem) (cdr j)))
				((null j))
				(cond ((eq 'S (car j)) (setq fl-asm nil))
				      ((eq 'C (car j)) (setq fl-comments t))
				      ((eq 'm (car j)) (setq fl-macl t))
				      ((eq 'o (car j)) (setq v-ofile (cadr i)
							     i (cdr i)))
				      ((eq 'e (car j)) (setq pre-eval (cadr i)
							     i (cdr i)))
				      ((eq 'i (car j)) (push (cadr i)
							     include-files)
				       		       (pop i))
				      ((eq 'w (car j)) (setq fl-warn nil))
				      ((eq 'W (car j)) (setq fl-warnfatal t))
				      ((eq 'q (car j)) (setq fl-verb nil))
				      ((eq 'Q (car j)) (setq fl-verb t))
				      ((eq 'T (car j)) (setq fl-tty t))
				      ((eq 'a (car j)) (setq fl-anno t))
				      ((eq 'i (car j)) (setq fl-inter t))
				      ((eq 'p (car j)) (setq fl-profile t))
				      ((eq 'F (car j)) (setq fl-tran nil))
				      ((eq 'v (car j)) (setq fl-vms t))
				      ((eq 'r (car j)) (setq fl-run t))
				      ((eq 'x (car j)) (setq fl-xref t))
				      ((eq 'c (car j)) (setq fl-case t))
				      ((eq 'u (car j)) (setq fl-uci  t))
				      ((eq '- (car j)))  ; ignore extra -'s
				      (t (comp-gerr "Unknown switch: "
						    (car j))))))
			   ((null v-root)
			    (setq temr (reverse tem))
			    (cond ((and (eq 'l (car temr))
					(eq '\. (cadr temr)))
				   (setq rootreal nil)
				   (setq v-root
					 (apply 'concat
						(reverse (cddr temr)))))
				  (t (setq v-root (car i)
					   rootreal t))))

			   (t (comp-gerr "Extra input file name: " (car i)))))

		 ;no transfer tables in vms
		 (cond (fl-vms (setq fl-tran nil)))

		 ; if verbose mode, print out the gc messages and
		 ; fasl messages, else turn them off.
		 (cond (fl-verb (setq $gcprint t
				      $ldprint t))
		       (t (setq $gcprint nil
				 $ldprint nil)))

		 ; eval arg after -e
		 (if pre-eval
		    then (if (null (errset
				      (eval (readlist (exploden pre-eval)))))
			    then (comp-gerr "-e form caused error: "
					    pre-eval)))

		 ; load file after -i arg
		 (if include-files
		    then (catch
			    (mapc
			       '(lambda (file)
				   (if (null (errset (load file)))
				      then (comp-err
					      "error when loading -i file: "
					      file)))
			       include-files)
			    Comp-error))

		 ; -c says set reader to xlate uc to lc
		 (cond (fl-case (sstatus uctolc t)))

		 ; If we are a cross compiler, then don't try to
		 ; assemble our output...
		 ;
		 #+for-vax
		 (if (status feature 68k)
		     then (setq fl-asm nil))
		 #+for-68k
		 (if (status feature vax)
		     then (setq fl-asm nil))

		 ; now see what the arguments have left us
		 (cond ((null v-root)
			(comp-gerr "No file for input"))
		       ((or (portp 
			     (setq vp-ifile 
				   (car (errset (infile 
						   (setq v-ifile 
							 (concat v-root '".l"))) 
						nil))))
			    (and rootreal
				 (portp
				  (setq vp-ifile
					(car (errset 
					         (infile (setq v-ifile v-root))
					         nil)))))))
		       (t (comp-gerr "Couldn't open the source file :"
				     (or v-ifile))))


		 ; determine the name of the .s file
		 ; strategy: if fl-asm is t (assemble) use (v-root).s
		 ;	     else use /tmp/(PID).s
		 ;  
		 ; direct asm to tty temporarily
		 (setq v-sfile "tty")
		 (setq vp-sfile nil)
		 (if (null fl-tty) then
		     (cond (fl-asm (setq v-sfile
					 (concat '"/tmp/Lzt"
							  (boole 1 65535
								 (sys:getpid))
							  '".s")))
			   (t (setq v-sfile
				    (if v-ofile
					then v-ofile
					else (concat v-root '".s")))))
		     
		     (cond ((not (portp (setq vp-sfile
					      (car (errset (outfile v-sfile)
							   nil)))))
			    (comp-gerr "Couldn't open the .s file: "
				       (or v-sfile)))))
				     
		 
		 ; determine the name of the .o file (object file)
		 ; strategy: if we aren't supposed to assemble the .s file
		 ;	      don't worry about a name
		 ; 	     else if a name is given, use it
		 ;	     else if use (v-root).o
		 ;  if profiling, use .o
		 (cond ((or v-ofile (null fl-asm)))		;ignore
		       ((null fl-profile) (setq v-ofile (concat v-root ".o")))
		       (t (setq v-ofile (concat v-root ".o"))))

		 ; determine the name of the .x file (xref file)
		 ; strategy: if fl-xref and v-ofile is true, then use
		 ; v-ofile(minus .o).x, else use (v-root).x
		 ;
		 (if fl-xref
		    then ; check for ending with .X for any X
			 (setq v-xfile
			       (if v-ofile
				  then (let ((ex (nreverse
						    (exploden v-ofile))))
					  (if (eq #/. (cadr ex))
					     then (implode
						     (nreverse
							`(#/x #/.
							   ,@(cddr ex))))
					     else (concat v-ofile ".x")))
				  else (concat v-root ".x")))
			 (if (portp
				(setq vp-xfile
				      (car (errset (outfile v-xfile)))))
			    thenret
			    else (comp-gerr "Can't open the .x file: "
					    v-xfile)))
		 (cond ((checkfatal) (return 1)))

		 ; g-complrname is a symbol which should be unique to
		 ; each fasl'ed file. It will contain the string which
		 ; describes the name of this file and the compiler
		 ; version.
		 (if fl-anno
		    then (setq g-complrname (concat "fcn-in-" v-ifile))
			 (Push g-funcs
			       `(eval (setq ,g-complrname
					    ,(get_pname
						(concat v-ifile
							" compiled by "
							compiler-name
							" on "
							(status ctime)))))))
							
		 
		 (setq readtable (makereadtable nil))	; use new readtable


		 ; if the macsyma flag is set, change the syntax to the
		 ; maclisp standard syntax.  We must be careful that we
		 ; dont clobber any syntax changes made by files preloaded
		 ; into the compiler.

		 (cond (fl-macl (setsyntax '\/ 'vescape) 	;  143 = vesc

				(cond ((eq 'vescape (getsyntax '\\))
				       (setsyntax '\\ 'vcharacter)))

				(cond ((eq 'vleft-bracket (getsyntax '\[))
				       (setsyntax '\[ 'vcharacter)
				       (setsyntax '\] 'vcharacter)))
				(setq ibase  8.)
				(sstatus uctolc t)
				
				(d-makespec 'ibase)	; to be special
				(d-makespec 'base)
				(d-makespec 'tty)

				(errset (cond ((null (getd 'macsyma-env))
					       (load 'machacks)))
					nil))
		       (fl-uci (load "ucifnc")
			       (cvttoucilisp)))

		 (cond (fl-inter (putprop '* 'cc-ignore 'fl-exprcc) ;comment
				 (remprop '* 'fl-expr)
				 ))

		 (cond ((checkfatal) (return 1)))  ; leave if fatal errors	

		 (if fl-verb 
		     then (comp-msg "Compilation begins with " compiler-name )
		          (comp-msg "source: "  v-ifile ", result: "
				    (cond (fl-asm v-ofile) (t v-sfile))))

		 (setq piport vp-ifile)		; set to standard input
		 (setq liszt-root-name v-root
		       liszt-file-name v-ifile)


		 (if fl-run then (d-printautorun))
	
		 (if fl-profile then (e-write1 '".globl mcount"))
	loop

		; main loop of the compiler.  It reads a form and
		; compiles it. It continues to compile forms from
		; liszt-process-forms was long at that list is
		; non-empty.  This allows one form to spawn off other
		; forms to be compiled (an alternative to (progn 'compile))
		;
	        (cond ((atom (errset 		; list for debugging,
						; errset for production.
			      (do ((i (read piport '<<end-of-file>>) 
				      (read piport '<<end-of-file>>))) 
				  ((eq i '<<end-of-file>>) nil)
				  (setq liszt-process-forms
					(cons i liszt-process-forms))
				  (do ((this (car liszt-process-forms)
					     (car liszt-process-forms)))
				      ((null liszt-process-forms))
				      (unpush liszt-process-forms)
				      (catch (liszt-form this) Comp-error)))))
		       (catch (comp-err "Lisp error during compilation")
			      Comp-error)
		       (setq piport nil)
		       (setq er-fatal (1+ er-fatal))
		       (return 1)))

		 (close piport)

		 ; if doing special character stuff (maclisp) reassert
		 ; the state

		 (cond (vps-include
			(comp-note  " done include")
			(setq piport (car vps-include)
			      vps-include (cdr vps-include)
			      v-ifile (car vns-include)
			      vns-include (cdr vns-include))
			(go loop)))

		 (cond (liszt-eof-forms
			(do ((ll liszt-eof-forms (cdr ll)))
			    ((null ll))
			    (cond ((atom (errset (liszt-form (car ll))))
				   (catch
				    (comp-note "Lisp error during eof forms")
				    Comp-error)
				   (setq piport nil)
				   (return 1))))))

		 ; reset input base
		 (setq ibase 10.)
		 (setq readtable (makereadtable t))
		 (sstatus uctolc nil)	; turn off case conversion
		 			; so bindtab will not have |'s
					; to quote lower case
		 (d-bindtab)

		 (d-printdocstuff)		; describe this compiler

		 (cond ((portp vp-sfile)
			(close vp-sfile)))  ; close assembler language file

		 ; if warnings are to be considered fatal, and if we
		 ; have seen to many warnings, make it fatal
		 (cond ((and fl-warnfatal (> er-warn 0))
			(comp-gerr "Too many warnings")))
		 
		 ; check for fatal errors and don't leave if so
		 (cond ((checkfatal) 
			(if fl-asm   			; unlink .s file
			    then (sys:unlink v-sfile))  ; if it is a tmp
			(return 1)))		; and ret with error status

		 (comp-note "Compilation complete")

		 (setq tem (Divide (difference (sys:time) starttime) 60))
		 (setq ntem (ptime))

		 (setq temcp (Divide (difference (car ntem) (car startptime))
				    3600))

		 (setq temgc (Divide (difference (cadr ntem) (cadr startptime))
				    3600))

		 (comp-note " Time: Real: " (car tem) ":" (cadr tem)
		        ", CPU: " (car temcp) ":" (quotient (cadr temcp) 60.0) 
			 ", GC: " (car temgc) ":" (quotient (cadr temgc) 60.0) 
			    " for "
			    (difference $gccount$ startgccount)
			    " gcs")

		 (cond (fl-xref
			(comp-note "Cross reference being generated")
			(print (list 'File v-ifile) vp-xfile)
			(terpr vp-xfile)
			(do ((ii g-allf (cdr ii)))
			    ((null ii))
			    (print (car ii) vp-xfile)
			    (terpr vp-xfile))
			(close vp-xfile)))


		 ; the assember we use must generate the new a.out format
		 ; with a string table.  We will assume that the assembler
		 ; is in /usr/lib/lisp/as so that other sites can run
		 ; the new assembler without installing the new assembler
		 ; as /bin/as
		 (cond (fl-asm 			; assemble file 
			 (comp-note "Assembly begins")
			 (cond ((not
				   (zerop
				      (setq asm-exit-status
					    (*process
					       (concat
						  lisp-library-directory
						  "/as "
					#+for-vax "-V"   ; use virt mem
						  " -o "
						  v-ofile
						  " "
						  v-sfile)))))
				(comp-gerr "Assembler detected error, code: "
					   asm-exit-status)
				(comp-note "Assembler temp file " v-sfile
					   " is not unlinked"))
			       (t (comp-note "Assembly completed successfully")
				  (errset (sys:unlink v-sfile)); unlink tmp
				  			       ; file
				  (if fl-run
				      then (errset
					    (sys:chmod v-ofile #O775)))))))

		 #+(and sun (not unisoft))
		 (if (and v-ofile fl-run)
		     then (if (null
			       (errset (let ((port (fileopen v-ofile "r+")))
					    (fseek port 20 0)
					    (tyo 0 port)
					    (tyo 0 port)
					    (tyo 128 port)
					    (tyo 0 port)
					    (close port))))
			      then (comp-err
				    "Error while fixing offset in object file: "
				    v-ofile)))

		 (setq readtable original-readtable)
		 #+monitoring
		 (errset (progn (monitor)	; turn off monitoring
				(print 'monitor-off))
			 nil)
		 (sstatus nofeature complr)
		 (return asm-exit-status))))

(def checkfatal
  (lambda nil
	  (cond ((greaterp er-fatal 0)
		 (catch (comp-err "Compilation aborted due to previous errors")
			Comp-error)
		 t))))

;--- do-lisztrc-check
; look for a liszt init file named
;  .lisztrc  or  lisztrc or $HOME/.lisztrc or $HOME/lisztrc
; followed by .o or .l or nothing
; return the symbol 'error' if an error occured while reading.
;
(defun do-lisztrc-check nil
   (do ((dirs `("." ,(getenv 'HOME)) (cdr dirs))
	(val)
	($gcprint nil)
	($ldprint nil))
       ((null dirs))
       (if (setq val
		 (do ((name '(".lisztrc" "lisztrc") (cdr name))
		      (val))
		     ((null name))
		     (if (setq val
			       (do ((ext '(".o" ".l" "") (cdr ext))
				    (file))
				   ((null ext))
				   (if (probef
					  (setq file (concat (car dirs)
							     "/"
							     (car name)
							     (car ext))))
				      then (if (atom (errset (load file)))
					      then (comp-msg
					"Error loading liszt init file "
						      file N
						      "Compilation aborted" N)
						   (return 'error)
					      else (return t)))))
			then (return val))))
	  then (return val))))

      
;--- liszt-form - i : form to compile
;	This compiles one form.
;
(def liszt-form
  (lambda (i)
     (prog (tmp v-x)
	  ; macro expand
       loop
	  (setq i (d-macroexpand i))
	  ; now look at what is left
	  (cond ((not (dtpr i)) (Push g-funcs `(eval ,i)))
		((eq (car i) 'def)
		 (cond (fl-verb (print (cadr i)) (terpr)(drain)))
		 (d-dodef i))
		((memq (car i) '(liszt-declare declare))
		 (funcall 'liszt-declare  (cdr i)))
		((eq (car i) 'eval-when) (doevalwhen i))
		((and (eq (car i) 'progn) (equal (cadr i) '(quote compile)))
		 ((lambda (internal-macros)	; compile macros too
			  (mapc 'liszt-form (cddr i)))
		       t))
		((or (and (eq (car i) 'includef) (setq tmp (eval (cadr i))))
		     (and (eq (car i) 'include ) (setq tmp (cadr i))))
		 (cond ((or (portp (setq v-x 
					 (car (errset (infile tmp) nil))))
			    (portp (setq v-x 
					 (car
					    (errset
					       (infile
						  (concat
						     lisp-library-directory
						     "/"
						     tmp))
					       nil))))
			    (portp (setq v-x 
					 (car (errset (infile (concat tmp
								      '".l")) 
						      nil)))))
			(setq vps-include (cons piport vps-include))
			(setq piport v-x)
			(comp-note " INCLUDEing file: "  tmp)
			(setq vns-include (cons v-ifile vns-include)
			      v-ifile tmp))
		       (t (comp-gerr "Cannot open include file: " tmp))))
		((eq (car i) 'comment) nil)   ; just ignore comments
		(t ; we have to macro expand
		   ; certain forms we would normally
		   ; just dump in the eval list.  This is due to hacks in
		   ; the mit lisp compiler which are relied upon by certain
		   ; code from mit.
		   (setq i (d-fullmacroexpand i))
		   
		   (Push g-funcs `(eval ,i)))))))

;--- d-dodef :: handle the def form
; 	- form : a def form: (def name (type args . body))
;
(defun d-dodef (form)
  (prog (g-ftype g-args body lambdaform symlab g-arginfo g-compfcn g-decls)

     
     (setq g-arginfo 'empty)
	
 loop
	; extract the components of the def form
	(setq g-fname (cadr form))
	(if (dtpr (caddr form))
	    then (setq g-ftype (caaddr form)
		       g-args (cadaddr form)
		       body (cddaddr form)
		       lambdaform (caddr form)
		       symlab (gensym 'F))
	    else (comp-gerr "bad def form " form))
	
	; check for a def which uses the mit hackish &xxx forms.
	; if seen, convert to a standard form and reexamine
	; the vax handles these forms in a special way.
	#+for-68k
	(if (or (memq '&rest g-args) 
		(memq '&optional g-args)
		(memq '&aux g-args))
	    then (setq form 
		       `(def ,(cadr form) ,(lambdacvt (cdr lambdaform))))
	         (go loop))
	
	; check for legal function name.  
	; then look at the type of the function and update the data base.
	(if (null (atom g-fname))
	    then (comp-err "bad function name")
	    else (setq g-flocal (get g-fname g-localf))    ; check local decl.
		 ; macros are special, they are always evaluated
		 ; and sometimes compiled.
		 (if (and (not g-flocal) (eq g-ftype 'macro))
		     then (eval form)
			  (if (and (null macros)
				   (null internal-macros))
			      then (comp-note g-fname
					      " macro will not be compiled")
				   (return nil))
			  (Push g-funcs `(macro ,symlab ,g-fname))
			  (if fl-anno then (setq g-arginfo nil)) ; no arg info
		  elseif g-flocal
		     then (if (null (or (eq g-ftype 'lambda)
					(eq g-ftype 'nlambda)))
			      then (comp-err
				       "bad type for local fcn: " g-ftype))
			  (if (or (memq '&rest g-args)
				  (memq '&optional g-args)
				  (memq '&aux g-args))
			      then (comp-err
				       "local functions can't use &keyword's "
				       g-fname))
		  elseif (or (eq g-ftype 'lambda)
			     (eq g-ftype 'lexpr))
		     then (push `(lambda ,symlab ,g-fname) g-funcs)
			  (putprop g-fname 'lambda g-functype)
		  elseif (eq g-ftype 'nlambda)
		     then (Push g-funcs `(nlambda ,symlab ,g-fname))
			  (putprop g-fname 'nlambda g-functype)
		     else (comp-err " bad function type " g-ftype)))
	(setq g-skipcode nil)	;make sure we aren't skipping code
	(forcecomment `(fcn ,g-ftype ,g-fname))
	(if g-flocal 
	   then (comp-note g-fname " is a local function")
	        (e-writel (car g-flocal))
	   else (if (null fl-vms) then (e-write2 '".globl" symlab))
	        (e-writel symlab))
	(setq g-locs nil g-loccnt 0 g-labs nil g-loc 'reg g-cc nil
	      g-ret t g-topsym (d-genlab))
	(if fl-xref then (setq g-refseen (gensym) g-reflst nil))
	(d-clearreg)
	#+for-68k (init-regmaskvec)
	; set up global variables which maintain knowledge about
	; the stack.  these variables are set up as if the correct
	; number of args were passed.
	(setq g-compfcn t)	; now compiling a function
	(push nil g-labs)		; no labels in a lambda
	(setq g-currentargs (length g-args))
	(d-prelude)			; do beginning stuff
	
	; on the vax, we handle & keywords in a special way in
	; d-outerlambdacomp.  This function also sets g-arginfo.
	#+for-vax
	(d-outerlambdacomp g-fname g-args (cddr lambdaform))
	
	#+for-68k
	(progn
	    (push (cons 'lambda 0) g-locs)
	    (mapc '(lambda (x)
		       (push nil g-locs)
		       (incr g-loccnt))
		  g-args)
	    ; set g-arginfo if this is a lambda. If it is a lexpr, then
	    ; we don't give all the info we could.
	    (setq g-arginfo
	     (if (eq g-ftype 'lambda)
		 then (cons g-loccnt g-loccnt)))
	    (d-lambbody lambdaform))

	(d-fini)
	(setq g-compfcn nil)		; done compiling a fcn
	(if fl-xref then 
	    (Push g-allf
		  (cons g-fname
			(cons (cond (g-flocal (cons g-ftype 'local))
				    (t g-ftype))
			      g-reflst))))
	(if (and fl-anno (not (eq 'empty g-arginfo)))
	   then (Push g-funcs `(eval (putprop
					',g-fname
					(list ',g-arginfo
					      ,g-complrname)
					'fcn-info))))
	; by storing argument count information during compilation
	; we can arg number check calls to this function which occur
	; further on. 
	(if (not (eq 'empty g-arginfo))
	   then (putprop g-fname (list g-arginfo) 'fcn-info))))

;--- d-lambdalistcheck :: scan lambda var list for & forms
; return
;  (required optional rest op-p body)
; required - list of required args
; optional - list of (variable default [optional-p])
; rest - either nil or the name of a variable for optionals
; op-p - list of variables set to t or nil depending if optional exists
; body - body to compile (has &aux's wrapped around it in lambdas)
;
#+for-vax
(defun d-lambdalistcheck (list body)
   (do ((xx list (cdr xx))
	(state 'req)
	(statechange)
	(arg)
	(req)(optional)(rest)(op-p)(aux))
       ((null xx)
	(list (nreverse req)
	      (nreverse optional)
	      rest
	      (nreverse op-p)
	      (d-lambda-aux-body-convert body (nreverse aux))))
       (setq arg (car xx))
       (if (memq arg '(&optional &rest &aux))
	  then (setq statechange arg)
	  else (setq statechange nil))
       (caseq state
	      (req
		 (if statechange
		    then (setq state statechange)
		  elseif (and (symbolp arg) arg)
		    then (push arg req)
		    else (comp-err " illegal lambda variable " arg)))
	      (&optional
		 (if statechange
		    then (if (memq statechange '(&rest &aux))
			    then (setq state statechange)
			    else (comp-err "illegal form in lambda list "
					   xx))
		  elseif (symbolp arg)
		    then ; optional which defaults to nil
			 (push (list arg nil) optional)
		  elseif (dtpr arg)
		    then (if (and (symbolp (car arg))
				  (symbolp (caddr arg)))
			    then ; optional with default
				 (push arg optional)
				 ; save op-p
				 (if (cddr arg)
				    then (push (caddr arg) op-p)))
		    else (comp-err "illegal &optional form "
				   arg)))
	      (&rest
		 (if statechange
		    then (if (eq statechange '&aux)
			    then (setq state statechange)
			    else (comp-err "illegal lambda variable form "
					   xx))
		  elseif rest
		    then (comp-err
			    "more than one rest variable in lambda list"
			    arg)
		    else (setq rest arg)))
	      (&aux
		 (if statechange
		    then (comp-err "illegal lambda form " xx)
		  elseif (and (symbolp arg) arg)
		    then (push (list arg nil) aux)
		  elseif (and (dtpr arg) (and (symbolp (car arg))
					      (car arg)))
		    then (push arg aux)))
	      (t (comp-err "bizzarro internal compiler error ")))))

;--- d-lambda-aux-body-convert :: convert aux's to lambdas
; give a function body and a list of aux variables
; and their inits, place a lambda initializing body around body
; for each lambda (basically doing a let*).
;
#+for-vax
(defun d-lambda-aux-body-convert (body auxlist)
   (if (null auxlist)
      then body
      else `(((lambda (,(caar auxlist))
		,@(d-lambda-aux-body-convert body (cdr auxlist)))
	     ,(cadar auxlist)))))

;--- d-outerlambdacomp :: compile a functions outer lambda body
; This function compiles the lambda expression which defines
; the function.   This lambda expression differs from the kind that
; appears within a function because
;  1. we aren't sure that the correct number of arguments have been stacked
;  2. the keywords &optional, &rest, and &aux may appear
;
; funname - name of function
; lambdalist - the local argument list, (with possible keywords)
; body - what follows the lambdalist
;
; 
;
#+for-vax
(defun d-outerlambdacomp (funname lambdalist body)
   (let (((required optional rest op-p newbody)
	  (d-lambdalistcheck lambdalist body))
	 (g-decls g-decls)
	 (reqnum 0) maxwithopt labs (maxnum -1) args)
       (d-scanfordecls body)
       ; if this is a declared lexpr, we aren't called
       ;
       (if (and (null optional) (null rest))
	   then ; simple, the number of args is required
		; if lexpr or local function, then don't bother
		(if (and (not g-flocal)
			 (not (eq g-ftype 'lexpr)))
		    then (d-checkforfixedargs
			     funname
			     (setq reqnum (setq maxnum (length required)))))
	   else ; complex, unknown number of args
		; cases:
		;  optional, no rest
		;  optional, with rest
		; no optional, rest + required
		; no optional, rest + no required
		(setq reqnum (length required)
		      maxwithopt (+ reqnum (length optional))
		      maxnum (if rest then -1 else maxwithopt))
		; determine how many args were given
		(e-sub3 '#.lbot-reg '#.np-reg '#.lbot-reg)
		(e-write4 'ashl '$-2 '#.lbot-reg '#.lbot-reg)
		;
		(if (null optional)
		    then ; just a rest
			 (let ((oklab (d-genlab))
			       (lllab (d-genlab))
			       (nopushlab (d-genlab)))
			     (if (> reqnum 0)
				 then (e-cmp '#.lbot-reg `($ ,reqnum))
				      (e-write2 'jgeq oklab)
				      ; not enough arguments given
				      (d-wnaerr funname reqnum -1)
				      (e-label oklab))
			     (e-pushnil 1)
			     (if (> reqnum 0)
				 then (e-sub `($ ,reqnum) '#.lbot-reg)
				 else (e-tst '#.lbot-reg))
			     (e-write2 'jleq nopushlab)
			     (e-label lllab)
			     (e-quick-call '_qcons)
			     (d-move 'reg 'stack)
			     (e-write3 'sobgtr '#.lbot-reg lllab)
			     (e-label nopushlab))
		    else ; has optional args
			 ; need one label for each optional plus 2
			 (do ((xx optional (cdr xx))
			      (res (list (d-genlab) (d-genlab))))
			     ((null xx) (setq labs res))
			     (push (d-genlab) res))
			 ; push nils for missing optionals
			 ; one case for required amount and one for
			 ; each possible number of optionals
			 (e-write4 'casel
				   '#.lbot-reg `($ ,reqnum)
				   `($ ,(- maxwithopt reqnum)))
			 (e-label (car labs))
			 (do ((xx (cdr labs) (cdr xx))
			      (head (car labs)))
			     ((null xx))
			     (e-write2 '.word (concat (car xx) "-" head)))
			 ; get here (when running code) if there are more
			 ; than the optional number of args or if there are
			 ; too few args.  If &rest is given, it is permitted
			 ; to have more than the required number
			 (let ((dorest (d-genlab))
			       (again (d-genlab))
			       (afterpush (d-genlab)))
			     (if rest
				 then ; check if there are greater than
				      ; the required number
				      ; preserve arg #
				      (C-push '#.lbot-reg)
				      (e-sub `($ ,maxwithopt) '#.lbot-reg)
				      (e-write2 'jgtr dorest)
				      (C-pop '#.lbot-reg))
			     ; wrong number of args
			     (d-wnaerr funname reqnum maxnum)
			     (if rest
				 then ; now cons the rest forms
				      (e-label dorest)
				      (e-pushnil 1)   ; list ends with nil
				      (e-label again)
				      (e-quick-call '_qcons)
				      (d-move 'reg 'stack)
				      ; and loop
				      (e-write3 'sobgtr '#.lbot-reg again)
				      ; arg #
				      (C-pop '#.lbot-reg)
				      (e-goto afterpush))
			     ; push the nils on the optionals
			     (do ((xx (cdr labs) (cdr xx)))
				 ((null xx))
				 (e-label (car xx))
				 ; if we have exactly as many arguments given
				 ; as the number of optionals, then we stack
				 ; a nil if there is a &rest after
				 ; the optionals
				 (if (null (cdr xx))
				     then (if rest
					      then (e-pushnil 1))
				     else (e-pushnil 1)))
			     (e-label afterpush))))
       ; for optional-p's stack t's
       (mapc '(lambda (form) (d-move 'T 'stack)) op-p)

       ; now the variables must be shallow bound
       ; creat a list of all arguments
       (setq args (append required
			  (mapcar 'car optional)
			  (if rest then (list rest))
			  op-p))

       (push (cons 'lambda 0) g-locs)
       (mapc '(lambda (x)
		  (push nil g-locs))
	     args)
       (setq g-loccnt (length args))
       (d-bindlamb args)  ; do shallow binding if necessary
       ;
       ; if any of the optionals have non null defaults or
       ; optional-p's, we have to evaluate their defaults
       ; or set their predicates.
       ; first, see if it is necessary
       (if (do ((xx optional (cdr xx)))
	       ((null xx) nil)
	       (if (or (cadar xx)  ; if non null default
		       (caddar xx)); or predicate
		   then (return t)))
	   then (makecomment '(do optional defaults and preds))
		; create labels again
		; need one label for each optional plus 1
		(do ((xx optional (cdr xx))
		     (res (list (d-genlab) )))
		    ((null xx) (setq labs res))
		    (push (d-genlab) res))
		; we need to do something if the argument count
		; is between the number of required arguments and
		; the maximum number of args with optional minus 1.
		; we have one case for the required number and
		; one for each optional except the last optional number
		;
		(let ((afterthis (d-genlab)))
		    (e-write4 'casel
			      '#.lbot-reg `($ ,reqnum)
			      `($ ,(- maxwithopt reqnum 1)))
		    (e-label (car labs))
		    (do ((xx (cdr labs) (cdr xx))
			 (head (car labs)))
			((null xx))
			(e-write2 '.word (concat (car xx) "-" head)))
		    (e-goto afterthis)
		    (do ((ll (cdr labs) (cdr ll))
			 (op optional (cdr op))
			 (g-loc nil)
			 (g-cc nil)
			 (g-ret nil))
			((null ll))
			(e-label (car ll))
			(if (caddar op)
			    then (d-exp `(setq ,(caddar op) nil)))
			(if (cadar op)
			    then (d-exp `(setq ,(caar op) ,(cadar op)))))
		    (e-label afterthis)))

       ; now compile the function
       (d-clearreg)
       (setq g-arginfo
	     (if (eq g-ftype 'nlambda)
		 then nil
		 else (cons reqnum (if (>& maxnum 0) then maxnum else nil))))
       (makecomment '(begin-fcn-body))
       (d-exp (do ((ll newbody (cdr ll))
		   (g-loc)
		   (g-cc)
		   (g-ret))
		  ((null (cdr ll)) (car ll))
		  (d-exp (car ll))))
       (d-unbind)))

#+for-vax
(defun d-checkforfixedargs (fcnname number)
   (let ((oklab (d-genlab)))
      (makecomment `(,fcnname should-have-exactly ,number args))
      ; calc -4*# of args
      (e-sub '#.np-reg '#.lbot-reg)
      (e-cmp '#.lbot-reg `($ ,(- (* number 4))))
      (e-write2 'jeql oklab)
      (d-wnaerr fcnname number number)
      (e-label oklab)))

;--- d-wnaerr  :: generate code to call wrong number of args error
; name is the function name,
; min is the minumum number of args for this function
; max is the maximum number (-1 if there is no maximum)
;  we encode the min and max in the way shown below.
;
#+for-vax
(defun d-wnaerr (name min max)
   (makecomment `(arg error for fcn ,name min ,min max ,max))
   (e-move 'r10 '#.lbot-reg)
   (C-push `($ ,(+ (* min 1000) (+ max 1))))
   (C-push (e-cvt (d-loclit name nil)))
   (e-write3 'calls '$2 '_wnaerr))

;--- d-genlab :: generate a pseudo label
;
(defun d-genlab nil
  (gensym 'L))

;--- liszt-interrupt-signal
; if we receive a interrupt signal (commonly a ^C), then
; unlink the .s file if we are generating a temporary one
; and exit
(defun liszt-interrupt-signal (sig)
   (if (and fl-asm (boundp 'v-sfile) v-sfile)
      then (sys:unlink v-sfile))
   (exit 1))
EndOfFile
cat >  liszt/util.l  << 'EndOfFile'
(include-if (null (get 'chead 'version)) "../chead.l")
(Liszt-file util
   "$Header: util.l,v 1.14 83/08/28 17:13:11 layer Exp $")

;;; ----	u t i l			general utility functions
;;;
;;;				-[Tue Aug 16 17:17:32 1983 by layer]-


;--- d-handlecc :: handle g-cc
; at this point the Z condition code has been set up and if g-cc is
; non nil, we must jump on condition to the label given in g-cc
;
(defun d-handlecc nil
   (if (car g-cc)
       then (e-gotot (car g-cc))
    elseif (cdr g-cc)
       then (e-gotonil (cdr g-cc))))

;--- d-invert :: handle inverted condition codes
; this routine is called if a result has just be computed which alters
; the condition codes such that Z=1 if the result is t, and Z=0 if the
; result is nil (this is the reverse of the usual sense).  The purpose
; of this routine is to handle g-cc and g-loc.  That is if g-loc is 
; specified, we must convert the value of the Z bit of the condition 
; code to t or nil and store that in g-loc.  After handling g-loc we
; must handle g-cc, that is if the part of g-cc is non nil which matches
; the inverse of the current condition code, we must jump to that.
;
(defun d-invert nil
  (if (null g-loc) 
      then (if (car g-cc) then (e-gotonil (car g-cc))
	    elseif (cdr g-cc) then  (e-gotot (cdr g-cc)))
      else (let ((lab1 (d-genlab))
		 (lab2 (if (cdr g-cc) thenret else (d-genlab))))
		(e-gotonil lab1)
		; Z=1, but remember that this implies nil due to inversion
		(d-move 'Nil g-loc)
		(e-goto lab2)
		(e-label lab1)
		; Z=0, which means t
		(d-move 'T g-loc)
		(if (car g-cc) then (e-goto (car g-cc)))
		(if (null (cdr g-cc)) then (e-label lab2)))))
			
;--- d-noninvert :: handle g-cc and g-loc assuming cc non inverted
; 
; like d-invert except Z=0 implies nil, and Z=1 implies t
;
(defun d-noninvert nil
  (if (null g-loc) 
      then (if (car g-cc) then (e-gotot (car g-cc))
	    elseif (cdr g-cc) then  (e-gotonil (cdr g-cc)))
      else (let ((lab1 (d-genlab))
		 (lab2 (if (cdr g-cc) thenret else (d-genlab))))
		(e-gotot lab1)
		; Z=0, this implies nil
		(d-move 'Nil g-loc)
		(e-goto lab2)
		(e-label lab1)
		; Z=1, which means t
		(d-move 'T g-loc)
		(if (car g-cc) then (e-goto (car g-cc)))
		(if (null (cdr g-cc)) then (e-label lab2)))))

;--- d-macroexpand :: macro expand a form as much as possible
;
; only macro expands the top level though.
(defun d-macroexpand (i)
   (prog (first type)
      loop
      (if (and (dtpr i) (symbolp (setq first (car i))))
	 then (if (eq 'macro (setq type (d-functyp first 'macro-ok)))
		 then (setq i (apply first i))
		      (go loop)
	       elseif (eq 'cmacro type)
		 then (setq i (apply (get first 'cmacro) i))
		      (go loop)))
      (return i)))

;--- d-fullmacroexpand :: macro expand down all levels
; this is not always possible to due since it is not always clear
; if a function is a lambda or nlambda, and there are lots of special
; forms.  This is just a first shot at such a function, this should
; be improved upon.
;
(defun d-fullmacroexpand (form)
   (if (not (dtpr form))
       then form
       else (setq form (d-macroexpand form))	; do one level
            (if (and (dtpr form) (symbolp (car form)))
		then (let ((func (getd (car form))))
			  (if (or (and (bcdp func)
				       (eq 'lambda (getdisc func)))
				  (and (dtpr func)
				       (memq (car func) '(lambda lexpr)))
				  (memq (car form) '(or and)))
			      then `(,(car form)
				      ,@(mapcar 'd-fullmacroexpand
						(cdr form)))
			    elseif (eq (car form) 'setq)
			      then (d-setqexpand form)
			    else form))
		else form)))

;--- d-setqexpand :: macro expand a setq statemant
; a setq is unusual in that alternate values are macroexpanded.
;
(defun d-setqexpand (form)
   (if (oddp (length (cdr form)))
       then (comp-err "wrong number of args to setq " form)
       else (do ((xx (reverse (cdr form)) (cddr xx))
		 (res))
		((null xx) (cons 'setq res))
		(setq res `(,(cadr xx)
			     ,(d-fullmacroexpand (car xx))
			     ,@res)))))
   
;--- d-typesimp ::  determine the type of the argument 
;
#+for-vax
(defun d-typesimp (arg val)
  (let ((argloc (d-simple arg)))
	(if (null argloc)
	    then (let ((g-loc 'reg)
		       g-cc g-ret)
		     (d-exp arg))
		 (setq argloc 'reg))
	(e-write4 'ashl '$-9 (e-cvt argloc) 'r0)
	(e-write3 'cmpb '"_typetable+1[r0]" val)
	(d-invert)))

#+for-68k
(defun d-typesimp (arg val)
   (let ((argloc (d-simple arg)))
       (if (null argloc)
	   then (let ((g-loc 'reg)
		      g-cc g-ret)
		    (d-exp arg))
		(setq argloc 'reg)
	   else (e-move (e-cvt argloc) 'd0))
       (e-sub '#.nil-reg 'd0)
       (e-write3 'moveq '($ 9) 'd1)
       (e-write3 'asrl 'd1 'd0)
       (e-write3 'lea '"_typetable+1" 'a5)
       (e-write3 'cmpb val '(% 0 a5 d0))
       (d-invert)))

;--- d-typecmplx  :: determine if arg has one of many types
;	- arg : lcode argument to be evaluated and checked
;	- vals : fixnum with a bit in position n if we are to check type n
;
#+for-vax
(defun d-typecmplx (arg vals)
  (let ((argloc (d-simple arg))
	(reg))
       (if (null argloc) then (let ((g-loc 'reg)
				    g-cc g-ret)
				   (d-exp arg))
			      (setq argloc 'reg))
       (setq reg 'r0)
       (e-write4 'ashl '$-9 (e-cvt argloc) reg)
       (e-write3 'cvtbl (concat "_typetable+1[" reg "]") reg)
       (e-write4 'ashl reg '$1 reg)
       (e-write3 'bitw vals reg)
       (d-noninvert)))

#+for-68k
(defun d-typecmplx (arg vals)
   (let ((argloc (d-simple arg))
	 (l1 (d-genlab))
	 (l2 (d-genlab)))
       (makecomment '(d-typecmplx: type check))
       (if (null argloc)
	   then (let ((g-loc 'reg)
		      g-cc g-ret)
		    (d-exp arg))
		(setq argloc 'reg)
	   else (e-move (e-cvt argloc) 'd0))
       (e-sub '#.nil-reg 'd0)
       (e-write3 'moveq '($ 9) 'd1)
       (e-write3 'asrl 'd1 'd0)
       (e-write3 'lea '"_typetable+1" 'a5)
       (e-add 'd0 'a5)
       (e-write3 'movb '(0 a5) 'd0)
       (e-write2 'extw 'd0)
       (e-write2 'extl 'd0)
       (e-write3 'moveq '($ 1) 'd1)
       (e-write3 'asll 'd0 'd1)
       (e-move 'd1 'd0)
       (e-write3 'andw vals 'd0)
       (d-noninvert)
       (makecomment '(d-typecmplx: end))))

;---- register handling routines.

;--- d-allocreg :: allocate a register 
;  name - the name of the register to allocate or nil if we should
;	  allocate the least recently used.
;
(defun d-allocreg (name)
  (if name 
      then (let ((av (assoc name g-reguse)))
		(if av then (rplaca (cdr av) (1+ (cadr av)))) ; inc used count
		name)
      else ; find smallest used count
	   (do ((small (car g-reguse))
		(smc (cadar g-reguse))
		(lis (cdr g-reguse) (cdr lis)))
	       ((null lis)
		(rplaca (cdr small) (1+ smc))
		(car small))
	       (if (< (cadar lis) smc)
		   then (setq small (car lis)
			      smc   (cadr small))))))


;--- d-bestreg :: determine the register which is closest to what we have
;  name - name of variable whose subcontents we want
;  pat  - list of d's and a's which tell which part we want
;
(defun d-bestreg (name pat)
  (do ((ll g-reguse (cdr ll))
       (val)
       (best)
       (tmp)
       (bestv -1))
      ((null ll)
       (if best
	   then (rplaca (cdr best) (1+ (cadr best)))
		(list (car best)
		      (if (> bestv 0) 
			  then (rplacd (nthcdr (1- bestv)
					       (setq tmp
						     (copy pat)))
				       nil)
			       tmp
			  else nil)
		      (nthcdr bestv pat))))
      (if (and (setq val (cddar ll))
	       (eq name (car val)))
	  then (if (> (setq tmp (d-matchcnt pat (cdr val)))
		      bestv)
		   then (setq bestv tmp
			      best  (car ll))))))

;--- d-matchcnt :: determine how many parts of a pattern match
; want - pattern we want to achieve
; have - pattern whose value exists in a register
; 
; we return a count of the number of parts of the pattern match.
; If this pattern will be any help at all, we return a value from 
; 0 to the length of the pattern.
; If this pattern will not work at all, we return a number smaller
; than -1.  
; For `have' to be useful for `want', `have' must be a substring of 
; `want'.  If it is a substring, we return the length of `have'.
; 
(defun d-matchcnt (want have)
  (let ((length 0))
       (if (do ((hh have (cdr hh))
		(ww want (cdr ww)))
	       ((null hh) t)
	       (if (or (null ww) (not (eq (car ww) (car hh))))
		   then (return nil)
		   else (incr length)))
	   then  length
	   else  -2)))

;--- d-clearreg :: clear all values in registers or just one
; if no args are given, clear all registers.
; if an arg is given, clear that register
;
(defun d-clearreg n
  (cond ((zerop n) 
	 (mapc '(lambda (x) (rplaca (cdr x) 0)
		     (rplacd (cdr x) nil))
	       g-reguse))
	(t (let ((av (assoc (arg 1) g-reguse)))
		(if av
		   then
			#+for-68k (d-regused (car av))
			(rplaca (cdr av) 0)
			(rplacd (cdr av) nil)
		   else nil)))))

;--- d-clearuse :: clear all register which reference a given variable
;
(defun d-clearuse (varib)
  (mapc '(lambda (x)
		 (if (eq (caddr x) varib) then (rplacd (cdr x) nil)))
	g-reguse))

;--- d-inreg :: declare that a value is in a register
; name - register name
; value - value in a register
;
(defun d-inreg (name value)
  (let ((av (assoc name g-reguse)))
       (if av then (rplacd (cdr av) value))
       name))

(defun e-setup-np-lbot nil
   (e-move '#.np-reg '#.np-sym)
   (e-move '#.lbot-reg '#.lbot-sym))

;---------------MC68000 only routines
#+for-68k
(progn 'compile

;--- d-regtype :: find out what type of register the operand goes
;		  in.
; eiadr - an EIADR
;
(defun d-regtype (eiadr)
   (if (symbolp eiadr)
       then (if (memq eiadr '(d0 d1 d2 d3 d4 d5 d6 d7 reg)) then 'd
	     elseif (memq eiadr '(a0 a1 a2 a3 a4 a5 a6 a7 sp areg)) then 'a)
    elseif (or (eq '\# (car eiadr))
	       (eq '$ (car eiadr))
	       (and (eq '* (car eiadr))
		    (eq '\# (cadr eiadr))))
       then 'd
       else 'a))

;--- d-regused :: declare that a reg is used in a function
;	regname - name of the register that is going to be used
;		  (ie, 'd0 'a2...)
;
(defun d-regused (regname)
   (let ((regnum (diff (cadr (exploden regname)) 48))
	 (regtype (car (explode regname))))
       (if (memq regname '(a0 a1 d0 d1))
	   thenret
	elseif (equal 'd regtype)
	   then (rplacx regnum g-regmaskvec t) regname
	   else (rplacx (plus regnum 8) g-regmaskvec t) regname)))

;--- d-makemask :: make register mask for moveml instr
;
(defun d-makemask ()
   (do ((ii 0 (1+ ii))
	(mask 0))
       ((greaterp ii 15) mask)
       (if (cxr ii g-regmaskvec)
	   then (setq mask (plus mask (expt 2 ii))))))

;--- init-regmaskvec :: initalize hunk structure to all default
;			save mask.
;
; nil means don't save it, and t means save the register upon function entry.
; order in vector: d0 .. d7, a0 .. a7.
; d3 : lbot (if $global-reg$ is t then save)
; d7 : _nilatom
; a2 : _np
; a3 : literal table ptr
; a4 : old _lbot (if $global-reg$ is t don't save)
; a5 : intermediate address calc
;
(defun init-regmaskvec ()
   (setq g-regmaskvec
	 (makhunk
	     (if $global-reg$
		 then (quote (nil nil nil t   nil nil nil t
			      nil nil t   t   t   t   nil nil))
		 else (quote (nil nil nil nil nil nil nil t
			      nil nil t   t   t   t   nil nil))))))

;--- Cstackspace :: calc local space on C stack
; space = 4 * (no. of register variables saved on stack)
;
(defun Cstackspace ()
   (do ((ii 0 (1+ ii))
	(retval 0))
       ((greaterp ii 15) (* 4 retval))
       (if (cxr ii g-regmaskvec) then (setq retval (1+ retval)))))

;--- d-alloc-register :: allocate a register
;  type - type of register (a or d)
;  name - the name of the register to allocate or nil if we should
;	  allocate the least recently used.
;
(defun d-alloc-register (type name)
   (if name 
       then (let ((av (assoc name g-reguse)))
		(d-regused name)
		(if av then (rplaca (cdr av) (1+ (cadr av)))) ; inc used count
		name)
       else ; find smallest used count
	    (let ((reguse))
		(do ((cur g-reguse (cdr cur)))
		    ((null cur))
		    (if (eq type (car (explode (caar cur))))
			then (setq reguse (cons (car cur) reguse))))
		(do ((small (car reguse))
		     (smc (cadar reguse))
		     (lis (cdr reguse) (cdr lis)))
		    ((null lis)
		     (rplaca (cdr small) (1+ smc))
		     (d-regused (car small))
		     (car small))
		    (if (< (cadar lis) smc)
			then (setq small (car lis)
				   smc   (cadr small)))))))

); end 68000 only routines
EndOfFile
cat >  liszt/lversion.l  << 'EndOfFile'
;; lversion.l
;;				-[Tue Nov 22 08:56:16 1983 by jkf]-
;;
;; this defines this symbols:
;;   this-liszt-version-built: ctime string which tells when this liszt
;;	was built.
;;   compiler-name: the banner printed out when liszt starts up

;; this file is not sccsed because it only contains version number
;; information.

(setq this-liszt-version-built (status ctime))

(setq compiler-name
   (concat "Liszt "
	   #.(cond ((status feature for-vax) "vax")
		   ((status feature for-68k) "68000")
		   (t "unknown machine"))
	   " version 8.39a"))
EndOfFile
cat >  liszt/lxref.l  << 'EndOfFile'
(setq rcs-lxref-ident
   "$Header: lxref.l,v 1.2 84/02/03 08:04:37 jkf Exp $")

;------   lxref: lisp cross reference program        
;-- author: j foderaro
;  This program generates a cross reference listing of a set of one or
; more lisp files.  It reads the output of cross reference files 
; generated by the compiler.  These files usually have the extension .x .
; the .x files are lisp readable.  There format is:
; The first s-expression is (File  <filename>) where <filename> is the
; name of the lisp source file.
; Then there is one s-expression for each function (including macros)
; which is defined in the file.  The car of each expression is the function
; name, the cadr is the function type and the cddr is a list of those
; functions called
; 
; lxref can be run from the command level
; % lxref foo.x bar.x
; or in this way
; % lxref
; -> (lxref foo.x bar.x)
;
; There is one option, that is changing the ignorelevel.  If a function
; is called by more than ignorelevel functions then all those functions
; are listed, instead a summary of the number of calls is printed.  This
; is useful for preventing  the printing of massive lists for common
; system functions such as setq.
; To change the ignorelevel to 40 you would type:
;
; % lxref -40 foo.x bar.x
;
;; internal data structures used in lxref:
;   funcs : list of functions mentioned either as caller or as callee
;  on each function in funcs, the property list contains some of these
;  indicators:
;	i-seen : always contains t [this is so we can avoid (memq foo funcs)
;	i-type : list of the types this function was declared as. In 1-1
;		 corresp with i-home
;	i-home : list of files this function was declared in. In 1-1 corresp
;	         with i-type
;	i-callers: list of functions calling this function





; insure we have plenty of space to grow into
(opval 'pagelimit 9999)


(declare (special xref-readtable width ignorefuncs ignorelevel readtable 
		  user-top-level poport i-seen i-type i-callers docseen
		  i-Chome i-Doc i-home funcs
		  callby-marker debug-mode
		  anno-off-marker liszt-internal
		  anno-on-marker))

(setq ignorelevel 50)
(setq callby-marker   (exploden ";.. ")	
      anno-off-marker (exploden ";.-")	
      anno-on-marker  (exploden ";.+"))	

; internal liszt functions
(setq liszt-internal '(Internal-bcdcall liszt-internal-do))

;--- xrefinit :: called automatically upon startup
;
(def xrefinit
   (lambda nil
      (let ((args (command-line-args))
	    (retval))
	 ; readtable should be the same as it was when liszt wrote
	 ; the xref file
	 (if args
	    then (signal 2 'exit)	; die on interrupt
		 (signal 15 'exit) 	; die on sigterm
		 (setq user-top-level nil)
		 (let ((retval (car (errset (funcall 'lxref args)))))
		    (exit (if retval thenret else -1)))
	    else (patom "Lxref - lisp cross reference program")
		 (terpr poport)
		 (setq user-top-level nil)))))

(setq user-top-level 'xrefinit)

;--- lxref :: main function
;
(defun lxref fexpr (files)
   (prog (p funcs i-seen i-home i-type i-callers filenm caller callee name
	    home type caller temp fname callers clength i-Chome i-Doc docseen
	    Chome Doc anno-mode debug-mode)

      (setq xref-readtable (makereadtable t))
      (setq i-seen (gensym) i-home (gensym) i-type (gensym)
	    i-callers (gensym) i-Chome (gensym) i-Doc (gensym))

      ; check for the ignorelevel option
      ; it must be the first option given.
      ;
      (If (and files (eq #/- (getcharn (car files) 1)))
	 then (If (fixp
		     (setq temp (readlist (cdr (explode (car files))))))
		 then (setq ignorelevel temp)
		      (setq files (cdr files))))

      ; process all files.  if a -a is seen, go into annotate mode.
      ; otherwise generate an xref file.
      ;
      (do ((ii files (cdr ii)))
	  ((null ii))
	  (if (eq '-d (car ii))
	     then (setq debug-mode t)
	   elseif anno-mode
	     then (process-annotate-file (car ii))
	   elseif (eq '-a (car ii))
	     then (setq anno-mode t)
	     else (process-xref-file (car ii))))
      (if (not anno-mode) (generate-xref-file))
      (return 0)))

;.. process-xref-file
(defun illegal-file (name)
   (msg "File " name " is not a valid cross reference file" N))

;--- process-xref-file :: scan the information in an xref file
; if the name ends in .l then change it to .x
;
;.. lxref
(defun process-xref-file (name)
   (if debug-mode then (msg "process-xref-file: " name N))
   (let (p fname filenm)
      ; convert foo.l to foo.x
      (setq fname (nreverse (exploden name)))
      (If (and (eq #/l (car fname)) (eq #/. (cadr fname)))
	 then (setq fname (implode (nreverse (cons #/x (cdr fname)))))
	 else (setq fname name))

      ; now look for foo or foo.x
      (If (and (null (errset (setq p (infile fname)) nil))
	       (null (errset (setq p (infile (concat fname ".x"))) nil)))
	 then (msg "Couldn't open " name N)
	 else (setq filenm (car (errset (read p))))
	      (If (dtpr filenm)
		 then (If (eq 'File (car filenm))
			 then (setq filenm (cadr filenm))
			      (process-File p filenm)
		       elseif (eq 'Chome (car filenm))
			 then (process-Chome p)
		       elseif (eq 'Doc (car filenm))
			 then (setq docseen t) (process-Doc p)
			 else (illegal-file name))
		 else (illegal-file name))
	      (close p))))


;--- process-File :: process an xref file from liszt
;
;.. process-xref-file
(defun process-File (p filenm)
   (let ((readtable xref-readtable))
      (do ((jj (read p) (read p))
	   (caller)
	   (callee))
	  ((null jj) (close p))
	  (setq caller (car jj))
	  (If (not (get caller i-seen))
	     then (putprop caller t i-seen)
		  (push caller funcs))	; add to global list
	  ; remember home of this function (and allow multiple homes)
	  (push filenm (get caller i-home))

	  ; remember type of this function (and allow multiple types)
	  (push (cadr jj) (get caller i-type))

	  ; for each function the caller calls
	  (do ((kk (cddr jj) (cdr kk)))
	      ((null kk))
	      (setq callee (car kk))
	      (If (not (get callee i-seen)) then (putprop callee t i-seen)
		  (push callee funcs))
	      (push (cons caller filenm) (get callee i-callers))))))

;.. process-xref-file
(defun process-Chome (p)
   (do ((jj (read p) (read p))
	(caller))
       ((null jj) (close p))
       (setq caller (car jj))
       (If (not (get caller i-seen))
	   then (putprop caller t i-seen)
	   (push caller funcs))	; add to global list
       ; remember home of this function (and allow multiple homes)
       (putprop caller (cons (cdr jj) (get caller i-Chome)) i-Chome)))

;--- process-Doc :: process a Doc file
;
; A doc file begins with an entry (Doc).
; subsequent entries are (Name File)  and this means that function
; Name is defined in file File.  This type of file is generated
; by a sed and awk script passing over the franz manual. (see the
; Makefile in the doc directory).
;
;.. process-xref-file
(defun process-Doc (p)
   (do ((jj (read p) (read p))
	(caller))
       ((null jj) (close p))
       (setq caller (car jj))
       (If (not (get caller i-seen))
	   then (putprop caller t i-seen)
	   (push caller funcs))	; add to global list
       ; remember home of this function (and allow multiple homes)
       (putprop caller (cons (cadr jj) (get caller i-Doc)) i-Doc)))

;.. generate-xref-file
(defun terprchk (wid)
  (cond ((> (setq width (+ wid width)) 78.) 
	 (terpr)
	 (patom "	")
	 (setq width (+ 8 wid)))))

; determine type of function
;.. generate-xref-file
(defun typeit (fcn)
  (cond ((bcdp fcn) (getdisc fcn))
	((dtpr fcn) (car fcn))))


;.. lxref
(defun generate-xref-file ()
   ; sort alphabetically
   (setq funcs (sort funcs 'alphalessp))

   ; now print out the cross reference
   (do ((ii funcs (cdr ii))
	(name) (home) (type) (callers) (Chome) (Doc) (clength))
       ((null ii))
       (setq name (car ii)
	     home (get name i-home)
	     type (get name i-type)
	     callers (get name i-callers)
	     Chome (get name i-Chome)
	     Doc (get name i-Doc))

       (If (lessp (setq clength (length callers)) ignorelevel)
	  then (setq callers (sortcar callers 'alphalessp)))

       (do ((xx Chome (cdr xx)))
	   ((null xx))
	   (setq home (cons (concat "<C-code>:" (caar xx))
			    home)
		 type (cons (cadar xx) type)))

       (If (null home)
	  then (setq home (If (getd name)
			     then (setq type
					(ncons (typeit (getd name))))
				  '(Franz-initial)
			   elseif (memq name liszt-internal)
			     then '(liszt-internal-function)
			   elseif (get name 'autoload)
			     then (list (concat "autoload: "
						(get name 'autoload)))
			     else '(Undefined))))

       (patom name)
       (patom "	")


       (If (null (cdr type))
	  then (patom (car type))
	       (patom "	")
	       (patom (car home))
	  else (patom "Mult def: ")
	       (mapcar '(lambda (typ hom)
			   (patom typ)
			   (patom " in ")
			   (patom hom)
			   (patom ", "))
		       type
		       home))


       (If docseen
	  then (If Doc then (msg "  [Doc: " (If (cdr Doc) then Doc
					       else (car Doc)) "]")
		  else (msg "  [**undoc**]")))
       (If (null callers) then (msg "	*** Unreferenced ***"))
       (terpr)
       (patom "	")
       (cond ((null callers))
	     ((not (lessp clength ignorelevel))
	      (patom "Called by ")
	      (print clength)
	      (patom " functions"))
	     (t (do ((jj callers (cdr jj))
		     (calle)
		     (width 8))
		    ((null jj))
		    ; only print name if in same file
		    (setq calle (caar jj))
		    (cond ((memq (cdar jj) home)
			   (terprchk (+ (flatc calle) 2))
			   (patom calle))
			  (t (terprchk (+ (flatc calle) 6 (flatc (cdar jj))))
			     (patom calle)
			     (patom " in ")
			     (patom (cdar jj))))
		    (If (cdr jj) then (patom ", ")))))
       (terpr)
       (terpr)
       botloop ))


;--- annotate code


		   
;--- process-annotate-file :: anotate a file
;
;.. lxref
(defun process-annotate-file (filename)
   (let (sourcep outp)
      ; make sure file exists and write annotate file as a
      ; file with the prefix #,
      (if (null (errset (setq sourcep (infile filename))))
	 then (msg "will ignore that file " N)
	 else ; will write to file.A (erasing the final l)
	      (let ((filen (concat "#," filename)))
		 (setq outp (outfile filen))
		 (anno-it sourcep outp)
		 (close outp)
		 (close sourcep)
		 ; now mv the original filename to #dfilename
		 ; and the annotated file to the original file
		 (let ((oldcopy (concat "#." filename)))
		    (if (null (errset
				 (progn (if (probef oldcopy)
					   then (sys:unlink oldcopy))
					(sys:link filename oldcopy)
					(sys:unlink filename)
					(sys:link filen filename)
					(sys:unlink filen))))
		       then (msg "An error occured while mving files around "
				 N
				 "files possibly affected "
				 filename oldcopy filen)))))))


;.. process-annotate-file
(defun anno-it (inp outp)
   (do ((xx (read-a-line inp) (read-a-line inp))
	(anno-it t))
       ((null xx))
       (if (match xx 1 callby-marker)  ; flush anno lines
	  then (flush-a-line outp inp)
	elseif (match xx 1 anno-off-marker)
	  then (setq anno-it nil)	; ';#-'  turns off annotating
	       (write-a-line xx outp inp)
	elseif (match xx 1 anno-on-marker)
	  then (setq anno-it t)
	       (write-a-line xx outp inp)
	  else (if anno-it then (anno-check xx outp))
	       (write-a-line xx outp inp))))


;;; file reading code for annotate function
; lines are read with (read-a-line port).  It will read up to the
; first 127 characters in the line, returning a hunk whose cxr 0 is the
; max(index) + 1 of the characters in the hunk.  the oversize-line flag
; will be set if there are still more character to be read from this line.
;
; the line should be printed by calling (print-a-line buffer) or if it isn't
; to be printed, (flush-a-line) should be called (which will check the
; oversize-line flag and flush unread input too).
;
(declare (special inp-buffer oversize-line))

(setq inp-buffer (makhunk 128))

;.. anno-it
(defun read-a-line (port)
   (setq oversize-line nil)
   (do ((i 1 (1+ i))
	(ch (tyi port) (tyi port)))
       ((or (eq #\newline ch)
	    (eq #\eof ch))
	(if (or (eq #\newline ch) (>& i 1))
	   then (rplacx 0 inp-buffer i)		; store size
		inp-buffer			; return buffer
	   else nil))	; return nil upon eof
       (rplacx i inp-buffer ch)
       (if (>& i 126)
	  then (setq oversize-line t)
	       (rplacx 0 inp-buffer (1+ i))
	       (return inp-buffer))))

;--- write-a-line :: write the given buffer and check for oversize-line
;
;.. anno-it
(defun write-a-line (buf oport iport)
   (do ((max (cxr 0 buf))
	(i 1 (1+ i)))
       ((not (<& i max))
	(if oversize-line
	    then (oversize-check oport iport t)
	    else (terpr oport)))
       (tyo (cxr i buf) oport)))

;.. anno-it
(defun flush-a-line (oport iport)
   (oversize-check oport iport nil))

;.. flush-a-line, write-a-line
(defun oversize-check (oport iport printp)
   (if oversize-line
      then (do ((ch (tyi iport) (tyi iport)))
	       ((or (eq ch #\eof) (eq ch #\newline))
		(cond ((and printp (eq ch #\newline))
		       (tyo ch oport))))
	       (if printp then (tyo ch oport)))))

	
		       
;.. anno-it
(defun anno-check (buffer outp)
   (if (match buffer 1 '(#\lpar #/d #/e #/f))
      then (let (funcname)
	      (if (setq funcname (find-func buffer))
		  (let ((recd (get funcname i-callers)))
		     (if recd
			then (printrcd recd outp)))))))

;--- printrcd :: print a description
;
;.. anno-check
(defun printrcd (fcns port)
   (let ((functions (sortcar fcns 'alphalessp)))
      (print-rec functions port 0)))

;.. print-rec, printrcd
(defun print-rec (fcns p wide)
   (if fcns
      then (let ((size (flatc (caar fcns))))
	      (if (>& (+ size wide 2) 78)
		 then (msg (P p) N )
		      (setq wide 0))
	      (if (=& wide 0)
		 then (mapc '(lambda (x) (tyo x p)) callby-marker)
		      (setq wide (length callby-marker)))
	      (if (not (=& wide 4))
		 then (msg (P p) ", ")
		      (setq wide (+ wide 2)))
	      (msg (P p) (caar fcns))
	      (print-rec (cdr fcns) p (+ wide size 2)))
      else (msg (P p) N)))

		      
		    
;--- match :: try to locate pattern in buffer
; start at 'start' in buf.
;.. anno-check, anno-it, match
(defun match (buf start pattern)
   (if (null pattern)
      then t
    elseif (and (<& start (cxr 0 buf))
	    (eq (car pattern) (cxr start buf)))
      then (match buf (1+ start) (cdr pattern))))

;--- find-func :: locate function name on line
;
;.. anno-check
(defun find-func (buf)
   ; first locate first space or tab
   (do ((i 1 (1+ i))
	(max (cxr 0 buf))
	(die))
       ((or (setq die (not (<& i max)))
	    (memq (cxr i buf) '(#\space #\tab)))
	(if die
	   then nil	; can find it, so give up
	   else ; find first non blank
		(do ((ii i (1+ ii)))
		    ((or (setq die (not (<& ii max)))
			 (not (memq (cxr ii buf) '(#\space #\tab))))
		     (if (or die (eq (cxr ii buf) #\lpar))
			then nil
			else ; fid first sep or left paren
			     (do ((iii (1+ ii) (1+ iii)))
				 ((or (not (<& iii max))
				      (memq (cxr iii buf)
					    '(#\space #\tab #\lpar)))
				  (implode-fun buf ii (1- iii)))))))))))

;--- implode-fun :: return implode of everything between from and to in buf
;
;.. find-func
(defun implode-fun (buf from to)
   (do ((xx (1- to) (1- xx))
	(res (list (cxr to buf)) (cons (cxr xx buf) res)))
       ((not (<& from xx))
	(implode (cons (cxr from buf) res)))))





EndOfFile
cat >  liszt/ltags  << 'EndOfFile'
/^\(DEF/	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(def/	{ print $2 "	" FILENAME "	/^" $0 "$/" }
EndOfFile
cat >  liszt/tags  << 'EndOfFile'
*arginfo	../decl.l	/^(def *arginfo$/
*args	../decl.l	/^(def *args$/
*expr	../decl.l	/^(defun *expr fexpr (args)$/
*fexpr	../decl.l	/^(defun *fexpr fexpr (args)$/
*lexpr	../decl.l	/^(defun *lexpr fexpr (args)$/
Cstackspace	../util.l	/^(defun Cstackspace ()$/
Liszt-file	../cmacros.l	/^(defmacro Liszt-file (name rcs-string)$/
Push	../cmacros.l	/^(defmacro Push (atm val)$/
c-*catch	../funa.l	/^(defun c-*catch nil$/
c-*throw	../func.l	/^(defun c-*throw nil$/
c-*throw	../func.l	/^(defun c-*throw nil$/
c-Internal-bcdcall	../funb.l	/^(defun c-Internal-bcdcall nil$/
c-\\	../fixnum.l	/^(defun c-\\ nil$/
c-assembler-code	../funa.l	/^(defun c-assembler-code nil$/
c-bcdcall	../funa.l	/^(defun c-bcdcall nil$/
c-boole	../funa.l	/^(defun c-boole nil$/
c-cond	../funa.l	/^(defun c-cond nil$/
c-cons	../funa.l	/^(defun c-cons nil$/
c-declare	../funb.l	/^(defun c-declare nil nil)$/
c-do	../funb.l	/^(defun c-do nil$/
c-errset	../funb.l	/^(defun c-errset nil$/
c-fixnumop	../fixnum.l	/^(defun c-fixnumop nil$/
c-funcall	../funb.l	/^(defun c-funcall nil$/
c-get	../funb.l	/^(defun c-get nil$/
c-go	../funb.l	/^(defun c-go nil$/
c-internal-bind-vars	../func.l	/^(defun c-internal-bind-vars nil$/
c-internal-fixnum-box	../funb.l	/^(defun c-internal-fixnum-box ()$/
c-internal-unbind-vars	../func.l	/^(defun c-internal-unbind-vars nil$/
c-lambexp	../funb.l	/^(defun c-lambexp nil$/
c-list	../funb.l	/^(defun c-list nil$/
c-prog	../func.l	/^(defun c-prog nil$/
c-progv	../func.l	/^(defun c-progv nil$/
c-return	../func.l	/^(defun c-return nil$/
c-rplaca	../func.l	/^(defun c-rplaca nil$/
c-rplaca	../func.l	/^(defun c-rplaca nil$/
c-rplacd	../func.l	/^(defun c-rplacd nil$/
c-rplacd	../func.l	/^(defun c-rplacd nil$/
c-rplacx	../funa.l	/^(defun c-rplacx nil$/
c-setarg	../func.l	/^(defun c-setarg nil$/
c-vsize	../vector.l	/^(defun c-vsize nil$/
c-vsize-byte	../vector.l	/^(defun c-vsize-byte nil$/
c-vsize-word	../vector.l	/^(defun c-vsize-word nil$/
cc-<&	../fixnum.l	/^(defun cc-<& nil$/
cc->&	../fixnum.l	/^(defun cc->& nil$/
cc-and	../funa.l	/^(defun cc-and nil$/
cc-arg	../funa.l	/^(defun cc-arg nil$/
cc-atom	../funa.l	/^(defun cc-atom nil$/
cc-bcdp	../funa.l	/^(defun cc-bcdp nil$/
cc-bigp	../funa.l	/^(defun cc-bigp nil$/
cc-cxr	../funa.l	/^(defun cc-cxr nil$/
cc-cxxr	../funa.l	/^(defun cc-cxxr (arg pat)$/
cc-cxxr	../funa.l	/^(defun cc-cxxr (arg pat)$/
cc-dtpr	../funb.l	/^(defun cc-dtpr nil$/
cc-eq	../funb.l	/^(defun cc-eq nil$/
cc-equal	../funb.l	/^(defun cc-equal nil$/
cc-fixp	../funb.l	/^(defun cc-fixp nil$/
cc-floatp	../funb.l	/^(defun cc-floatp nil$/
cc-function	../funb.l	/^(defun cc-function nil$/
cc-ignore	../funb.l	/^(defun cc-ignore nil$/
cc-memq	../funb.l	/^(defun cc-memq nil$/
cc-memq	../funb.l	/^(defun cc-memq nil$/
cc-not	../func.l	/^(defun cc-not nil$/
cc-numberp	../func.l	/^(defun cc-numberp nil$/
cc-offset-cxr	../funb.l	/^(defun cc-offset-cxr nil$/
cc-oneminus	../fixnum.l	/^(defun cc-oneminus nil$/
cc-oneminus	../fixnum.l	/^(defun cc-oneminus nil$/
cc-oneplus	../fixnum.l	/^(defun cc-oneplus nil$/
cc-oneplus	../fixnum.l	/^(defun cc-oneplus nil$/
cc-or	../func.l	/^(defun cc-or nil$/
cc-quote	../func.l	/^(defun cc-quote nil$/
cc-setq	../func.l	/^(defun cc-setq nil$/
cc-stringp	../func.l	/^(defun cc-stringp nil$/
cc-symbolp	../func.l	/^(defun cc-symbolp nil$/
cc-typep	../func.l	/^(defun cc-typep nil$/
cc-typep	../func.l	/^(defun cc-typep nil$/
cc-vectorip	../vector.l	/^(defun cc-vectorip nil$/
cc-vectorp	../vector.l	/^(defun cc-vectorp nil$/
cc-vref	../vector.l	/^(defun cc-vref ()$/
cc-vrefi-byte	../vector.l	/^(defun cc-vrefi-byte ()$/
cc-vrefi-long	../vector.l	/^(defun cc-vrefi-long ()$/
cc-vrefi-word	../vector.l	/^(defun cc-vrefi-word ()$/
cc-vset	../vector.l	/^(defun cc-vset ()$/
cc-vseti-byte	../vector.l	/^(defun cc-vseti-byte ()$/
cc-vseti-long	../vector.l	/^(defun cc-vseti-long ()$/
cc-vseti-word	../vector.l	/^(defun cc-vseti-word ()$/
checkfatal	../tlev.l	/^(def checkfatal$/
cm-<	../fixnum.l	/^(defun cm-< nil$/
cm-=	../fixnum.l	/^(defun cm-= nil$/
cm-=&	../fixnum.l	/^(defun cm-=& nil$/
cm->	../fixnum.l	/^(defun cm-> nil$/
cm-assq	../funa.l	/^(defun cm-assq nil$/
cm-fixnum-cxr	../funb.l	/^(defun cm-fixnum-cxr ()$/
cm-getaccess	../funb.l	/^(defun cm-getaccess nil `(cdr ,(cadr v-form)))$/
cm-getaux	../funb.l	/^(defun cm-getaux  nil `(car ,(cadr v-form)))$/
cm-getd	../funb.l	/^(defun cm-getd nil `(cxr 2 ,(cadr v-form)))$/
cm-getdata	../funb.l	/^(defun cm-getdata nil `(cxr 2 ,(cadr v-form)))$/
cm-getdisc	../funb.l	/^(defun cm-getdisc nil `(cxr 1 ,(cadr v-form)))$/
cm-map	../funb.l	/^(defun cm-map nil$/
cm-mapc	../funb.l	/^(defun cm-mapc nil$/
cm-mapcan	../funb.l	/^(defun cm-mapcan nil$/
cm-mapcar	../funb.l	/^(defun cm-mapcar nil$/
cm-mapcon	../funb.l	/^(defun cm-mapcon nil$/
cm-maplist	../funb.l	/^(defun cm-maplist nil$/
cm-ncons	../func.l	/^(defun cm-ncons nil$/
cm-prog1	../func.l	/^(defun cm-prog1 nil$/
cm-prog2	../func.l	/^(defun cm-prog2 nil$/
cm-progn	../func.l	/^(defun cm-progn nil$/
cm-symeval	../func.l	/^(defun cm-symeval nil$/
cm-zerop	../func.l	/^(defun cm-zerop nil$/
cm-zerop	../func.l	/^(defun cm-zerop nil$/
comp-err	../cmacros.l	/^(def comp-err$/
comp-gerr	../cmacros.l	/^(def comp-gerr$/
comp-msg	../cmacros.l	/^(def comp-msg$/
comp-note	../cmacros.l	/^(def comp-note$/
comp-warn	../cmacros.l	/^(def comp-warn$/
compile-fcn	../decl.l	/^(defmacro compile-fcn (name fcnname indicator &optional (args nil args-p))$/
d-allfixnumargs	../datab.l	/^(defun d-allfixnumargs (forms)$/
d-alloc-register	../util.l	/^(defun d-alloc-register (type name)$/
d-allocreg	../util.l	/^(defun d-allocreg (name)$/
d-argcheckit	../expr.l	/^(defun d-argcheckit (info numargs class)$/
d-argnumchk	../expr.l	/^(defun d-argnumchk (class)$/
d-arrayindexcomp	../array.l	/^(defun d-arrayindexcomp (actual formal)$/
d-asciiout	../io.l	/^(defun d-asciiout (args)$/
d-ashl	../instr.l	/^(defun d-ashl (count src dst)$/
d-asll	../instr.l	/^(defun d-asll (count src dst)$/
d-asrl	../instr.l	/^(defun d-asrl (count src dst)$/
d-bcdcall	../expr.l	/^(defun d-bcdcall (n)$/
d-bcdcall	../expr.l	/^(defun d-bcdcall (n)$/
d-bestreg	../util.l	/^(defun d-bestreg (name pat)$/
d-bindlamb	../funb.l	/^(defun d-bindlamb (vrbs)$/
d-bindlrec	../funb.l	/^(defun d-bindlrec (vrb locs specs lev)$/
d-bindprg	../func.l	/^(defun d-bindprg (spcs locs)$/
d-bindtab	../io.l	/^(defun d-bindtab nil$/
d-booleexpand	../funa.l	/^(defun d-booleexpand (form)$/
d-boolexlate	../funa.l	/^(defun d-boolexlate (form)$/
d-callbig	../expr.l	/^(defun d-callbig (name args bcdp)$/
d-callbig	../expr.l	/^(defun d-callbig (name args bcdp)$/
d-calldirect	../expr.l	/^(defun d-calldirect (name c)$/
d-calldirect	../expr.l	/^(defun d-calldirect (name c)$/
d-calltran	../expr.l	/^(defun d-calltran (name c)$/
d-calltran	../expr.l	/^(defun d-calltran (name c)$/
d-checkforfixedargs	../tlev.l	/^(defun d-checkforfixedargs (fcnname number)$/
d-classify	../func.l	/^(defun d-classify (lst)$/
d-clearreg	../util.l	/^(defun d-clearreg n$/
d-clearuse	../util.l	/^(defun d-clearuse (varib)$/
d-cmp	../cmacros.l	/^(defmacro d-cmp (arg1 arg2)$/
d-cmpnil	../cmacros.l	/^(defmacro d-cmpnil (iadr)$/
d-collapse	../fixnum.l	/^(defun d-collapse (form op)$/
d-cxxr	../expr.l	/^(defun d-cxxr (name)$/
d-dodef	../tlev.l	/^(defun d-dodef (form)$/
d-dostore	../array.l	/^(defun d-dostore (spec value indexes)$/
d-dotailrecursion	../expr.l	/^(defun d-dotailrecursion (name args)$/
d-exp	../expr.l	/^(defun d-exp (v-form)$/
d-exps	../expr.l	/^(defun d-exps (exps)$/
d-findfirstprop	../datab.l	/^(defun d-findfirstprop (name type)$/
d-fini	../io.l	/^(defun d-fini nil$/
d-fixexpand	../fixnum.l	/^(defun d-fixexpand (x)$/
d-fixnumbox	../fixnum.l	/^(defun d-fixnumbox ()$/
d-fixnumbox	../fixnum.l	/^(defun d-fixnumbox ()$/
d-fixnumcode	../fixnum.l	/^(defun d-fixnumcode (expr)$/
d-fixnumcode	../fixnum.l	/^(defun d-fixnumcode (expr)$/
d-fixnumexp	../fixnum.l	/^(defun d-fixnumexp (x)$/
d-fixnump	../datab.l	/^(defun d-fixnump (vrb)$/
d-fixop	../fixnum.l	/^(defun d-fixop (opcode lispopcode)$/
d-fullmacroexpand	../util.l	/^(defun d-fullmacroexpand (form)$/
d-functyp	../datab.l	/^(defun d-functyp (name macrochk)$/
d-genlab	../tlev.l	/^(defun d-genlab nil$/
d-handlearrayref	../array.l	/^(defun d-handlearrayref nil$/
d-handlecc	../util.l	/^(defun d-handlecc nil$/
d-inreg	../util.l	/^(defun d-inreg (name value)$/
d-invert	../util.l	/^(defun d-invert nil$/
d-lambbody	../funb.l	/^(defun d-lambbody (body)$/
d-lambda-aux-body-convert	../tlev.l	/^(defun d-lambda-aux-body-convert (body auxlist)$/
d-lambdalistcheck	../tlev.l	/^(defun d-lambdalistcheck (list body)$/
d-loc	../datab.l	/^(defun d-loc (form)$/
d-loclit	../datab.l	/^(defun d-loclit (form flag)$/
d-locv	../datab.l	/^(defun d-locv (sm)$/
d-macroexpand	../util.l	/^(defun d-macroexpand (i)$/
d-makemask	../util.l	/^(defun d-makemask ()$/
d-makespec	../decl.l	/^(defun d-makespec (vrb)$/
d-mapconvert	../funb.l	/^(defun d-mapconvert (access join resu form )$/
d-matchcnt	../util.l	/^(defun d-matchcnt (want have)$/
d-move	../instr.l	/^(defun d-move (from to)$/
d-movespec	../instr.l	/^(defun d-movespec (from to)$/
d-noninvert	../util.l	/^(defun d-noninvert nil$/
d-olddo-to-newdo	../funb.l	/^(defun d-olddo-to-newdo (v-l)$/
d-outerlambdacomp	../tlev.l	/^(defun d-outerlambdacomp (funname lambdalist body)$/
d-popframe	../funa.l	/^(defun d-popframe ()$/
d-prelude	../io.l	/^(defun d-prelude nil$/
d-printautorun	../io.l	/^(defun d-printautorun nil$/
d-printdocstuff	../io.l	/^(defun d-printdocstuff nil$/
d-pushargs	../expr.l	/^(defun d-pushargs (args)$/
d-pushframe	../funa.l	/^(defun d-pushframe (class arg1 arg2)$/
d-regtype	../util.l	/^(defun d-regtype (eiadr)$/
d-regused	../util.l	/^(defun d-regused (regname)$/
d-rsimple	../datab.l	/^(defun d-rsimple (arg)$/
d-scanfordecls	../funb.l	/^(defun d-scanfordecls (forms)$/
d-semisimple	../funa.l	/^(defun d-semisimple (form)$/
d-setqexpand	../util.l	/^(defun d-setqexpand (form)$/
d-shiftcheck	../fixnum.l	/^(defun d-shiftcheck (operator operand)$/
d-simple	../datab.l	/^(defun d-simple (arg)$/
d-specialp	../datab.l	/^(defun d-specialp (vrb)$/
d-structgen	../funa.l	/^(defun d-structgen (index base width)$/
d-structgen	../funa.l	/^(defun d-structgen (index base width)$/
d-supercxr	../funa.l	/^(defun d-supercxr (type offsetonly)$/
d-supercxr	../funa.l	/^(defun d-supercxr (type offsetonly)$/
d-superrplacx	../funa.l	/^(defun d-superrplacx (type)$/
d-superrplacx	../funa.l	/^(defun d-superrplacx (type)$/
d-toplevmacroexpand	../fixnum.l	/^(defun d-toplevmacroexpand (x)$/
d-tranloc	../datab.l	/^(defun d-tranloc (fname)$/
d-tst	../cmacros.l	/^(defmacro d-tst (arg)$/
d-typecmplx	../util.l	/^(defun d-typecmplx (arg vals)$/
d-typecmplx	../util.l	/^(defun d-typecmplx (arg vals)$/
d-typesimp	../util.l	/^(defun d-typesimp (arg val)$/
d-typesimp	../util.l	/^(defun d-typesimp (arg val)$/
d-unbind	../func.l	/^(defun d-unbind nil$/
d-vectorindexcode	../vector.l	/^(defun d-vectorindexcode ()$/
d-vectorsize	../vector.l	/^(defun d-vectorsize (form shift)$/
d-vref	../vector.l	/^(defun d-vref (type)$/
d-vset	../vector.l	/^(defun d-vset (type)$/
d-wnaerr	../tlev.l	/^(defun d-wnaerr (name min max)$/
declare-handler	../decl.l	/^(defmacro declare-handler (args name type toplevind)$/
decr	../cmacros.l	/^(defmacro decr (atm)$/
do-lisztrc-check	../tlev.l	/^(defun do-lisztrc-check nil$/
doevalwhen	../decl.l	/^(def doevalwhen $/
e-Cstack	../cmacros.l	/^(defmacro e-Cstack (src)$/
e-Lstack	../cmacros.l	/^(defmacro e-Lstack (src)$/
e-add	../cmacros.l	/^(defmacro e-add (src dst)$/
e-add	../instr.l	/^(defun e-add (src dst)$/
e-add3	../cmacros.l	/^(defmacro e-add3 (s1 s2 dest)$/
e-add3	../cmacros.l	/^(defmacro e-add3 (s1 s2 dest)$/
e-call-qnewint	../cmacros.l	/^(defmacro e-call-qnewint ()$/
e-cmp	../cmacros.l	/^(defmacro e-cmp (src dst)$/
e-cmp	../instr.l	/^(defun e-cmp (src dst)$/
e-cmpnil	../cmacros.l	/^(defmacro e-cmpnil (eiadr)$/
e-cvt	../io.l	/^(defun e-cvt (arg)$/
e-cvtas	../io.l	/^(defun e-cvtas (form)$/
e-cvtas	../io.l	/^(defun e-cvtas (form)$/
e-docomment	../io.l	/^(defun e-docomment nil$/
e-dropnp	../io.l	/^(defun e-dropnp (n)$/
e-goto	../io.l	/^(defun e-goto (lbl)$/
e-gotonil	../io.l	/^(defun e-gotonil (lbl)$/
e-gotot	../io.l	/^(defun e-gotot (lbl)$/
e-jump	../io.l	/^(defun e-jump (l)$/
e-label	../io.l	/^(defun e-label (lbl)$/
e-move	../instr.l	/^(defun e-move (from to)$/
e-pop	../io.l	/^(defun e-pop (nargs)$/
e-pushnil	../io.l	/^(defun e-pushnil (nargs)$/
e-pushnil	../io.l	/^(defun e-pushnil (nargs)$/
e-quick-call	../cmacros.l	/^(defmacro e-quick-call (what)$/
e-return	../io.l	/^(defun e-return nil$/
e-setup-np-lbot	../util.l	/^(defun e-setup-np-lbot nil$/
e-setupbind	../io.l	/^(defun e-setupbind nil$/
e-shallowbind	../io.l	/^(defun e-shallowbind (name val)$/
e-sub	../cmacros.l	/^(defmacro e-sub (src dst)$/
e-sub	../instr.l	/^(defun e-sub (src dst)$/
e-tst	../cmacros.l	/^(defmacro e-tst (src)$/
e-uncvt	../io.l	/^(defun e-uncvt (arg)$/
e-unsetupbind	../io.l	/^(defun e-unsetupbind nil$/
e-unshallowbind	../io.l	/^(defun e-unshallowbind (n)$/
e-unshallowbind	../io.l	/^(defun e-unshallowbind (n)$/
e-write1	../io.l	/^(defun e-write1 (lit)$/
e-write2	../io.l	/^(defun e-write2 (lit frm)$/
e-write2	../io.l	/^(defun e-write2 (lit frm)$/
e-write3	../io.l	/^(defun e-write3 (lit frm1 frm2)$/
e-write3	../io.l	/^(defun e-write3 (lit frm1 frm2)$/
e-write4	../io.l	/^(defun e-write4 (lit frm1 frm2 frm3)$/
e-write5	../io.l	/^(defun e-write5 (lit frm1 frm2 frm3 frm4)$/
e-writel	../io.l	/^(defun e-writel (label)$/
em-checknpdrop	../io.l	/^(defmacro em-checknpdrop nil$/
em-checkskip	../io.l	/^(defmacro em-checkskip nil$/
fixnum	../decl.l	/^(defun fixnum fexpr (args)$/
flonum	../decl.l	/^(defun flonum fexpr (args)$/
forcecomment	../cmacros.l	/^(defmacro forcecomment (arg)$/
incr	../cmacros.l	/^(defmacro incr (atm)$/
init-regmaskvec	../util.l	/^(defun init-regmaskvec ()$/
lambda	../decl.l	/^(defun lambda fexpr (args)$/
liszt	../tlev.l	/^(def liszt$/
liszt-declare	../decl.l	/^(defun liszt-declare fexpr (forms)$/
liszt-form	../tlev.l	/^(def liszt-form$/
liszt-interrupt-signal	../tlev.l	/^(defun liszt-interrupt-signal (sig)$/
lisztinit	../tlev.l	/^(def lisztinit$/
localf	../decl.l	/^(def localf$/
macarray	../decl.l	/^(def macarray $/
macros	../decl.l	/^(def macros $/
makecomment	../cmacros.l	/^(defmacro makecomment (arg)$/
niceprint	../cmacros.l	/^(def niceprint$/
nlambda	../decl.l	/^(defun nlambda fexpr (args)$/
notype	../decl.l	/^(defun notype fexpr (args)$/
sfilewrite	../cmacros.l	/^(defmacro sfilewrite (arg)$/
sfilewriteln	../cmacros.l	/^(defmacro sfilewriteln (arg)$/
special	../decl.l	/^(defun special fexpr (args)$/
specials	../decl.l	/^(def specials$/
unpush	../cmacros.l	/^(defmacro unpush (atm)$/
unspecial	../decl.l	/^(defun unspecial fexpr (args)$/
EndOfFile
cat >  liszt/vax/Makefile  << 'EndOfFile'
#$Header: /na/franz/liszt/vax/RCS/Makefile,v 1.6 83/08/15 19:27:49 layer Exp $
#
#	Makefile for liszt 
#
# Copyright (c) 1980, 1982, The Regents of the University of California.
# the Copyright applies to all files referenced in this Makefile.
# All rights reserved.  
# author: j. foderaro
#
# this makefile creates these things:
#   nliszt - the lisp compiler.  We call it nliszt so we can test it out
#	     without having to say ./liszt
#   tags - a tags file for use by ex/vi
#
# CTE refers to compile time enviroment 
#
#--- Default Paths and programs
#
.DEFAULT:nliszt

CopyTo = /dev/null
ObjDir = /usr/ucb
Liszt = ${ObjDir}/liszt
Lisp = ${ObjDir}/lisp

Flg = -xqa

CTESrc = ../chead.l ../cmacros.l ../const.l

CTEObj= cmacros.o

Src =  ../array.l ../datab.l ../decl.l 	../expr.l ../fixnum.l ../funa.l	 \
	../funb.l ../func.l ../io.l ../tlev.l ../util.l ../lversion.l	\
	../vector.l ../instr.l

SharedSrc = ${CTESrc} ${Src} ../ChangeLog ../cmake.l

AllSrc =  Makefile lisprc.l lisztrc.l

Obj = array.o datab.o decl.o expr.o fixnum.o funa.o funb.o func.o io.o \
	tlev.o util.o lversion.o vector.o instr.o

AllObj =  ${CTEObj} ${Obj}

donliszt:
	rm -f nliszt
	make Liszt=${Liszt} Lisp=${Lisp} nliszt

nliszt: ${CTEObj} ${Obj} ${Lisp}
	echo "(load '../cmake.l)(genl nliszt)" | ${Lisp} 

#--- generate an interpreted version
snliszt: ${Src} ${Lisp}
	echo "(load '../cmake.l)(genl snliszt slow)" | ${Lisp}

array.o: ../array.l
	${Liszt} ${Flg} ../array.l -o array.o

vector.o: ../vector.l
	${Liszt} ${Flg} ../vector.l -o vector.o

instr.o: ../instr.l
	${Liszt} ${Flg} ../instr.l -o instr.o

datab.o: ../datab.l
	${Liszt} ${Flg} ../datab.l -o datab.o

decl.o: ../decl.l
	${Liszt} ${Flg} ../decl.l -o decl.o

expr.o: ../expr.l
	${Liszt} ${Flg} ../expr.l -o expr.o

fixnum.o: ../fixnum.l
	${Liszt} ${Flg} ../fixnum.l -o fixnum.o

funa.o: ../funa.l
	${Liszt} ${Flg} ../funa.l -o funa.o

funb.o: ../funb.l
	${Liszt} ${Flg} ../funb.l -o funb.o

func.o: ../func.l
	${Liszt} ${Flg} ../func.l -o func.o

io.o: ../io.l
	${Liszt} ${Flg} ../io.l -o io.o

tlev.o: ../tlev.l
	${Liszt} ${Flg} ../tlev.l -o tlev.o

util.o: ../util.l
	${Liszt} ${Flg} ../util.l -o util.o

lversion.o: ../lversion.l
	${Liszt} ${Flg} ../lversion.l -o lversion.o

cmacros.o: ../cmacros.l
	${Liszt} ${Flg} ../cmacros.l -o cmacros.o

tags:	../tags ${Src} ${CTESrc}
	awk -f ../ltags ${Src} ${CTESrc} | sort > ../tags

#
install: nliszt
	-rm -f ${ObjDir}/liszt
	mv nliszt ${ObjDir}/liszt

copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@../../scriptcat . liszt/vax ${AllSrc}

cleanobj:	
	rm -f \#* *.[xo] map

clean:
	make cleanobj
	rm -f nliszt snliszt
EndOfFile
cat >  liszt/vax/lisprc.l  << 'EndOfFile'
(sstatus feature for-vax)

EndOfFile
cat >  liszt/vax/lisztrc.l  << 'EndOfFile'
(putprop 'chead nil 'version)
(sstatus feature for-vax)
EndOfFile
cat >  liszt/68k/Makefile  << 'EndOfFile'
#$Header: Makefile,v 1.18 83/09/12 15:27:18 layer Exp $
#
#				-[Sat Jul 30 15:47:44 PDT 1983 by layer]-
#
#	Makefile for liszt 
#
# Copyright (c) 1980, 1982,  The Regents of the University of California.
# the Copyright applies to all files referenced in this Makefile.
# All rights reserved.  
# Authors: John Foderaro (jkf@berkeley.ARPA)
#	   Kevin Layer (layer@berkeley.ARPA)
#
# this makefile creates these things:
#   liszt - the interface to the lisp compiler.  This is used only for
#	    non virtual memory systems, because the overhead for forking
#	    the assembler is too great.
#   nliszt - the lisp compiler. This is the default.
#   snliszt - the lisp compiler, but interpreted.
#   fromasm - used to build the compiler usually for the first
#		time from only .s files.  These files are assembled
#		and loaded into a lisp.
#   install - install the new version created
#   clean - remove all .o files and *nliszt's
#   tags - a tags file for use by ex/vi
#
# CTE refers to compile time enviroment 
#
#--- Default Paths and programs
#
.DEFAULT:nliszt
.SUFFIXES:
.SUFFIXES: .l.o

# DESTDIR is the relative offset of where the compiler goes
# (when making new distributions, the `root' is often at /nbsd).
# RootDir is the root directory of the franz lisp system
# (this is changed when the system is configured by ../../lispconf).
DESTDIR =

LibDir = ${DESTDIR}/usr/lib/lisp
ObjDir = ${DESTDIR}/usr/ucb
Liszt = ${ObjDir}/liszt
Lisp = ${ObjDir}/lisp
#ifdef swapper
#XLiszt = ${ObjDir}/xliszt
#endif

CFLAGS = -O # -Ddebug
Flg =  -xqa

CTESrc = ../chead.l ../cmacros.l ../const.l

CTEObj= cmacros.o

Src =  ../array.l ../datab.l ../decl.l ../expr.l ../fixnum.l ../funa.l\
       ../instr.l ../vector.l ../funb.l ../func.l ../io.l\
       ../tlev.l ../util.l ../lversion.l

SharedSrc = ${CTESrc} ${Src} ../ChangeLog ../cmake.l

AllSrc =  Makefile Makefile2 lisprc.l lisztrc.l liszt.c

Obj = array.o vector.o datab.o decl.o expr.o fixnum.o\
      instr.o funa.o funb.o func.o io.o tlev.o util.o lversion.o

AllObj =  ${CTEObj} ${Obj}

#liszt :: the user interface to xliszt
# (only for swapped based systems, right now dual/unisoft)
#ifdef swapper
#liszt:	liszt.c
#	cc $(CFLAGS) -DLISZT='"${XLiszt}"' -DAS='"${LibDir}/as"'\
#	   -o liszt liszt.c
#else
liszt:
#endif

donliszt:
	rm -f nliszt
	make Liszt=${Liszt} Lisp=${Lisp} nliszt

nliszt: ${CTEObj} ${Obj} liszt ${Lisp}
	rm -f nliszt
	echo "(load '../cmake.l)(genl nliszt)" | ${Lisp} 

#--- generate an interpreted version
snliszt: ${Src} ${Lisp}
	rm -f snliszt
	echo "(load '../cmake.l)(genl snliszt slow)" | ${Lisp}

# 'fromasm' is for making the compiler from
# .s files.  On 68k systems this is much faster than
# doing a 'make slow', then a 'make fast'.
fromasm:	assit load liszt
assit:
	for i in *.s; do echo $$i; as $$i; done

#--- load .o files into a lisp
load:
	rm -f nliszt
	echo "(load '../cmake.l)(genl nliszt)" | ${Lisp} 

# install nliszt, and if we are on a swap based system, then
#install nliszt as xliszt, and liszt (from liszt.c) as liszt.
install:
#ifdef swapper
#	mv nliszt ${XLiszt}
#	cp liszt ${Liszt}
#else
	mv nliszt ${Liszt}
#endif

clean:	cleanobj
	rm -f \#* *nliszt *.s

cleanobj:
	rm -f *.[ox]

#--- rules for each lisp file:
cmacros.o: ../cmacros.l
	${Liszt} ${Flg} ../cmacros.l -o cmacros.o

array.o: ../array.l
	${Liszt} ${Flg} ../array.l -o array.o

instr.o: ../instr.l
	${Liszt} ${Flg} ../instr.l -o instr.o

vector.o: ../vector.l
	${Liszt} ${Flg} ../vector.l -o vector.o

datab.o: ../datab.l
	${Liszt} ${Flg} ../datab.l -o datab.o

decl.o: ../decl.l
	${Liszt} ${Flg} ../decl.l -o decl.o

expr.o: ../expr.l
	${Liszt} ${Flg} ../expr.l -o expr.o

fixnum.o: ../fixnum.l
	${Liszt} ${Flg} ../fixnum.l -o fixnum.o

funa.o: ../funa.l
	${Liszt} ${Flg} ../funa.l -o funa.o

funb.o: ../funb.l
	${Liszt} ${Flg} ../funb.l -o funb.o

func.o: ../func.l
	${Liszt} ${Flg} ../func.l -o func.o

io.o: ../io.l
	${Liszt} ${Flg} ../io.l -o io.o

tlev.o: ../tlev.l
	${Liszt} ${Flg} ../tlev.l -o tlev.o

util.o: ../util.l
	${Liszt} ${Flg} ../util.l -o util.o

lversion.o: ../lversion.l
	${Liszt} ${Flg} ../lversion.l -o lversion.o

tags:	../tags ${Src} ${CTESrc}
	awk -f ../ltags ${Src} ${CTESrc} | sort > ../tags

print:
#	@pr README
	@ls -l | pr 
	@pr TODO Makefile* ../cmake.l lisztrc.l lisprc.l
	@pr -h "Liszt.c (for non-VMUNIX systems only)" liszt.c
	@/usr/local/slp -l ../lversion.l ../chead.l ../cmacros.l\
	   ../datab.l ../decl.l ../expr.l\
	   ../funa.l ../funb.l ../func.l\
	   ../fixnum.l ../array.l ../io.l ../tlev.l ../util.l

iprint:
	igrind -lsh Makefile*
	igrind -lc -h "Liszt.c (for non-VMUNIX systems only)" liszt.c
	vlp -p 10 ../lversion.l\
	   ../chead.l ../cmacros.l\
	   ../datab.l ../decl.l ../expr.l\
	   ../funa.l ../funb.l ../func.l\
	   ../fixnum.l ../array.l ../io.l ../tlev.l ../util.l\
	   ../cmake.l lisztrc.l lisprc.l > vlp.out
	itroff vlp.out
	rm vlp.out

scriptcatall: ${AllSrc}
	@../../scriptcat . liszt/68k ${AllSrc}

copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))
EndOfFile
cat >  liszt/68k/Makefile2  << 'EndOfFile'
#make .s files

Liszt = ./nliszt
Flg = -Sqa
X = ./

DotSSrc = $(X)array.s $(X)cmacros.s $(X)datab.s $(X)decl.s\
	  $(X)expr.s $(X)fixnum.s $(X)funa.s $(X)funb.s $(X)func.s $(X)io.s\
	  $(X)lversion.s $(X)tlev.s $(X)util.s $(X)vector.s $(X)instr.s

.DEFAULT:xtra

xtra:	${DotSSrc}

scriptcatxtra:
	@../../scriptcat . liszt/68k ${DotSSrc}

$(X)array.s: ../array.l
	${Liszt} ${Flg} ../array.l -o $(X)array.s

$(X)instr.s: ../instr.l
	${Liszt} ${Flg} ../instr.l -o $(X)instr.s

$(X)vector.s: ../vector.l
	${Liszt} ${Flg} ../vector.l -o $(X)vector.s

$(X)datab.s:  ../datab.l
	${Liszt} ${Flg} ../datab.l -o $(X)datab.s

$(X)decl.s:  ../decl.l
	${Liszt} ${Flg} ../decl.l -o $(X)decl.s

$(X)expr.s:  ../expr.l
	${Liszt} ${Flg} ../expr.l -o $(X)expr.s

$(X)fixnum.s:  ../fixnum.l
	${Liszt} ${Flg} ../fixnum.l -o $(X)fixnum.s

$(X)funa.s:  ../funa.l
	${Liszt} ${Flg} ../funa.l -o $(X)funa.s

$(X)funb.s:  ../funb.l
	${Liszt} ${Flg} ../funb.l -o $(X)funb.s

$(X)func.s:  ../func.l
	${Liszt} ${Flg} ../func.l -o $(X)func.s

$(X)io.s:  ../io.l
	${Liszt} ${Flg} ../io.l -o $(X)io.s

$(X)tlev.s:  ../tlev.l
	${Liszt} ${Flg} ../tlev.l -o $(X)tlev.s

$(X)util.s:  ../util.l
	${Liszt} ${Flg} ../util.l -o $(X)util.s

$(X)lversion.s:  ../lversion.l
	${Liszt} ${Flg} ../lversion.l -o $(X)lversion.s

$(X)cmacros.s: ../cmacros.l
	${Liszt} ${Flg} ../cmacros.l -o $(X)cmacros.s
EndOfFile
cat >  liszt/68k/lisprc.l  << 'EndOfFile'
(sstatus feature for-68k)
(sstatus feature no-global-reg)
EndOfFile
cat >  liszt/68k/lisztrc.l  << 'EndOfFile'
(putprop 'chead nil 'version)
(sstatus feature for-68k)
(sstatus feature no-global-reg)
EndOfFile
cat >  liszt/68k/liszt.c  << 'EndOfFile'
#ifndef lint
static char *rcsid = "$Header: liszt.c 1.6 83/07/25 12:07:31 layer Exp $";
#endif

/*
**			-[Wed May  4 18:18:10 1983 by layer]-
**
**
** liszt :: interface to the lisp compiler
**
** There are two reasons for having a C interface to the compiler:
**	1) Fseek doesn't work properly from lisp, and there is no
**	   lseek.
**	2) To start up a process from a 1 Mb process, like when liszt forks
**	   a /usr/lib/lisp/as to assemble the output of the compiler, takes
**	   too long. (The compiler is 100 times larger than this program.)
**
**/

#include	<stdio.h>
#include	"../../franz/h/aout.h"
#include	"../../franz/h/config.h"

#ifndef LISZT
#define LISZT	"/usr/ucb/xliszt"
#endif

#ifndef AS
#define AS	"/usr/lib/lisp/as"
#endif

#ifndef OFFSET
#define OFFSET		0x0
#endif

main(argc,argv,envp)
	register char *argv[], **envp;
{
	struct exec header;
	register int autorun = 0;
	register int no_assem = 0;
	register char *p;
	register int oflag = 0, cur;
	register int objp;
	register int slen;
	char temp[20], tempfile[20], srcfile[20], outfile[20];
	char *args_to_string();
	char *flags_to_string();
	char command[1024];
    
	/*
	**  process arguments :: check for -r and -S switches
	**
	**  -F is a special flag that means just to fix the offset in the
	** object file, and then quit.
	**
	**/
	/* If no args, then give the user an interactive liszt */
        if (argc == 1)
	{
		execle(LISZT, "liszt", 0, envp);
		exit(100);
	} else
	{
		for (cur = 1; cur < argc; cur++) {
			if (*argv[cur] == '-')
			{
				p = argv[cur];
				p++;
				if (*p == 'o')
				{
		    			strcpy(outfile,argv[++cur]);
		    			oflag++;
				}
				else if (*p == 'F')
				{
					strcpy(outfile,argv[++cur]);
					autorun = 1;
					goto fixit;
				}
				else
				{
		    			for (; *p; p++) {
						switch (*p)
						{
			    			case 'S':
			        			no_assem++;
			        			break;
			    			case 'r':
			        			autorun++;
			        			break;
			    			default:
			        			break;
						}
		    			}
				}
	    		}
			else
			{	/* must be filename */
	        		strcpy(srcfile, argv[cur]);
	    		}
        	}
    	}

	if (no_assem)
	{
    		sprintf(command, "%s %s", LISZT, args_to_string(argv));
#ifdef debug
    		printf("%s\n", command);
#else
		exit(system(command));
#endif
	}

	sprintf(tempfile, "/tmp/Lzt%d.s", getpid());

	/* If output file not given, then we deduce it... */
	if (oflag == 0)
	{
		strcpy(outfile,srcfile);
		slen = strlen(outfile);
		if (outfile[slen - 2] == '.')
		{
			outfile[slen - 1] = 'o';
		}
		else
		{
			strcpy(temp,outfile);
			sprintf(outfile, "%s.o", temp);
		}
	}

	sprintf(command, "%s -S%s -o %s %s",
			 LISZT, flags_to_string(argc, argv), tempfile, srcfile);
#ifdef debug
	printf("%s\n", command);
#else
    	if (system(command) != 0)
	{
		exit(101);
    	}
#endif

	sprintf(command, "%s -o %s %s", AS, outfile, tempfile);
#ifdef debug
	printf("%s\n", command);
#else
	if (system(command) != 0)
	{
		exit(102);
	}
	unlink(tempfile);

fixit:
    	if (autorun)
	{
		if ((objp = open(outfile,2)) == -1)
		{
	    		perror(outfile);
	    		exit(103);
		}
		if (read(objp,&header,sizeof header) != sizeof (struct exec))
		{
			perror("read failed");
			exit(1);
		}

		/* Change the offset to the correct value */
		header.a_entry = OFFSET;

		/* seek back to beginning */
		if (lseek(objp,0,0) != 0)
		{
	    		perror("seek failed");
	    		exit(104);
		}

		/* write the new a.out header... */
		if (write(objp,&header,sizeof header) != sizeof(struct exec))
		{
	    		perror("write failed");
	    		exit(105);
		}

		/* make it executable */
		chmod(outfile, 0755);
    	} else
		exit(0);
#endif
}

char *
args_to_string(pp)
	char *pp[];
{
    	char result[1024];
    	register int ii = 0,
		     jj = 1;

    	for (; pp[jj]; ii++, jj++)
	{
		xstrcpy(&result[ii],pp[jj]);
		ii = ii + strlen(pp[jj]);
    	}
    	result[ii++] = '\0';
    	return(result);
}

char *
flags_to_string(argc, argv)
	int argc;
	char *argv[];
{
    	char result[128];
    	register int chari, word, skipnext = 0, out = 0;

	for (word = 1; word < argc; word++)
	{
		if (skipnext)
		{
			skipnext = 0;
			word++;
			continue;
		}
		if (*argv[word] == '-')
			for (chari = 1; argv[word][chari]; chari++)
				if (argv[word][chari] == 'o')
					skipnext = 1;
				else
					result[out++] = argv[word][chari];
	}
    	result[out] = '\0';
    	return(result);
}

xstrcpy(s, t)
	char *s, *t;
{
    	while (*t != '\0')
	{
        	*s++ = *t++;
    	}
    	*s = ' ';
}
EndOfFile
cat >  doc/lmacs  << 'EndOfFile'
." @(#)lmacs	34.4 3/23/82
." $Header: lmacs 1.2 83/07/01 11:21:33 sklower Exp $
."""""""
." macros for the Franz Lisp Manual
." 
." first we set these global me variables
.""""""""
.nr ss 3v	\" space 4v between sections
."" comment:
.nr si 3n	\" section indent
.""""""""
." the following two lines are for larger type font
." .nr pp 12
." .nr sp 12
." If we are making an on line manual, include the line below:
.if 0 .ll 7.5i	\" extra wide for nroff, DISABLED
."""""""""""""""
."  A chapter is begun by
."	.Lc chaptertitle number
."
." a function is introduced by a 
."	.Lf functionname arglist
." where the arglist must be one string, use "'s if necessary.
." if there are two names for a function then the first is called with
." .Lf and subsequent ones with .Lx
." then there are these macros to begin text describing what the function
." does:
."	.Wh
."	<text>			says "WHERE" allowing you to give more
."				details on a function.
."	.Re
."	<text>			tells what value the function returns
."
."	.No
."	<text>			begins a note, giving more detail on the fcn
."
."	.Se
."	<text>			describes a size effect of a function.
."
."	.Im
."	<text>			note to implementor. this will only be
."				printed out in the implementors version of
."				the manual.
."	.Rm			prints a message about this function being
."				likely to disappear
."
."	.Ex			begin a short example
."
."	.Eb			begin an large offset example
."	.Ee			end an example
."
."	.Fb			begin a large offset example but don't
."				try to keep it on one page.
."	.Fe			end what .Fb started
."
." useful macros
."	.Fr rest		prints out Franz Lisp and appends rest
."				to it.
."
." used in creating the index, table of contents and appendicies
."				
."	.Ib			begin index
."	.In ch# pg# fcn-name fcn-args    this isnt inserted by hand, but
."				is generated by the index program. it indicates
."				where a function begins.
."
."	.Ap c T			begin appendix c with title T
."
.""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.de Lc
." .in 0
.++ RC '\\$1''\\\\\\\\\\\\\\\\n(ch-%'
.nr % 2
.nr ch \\$2-1
.+c \\$1
.fo '''\fR\s-2Printed:\ \*(td\s0\fP'
..
.de Lf
.sp 1v
.ne 11
.Lx \\$1 "\\$2"
..
.de Lx
.in 0
.ie '\\$2'' \fB(\\$1)\fP
.el \fB(\\$1\fP \\$2\fB)\fP
.br
.nr $i 5n
." if troff, then put nice index entry, if nroff then we are making an
." online manual so put out a cryptic lisp expression. If you want to
." make an nroff version of the manual with index, then you will have
." to alter the lines below: replace .if t with .if 1   and .if n with .if 0
.if t .tm .In \\n(ch \\n% \\$1 "\\$2"
.if n .tm (\\$1 ch\\n(ch.r)
..
.de Re
.ip \s-2RETURNS\s0: 9
..
.de Ex
.ip \s-2EXAMPLE\s0: 9
..
.de No
.ip \s-2NOTE\s0: 6
..
.de Eq
.ip \s-2EQUIVALENT\ TO\s0: 15
..
.de Im
.ip \s-2IMPLEMENTATION\s0: 20
..
.de Se
.ip \s-2SIDE\ EFFECT\s0: 13
..
.de Wh
.ip \s-2WHERE\s0: 9
..
.de Rm
.No
this function will most likely disappear in future releases.
..
.de Fr
F\s-2RANZ\s0 L\s-2ISP\s0\\$1
..
.de Ib	\"	beginning of index
.Ap 1 Index\ to\ F\s-2RANZ\s0\ L\s-2ISP\s0\ Functions
.ta 6i	\" set tab stop for location column
.tc .		\" generate dots to line up page numbers
.nf
..
.de In
.ie '\\$4'' (\\fB\\$3\\fR)\t\\$1-\\$2
.el (\\fB\\$3\\fR\ \\$4)\t\\$1-\\$2
..
.de Eb
.in 0
.(b 
.sp 1v
.hl
.sz -2
..
.de Ee
.sz +2
.hl
.sp 1v
.)b
..
.de Fb
.in 0
.sp 1v
.ne 1i
.hl
.sz -2
..
.de Fe
.sz +2
.hl
.sp 1v
..
.de Ap	\" appendix n title  (n is 1 2 3 4  for A B C D etc)
.++ RA '''\\\\\\\\\\\\\\\\n(ch-%'
.nr ch \\$1-1
.+c \\$2
.fo '''\fR\s-2Printed:\ \*(td\s0\fP'
..
EndOfFile
cat >  doc/ch0.n  << 'EndOfFile'
." $Header: ch0.n,v 1.3 83/07/27 15:10:52 layer Exp $
.pp
\ \ 
.sp 2i
.tl ''\s14The\ \s16F\s14RANZ\ \s16L\s14ISP\ \s14Manual''
.ps 10
.sp 1v
.tl ''by''
.sp 2v
.tl ''\fIJohn\ K.\ Foderaro\fP''
.sp 2v
.tl ''\fIKeith\ L.\ Sklower\fP''
.sp 2v
.tl ''\fIKevin\ Layer\fP''
.sp 2i
.tl ''June 1983''
.sp 2i
.tl '''A document in'
.tl '''four movements'
.bp
.sp 1i
.ft I
.ll 5.5i
.in .5i
.tl ''Overture''
.sp 2v
A chorus of students
under the direction of
Richard Fateman have contributed to
building 
.Fr
from a mere melody into a full
symphony .
The major contributors to the initial system were
Mike Curry,  John Breedlove and Jeff Levinsky.
Bill Rowan added the garbage collector and array package.
Tom London worked on an early compiler and helped in 
overall system design.
Keith Sklower has contributed much to 
.Fr ,
adding the 
bignum package and rewriting most of the code to increase
its efficiency and clarity.
Kipp Hickman and Charles Koester added hunks.
Mitch Marcus added *rset, evalhook and evalframe.
Don Cohen and others at Carnegie-Mellon 
made some improvements to evalframe and 
provided various features modelled after UCI/CMU PDP-10 Lisp and
Interlisp environments (editor, debugger, top-level).
John Foderaro wrote the compiler, added a few functions,
and wrote much of this manual. Of course, other authors have
contributed specific chapters as indicated.
Kevin Layer modified the compiler to produce code for the
Motorola 68000, and helped make
.Fr
pass ``Lint''.
.br
This manual may be supplemented or supplanted by local
chapters representing alterations, additions and deletions.
We at U.C. Berkeley are pleased to learn of generally
useful system features, bug fixes, or useful program packages,
and we will attempt to redistribute such contributions.
.sp 1.75i
.ft R
.ll 6.0i
.in 0
\(co 1980, 1981, 1983 by the Regents of the University of California.
(exceptions: Chapters 13, 14 (first half), 15 and 16 have separate copyrights,
as indicated. These are reproduced by permission of the copyright
holders.)
.br
Permission to copy without fee all or part of this material is granted
provided that the copies are not made or
distributed for direct commercial advantage, and the copyright
notice of the Regents, University of California, is given.
All rights reserved.
.br
.sp 2v
Work reported herein was supported in part by 
the U. S. Department
of Energy, Contract DE-AT03-76SF00034, Project Agreement
DE-AS03-79ER10358, and the National Science
Foundation under Grant No.  MCS 7807291
.sp 2v
UNIX is a trademark of Bell Laboratories.  VAX and PDP are trademarks
of Digital Equiptment Coporation.  MC68000 is a trademark of
Motorola Semiconductor Products, Inc.
.bp
.ps 16
.sp 1i
.tl ''Score''
.sp .5i
.ps 12
.in 1i.
.ti 2i
\fBFirst Movement \fI(allegro non troppo)\fR
.ps 10
.sp 1v
.de CH
.ti -.5i
\fR\\$1 \\$2\fP
.br
..
.ft I
.CH 1. F\s-2RANZ\s0\ L\s-2ISP\s0 
Introduction to 
.Fr ,
details of data types,
and description of notation
.CH 2. Data\ Structure\ Access
Functions for the creation, destruction  
and  manipulation of lisp data objects.
.CH 3. Arithmetic\ Functions
Functions to perform arithmetic operations.
.CH 4. Special\ Functions
Functions for altering flow of control.
Functions for mapping other functions over lists.
.CH 5. I/O\ Functions
Functions for reading and writing from ports.
Functions for the modification of the reader's syntax.
.CH 6. System\ Functions 
Functions for storage management, debugging, and for the reading 
and setting of global Lisp status variables.
Functions for doing UNIX-specific tasks such as process control.
.ft R
.sp 2v
.ps 12
.ti 2i
\fBSecond Movement \fI(Largo)\fR
.ps 10
.sp 1v
.ft I
.CH 7. The\ Reader
A description of the syntax codes used by the reader.
An explanation of character macros.
.CH 8. Functions,\ Fclosures,\ and\ Macros 
A description of various types of functional objects.
An example of the use of foreign functions.
.CH 9. Arrays\ and\ Vectors
A detailed description of the parts of an array and of 
Maclisp compatible arrays.
.CH 10. Exception\ Handling 
A description of the error handling sequence and of autoloading.
.ft R
.bp
.ps 12
.ti 2i
\fBThird Movement \fI(Scherzo)\fR
.ps 10
.sp 1v
.ft I
.CH 11. The\ Joseph\ Lister\ Trace\ Package 
A description of a very useful debugging aid.
.CH 12. Liszt,\ the\ lisp\ compiler 
A description of the operation of the
compiler and hints for making functions compilable.
.CH 13. CMU\ Top\ Level\ and\ File\ Package
A description of a top level with a history mechanism and a 
package which helps you keep track of files of lisp functions.
.CH 14 Stepper
A description of a program which permits you to  put breakpoints
in lisp code and to single step it.  A description of the
evalhook and funcallhook mechanism.
.CH 15 Fixit
A program which permits you to examine and modify evaluation stack 
in order to fix bugs on the fly.
.CH 16 Lisp\ Editor
A structure editor for interactive modification of lisp code.
.ft R
.sp 2v
.ps 12
.ti 2i
\fBFinal Movement \fI(allegro)\fR
.ps 10
.sp 1v
.ft I
.CH Appendix\ A -\ Function\ Index 
.CH Appendix\ B -\ List\ of\ Special\ Symbols
.CH Appendix\ C -\ Short\ Subjects
Garbage collector, Debugging, Default Top Level
EndOfFile
cat >  doc/ch1.n  << 'EndOfFile'
." $Header: ch1.n,v 1.3 83/07/27 15:11:17 layer Exp $
.Lc \s+2F\s-2RANZ\s0\ L\s-2ISP\s0\s-2 1
.sh 2
.Fr \*[\(dg\*]
was created as a tool to further research in symbolic and
algebraic manipulation,
artificial intelligence,
and programming languages at the University of California
at Berkeley.
.(f
\*[\(dg\*]It is rumored that this name has something to do with Franz
Liszt [F\fIr\fPa\*:nts List] (1811-1886) a Hungarian composer
and keyboard virtuoso. 
These allegations have never been proven.
.)f
Its roots are in a PDP-11 Lisp system which originally came
from Harvard.
As it grew it adopted features of Maclisp and Lisp Machine Lisp.
Substantial compatibility with other Lisp dialects
(Interlisp, UCILisp, CMULisp) is achieved by 
means of support packages and compiler switches.
The heart of
.Fr
is written almost entirely in the programming language C.
Of course, it has been greatly extended by additions written
in Lisp.
A small part is written in the assembly language for the current
host machines, VAXen and a couple of flavors of 68000.
Because 
.Fr
is written in C, it is relatively portable and easy to comprehend.
.pp
.Fr
is capable of running large lisp programs in a timesharing environment,
has facilities for arrays and user defined structures,
has a user controlled reader with character and word macro  capabilities,
and can interact directly with compiled Lisp, C, Fortran, and Pascal code.
.pp 
This document is a reference manual for the 
.Fr
system.
It is not a Lisp primer or introduction to the language.
Some parts will be of interest primarily to those maintaining 
.Fr
at their computer site.
There is an additional document entitled
\fIThe Franz Lisp System,\fp
by John Foderaro, which partially describes the system implementation.
.Fr ,
as delivered by Berkeley, includes all source code
and machine readable version of this manual and system document.
The system document is in a single file named "franz.n" in
the "doc" subdirectory.
.pp
This document is divided into four Movements.
In the first one we will attempt to describe the language of
.Fr
precisely and completely as it now stands (Opus 38.69, June 1983).
In the second Movement we will look at the reader, function types,
arrays and exception handling.
In the third Movement we will look at several large support packages 
written to help the 
.Fr
user, namely the trace package,  compiler, fixit and stepping package.
Finally the fourth movement contains  an index into the other movements.
In the rest of this chapter we shall examine the data types of 
.Fr .
The conventions used in the description of the 
.Fr
functions will be given in \(sc1.3 -- it is very important that 
these conventions are  understood.
.sh 2 Data\ Types
.Fr
has fourteen data types.
In this section we shall look in detail at each type and if a type is
divisible we shall look inside it.
There is a Lisp function
.i type
which will return the type name of a lisp object.
This is the official 
.Fr
name for that type and we will use this name and this name only in 
the manual to avoid confusing the reader.
The types are listed in terms of importance rather than alphabetically.
.sh 3 lispval - - 0
This is the name we use to describe any Lisp object.
The function
.i type
will never return `lispval'.
.sh 3 symbol
This object corresponds to a variable in most other programming languages.
It may have a value or may be `unbound'.
A symbol may be 
.i lambda 
.i bound 
meaning that its current value is stored
away somewhere and the symbol  is given a new value for the duration of a 
certain context.
When the Lisp processor  leaves that context, the 
symbol's current value is thrown
away and its old value is restored.
.sp .5v
A symbol may also have a 
.i function 
.i binding .
This function binding is static; it cannot be lambda bound.
Whenever the symbol is used in the functional position of a Lisp expression
the function binding of the symbol is examined (see Chapter 4 for more
details on  evaluation).
.sp .5v
A symbol may also have a 
.i property 
.i list ,
another static data structure.
The property list consists of a list of an even number of elements,
considered to be grouped as pairs. 
The first element of the pair is the 
.i indicator 
the second the 
.i value 
of that indicator.
.sp .5v
Each symbol has a print name 
.i (pname) 
which is how this symbol is accessed from input and referred to
on  (printed) output.
.sp .5v
A symbol also has a hashlink used to link symbols together in the
oblist -- this field is inaccessible to the lisp user.
.sp .5v
Symbols are created by the reader and by the functions
.i concat ,
.i maknam
and their derivatives.
Most symbols live on 
.Fr 's
sole 
.i oblist ,
and therefore two symbols with the same print name are
usually the  exact same object (they are
.i eq ).
Symbols which are not on the oblist are said to be 
.i uninterned.
The function
.i maknam
creates uninterned symbols while 
.i concat
creates 
.i interned 
ones.
.sp 1v
.TS
box center ; 
c | c | c |  c .
Subpart name	Get value	Set value	Type

=
value	eval	set	lispval
		setq
_
property	plist	setplist	list or nil
list	get	putprop	
		defprop	
_
function	getd	putd	array, binary, list
binding		def	or nil
_
print name	get_pname		string
_
hash link
.TE
.sh 3 list
A list cell has two parts, called the car and cdr.
List cells are created by the function 
.i cons .
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
car	car	rplaca	lispval
_
cdr	cdr	rplacd	lispval
.TE
.sh 3 binary
This type acts as a function header for machine coded functions.
It has two parts, a pointer to the start of the function and a
symbol whose print name describes the 
argument
.i discipline .
The discipline (if 
.i lambda ,
.i macro 
or 
.i nlambda )
determines whether the arguments to this function will be evaluated
by the caller
before this function is called.
If the discipline is a string (specifically 
"\fIsubroutine\fP",
"\fIfunction\fP",
"\fIinteger-function\fP",
"\fIreal-function\fP",
"\fIc-function\fP",
"\fIdouble-c-function\fP",
or "\fIvector-c-function\fP"
)
then this function is
a foreign subroutine or function (see \(sc8.5 for more details on this).
Although the type of the 
.i entry 
field of a binary type object is usually \fBstring\fP or \fBother\fP,
the object pointed to
is actually a sequence of machine instructions.
.br
Objects of type binary are created by 
.i mfunction,
.i cfasl,
and
.i getaddress.
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
entry	getentry		string or fixnum
_
discipline	getdisc	putdisc	symbol or fixnum
.TE
.sh 3 fixnum
A fixnum is an integer constant in the range \(mi2\*[31\*] to
2\*[31\*]\(mi1.
Small fixnums (-1024 to 1023) are stored in a special table so they needn't be
allocated each time one is needed.
In principle, the range for fixnums is machine dependent, although
all current implementations for franz have this range.
.sh 3 flonum
A flonum is a double precision real number. On the VAX,
the range is
\(+-2.9\(mu10\*[-37\*] to \(+-1.7\(mu10\*[38\*].
There are approximately sixteen decimal digits of precision.
Other machines may have other ranges.
.sh 3 bignum
A bignum is an integer of potentially unbounded size.
When integer arithmetic exceeds the limits of fixnums mentioned above,
the calculation is automatically done with bignums.
Should calculation with bignums give a result which can be represented
as a fixnum, then the fixnum representation will be used\*[\(dg\*].
.(f
\*[\(dg\*]The current algorithms for integer arithmetic operations will return
(in certain cases) a result 
between \(+-2\*[30\*] and 2\*[31\*] as a bignum although this
could be represented as a fixnum.
.)f
This contraction is known as
.i integer
.i normalization .
Many Lisp functions assume that integers are normalized.
Bignums are composed of a sequence of
.b list
cells and a cell known as an 
.b sdot.
The user should consider a 
.b bignum
structure indivisible and use functions such as
.i haipart ,
and 
.i bignum-leftshift
to extract parts of it.
.sh 3 string
A string is a null terminated sequence of characters.
Most functions of symbols which operate on the symbol's print name will
also work on strings.
The default reader syntax is set so that 
a sequence of characters surrounded by double quotes is a string.
.sh 3  port
A port is a structure which the system I/O routines can reference to
transfer data between the Lisp system and external media.
Unlike other Lisp objects there are a very limited number of ports (20).
Ports are allocated by 
.i infile 
and 
.i outfile 
and deallocated by 
.i close 
and 
.i resetio .
The 
.i print
function prints a port as a percent sign followed by the name of the file it
is connected to (if the port was opened by \fIfileopen, infile, or outfile\fP).
During initialization,
.Fr
binds the symbol \fBpiport\fP to a port attached to the standard input stream.
This port prints as %$stdin.
There are ports connected to the standard output and error streams,
which print as %$stdout and %$stderr.
This is discussed in more detail at the beginning of Chapter 5.
.sh 3 vector
Vectors are indexed sequences of data.
They can be used to implement a notion of user-defined types
via their associated property list.
They make \fBhunks\fP (see below) logically unnecessary, although hunks are very
efficiently garbage collected.
There is a second kind of vector, called an immediate-vector,
which stores binary data.
The name that the function \fItype\fP returns for immediate-vectors
is \fBvectori\fP.
Immediate-vectors could be used to implement strings and block-flonum arrays,
for example.
Vectors are discussed in chapter 9.
The functions
\fInew-vector\fP, and
\fIvector\fP, can
be used to create vectors.
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
datum[\fIi\fP]	vref	vset	lispval
_
property	vprop	vsetprop	lispval
		vputprop
_
size	vsize	\-	fixnum
.TE
.sh 3 array
Arrays are rather complicated types and are fully described in
Chapter 9.
An array consists of a block of contiguous data, a function
to access that data, and auxiliary fields for use by the accessing
function.
Since an array's accessing function is created by the user, an array can
have any form the user chooses (e.g. n-dimensional, triangular, or hash
table).
.br
Arrays are created by the function
.i marray .
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
access function	getaccess	putaccess	binary, list
			or symbol
_
auxiliary	getaux	putaux	lispval
_
data	arrayref	replace	block of contiguous
		set	lispval
_
length	getlength	putlength	fixnum
_
delta	getdelta	putdelta	fixnum
.TE
.sh 3 value
A value cell contains a pointer to a lispval.
This type is used mainly by arrays of general lisp objects.
Value cells are created with the 
.i ptr
function.
A value cell containing a pointer to the symbol `foo' is printed
as `(ptr\ to)foo'
.sh 3 hunk
A hunk is a vector of from 1 to 128 lispvals.
Once a hunk is created (by 
.i hunk 
or 
.i makhunk ) 
it cannot grow or shrink.
The access time for an element of a hunk is slower than a list cell element
but faster than an array.
Hunks are really only allocated in sizes which are powers of two, but 
can appear to the user to be any size in the 1 to 128 range.
Users of hunks must realize that \fI(not\ (atom\ 'lispval))\fP
will return true if 
.i lispval
is a hunk.
Most lisp systems do not have a direct test for a list cell and instead use
the above test and assume that 
a true result means 
.i lispval 
is a list cell.
In
.Fr
you can use
.i dtpr
to check for a list cell.
Although hunks are not list cells, you can still access the first two
hunk elements with 
.i cdr
and
.i car
and you can access any hunk element with
.i cxr \*[\(dg\*].
.(f
\*[\(dg\*]In a hunk, the function 
.i cdr
references the first element 
and 
.i car
the second.
.)f
You can set the value of the first two elements of a hunk with 
.i rplacd
and 
.i rplaca
and you can set the value of any element of the hunk with 
.i rplacx .
A hunk is printed by printing its contents surrounded by { and }.
However a hunk cannot be read in in this way in the standard lisp system.
It is easy to write a reader macro to do this if desired.
.sh 3 other
Occasionally, you can obtain a pointer to storage not allocated
by the lisp system.  One example of this is the entry field of
those
.Fr
functions written in C.  Such objects are classified as of type
\fBother\fP.
Foreign functions which call malloc to allocate their own space,
may also inadvertantly create such objects.
The garbage collector is supposed to ignore such objects.
.sh 2 Documentation Conventions.
The conventions used in the following chapters were designed to
give a great deal of information in a brief
space.
The first line of a function description contains the function
name in \fBbold\ face\fP and then lists the arguments, if any.
The arguments all have names which begin with a letter  or letters and 
an underscore.
The letter(s) gives the allowable type(s) for that argument according to
this table.
.sp 1v
.TS
box center ;
c  | c 
l | l .
Letter	Allowable type(s)

=
g	any type
_
s	symbol (although nil may not be allowed)
_
t	string
_
l	list (although nil may be allowed)
_
n	number (fixnum, flonum, bignum)
_
i	integer (fixnum, bignum)
_
x	fixnum
_
b	bignum
_
f	flonum
_
u	function type (either binary or lambda body)
_
y	binary
_
v	vector
_
V	vectori
_
a	array
_
e	value
_
p	port (or nil)
_
h	hunk
.TE

In the first line of a function description,
those arguments preceded by a quote mark are evaluated (usually 
before the function is called).
The quoting convention is used so that we can give a name to the result of
evaluating the argument and we can describe the allowable types.
If an argument is not quoted it does not mean that that argument will
not be evaluated, but rather that 
if it is evaluated, the time at which it is evaluated
will be specifically mentioned in the function description.
Optional arguments are surrounded by square brackets.
An ellipsis (...) means zero or more occurrences of an argument of the 
directly preceding
type.
EndOfFile
cat >  doc/ch2.n  << 'EndOfFile'
." $Header: ch2.n,v 1.7 83/07/30 14:42:38 layer Exp $
.Lc Data\ Structure\ Access 2
.pp
The following functions allow one to create and manipulate the various types
of lisp data structures.
Refer to \(sc1.2 for details of the data structures known to 
.Fr .
.sh 2 Lists \n(ch 1
.pp
The following functions exist for the creation and manipulating of lists.
Lists are composed of a linked list of objects called 
either 'list cells', 'cons cells' or 'dtpr cells'.
Lists are normally terminated with the special symbol 
.b nil .
.b nil 
is both a symbol and a representation for the empty list ().
.sh 3 list\ creation
.Lf cons "'g_arg1 'g_arg2"
.Re
a new list cell whose car is g_arg1 and whose cdr is g_arg2.
.Lf xcons "'g_arg1 'g_arg2"
.Eq
\fI(cons 'g_arg2 'g_arg1)\fP
.Lf ncons "'g_arg"
.Eq 
\fI(cons 'g_arg nil)\fP
.Lf list "['g_arg1 ... ]"
.Re
a list whose elements are the g_arg\fIi\fP.
.Lf append "'l_arg1 'l_arg2"
.Re
a list containing the elements of l_arg1 followed by l_arg2.
.No
To generate the result, the top level list cells of l_arg1 are duplicated
and the cdr of the last list cell is set to point to l_arg2.
Thus this is an expensive operation if l_arg1 is large.
See the descriptions of 
.i nconc 
and 
.i tconc 
for cheaper ways of doing the 
.i append 
if the list l_arg1 can be altered.
.Lf append1 "'l_arg1 'g_arg2"
.Re
a list like l_arg1 with g_arg2 as the last element.
.No
this is equivalent to (append 'l_arg1 (list 'g_arg2)).
.Eb
; A common mistake is using append to add one element to the end of a list
\-> \fI(append '(a b c d) 'e)\fP
(a b c d . e)
; The user intended to say:
\-> \fI(append '(a b c d) '(e))
(a b c d e)
; better is append1
\-> \fI(append1 '(a b c d) 'e)\fP
(a b c d e)
.Ee
.Lf quote! "[g_qform\fIi\fP] ...[! 'g_eform\fIi\fP] ...  [!! 'l_form\fIi\fP] ..."
.Re
The list resulting from the  splicing and insertion process 
described below.
.No
.i quote!
is the complement of the
.i list
function.  
.i list
forms a list by evaluating each for in the argument list; evaluation is
suppressed if the form is \fIquote\fPed.  In 
.i quote!,
each form is implicitly \fIquote\fPed.  To be evaluated, a form
must be preceded by one of the evaluate operations ! and !!. ! g_eform
evaluates g_form and the value is inserted in the place of the call;
!! l_form evaluates l_form and the value is spliced into the place of
the call.
.br
.sp
`Splicing in' means that the parentheses surrounding the list are removed
as the example below shows.
Use of the evaluate operators can occur at any level in a
form argument.
.br
.sp
Another way to get the effect of the \fIquote!\fP function is to use
the backquote character macro (see \(sc 8.3.3).
.Eb
\fI(quote! cons ! (cons 1 2) 3) = (cons (1 . 2) 3)\fP
\fI(quote! 1 !! (list 2 3 4) 5) = (1 2 3 4 5)\fP
\fI(setq quoted 'evaled)(quote! ! ((I am  ! quoted))) = ((I am evaled))\fP
\fI(quote! try ! '(this ! one)) = (try (this ! one))\fP
.Ee

.Lf bignum-to-list "'b_arg"
.Re
A list of the fixnums which are used to represent the bignum.
.No
the inverse of this function is
.i list-to-bignum.
.Lf list-to-bignum "'l_ints"
.Wh
l_ints is a list of fixnums.
.Re
a bignum constructed of the given fixnums.
.No
the inverse of this function is
.i bignum-to-list.

.sh 3 list\ predicates 
.Lf dtpr "'g_arg"
.Re
t iff g_arg is a list cell.
.No
that (dtpr '()) is nil.  The name \fBdtpr\fP is
a contraction for ``dotted pair''.
.Lf listp "'g_arg"
.Re
t iff g_arg is a list object or nil.
.Lf tailp "'l_x 'l_y"
.Re
l_x, if a list cell
.i eq
to l_x is found by
.i cdr ing
down l_y zero or more times, nil otherwise.
.Eb
\-> \fI(setq x '(a b c d) y (cddr x))\fP
(c d)
\-> \fI(and (dtpr x) (listp x))\fP	; x and y are dtprs and lists
t
\-> \fI(dtpr '())\fP		; () is the same as nil and is not a dtpr
nil
\-> \fI(listp '())\fP 		; however it is a list
t
\-> \fI(tailp y x)\fP
(c d)
.Ee
.Lf length "'l_arg"
.Re
the number of elements in the top level of list l_arg.
.sh 3 list\ accessing
.Lf car "'l_arg"
.Lx cdr "'l_arg"
.Re the appropriate part of
.i cons
cell.
(\fIcar\fP (\fIcons\fP x y)) is always x,
(\fIcdr\fP (\fIcons\fP x y)) is always y.
In
.Fr ,
the cdr portion is located first in memory.
This is hardly noticeable, and we mention it
primarily as a curiosity.
.Lf c\.\.r "'lh_arg"
.Wh 
the .. represents any positive number of \fBa\fP's and \fBd\fP's.
.Re
the result of accessing the list structure in the way determined by
the function name.
The \fBa\fP's and \fBd\fP's are read from right to left, a 
.b d
directing the access down the cdr part of the list cell and an
.b a
down the car part.
.No
lh_arg may also be nil, and it is guaranteed that the car and cdr of nil
is nil.
If lh_arg is a hunk, then \fI(car\ 'lh_arg)\fP is the same as 
\fI(cxr\ 1\ 'lh_arg)\fP and  \fI(cdr\ 'lh_arg)\fP is the same
as \fI(cxr\ 0\ 'lh_arg)\fP.
.br
It is generally hard to read and understand the context
of functions with large strings of 
.b a 's
and
.b d 's,
but these functions are supported by rapid accessing and open-compiling
(see Chapter 12).
.Lf nth "'x_index 'l_list"
.Re
the nth element of l_list, assuming zero-based index.
Thus (nth 0 l_list) is the same as (car l_list).
.i nth
is both a function, and a compiler macro, so that
more efficient code might be generated than for
.i nthelem
(described below).
.No
If x_arg1 is non-positive or greater than the length
of the list, nil is returned. 
.Lf nthcdr "'x_index 'l_list"
.Re
the result of \fIcdr\fPing down the list l_list x_index times.
.No
If x_index is less than 0, then \fI(cons\ nil\ 'l_list)\fP is returned.
.Lf nthelem "'x_arg1 'l_arg2"
.Re
The x_arg1'\fIst\fP element of the list l_arg2.
.No
This function comes from the PDP-11 Lisp system.
.Lf last "'l_arg"
.Re
the last list cell in the list l_arg.
.Ex
\fIlast\fP does NOT return the last element of a list!
.br
\fI(last '(a b))\fP = (b)
.Lf ldiff "'l_x 'l_y"
.Re
a  list  of all
elements in l_x but not in l_y
, i.e., the list difference of
l_x and l_y.
.No
l_y must be a tail of l_x, i.e.,
.i eq
to the result of applying some number of \fIcdr\fP's
to l_x.  
Note  that  the  value  of  \fIldiff\fP  is  always  new  list
structure unless l_y is nil, in which case \fI(ldiff l_x nil)\fP is l_x
itself.
If l_y  is  not  a  tail  of  l_x, \fIldiff\fP generates an error.
.Ex
\fI(ldiff 'l_x (member 'g_foo 'l_x))\fP gives all elements
in l_x up to the first g_foo.
.sh 3 list\ manipulation
.Lf rplaca "'lh_arg1 'g_arg2"
.Re
the modified lh_arg1.
.Se
the car of lh_arg1 is set to  g_arg2.
If lh_arg1 is a hunk then the second element of the hunk is set to g_arg2.
.Lf rplacd "'lh_arg1 'g_arg2"
.Re
the modified lh_arg1.
.Se
the cdr of lh_arg2 is set to g_arg2.
If lh_arg1 is a hunk then the first element of the hunk is set to g_arg2.

.Lf attach "'g_x 'l_l"
.Re
l_l whose 
.i car
is now g_x, whose 
.i cadr 
is the original \fI(car\ l_l)\fP, 
and whose 
.i cddr 
is the original \fI(cdr\ l_l)\fP.
.No
what happens is that g_x is added to the 
beginning of list l_l  yet maintaining the same list cell  at the 
beginning of the list.
.Lf delete "'g_val 'l_list ['x_count]"
.Re
the result of splicing g_val from the top level of
l_list no more than x_count times.
.No
x_count defaults to a very large number, thus if x_count is not given, all
occurrences of g_val are removed from the top level of l_list.
g_val is compared with successive 
.i car 's
of l_list using the function
.i equal .
.Se
l_list is modified using rplacd, no new list cells are used.
.Lf delq "'g_val 'l_list ['x_count]"
.Lx dremove "'g_val 'l_list ['x_count]"
.Re
the result of splicing g_val from the top level of l_list no more than
x_count times.
.No
.i delq 
(and 
.i dremove )
are the same as 
.i delete 
except that 
.i eq
is used for comparison instead of 
.i equal .
.Eb
; note that you should use the value returned by \fIdelete\fP or \fIdelq\fP
; and not assume that g_val will always show the deletions.
; For example

\-> \fI(setq test '(a b c a d e))\fP
(a b c a d e)
\-> \fI(delete 'a test)\fP
(b c d e)         ; the value returned is what we would expect	
\-> \fItest\fP
(a b c d e)       ; but test still has the first a in the list!
.Ee
.Lf remq "'g_x 'l_l ['x_count]"
.Lx remove "'g_x 'l_l"
.Re
a 
.i copy
of l_l with all top level elements
.i equal
to g_x removed.
.i remq
uses 
.i eq
instead of
.i equal
for comparisons.
.No
remove does not modify its arguments like 
.i delete ,
and
.i delq 
do.
.Lf insert "'g_object 'l_list 'u_comparefn 'g_nodups"
.Re
a list consisting of l_list with g_object destructively inserted
in a place determined by the ordering function u_comparefn.
.No
\fI(comparefn 'g_x 'g_y)\fP
should return something non-nil if g_x can precede g_y in sorted order,
nil if g_y must precede g_x.
If u_comparefn is nil, alphabetical order
will be used.  
If g_nodups is non-nil, an element will not be inserted if an
equal element is already in the list.
.i insert
does binary search to determine where to insert the new element.
.Lf merge "'l_data1 'l_data2 'u_comparefn"
.Re
the merged list of the two input sorted lists l_data1 and l_data1
using binary comparison function u_comparefn.  
.No
\fI(comparefn 'g_x 'g_y)\fP
should return something non-nil if g_x can precede g_y in sorted order,
nil if g_y must precede g_x.  If u_comparefn is nil, 
alphabetical order
will be used.  u_comparefn should be thought of as "less than or equal".
.i merge
changes both of its data arguments.
.Lf subst "'g_x 'g_y 'l_s"
.Lx dsubst "'g_x 'g_y 'l_s"
.Re
the result of substituting g_x for all 
.i equal
occurrences of g_y  at all levels in l_s.  
.No
If g_y is a symbol, 
.i eq
will be used for comparisons.
The function
.i subst
does not modify l_s 
but the function
.i dsubst
(destructive substitution)
does.
.Lf lsubst "'l_x 'g_y 'l_s"
.Re
a copy of l_s  with l_x spliced in for every occurrence of of g_y 
at all levels. 
Splicing in means that the parentheses surrounding the list l_x are removed
as the example below shows.
.Eb
\-> \fI(subst '(a b c) 'x '(x y z (x y z) (x y z)))\fP
((a b c) y z ((a b c) y z) ((a b c) y z))
\-> \fI(lsubst '(a b c) 'x '(x y z (x y z) (x y z)))\fP
(a b c y z (a b c y z) (a b c y z))
.Ee
.Lf subpair "'l_old 'l_new 'l_expr"
.Wh
there are  the same number of elements in l_old as l_new.
.Re
the list l_expr with all occurrences of a object in l_old replaced by
the corresponding one in l_new.
When a substitution is made, a copy of the value to substitute in 
is not made.
.Ex
\fI(subpair '(a c)' (x y) '(a b c d)) = (x b y d)\fP

.Lf nconc "'l_arg1 'l_arg2 ['l_arg3 ...]"
.Re
A list consisting of the elements of l_arg1 followed by the elements of
l_arg2 followed by l_arg3 and so on.
.No
The 
.i cdr 
of the last list cell of l_arg\fIi\fP is changed to point to 
l_arg\fIi+1\fP.
.Eb 
; \fInconc\fP is faster than \fIappend\fP because it doesn't allocate new list cells. 
\-> \fI(setq lis1 '(a b c))\fP
(a b c)
\-> \fI(setq lis2 '(d e f))\fP
(d e f)
\-> \fI(append lis1 lis2)\fP
(a b c d e f)
\-> \fIlis1\fP
(a b c)       ; note that lis1 has not been changed by \fIappend\fP
\-> \fI(nconc lis1 lis2)\fP
(a b c d e f) ; \fInconc\fP returns the same value as \fIappend\fP
\-> \fIlis1\fP
(a b c d e f) ; but in doing so alters lis1
.Ee

.Lf reverse "'l_arg"
.Lx nreverse "'l_arg"
.Re
the list l_arg with the elements at the top
level in reverse  order.
.No
The function
.i nreverse
does the reversal in place,
that is the list structure is modified.
.Lf nreconc "'l_arg 'g_arg"
.Eq
\fI(nconc (nreverse 'l_arg) 'g_arg)\fP

.sh 2 Predicates
.pp
The following functions test for properties of data objects.  
When the result of the test is either 'false' or 'true', then
\fBnil\fP will be returned for 'false' and something other than
\fBnil\fP (often \fBt\fP) will be returned for 'true'.
.Lf arrayp "'g_arg"
.Re
t iff g_arg is of type array.
.Lf atom "'g_arg"
.Re
t iff g_arg is not a list or hunk object.
.No
\fI(atom '())\fP returns t.
.Lf bcdp "'g_arg"
.Re
t iff g_arg is a data object of type binary.
.No
This function is a throwback to the PDP-11 Lisp system.
The name stands for binary code predicate.
.Lf bigp "'g_arg"
.Re
t iff g_arg is a bignum.
.Lf dtpr "'g_arg"
.Re
t iff g_arg is a list cell.
.No
that (dtpr '()) is nil.
.Lf hunkp "'g_arg"
.Re
t iff g_arg is a hunk.
.Lf listp "'g_arg"
.Re
t iff g_arg is a list object or nil.
.Lf stringp "'g_arg"
.Re
t iff g_arg is a string.
.Lf symbolp "'g_arg"
.Re
t iff g_arg is a symbol.
.Lf valuep "'g_arg"
.Re
t iff g_arg is a value cell
.Lf vectorp 'v_vector
.Re
\fBt\fP iff the argument is a vector.
.Lf vectorip 'v_vector
.Re
\fBt\fP iff the argument is an immediate-vector.
.Lf type "'g_arg"
.Lx typep "'g_arg"
.Re
a symbol whose pname describes the type of g_arg.
.Lf signp "s_test 'g_val"
.Re
t iff g_val is a number  and the given test s_test on g_val returns true.
.No
The fact that 
.i signp
simply returns nil if g_val is not a number is probably the most
important reason that 
.i signp
is used.
The permitted values for s_test and what they mean are given in this table.
.TS
center box;
l l .
s_test	tested

=
l	g_val < 0
le	g_val \(<= 0
e	g_val = 0
n	g_val \(!= 0
ge	g_val \(>= 0
g	g_val > 0
.TE
.Lf eq "'g_arg1 'g_arg2"
.Re
t if g_arg1 and g_arg2 are the exact same lisp object.
.No
.i Eq
simply tests if g_arg1 and g_arg2 are located in the exact same
place in memory.
Lisp objects which print the same are not necessarily 
.i eq .
The only objects guaranteed to be 
.i eq
are interned symbols with the same print name.
[Unless a symbol is created in a special way (such as with
.i uconcat 
or 
.i maknam )
it will be interned.]
.Lf neq "'g_x 'g_y"
.Re
t if g_x is not 
.i eq
to g_y, otherwise nil.
.Lf equal "'g_arg1 'g_arg2"
.Lx eqstr "'g_arg1 'g_arg2"
.Re
t iff g_arg1 and g_arg2 have the same structure as described below.
.No
g_arg and g_arg2 are 
.i equal
if
.np
they are \fIeq\fP.
.np
they are both fixnums with the same value
.np
they are both flonums with the same value
.np
they are both bignums with the same value
.np
they are both strings and are identical.
.np
they are both lists and their cars and cdrs are
.i equal .
.Eb
; \fIeq\fP is much faster than \fIequal\fP, especially in compiled code,
; however you cannot use \fIeq\fP to test for equality of numbers outside
; of the range -1024 to 1023.  \fIequal\fP will always work.
\-> \fI(eq 1023 1023)\fP
t
\-> \fI(eq 1024 1024)\fP
nil
\-> \fI(equal 1024 1024)\fP
t
.Ee

.Lf not "'g_arg"
.Lx null "'g_arg"
.Re
t iff g_arg is nil.

.Lf member "'g_arg1 'l_arg2"
.Lx memq "'g_arg1 'l_arg2"
.Re
that part of the l_arg2 beginning with the first occurrence
of g_arg1.
If g_arg1 is not in the top level of l_arg2, nil is returned.
.No
.i member 
tests for equality with 
.i equal ,
.i memq 
tests for equality with 
.i eq .

.sh 2 Symbols\ and\ Strings
.pp
In many of the following functions the distinction between symbols and
strings is somewhat blurred.
To remind ourselves of the difference,
a string is a null terminated sequence of characters, stored as
compactly as possible.
Strings are used as constants in
.Fr .
They
.i eval
to themselves.
A symbol has additional structure:
a value, property list, function binding,
as well as its external representation (or print-name).
If a symbol is given to one of the string manipulation functions below, its
print name will be used as the string.
.pp
Another popular way to represent strings in Lisp is as a list of fixnums
which represent characters.
The suffix 'n' to a string manipulation function indicates that it 
returns a string in this form.
.sh 3 symbol\ and\ string\ creation
.Lf concat "['stn_arg1 ... ]"
.Lx uconcat "['stn_arg1 ... ]"
.Re
a symbol whose print name
is the result of concatenating the print names,
string characters or numerical representations
of the sn_arg\fIi\fP.
.No
If no arguments are given, a symbol with a null pname is returned.
\fIconcat\fP places the symbol created on the oblist, the function 
.i uconcat
does the same thing but does not place the new symbol on the oblist.
.Ex
\fI(concat 'abc (add 3 4) "def")\fP = abc7def
.Lf concatl "'l_arg"
.Eq
\fI(apply 'concat 'l_arg)\fP

.Lf implode "'l_arg"
.Lx maknam "'l_arg"
.Wh
l_arg is a list of symbols, strings and small fixnums.
.Re
The symbol whose print name is the result of concatenating the 
first characters of the print names of the symbols and strings
in the list.
Any fixnums are converted to the equivalent ascii character.
In order to concatenate entire strings or print names, use the
function
.i concat .
.No
.i implode 
interns the symbol it creates,
.i maknam 
does not.
.Lf gensym "['s_leader]"
.Re
a new uninterned atom beginning with the first character of s_leader's
pname, or beginning with g if s_leader is not given.
.No
The symbol looks like x0nnnnn where x is s_leader's first character and
nnnnn is the number of times you have called gensym.
.Lf copysymbol "'s_arg 'g_pred"
.Re
an uninterned symbol with the same print name as s_arg.
If g_pred is non nil, then the value, function binding
and property list of the new symbol are made 
.i eq 
to those of s_arg.

.Lf ascii "'x_charnum"
.Wh
x_charnum is between 0 and 255.
.Re
a symbol whose print name is the single character whose fixnum 
representation is x_charnum.

.Lf intern "'s_arg"
.Re
s_arg
.Se
s_arg is put on the oblist if it is not already there.
.Lf remob "'s_symbol"
.Re
s_symbol
.Se
s_symbol is removed from the oblist.
.Lf rematom "'s_arg"
.Re
t if s_arg is indeed an atom.
.Se
s_arg is put on the free atoms list, effectively reclaiming an
atom cell.
.No
This function does 
.i not
check to see if s_arg is on the oblist or is referenced anywhere.
Thus calling 
.i rematom
on an atom in the oblist may result in disaster when that atom cell
is reused!
.sh 3 string\ and\ symbol\ predicates
.Lf boundp "'s_name"
.Re
nil  if s_name is unbound: that is, it has never been given a value.
If x_name has the value g_val, then (nil\ .\ g_val) is returned.
See also 
.i makunbound .
.Lf alphalessp "'st_arg1 'st_arg2"
.Re
t iff the `name' of st_arg1 is alphabetically less than the 
name of st_arg2.  
If st_arg is a symbol then its `name' is its print name.
If st_arg is a string, then its `name' is the string itself.
.sh 3 symbol\ and\ string\ accessing
.Lf symeval "'s_arg"
.Re
the value of symbol s_arg.
.No
It is illegal to ask for the value of an unbound symbol.
This function has the same effect as
.i eval ,
but compiles into much more efficient code.
.Lf get_pname "'s_arg"
.Re
the string which is the print name of s_arg.
.Lf plist "'s_arg"
.Re
the property list of s_arg.
.Lf getd "'s_arg"
.Re
the function definition of s_arg or nil if there is no function definition.
.No
the function definition may turn out to be an array header.
.Lf getchar "'s_arg 'x_index"
.Lx nthchar "'s_arg 'x_index"
.Lx getcharn "'s_arg 'x_index"
.Re
the x_index\fIth\fP character of the print name of s_arg or nil if x_index
is less than 1 or greater than the length of s_arg's print name.
.No
.i getchar 
and 
.i nthchar 
return a symbol with a single character print name,
.i getcharn 
returns the fixnum representation of the character.
.Lf substring "'st_string 'x_index ['x_length]"
.Lx substringn "'st_string 'x_index ['x_length]"
.Re
a string of length at most
x_length starting at x_index\fIth\fP character
in the string.
.No
If x_length is not given, all of the characters for x_index
to the end of the string are returned.
If x_index is negative the string begins at the
x_index\fIth\fP character from the end.
If x_index is out of bounds, nil is returned.
.No
.i substring 
returns a list of symbols, 
.i substringn 
returns a list of fixnums.
If 
.i substringn 
is given a 0 x_length argument then a single fixnum 
which is the x_index\fIth\fP character is returned.
.sh 3 symbol\ and\ string\ manipulation
.Lf set "'s_arg1 'g_arg2"
.Re
g_arg2.
.Se
the value of s_arg1 is set to g_arg2.
.Lf setq "s_atm1 'g_val1 [ s_atm2 'g_val2 ... ... ]"
.Wh
the arguments are pairs of atom names and expressions.
.Re
the last g_val\fIi\fP.
.Se
each s_atm\fIi\fP is set to have the value g_val\fIi\fP.
.No
.i set
evaluates all of its arguments,
.i setq
does not evaluate the s_atm\fIi\fP.
.Lf desetq "sl_pattern1 'g_exp1 [... ...]"
.Re
g_expn
.Se
This acts just like \fIsetq\fP if all the sl_pattern\fIi\fP are symbols.
If sl_pattern\fIi\fP is a list then it  is a template which should
have the same structure as g_exp\fIi\fP
The symbols in sl_pattern are assigned to the corresponding 
parts of g_exp.
(See also
.i setf
)
.Ex
\fI(desetq (a b (c . d)) '(1 2 (3 4 5)))\fP
.br
sets a to 1, b to 2, c to 3, and d to (4 5).

.Lf setplist "'s_atm 'l_plist"
.Re
l_plist.
.Se
the property list of s_atm is set to l_plist.
.Lf makunbound "'s_arg"
.Re
s_arg
.Se
the value of s_arg is made `unbound'.
If the interpreter attempts to evaluate s_arg before it is again 
given a value, an unbound variable error will occur.
.Lf aexplode "'s_arg"
.Lx explode  "'g_arg"
.Lx aexplodec "'s_arg"
.Lx explodec "'g_arg"
.Lx aexploden "'s_arg"
.Lx exploden "'g_arg"
.Re
a list of the characters used to print out s_arg or g_arg.
.No
The functions beginning with 'a' are internal functions which are limited
to symbol arguments.  
The functions 
.i aexplode 
and 
.i explode
return a list of characters which 
.i print
would use to print the argument.  
These characters include all necessary escape characters.
Functions 
.i aexplodec 
and
.i explodec
return a list of characters which
.i patom
would use to print the argument (i.e. no escape characters).
Functions 
.i aexploden 
and 
.i exploden
are similar to 
.i aexplodec 
and 
.i explodec 
except that a list of fixnum equivalents of characters are returned.
.Eb
\-> \fI(setq x '|quote this \e| ok?|)\fP
|quote this \e| ok?|
\-> \fI(explode x)\fP
(q u o t e |\e\e| | | t h i s |\e\e| | | |\e\e| |\e|| |\e\e| | | o k ?)
; note that |\e\e| just means the single character: backslash.
; and |\e|| just means the single character: vertical bar
; and | | means the single character: space

\-> \fI(explodec x)\fP
(q u o t e | | t h i s | | |\e|| | | o k ?)
\-> \fI(exploden x)\fP
(113 117 111 116 101 32 116 104 105 115 32 124 32 111 107 63)
.Ee
.sh 2 Vectors
.pp
See Chapter 9 for a discussion of vectors.
They are less efficient that hunks but more efficient than arrays.
.sh 3 vector\ creation
.Lf new-vector "'x_size ['g_fill ['g_prop]]"
.Re
A \fBvector\fP of length x_size.
Each data entry is initialized to g_fill, or to nil, if the argument g_fill
is not present.
The vector's property is set to g_prop, or to nil, by default.
.Lf new-vectori-byte "'x_size ['g_fill ['g_prop]]"
.Lx new-vectori-word "'x_size ['g_fill ['g_prop]]"
.Lx new-vectori-long "'x_size ['g_fill ['g_prop]]"
.Re
A \fBvectori\fP with x_size elements in it.
The actual memory requirement is two long words + x_size*(n bytes),
where n is 1 for new-vector-byte, 2 for new-vector-word, or 4 for
new-vectori-long.
Each data entry is initialized to g_fill, or to zero, if the argument g_fill
is not present.
The vector's property is set to g_prop, or nil, by default.
.sp 2v
.lp
Vectors may be created by specifying multiple initial values:
.Lf vector "['g_val0 'g_val1 ...]"
.Re
a \fBvector\fP, with as many data elements as there are arguments.
It is quite possible to have a vector with no data elements.
The vector's property will be a null list.
.Lf vectori-byte "['x_val0 'x_val2 ...]"
.Lx vectori-word "['x_val0 'x_val2 ...]"
.Lx vectori-long "['x_val0 'x_val2 ...]"
.Re
a \fBvectori\fP, with as many data elements as there are arguments.
The arguments are required to be fixnums.
Only the low order byte or word is used in the case of vectori-byte
and vectori-word.
The vector's property will be null.
.sh 3 vector\ reference
.Lf vref "'v_vect 'x_index"
.Lx vrefi-byte "'V_vect 'x_bindex"
.Lx vrefi-word "'V_vect 'x_windex"
.Lx vrefi-long "'V_vect 'x_lindex"
.Re
the desired data element from a vector.
The indices must be fixnums.
Indexing is zero-based.
The vrefi functions sign extend the data.
.Lf vprop 'Vv_vect
.Re
The Lisp property associated with a vector.
.Lf vget "'Vv_vect 'g_ind"
.Re
The value stored under g_ind if the Lisp property associated
with 'Vv_vect is a disembodied property list.
.Lf vsize 'Vv_vect
.Lx vsize-byte 'V_vect
.Lx vsize-word 'V_vect
.Re
the number of data elements in the vector.  For immediate-vectors,
the functions vsize-byte and vsize-word return the number of data elements,
if one thinks of the binary data as being comprised of bytes or words.
.sh 3 vector\ modfication
.Lf vset "'v_vect 'x_index 'g_val"
.Lx vseti-byte "'V_vect 'x_bindex 'x_val"
.Lx vseti-word "'V_vect 'x_windex 'x_val"
.Lx vseti-long "'V_vect 'x_lindex 'x_val"
.Re
the datum.
.Se
The indexed element of the vector is set to the value.
As noted above, for vseti-word and vseti-byte, the index
is construed as the number of the data element within
the vector.  It is not a byte address.
Also, for those two functions,
the low order byte or word of x_val is what is stored.
.Lf vsetprop "'Vv_vect 'g_value"
.Re
g_value.  This should be either a symbol
or a disembodied property list whose
.i car
is a symbol identifying the type of
the vector.
.Se
the property list of Vv_vect is set to g_value.
.Lf vputprop "'Vv_vect 'g_value 'g_ind"
.Re
g_value.
.Se
If the vector property of Vv_vect is a disembodied property list,
then vputprop adds the value g_value under the indicator g_ind.
Otherwise, the old vector property is made the first
element of the list.
.sh 2 Arrays
.pp
See Chapter 9 for a complete description of arrays.
Some of these functions are part of a Maclisp array
compatibility package representing only one simple way of using the
array structure of
.Fr .
.sh 3 array\ creation
.Lf marray  "'g_data 's_access 'g_aux 'x_length 'x_delta"
.Re
an array type with the fields set up from the above arguments
in the obvious way (see \(sc 1.2.10).
.Lf *array "'s_name 's_type 'x_dim1 ... 'x_dim\fIn\fP"
.Lx array "s_name s_type x_dim1 ... x_dim\fIn\fP"
.Wh
s_type may be one of t, nil, fixnum, flonum, fixnum-block and 
flonum-block.
.Re
an array of type s_type with n dimensions of extents given by the 
x_dim\fIi\fP.
.Se
If s_name is non nil, the function definition of s_name is
set to the array structure returned.
.No
These 
functions create a Maclisp compatible array.
In 
.Fr
arrays of type t, nil, fixnum and flonum are equivalent and the elements
of these arrays can be any type of lisp object.
Fixnum-block and flonum-block arrays are restricted to fixnums and flonums
respectively and are used mainly to communicate with 
foreign functions (see \(sc8.5).
.No
.i *array 
evaluates its arguments, 
.i array
does not.
.sh 3 array\ predicate
.Lf arrayp "'g_arg"
.Re
t iff g_arg is of type array.
.sh 3 array\ accessors

.Lf getaccess "'a_array"
.Lx getaux "'a_array"
.Lx getdelta "'a_array"
.Lx getdata "'a_array"
.Lx getlength "'a_array"
.Re
the field of the array object a_array given by the function name.
.Lf arrayref "'a_name 'x_ind"
.Re
the x_ind\fIth\fP element of the array object a_name.
x_ind of zero accesses the first element.
.No
.i arrayref
uses the data, length and delta fields of a_name to determine which
object to return.
.Lf arraycall "s_type 'as_array 'x_ind1 ... "
.Re
the element selected by  the indices from the array a_array
of type s_type.
.No
If as_array is a symbol then the function binding of this symbol should
contain an array object.
.br
s_type is ignored by
.i arraycall
but is included for compatibility with Maclisp.
.Lf arraydims "'s_name"
.Re
a list of the type and bounds of the array s_name.
.Lf listarray "'sa_array ['x_elements]"
.Re
a list of all of the elements in array sa_array.
If x_elements
is given, then only the first x_elements are returned.

.Eb
; We will create a 3 by 4 array of general lisp objects
\-> \fI(array ernie t 3 4)\fP
array[12]

; the array header is stored in the function definition slot of the
; symbol ernie
\-> \fI(arrayp (getd 'ernie))\fP
t
\-> \fI(arraydims (getd 'ernie))\fP
(t 3 4)

; store in ernie[2][2] the list (test list)
\-> \fI(store (ernie 2 2) '(test list))\fP
(test list)

; check to see if it is there
\-> \fI(ernie 2 2)\fP
(test list)

; now use the low level function \fIarrayref\fP to find the same element
; arrays are 0 based and row-major (the last subscript varies the fastest)
; thus element [2][2] is the 10th element , (starting at 0).
\-> \fI(arrayref (getd 'ernie) 10)\fP
(ptr to)(test list)    ; the result is a value cell (thus the (ptr to))
.Ee
.sh 3 array\ manipulation
.Lf putaccess "'a_array 'su_func"
.Lx putaux "'a_array 'g_aux"
.Lx putdata "'a_array 'g_arg"
.Lx putdelta "'a_array 'x_delta"
.Lx putlength "'a_array 'x_length"
.Re
the second argument to the function.
.Se
The field of the array object given by the function name is replaced
by the second argument to the function.
.Lf store "'l_arexp 'g_val"
.Wh
l_arexp is an expression
which references an array element.
.Re
g_val
.Se
the array location which contains the element which l_arexp references is 
changed to contain g_val.
.Lf fillarray "'s_array 'l_itms"
.Re
s_array
.Se
the array s_array is filled with elements from l_itms.
If there are not enough elements in l_itms to fill the entire array,
then the last element of l_itms is used to fill the remaining parts
of the array.
.sh 2 Hunks
.pp
Hunks are vector-like objects whose size can range from 1 to 128 elements.
Internally, hunks are allocated in sizes which are powers of 2.
In order to create hunks of a given size, 
a hunk with at least that many elements is allocated
and a distinguished symbol \s-2EMPTY\s0 is placed in those 
elements not requested.
Most hunk functions respect those distinguished symbols, but there are
two 
.i (*makhunk
and
.i *rplacx )
which will overwrite the distinguished symbol.
.sh 3 hunk\ creation
.Lf hunk "'g_val1 ['g_val2 ... 'g_val\fIn\fP]"
.Re
a hunk of length n whose elements are initialized to the g_val\fIi\fP.
.No
the maximum size of a hunk is 128.
.Ex
\fI(hunk 4 'sharp 'keys)\fP = {4 sharp keys}
.Lf makhunk "'xl_arg"
.Re
a hunk of length xl_arg initialized to all nils if xl_arg is a fixnum.
If xl_arg is a list, then we return a hunk of size \fI(length\ 'xl_arg)\fP
initialized to the elements in xl_arg.
.No
\fI(makhunk\ '(a\ b\ c))\fP is equivalent to \fI(hunk\ 'a\ 'b\ 'c)\fP.
.Ex
\fI(makhunk 4)\fP = \fI{nil nil nil nil}\fP
.Lf *makhunk "'x_arg"
.Re
a hunk of size 2\*[x_arg\*] initialized to \s-2EMPTY\s0.
.No
This is only to be used by such functions as \fIhunk\fP and \fImakhunk\fP
which create and initialize hunks for users.
.sh 3 hunk\ accessor
.Lf cxr "'x_ind 'h_hunk"
.Re
element x_ind (starting at 0) of hunk h_hunk.
.Lf hunk-to-list 'h_hunk
.Re
a list consisting of the elements of h_hunk.
.sh 3 hunk\ manipulators
.Lf rplacx "'x_ind 'h_hunk 'g_val"
.Lx *rplacx "'x_ind 'h_hunk 'g_val"
.Re
h_hunk
.Se
Element x_ind (starting at 0) of h_hunk is set to g_val.
.No
.i rplacx 
will not modify one of the distinguished (EMPTY) elements
whereas
.i *rplacx 
will.
.Lf hunksize "'h_arg"
.Re
the size of the hunk h_arg.
.Ex
\fI(hunksize (hunk 1 2 3))\fP = 3
.sh 2 Bcds
.pp
A bcd object contains a pointer to compiled code and to the type of 
function object the compiled code represents.
.Lf getdisc "'y_bcd"
.Lx getentry "'y_bcd"
.Re
the field of the bcd object given by the function name. 
.Lf putdisc "'y_func 's_discipline"
.Re
s_discipline
.Se
Sets the discipline field of y_func to s_discipline.
.sh 2 Structures
.pp
There are three common structures constructed out of list cells: the
assoc list, the property list and the tconc list.
The functions below manipulate these structures.
.sh 3 assoc\ list
.pp
An `assoc list' (or alist) is a common lisp data structure.  It has the
form 
.br
.ce 1
((key1 . value1) (key2 . value2) (key3 . value3) ... (keyn . valuen))
.Lf assoc "'g_arg1 'l_arg2"
.Lx assq "'g_arg1 'l_arg2"
.Re
the first top level element of l_arg2 whose
.i car
is 
.i equal
(with 
.i assoc )
or
.i eq
(with 
.i assq )
to g_arg1.
.No
Usually l_arg2 has an
.i a-list
structure and g_arg1 acts as key.
.Lf sassoc "'g_arg1 'l_arg2 'sl_func"
.Re 
the result of \fI(cond\ ((assoc\ 'g_arg\ 'l_arg2)\ (apply\ 'sl_func\ nil)))\fP
.No
sassoc is written as a macro.
.Lf sassq "'g_arg1 'l_arg2 'sl_func"
.Re 
the result of \fI(cond\ ((assq\ 'g_arg\ 'l_arg2)\ (apply\ 'sl_func\ nil)))\fP
.No
sassq is written as a macro.

.Eb
; \fIassoc\fP or \fIassq\fP is given a key and an assoc list and returns
; the key and value item if it exists, they differ only in how they test
; for equality of the keys.

\-> \fI(setq alist '((alpha . a) ( (complex key) . b) (junk . x)))\fP
((alpha . a) ((complex key) . b) (junk . x))

; we should use \fIassq\fP when the key is an atom
\-> \fI(assq 'alpha alist)\fP
(alpha . a)

; but it may not work when the key is a list
\-> \fI(assq '(complex key) alist)\fP
nil

; however \fIassoc\fP will always work
\-> \fI(assoc '(complex key) alist)\fP
((complex key) . b)
.Ee
.Lf sublis "'l_alst 'l_exp"
.Wh
l_alst is an 
.i a-list .
.Re
the list l_exp with every occurrence of key\fIi\fP replaced by val\fIi\fP.
.No
new list structure is returned to prevent modification of l_exp.
When a substitution is made, a copy of the value to substitute in 
is not made.
.sh 3 property\ list
.pp
A property list consists of an alternating sequence of keys and
values.  Normally a property list is stored on a symbol. A list
is a 'disembodied' property list if it contains an odd number of
elements, the first of which is ignored.
.Lf plist "'s_name"
.Re
the property list of s_name.
.Lf setplist "'s_atm 'l_plist"
.Re
l_plist.
.Se
the property list of s_atm is set to l_plist.

.Lf get "'ls_name 'g_ind"
.Re
the value under indicator g_ind in ls_name's property list if ls_name
is a symbol.
.No
If there is no indicator g_ind in ls_name's property list nil is returned.
If ls_name is a list of an odd number of elements then it is a disembodied
property list. 
\fIget\fP searches a disembodied property list by starting at its 
\fIcdr\fP, and comparing every other element with g_ind, using 
\fIeq\fP.
.Lf getl "'ls_name 'l_indicators"
.Re
the property list ls_name beginning at the first indicator which is
a member of the list l_indicators, or nil if none of the indicators
in l_indicators are on ls_name's property list.
.No
If ls_name is a list, then it is assumed to be a disembodied property
list.

.Lf putprop "'ls_name 'g_val 'g_ind"
.Lx defprop "ls_name g_val g_ind"
.Re
g_val.
.Se
Adds to the property list of ls_name the value g_val under the indicator
g_ind.
.No
.i putprop
evaluates it arguments, 
.i defprop
does not.
ls_name may be a disembodied property list, see \fIget\fP.
.Lf remprop "'ls_name 'g_ind"
.Re
the portion of  ls_name's property list beginning with the 
property under the indicator g_ind.
If there is no g_ind indicator in ls_name's plist, nil is returned.
.Se
the value under indicator g_ind and g_ind itself is removed from 
the property list of ls_name.
.No
ls_name may be a disembodied property list, see \fIget\fP.

.Eb
\-> \fI(putprop 'xlate 'a 'alpha)\fP
a
\-> \fI(putprop 'xlate 'b 'beta)\fP
b
\-> \fI(plist 'xlate)\fP
(alpha a beta b)
\-> \fI(get 'xlate 'alpha)\fP
a
; use of a disembodied property list:
\-> \fI(get '(nil fateman rjf sklower kls foderaro jkf) 'sklower)\fP
kls
.Ee
.sh 3 tconc\ structure
.pp
A tconc structure is a special type of list designed to make it
easy to add objects to the end.
It consists of a list cell whose 
.i car
points to a 
list of the elements added with 
.i tconc
or 
.i lconc
and whose
.i cdr
points to the last list cell of the list pointed to by the 
.i car.
.Lf tconc "'l_ptr 'g_x"
.Wh
l_ptr is a tconc structure.
.Re
l_ptr with g_x added to the end.
.Lf lconc "'l_ptr 'l_x"
.Wh
l_ptr is a tconc structure.
.Re
l_ptr with the list l_x spliced in at the end.
.Eb
; A \fItconc\fP structure can be initialized in two  ways.  
; nil can be given to \fItconc\fP in which case \fItconc\fP will generate 
; a \fItconc\fP structure.

\->\fI(setq foo (tconc nil 1))\fP
((1) 1)

; Since \fItconc\fP destructively adds to 
; the list, you can now add to foo without using \fIsetq\fP again.

\->\fI(tconc foo 2)\fP
((1 2) 2)
\->\fIfoo\fP
((1 2) 2)

; Another way to create a null  \fItconc\fP structure
; is to use \fI(ncons\ nil)\fP.

\->\fI(setq foo (ncons nil))\fP
(nil)
\->\fI(tconc foo 1)\fP
((1) 1)

; now see what \fIlconc\fP can do
\-> \fI(lconc foo nil)\fP
((1) 1)			; no change
\-> \fI(lconc foo '(2 3 4))\fP
((1 2 3 4) 4)
.Ee
.sh 3 fclosures
.pp
An fclosure is a functional object which admits some data
manipulations.  They are discussed in \(sc8.4.
Internally, they are constructed from vectors.
.Lf fclosure "'l_vars 'g_funobj"
.Wh
l_vars is a list of variables, g_funobj is any object
that can be funcalled (including, fclosures).
.Re
A vector which is the fclosure.
.Lf fclosure-alist "'v_fclosure"
.Re
An association list representing the variables in the fclosure.
This is a snapshot of the current state of the fclosure.
If the bindings in the fclosure are changed, any previously
calculated results of
.i fclosure-alist
will not change.
.Lf fclosure-function "'v_fclosure"
.Re
the functional object part of the fclosure.
.Lf fclosurep "'v_fclosure"
.Re
t iff the argument is an fclosure.
.Lf symeval-in-fclosure "'v_fclosure 's_symbol"
.Re
the current binding of a particular symbol in an fclosure.
.Lf set-in-fclosure "'v_fclosure 's_symbol 'g_newvalue"
.Re
g_newvalue.
.Se
The variable s_symbol is bound in the fclosure to g_newvalue.
.sh 2 Random\ functions
.pp
The following functions don't fall into any of the classifications above.
.Lf bcdad "'s_funcname"
.Re
a fixnum which is the address in memory where the function 
s_funcname begins.
If s_funcname is not a machine coded function (binary) then 
.i bcdad 
returns nil.
.Lf copy "'g_arg"
.Re
A structure 
.i equal
to g_arg but with new list cells.
.Lf copyint* "'x_arg"
.Re
a fixnum with the same value as x_arg but in a freshly allocated cell.
.Lf cpy1 "'xvt_arg"
.Re
a new cell of the same type as xvt_arg with the same value as xvt_arg.
.Lf getaddress "'s_entry1 's_binder1 'st_discipline1 [... ... ...]"
.Re
the binary object which s_binder1's  function field is set to.
.No
This looks in the running lisp's symbol table for a symbol with the same
name as s_entry\fIi\fP.
It then creates a binary object
whose entry field points to s_entry\fIi\fP 
and whose discipline is st_discipline\fIi\fP.
This binary object is stored in the function field of s_binder\fIi\fP.
If st_discipline\fIi\fP is nil, then "subroutine" is used by default.
This is especially useful for 
.i cfasl
users.
.Lf macroexpand "'g_form"
.Re
g_form after all macros in it are
expanded.
.No
This function will only macroexpand 
expressions which could be evaluated
and it does not know about the special nlambdas such as 
.i cond
and
.i do ,
thus it misses many macro expansions.
.Lf ptr "'g_arg"
.Re
a value cell initialized to point to g_arg.
.Lf quote "g_arg"
.Re
g_arg.
.No
the reader allows you to abbreviate (quote foo) as 'foo.
.Lf kwote "'g_arg"
.Re
 \fI(list (quote quote) g_arg)\fP.
.Lf replace "'g_arg1 'g_arg2"
.Wh
g_arg1 and g_arg2 must be the same type of lispval and not symbols or hunks.
.Re
g_arg2.
.Se
The effect of
.i replace 
is dependent on the type of the g_arg\fIi\fP although one will notice 
a similarity in the effects.
To understand what 
.i replace
does to fixnum and flonum arguments,
you must first understand that 
such numbers are `boxed' in 
.Fr .
What this means is that if the symbol x has a value 32412, then in
memory the value element of x's symbol structure contains the address of
another word of memory (called a box) with 32412 in it.
.br
.sp
Thus, there are two ways of changing the value of x:
the first is to change
the value element of x's symbol structure to point to a word of memory
with a different value.
The second way is to change the value in the box which x points to.
The former method is used almost all of the time, the latter is
used very rarely and has the potential to cause great confusion.
The function
.i replace
allows you to do the latter, i.e., to actually change the value in
the box.
.br
.sp
You should watch out for these situations.
If you do \fI(setq\ y\ x)\fP,
then both x and y will point to the same box.
If you now \fI(replace\ x\ 12345)\fP,
then y will also have the value 12345.
And, in fact, there may be many other pointers to that box.
.br
.sp
Another problem with replacing fixnums
is that some boxes are read-only.
The fixnums between -1024 and 1023 are stored in a read-only area
and attempts to replace them will result in an "Illegal memory reference"
error (see the description of 
.i copyint*
for a way around this problem).
.br
.sp
For the other valid types, the effect of 
.i replace 
is easy to understand.
The fields of g_val1's structure are made eq to the corresponding fields of
g_val2's structure.
For example, if x  and  y have lists as values then the effect of
\fI(replace\ x\ y)\fP is the same as 
\fI(rplaca\ x\ (car\ y))\fP and \fI(rplacd\ x\ (cdr\ y))\fP.
.Lf scons "'x_arg 'bs_rest"
.Wh
bs_rest is a bignum or nil.
.Re
a bignum whose first bigit is x_arg 
and whose higher order bigits are bs_rest.
.Lf setf "g_refexpr 'g_value"
.No
.i setf
is a generalization of setq.  Information may be stored by
binding variables, replacing entries of arrays, and vectors,
or being put on property lists, among others.
Setf will allow the user to store data into some location,
by mentioning the operation used to refer to the location.
Thus, the first argument may be partially evaluated, but only
to the extent needed to calculate a reference.
.i setf
returns g_value.
(Compare to
.i desetq
)
.Eb
  (setf x 3)        =  (setq x 3)
  (setf (car x) 3)  = (rplaca x 3)
  (setf (get foo 'bar) 3) = (putprop foo 3 'bar)
  (setf (vref vector index) value) = (vset vector index value)
.Ee
.Lf sort "'l_data 'u_comparefn"
.Re
a list of the elements of l_data ordered by the comparison
function u_comparefn.
.Se
the list l_data is modified rather than allocated in new storage.
.No
\fI(comparefn 'g_x 'g_y)\fP should return something
non-nil if g_x can precede g_y in sorted order; nil if g_y must precede
g_x.  
If u_comparefn is nil, 
alphabetical order will be used.
.Lf sortcar "'l_list 'u_comparefn"
.Re
a list of the elements of l_list with the 
.i car 's
ordered by the sort function u_comparefn.
.Se
the list l_list is modified rather than copied.
.No
Like \fIsort\fP, 
if u_comparefn is nil, 
alphabetical order will be used.
EndOfFile
cat >  doc/ch3.n  << 'EndOfFile'
." $Header: ch3.n,v 1.3 83/06/21 13:00:48 sklower Exp $
.Lc Arithmetic\ Functions 3
.pp
This chapter describes 
.Fr "'s"
functions for doing arithmetic.
Often the same function is known by many names.
For example,
.i add
is also
.i plus ,
and
.i sum .
This is caused by our desire to be compatible with other Lisps.
The 
.Fr
user should avoid using functions with names
such as \(pl and \(** unless
their arguments are fixnums.
The Lisp compiler takes advantage of these implicit declarations.
.pp
An attempt to divide or to generate a floating
point result outside of the range of
floating point numbers
will cause a floating exception signal
from the UNIX operating system.
The user can catch and process this interrupt if desired (see the 
description of the
.i signal
function).
.sh 2 Simple\ Arithmetic\ Functions \n(ch 1
.Lf add "['n_arg1 ...]"
.Lx plus "['n_arg1 ...]"
.Lx sum "['n_arg1 ...]"
.Lx \(pl "['x_arg1 ...]"
.Re
the sum of the arguments. If no arguments are given, 0 is returned.
.No
if the size of the partial sum exceeds the limit of a fixnum, the
partial sum will be converted to a bignum.
If any of the arguments are flonums, the partial sum will be 
converted to a flonum when that argument is processed and the 
result will thus be a flonum.
Currently, if in the process of doing the 
addition a bignum must be converted into
a flonum an error message will result.
.Lf add1 'n_arg
.Lx 1+ 'x_arg
.Re
its argument plus 1.
.Lf diff "['n_arg1 ... ]"
.Lx difference "['n_arg1 ... ]"
.Lx \(mi  "['x_arg1 ... ]"
.Re
the result of subtracting from n_arg1 all subsequent arguments. 
If no arguments are given, 0 is returned.
.No
See the description of add for details on data type conversions and
restrictions.
.Lf sub1 "'n_arg"
.Lx 1\(mi "'x_arg"
.Re
its argument minus 1.
.Lf minus "'n_arg"
.Re
zero minus n_arg.
.Lf product "['n_arg1 ... ]"
.Lx times "['n_arg1 ... ]"
.Lx \(** "['x_arg1 ... ]"
.Re
the product of all of its arguments.
It returns 1 if there are no arguments.
.No
See the description of the function \fIadd\fP for details and restrictions to the
automatic data type coercion.
.Lf quotient "['n_arg1 ...]"
.Lx / "['x_arg1 ...]"
.Re
the result of dividing the first argument by succeeding ones.
.No
If there are no arguments, 1 is returned.
See the description of the function \fIadd\fP for details and restrictions
of data type coercion.
A divide by zero will cause a floating exception interrupt -- see 
the description of the
.i signal 
function.
.Lf *quo "'i_x 'i_y"
.Re
the integer part of i_x / i_y.
.Lf Divide "'i_dividend 'i_divisor"
.Re
a list whose car is the quotient and whose cadr is the remainder of the
division of i_dividend by i_divisor.
.No
this is restricted to integer division.
.Lf Emuldiv "'x_fact1 'x_fact2 'x_addn 'x_divisor"
.Re
a list of the quotient and remainder of this operation: 
((x_fact1\ *\ x_fact2)\ +\ (sign\ extended)\ x_addn)\ /\ x_divisor.
.No
this is useful for creating a bignum arithmetic package in Lisp.
.sh 2 predicates
.Lf numberp "'g_arg"
.Lf numbp "'g_arg"
.Re
t iff g_arg is a number (fixnum, flonum or bignum).
.Lf fixp "'g_arg"
.Re
t iff g_arg is a fixnum or bignum.
.Lf floatp "'g_arg"
.Re
t iff g_arg is a flonum.
.Lf evenp "'x_arg"
.Re
t iff x_arg is even.
.Lf oddp "'x_arg"
.Re
t iff x_arg is odd.
.Lf zerop "'g_arg"
.Re
t iff g_arg is a number equal to 0.
.Lf onep "'g_arg"
.Re
t iff g_arg is a number equal to 1.
.Lf plusp "'n_arg"
.Re
t iff n_arg is greater than zero.
.Lf minusp "'g_arg"
.Re
t iff g_arg is a negative number.
.Lf greaterp "['n_arg1 ...]"
.Lx > "'fx_arg1 'fx_arg2"
.Lx >& "'x_arg1 'x_arg2"
.Re
t iff the arguments are in a strictly decreasing order.
.No
In functions
.i greaterp
and
.i >
the function 
.i difference 
is used to compare adjacent values. 
If any of the arguments are non-numbers, the error message will come 
from the 
.i difference 
function.
The arguments to 
.i >
must  be fixnums or both flonums.
The arguments to
.i >&
must both be fixnums.
.Lf lessp "['n_arg1 ...]"
.Lx < "'fx_arg1 'fx_arg2"
.Lx <& "'x_arg1 'x_arg2"
.Re
t iff the arguments are in a strictly increasing order.
.No
In functions
.i lessp
and
.i <
the function \fIdifference\fP is used to compare adjacent values. 
If any of the arguments are non numbers, the error message will come 
from the \fIdifference\fP function.
The arguments to 
.i < 
may be either fixnums or flonums but must be the same type.
The arguments to
.i <&
must be fixnums.
.Lf \(eq "'fx_arg1 'fx_arg2"
.Lf \(eq& "'x_arg1 'x_arg2"
.Re
t iff the arguments have the same value.
The arguments to \(eq must be the either both fixnums or both flonums.
The arguments to \(eq& must be fixnums.
.sh 2 Trignometric\ Functions 
.pp
Some of these funtcions are taken from the host math library, and
we take no further responsibility for their accuracy.
.Lf cos "'fx_angle"
.Re
the (flonum) cosine of fx_angle (which is assumed to be in radians).
.Lf sin "'fx_angle"
.Re
the sine of fx_angle (which is assumed to be in radians).
.Lf acos "'fx_arg"
.Re
the (flonum) arc cosine of fx_arg in the range 0 to \(*p.
.Lf asin "'fx_arg"
.Re
the (flonum) arc sine of fx_arg in the range \(mi\(*p/2 to \(*p/2.
.Lf atan "'fx_arg1 'fx_arg2"
.Re
the (flonum) arc tangent of fx_arg1/fx_arg2 in the range -\(*p to \(*p.
.sh 2 Bignum/Fixnum\ Manipulation
.Lf haipart "bx_number x_bits"
.Re
a fixnum (or bignum) which contains
the x_bits high bits of
\fI(abs\ bx_number)\fP if x_bits is positive, otherwise
it returns the \fI(abs\ x_bits)\fP low bits of \fI(abs\ bx_number)\fP.
.Lf haulong "bx_number"
.Re
the number of significant bits in bx_number.
.No
the result is equal to the least integer greater to or equal to the
base two logarithm of
one plus the absolute value of bx_number.
.Lf bignum-leftshift "bx_arg x_amount"
.Re
bx_arg shifted left by x_amount.  If
x_amount is negative, bx_arg will be shifted right by the magnitude of
x_amount.
.No
If bx_arg is shifted right, it will be rounded to the nearest even number.
.Lf sticky-bignum-leftshift "'bx_arg 'x_amount"
.Re
bx_arg shifted left by x_amount.  If
x_amount is negative, bx_arg will be shifted right by the magnitude of
x_amount and rounded.
.No
sticky rounding is done this way: after shifting,
the low order bit is changed to 1
if any 1's were shifted off to the right.
.sh 2 Bit\ Manipulation
.Lf boole "'x_key 'x_v1 'x_v2 ..."
.Re
the result of the bitwise boolean operation as described in the following
table.
.No
If there are more than 3 arguments, then evaluation proceeds left to
right with each partial result becoming the new value of x_v1.
That is, 
.br
\ \ \ \ \ \fI(boole\ 'key\ 'v1\ 'v2\ 'v3)\ \(==\ (boole\ 'key\ (boole\ 'key\ 'v1\ 'v2)\ 'v3)\fP.
.br
In the following table, \(** represents bitwise and, \(pl represents
bitwise or, \o'\(ci\(pl' represents bitwise xor and \(no represents
bitwise negation and is the highest precedence operator.
.ps 8
.TS
center box ;
c s s s s s s s s
c c c c c c c c c.
(boole 'key 'x 'y)

=
key	0	1	2	3	4	5	6	7
result	0	x \(** y	\(no x \(** y	y	x \(** \(no y	x	x \o'\(ci\(pl' y	x \(pl y

common
names		and			bitclear		xor	or	

_

key	8	9	10	11	12	13	14	15
result	\(no (x \(pl y)	\(no(x \o'\(ci\(pl' y)	\(no x	\(no x \(pl y	\(no y	x \(pl \(no y	\(no x \(pl \(no y	-1
common
names	nor	equiv		implies			nand
.TE
.ps 10
.pp
.Lf lsh "'x_val 'x_amt"
.Re
x_val shifted left by x_amt if x_amt is positive.
If x_amt is negative, then 
.i lsh
returns x_val shifted right by the magnitude if x_amt.
.No
This always returns a fixnum even for those numbers whose magnitude is
so large that they would normally be represented as a bignum,
i.e. shifter bits are lost.
For more general bit shifters, see
.i bignum-leftshift
and
.i sticky-bignum-leftshift.
.Lf rot "'x_val 'x_amt"
.Re
x_val rotated left by x_amt if x_amt is positive. 
If x_amt is negative, then x_val is rotated right by the magnitude of x_amt.
.sh 2 Other\ Functions
.pp
As noted above, some of the following functions are inherited from the
host math library, with all their virtues and vices.
.Lf abs 'n_arg
.Lx absval 'n_arg
.Re
the absolute value of n_arg.
.Lf exp "'fx_arg"
.Re
.i e
raised to the fx_arg power (flonum) .
.Lf expt "'n_base 'n_power"
.Re
n_base raised to the n_power power.
.No
if either of the arguments are flonums, the calculation will be done using
.i log
and 
.i exp .
.Lf fact "'x_arg"
.Re
x_arg factorial. (fixnum or bignum)
.Lf fix "'n_arg"
.Re
a fixnum as close as we can get to n_arg.
.No
\fIfix\fP will round down.
Currently, if n_arg is a flonum larger 
than the size of a fixnum, this will fail.
.Lf float "'n_arg"
.Re
a flonum as close as we can get to n_arg.
.No
if n_arg is a bignum larger than the maximum size of a flonum,
then a floating exception will occur.
.Lf log "'fx_arg"
.Re
the natural logarithm of fx_arg.
.Lf max "'n_arg1 ... "
.Re
the maximum value in the list of arguments.
.Lf min "'n_arg1 ... "
.Re
the minimum value in the list of arguments.
.Lf mod "'i_dividend 'i_divisor"
.Lx remainder "'i_dividend 'i_divisor"
.Re
the remainder when i_dividend is divided by i_divisor.
.No
The sign of the result will have the same sign as i_dividend.
.Lf *mod "'x_dividend 'x_divisor"
.Re
the balanced representation of x_dividend modulo x_divisor.
.No
the range of the balanced representation is abs(x_divisor)/2 to 
(abs(x_divisor)/2) \(mi x_divisor + 1.
.Lf random "['x_limit]"
.Re
a fixnum between 0 and x_limit \(mi 1 if x_limit is given.
If x_limit is not given, any fixnum, positive or negative, might be
returned.
.Lf sqrt "'fx_arg"
.Re
the square root of fx_arg.
EndOfFile
cat >  doc/ch4.n  << 'EndOfFile'
." $Header: ch4.n,v 1.4 83/07/27 15:11:44 layer Exp $
.pp
.Lc Special\ Functions 4
.Lf and "[g_arg1 ...]"
.Re
the value of the last argument if all arguments evaluate
to a non-nil value, otherwise 
.i and 
returns nil.
It returns t if there are no arguments.
.No
the arguments are evaluated left to right and evaluation will cease
with the first nil encountered.
.Lf apply "'u_func 'l_args"
.Re
the result of applying function u_func to the arguments in the list l_args.
.No
If u_func is a lambda, then the \fI(length\ l_args)\fP should equal the
number of formal parameters for the u_func.
If u_func is a nlambda or macro, then l_args is bound to the single
formal parameter.
.Eb
; \fIadd1\fP is a lambda of 1 argument
\-> \fI(apply 'add1 '(3))\fP
4

; we will define \fIplus1\fP as a macro which will be equivalent to \fIadd1\fP
\-> \fI(def plus1 (macro (arg) (list 'add1 (cadr arg))))\fP
plus1
\-> \fI(plus1 3)\fP
4

; now if we \fIapply\fP a macro we obtain the form it changes to.
\-> \fI(apply 'plus1 '(plus1 3))\fP
(add1 3)

; if we \fIfuncall\fP a macro however, the result of the macro is \fIeval\fPed
; before it is returned.
\-> \fI(funcall 'plus1 '(plus1 3))\fP
4

; for this particular macro, the \fIcar\fP of the \fIarg\fP is not checked
; so that this too will work
\-> \fI(apply 'plus1 '(foo 3))\fP
(add1 3)

.Ee
.Lf arg "['x_numb]"
.Re 
if x_numb is specified then the x_numb'\fIth\fP argument to 
the enclosing lexpr
If x_numb is not specified then this returns the number of arguments 
to the enclosing lexpr.
.No
it is an error to the interpreter if x_numb is given and out of range.
.Lf break "[g_message ['g_pred]]"
.Wh
if g_message is not given it is assumed to be the null string, and
if g_pred is not given it is assumed to be t.
.Re
the value of \fI(*break 'g_pred 'g_message)\fP
.Lf *break "'g_pred 'g_message"
.Re
nil immediately if g_pred is nil, else
the value of the next (return 'value) expression typed in at top level.
.Se
If the predicate, g_pred, evaluates to non-null,
the lisp system stops and prints out `Break '
followed by g_message. 
It then enters a break loop
which allows one to interactively debug a program.
To continue execution from a break you can use the
.i return 
function. 
to return to top level or another break level, you can use
.i retbrk 
or 
.i reset .
.Lf caseq "'g_key-form l_clause1 ..."
.Wh 
l_clause\fIi\fP is a list of the form
(g_comparator ['g_form\fIi\fP ...]).
The comparators may be symbols, small fixnums, a list of small fixnums or
symbols.
.No
The way caseq works is that it evaluates g_key-form,
yielding a value we will call the selector.
Each clause is examined until the selector is found
consistent with the comparator.
For a symbol, or a fixnum, this means the two must be \fIeq\fP.
For a list, this means that the selector must be \fIeq\fP to
some element of the list.
.br
.sp
The comparator consisting of the symbol \fBt\fP has special semantics:
it matches anything, and consequently, should be the last comparator.
.br
.sp
In any case, having chosen a clause, \fIcaseq\fP evaluates each form
within that clause and
.Re
the value of the last form.  If no comparators are matched,
\fIcaseq\fP returns nil.
.Eb
Here are two ways of defining the same function:
\->\fI(defun fate (personna)
	(caseq personna
	  (cow '(jumped over the moon))
	  (cat '(played nero))
	  ((dish spoon) '(ran away with each other))
	  (t '(lived happily ever after))))\fP
fate
\->\fI(defun fate (personna)
	(cond
		((eq personna 'cow) '(jumped over the moon))
		((eq personna 'cat) '(played nero))
		((memq personna '(dish spoon)) '(ran away with each other))
		(t '(lived happily ever after))))\fP
fate
.Ee
.Lf catch "g_exp [ls_tag]"
.Wh
if ls_tag is not given, it is assumed to be nil.
.Re
the result of \fI(*catch 'ls_tag g_exp)\fP
.No
catch is defined as a macro.
.Lf *catch "'ls_tag g_exp"
.Wh
ls_tag is either a symbol or a list of symbols.
.Re
the result of evaluating g_exp or the value thrown during the evaluation
of g_exp.
.Se
this first sets up a `catch frame' on the lisp runtime stack.
Then it begins to evaluate g_exp.
If g_exp evaluates normally, its value is returned.
If, however, a value is thrown during the evaluation of g_exp then
this *catch will return with that value if one of these cases
is true:
.nr $p 0
.np
the tag thrown to is ls_tag 
.np
ls_tag is a list and the tag thrown to is a member of this list
.np
ls_tag is nil.
.No
Errors are implemented as a special kind of throw.
A catch with no tag will not catch an error but a catch whose tag is
the error type will catch that type of error.
See Chapter 10 for more information.
.Lf comment "[g_arg ...]"
.Re
the symbol comment.
.No
This does absolutely nothing.
.Lf cond "[l_clause1 ...]"
.Re
the last value evaluated in the first clause satisfied.
If no clauses are satisfied then nil is returned.
.No
This is the basic conditional `statement' in lisp.
The clauses are processed from left to right.
The first element of a clause is evaluated.
If it evaluated to a non-null value then that clause is satisfied and
all following elements of that clause are evaluated.
The last value computed is returned as the value of the cond.
If there is just one element in the clause then its value is returned.
If the first element of a clause evaluates to nil, then the other
elements of that clause are not evaluated and the system moves to
the next clause.
.Lf cvttointlisp
.Se
The reader is modified to conform with the Interlisp syntax.
The character % is made the escape character and special meanings for
comma, backquote and backslash are removed. 
Also the reader is told to convert upper case to lower case. 
.Lf cvttofranzlisp
.Se
.Fr "'s"
default syntax is reinstated.
One would run this function after having run any
of the other
.i cvtto-
functions.
Backslash is made the escape character, super-brackets work again,
and the reader distinguishes between upper and
lower case.
.Lf cvttomaclisp
.Se
The reader is modified to conform with Maclisp syntax.
The character / is made the escape character and the special meanings
for backslash, left and right bracket are removed.
The reader is made case-insensitive.
.Lf cvttoucilisp
.Se
The reader is modified to conform with UCI Lisp syntax.
The character / is made the escape character, tilde is made the comment
character, exclamation point takes on the unquote function normally
held by comma, and backslash, comma, semicolon become normal 
characters.
Here too, the reader is made case-insensitive.
.Lf debug "s_msg"
.Se
Enter the Fixit package described in Chapter 15.
This package allows you to examine the evaluation stack in detail.
To  leave the Fixit package type 'ok'.
.Lf debugging "'g_arg"
.Se
If g_arg is non-null,
Franz unlinks the transfer tables, does a \fI(*rset\ t)\fP to turn on
evaluation monitoring and sets the all-error catcher (ER%all) to be
\fIdebug-err-handler\fP.
If g_arg is nil,
all of the above changes are undone.
.Lf declare "[g_arg ...]"
.Re
nil
.No
this is a no-op to the evaluator.
It has special meaning to the compiler (see Chapter 12).
.Lf def "s_name (s_type l_argl g_exp1 ...)"
.Wh
s_type is one of lambda, nlambda, macro or lexpr.
.Re
s_name
.Se
This defines the function s_name to the lisp system.
If s_type is nlambda or macro then the argument list l_argl must contain
exactly one non-nil symbol.
.Lf defmacro "s_name l_arg g_exp1 ..."
.Lx defcmacro "s_name l_arg g_exp1 ..."
.Re
s_name
.Se
This defines the macro s_name.  
\fIdefmacro\fP makes it easy to write macros since it makes
the syntax just like \fIdefun\fP.
Further information on \fIdefmacro\fP is in \(sc8.3.2.
\fIdefcmacro\fP defines compiler-only macros, or cmacros.  
A cmacro is stored on the property list of a
symbol under the indicator \fBcmacro\fP.
Thus a function can
have a normal definition and a cmacro definition.
For an example of the use of cmacros, see the definitions
of nthcdr and nth in /usr/lib/lisp/common2.l
.Lf defun "s_name [s_mtype] ls_argl g_exp1 ... "
.Wh
s_mtype is one of fexpr, expr, args or macro.
.Re
s_name
.Se
This defines the function s_name.
.No
this exists for Maclisp compatibility, it is just a macro which
changes the defun form to the def form.
An s_mtype of fexpr is converted to nlambda
and of expr to lambda. Macro remains the same.
If ls_arg1 is a non-nil symbol, then the type is assumed to be lexpr and
ls_arg1 is the symbol which is bound to the number of args when the
function is entered.
.br
For compatibility with the Lisp Machine Lisp, there are three types of
optional parameters that can occur in ls_argl:  \fI&optional\fP declares that
the following symbols are optional, and may or may not appear in the
argument list to the function, \fI&rest symbol\fP
declares that all forms in the
function call that are not accounted for by previous lambda bindings
are to be assigned to \fIsymbol\fP, and \fI&aux form1 ... formn\fP
declares that the \fIformi\fP are either symbols, in which case they
are lambda bound to \fBnil\fP, or lists, in which case the first element
of the list is lambda bound to the second, evaluated element.
.Eb
; \fIdef\fP and \fIdefun\fP here are used to define identical functions
; you can decide for yourself which is easier to use.
\-> \fI(def append1 (lambda (lis extra) (append lis (list extra))))\fP
append1

\-> \fI(defun append1 (lis extra) (append lis (list extra)))\fP
append1

; Using the & forms...
\-> \fI(defu\kCn test (a b &optional c &aux (retval 0) &rest z)
        \h'|\nCu'\kB(if c them (msg \kA"Optional arg present" N
                        \h'|\nAu'"c is " c N))
        \h'|\nBu'(msg \kA"rest is " z N
             \h'|\nAu'"retval is " retval N))\fP
test
\-> \fI(test 1 2 3 4)\fP
Optional arg present
c is 3
rest is (4)
retval is 0
.Ee
.Lf defvar "s_variable ['g_init]"
.Re
s_variable.
.No
This form is put at the top level in files, like \fIdefun\fB.
.Se
This declares s_variable to be special. If g_init is present
and s_variable is unbound when the file is read in, s_variable
will be set to the value of g_init.
An advantage of `(defvar foo)' over `(declare (special foo))' is that if
a file containing defvars is loaded (or fasl'ed) in during compilation,
the variables mentioned in the defvar's will be declared special.  The only
way to have that effect with `(declare (special foo))' is to \fIinclude\fP
the file.  
.Lf do "l_vrbs l_test g_exp1 ..."
.Re
the last form in the cdr of l_test evaluated, or a value explicitly given by
a return evaluated within the do body.
.No
This is the basic iteration form for
.Fr .
l_vrbs is a list of zero or more var-init-repeat forms.
A var-init-repeat form looks like:
.br
.tl ''(s_name [g_init [g_repeat]])''
There are three cases depending on what is present in the form.
If just s_name is present, this means that when the do is entered,
s_name is lambda-bound to nil and is never modified by the system 
(though the program is certainly free to modify its value).
If the form is (s_name\ 'g_init) then the only difference is that
s_name is lambda-bound to the value of g_init instead of nil.
If g_repeat is also present then s_name is lambda-bound to g_init
when the loop is entered and after each pass through the do body
s_name is  bound to the value of g_repeat.
.br
l_test is either nil or has the form of a cond clause.
If it is nil then the do body will be evaluated only once and the
do will return nil.
Otherwise, before the do body is evaluated the car of l_test is 
evaluated and if the result is non-null, this signals an end to
the looping.
Then the rest of the forms in l_test are evaluated
and the value of the last one is returned as the value of the do.
If the cdr of l_test is nil, then nil is returned -- thus this is not
exactly like a cond clause.
.br
g_exp1 and those forms which follow constitute the do body.
A do body is like a prog body and thus may have labels and one may
use the functions go and return.
.br
The sequence of evaluations is this:
.nr $p 0
.np
the init forms are evaluated left to right and  stored in temporary
locations.
.np
Simultaneously all do variables are lambda bound to the value of
their init forms or nil.
.np
If l_test is non-null, then the car is evaluated and if it is non-null,
the rest of the forms in l_test are evaluated and the last value is 
returned as the value
of the do.
.np
The forms in the do body are evaluated left to right.
.np
If l_test is nil the do function returns with the value nil.
.np
The repeat forms are evaluated and saved in temporary locations.
.np
The variables with repeat forms are simultaneously
bound to the values of those forms.
.np
Go to step 3.
.No
there is an alternate form of do which can be used when there is
only one do variable.
It is described next.
.Eb
; this is  a simple function which numbers the elements of a list.
; It uses a \fIdo\fP function with two local variables.
\-> \fI(defun printem (lis)
	     (do ((xx lis (cdr xx))
		  (i 1 (1+ i)))
		 ((null xx) (patom "all done") (terpr))
		 (print i)
		 (patom ": ")
		 (print (car xx))
		 (terpr)))\fP
printem
\-> \fI(printem '(a b c d))\fP
1: a
2: b
3: c
4: d
all done
nil
\-> 
.Ee
.Lf do "s_name g_init g_repeat g_test g_exp1 ..."
.nr $p 0
.No
this is another, less general,  form of do.
It is evaluated by:
.np
evaluating g_init
.np
lambda binding s_name to value of g_init
.np
g_test is evaluated and if it is not nil the do function returns with nil.
.np
the do body is evaluated beginning at g_exp1.
.np
the repeat form is evaluated and stored in s_name.
.np
go to step 3.
.Re
nil
.Lf environment "[l_when1 l_what1 l_when2 l_what2 ...]"
.Lx environment-maclisp "[l_when1 l_what1 l_when2 l_what2 ...]"
.Lx environment-lmlisp "[l_when1 l_what1 l_when2 l_what2 ...]"
.Wh
the when's are a subset of (eval compile load), and the symbols have the
same meaning as they do in 'eval-when'.
.br
.sp
The what's may be 
.br
	(files file1 file2 ... fileN),
.br
which insure that the named files are loaded.
To see if file\fIi\fP is loaded,
it looks for a 'version' property under
file\fIi\fP's property list.  Thus to prevent multiple loading,
you should put
.br
	(putprop 'myfile t 'version),
.br
at the end of myfile.l.
.br
.sp
Another acceptable form for a what is
.br
(syntax type)
.br
Where type is either maclisp, intlisp, ucilisp, franzlisp.
.Se
\fIenvironment-maclisp\fP sets the environment to that which
`liszt -m' would generate.
.br
.sp
\fIenvironment-lmlisp\fP  sets up the lisp machine environment. This is like
maclisp but it has additional macros.
.br
.sp
For these specialized environments, only the \fBfiles\fP clauses are useful.
.Eg
	(environment-maclisp (compile eval) (files foo bar))
.Re
the last list of files requested.
.Lf err "['s_value [nil]]"
.Re
nothing (it never returns).
.Se
This causes an error and if this error is caught by an 
.i errset
then that 
.i errset
will return s_value instead of nil.
If the second arg is given, then it must be nil (\s-2MAC\s0lisp 
compatibility).
.Lf error "['s_message1 ['s_message2]]"
.Re
nothing (it never returns).
.Se
s_message1 and s_message2 are \fIpatom\fPed if they are given and
then \fIerr\fP is called (with no arguments), which causes an error.
.Lf errset "g_expr [s_flag]"
.Re
a list of one element, which is the value resulting from evaluating g_expr.
If an error occurs during the evaluation of g_expr, then the locus of control
will return to the 
.i errset
which will then return nil (unless the error was caused by a call to
.i err,
with a non-null argument).
.Se
S_flag is evaluated before g_expr is evaluated. 
If s_flag is not given, then it is assumed to be t.
If an error occurs during the evaluation of g_expr, and s_flag evaluated to 
a non-null value, then the error message associated with the
error is printed before control returns to the errset.
.Lf eval "'g_val ['x_bind-pointer]"
.Re
the result of evaluating g_val.
.No
The evaluator evaluates g_val in this way:
.br
If g_val is a symbol, then the evaluator returns its value.
If g_val had never been assigned a value, then this causes 
an `Unbound Variable' error.
If x_bind-pointer is given, then the variable is evaluated with
respect to that pointer (see \fIevalframe\fP for details on bind-pointers).
.br
.sp
If g_val is of type value, then its value is returned.
If g_val is of any other type than list, g_val is returned.
.br
.sp
If g_val is a list object then g_val is either a function call or
array reference.
Let g_car be the first element of g_val.
We continually evaluate g_car until we end up with a symbol with
a non-null function binding
or a non-symbol.
Call what we end up with: g_func.
.br
.sp
G_func must be one of three types: list, binary or array.
If it is a list then the first element of the list, which 
we shall call g_functype, must be either
lambda, nlambda, macro or lexpr.
If g_func is a binary, then its discipline, which we shall call
g_functype, is either lambda, nlambda, macro or a string.
If g_func is an array then this form is evaluated specially, see
Chapter 9 on arrays.
If g_func is a list or binary, then g_functype will determine how
the arguments to this function, the cdr of g_val, are processed.
If g_functype is a string, then this is a foreign function call (see \(sc8.5
for more details).
.br
.sp
If g_functype is lambda or lexpr, the arguments are evaluated
(by calling 
.i eval
recursively) and stacked.
If g_functype is nlambda then the argument list is stacked.
If g_functype is macro then the entire form, g_val is stacked.
.br
.sp
Next, the formal variables are lambda bound.
The formal variables are the cadr of g_func.  If g_functype is
nlambda, lexpr or macro, there should only be one formal variable.
The values on the stack are lambda bound to the formal variables
except in the case of a lexpr, where the number of actual arguments
is bound to the formal variable.
.br
.sp
After the binding is done, the function is invoked, either by
jumping to the entry point in the case of a binary or 
by evaluating the list of forms beginning at cddr g_func.
The result of this function invocation is returned as the value 
of the call to eval.
.Lf evalframe "'x_pdlpointer"
.Re
an evalframe descriptor for the evaluation frame just before x_pdlpointer.
If x_pdlpointer is nil, it returns the evaluation frame of the frame just
before the current call to \fIevalframe\fP.
.No
An evalframe descriptor describes a call to \fIeval\fP, \fIapply\fP
or \fIfuncall\fP.
The form of the descriptor is 
.br
\fI(type pdl-pointer expression bind-pointer np-index lbot-index)\fP
.br
where type is `eval' if this describes a call to \fIeval\fP or `apply'
if this is a call to \fIapply\fP or \fIfuncall\fP.
pdl-pointer is a number which  describes
this context. 
It can be passed to
.i evalframe
to obtain the next descriptor and
can be passed to 
.i freturn
to cause a return from this context.
bind-pointer is the size of variable  binding stack when this
evaluation began. 
The bind-pointer can be given as a second argument
to \fIeval\fP to order to evaluate variables in the same context as
this  evaluation. 
If type is `eval' then expression
will have the form \fI(function-name\ arg1\ ...)\fP.
If type is `apply' then expression will have the form
\fI(function-name\ (arg1\ ...))\fP.
np-index and lbot-index are pointers into the
argument stack (also known as the \fInamestack\fP array) at the time of call.
lbot-index points to the first argument, np-index points one beyond
the last argument.
.br
In order for there to be enough information
for \fIevalframe\fP to return, you must call \fI(*rset\ t)\fP.
.Ex
\fI(progn (evalframe nil))\fP
.br
returns \fI(eval 2147478600 (progn (evalframe nil)) 1 8 7)\fP
.Lf evalhook "'g_form 'su_evalfunc ['su_funcallfunc]"
.Re 
the result of evaluating g_form after lambda binding `evalhook' to
su_evalfunc and, if it is given, lambda binding `funcallhook' to 
su_funcallhook.
.No
As explained in \(sc14.4, the function
.i eval
may pass the job of evaluating a form to a user `hook' function when 
various switches are set.
The  hook function normally prints the form to be evaluated on the
terminal and then evaluates it by calling 
.i evalhook .
.i Evalhook
does the lambda binding mentioned above and then calls 
.i eval 
to evaluate the form after setting an internal switch to tell 
.i eval
not to call the user's hook function just this one time.
This allows the evaluation process to advance one step and yet
insure that further calls to 
.i eval
will cause traps to the hook function (if su_evalfunc is non-null).
.br
In order for \fIevalhook\fP to work, \fI(*rset\ t)\fP and 
\fI(sstatus\ evalhook\ t)\fP must have been done previously.
.Lf exec "s_arg1 ..."
.Re
the result of forking and executing the command named by concatenating
the s_arg\fIi\fP together with spaces in between.
.Lf exece "'s_fname ['l_args ['l_envir]]"
.Re
the error code from the system if it was unable to 
execute the command s_fname with arguments
l_args and with the environment set up as specified in l_envir.
If this function is successful, it will not return, instead the lisp
system will be overlaid by the new command.
.Lf freturn "'x_pdl-pointer 'g_retval"
.Re
g_retval from the context given by x_pdl-pointer.
.No
A pdl-pointer denotes a certain expression currently being evaluated.  
The pdl-pointer for a given expression can be obtained from
.i evalframe .
.Lf frexp "'f_arg"
.Re
a list cell \fI(exponent . mantissa)\fP which represents the 
given flonum
.No
The exponent will be a fixnum, the mantissa a 56 bit bignum.
If you think of the the binary point occurring right after the
high order bit of mantissa, then
f_arg\ =\ 2\*[exponent\*]\ *\ mantissa.
.Lf funcall "'u_func ['g_arg1 ...]"
.Re
the value of applying function u_func to the arguments g_arg\fIi\fP
and then evaluating that result if u_func is a macro.
.No
If u_func is a macro or nlambda then there should be only one g_arg.
\fIfuncall\fP is the function which the evaluator uses to evaluate
lists.
If \fIfoo\fP is a lambda or lexpr or array, 
then \fI(funcall\ 'foo\ 'a\ 'b\ 'c)\fP
is equivalent to \fI(foo\ 'a\ 'b\ 'c)\fP.
If \fIfoo\fP is a nlambda
then \fI(funcall\ 'foo\ '(a\ b\ c))\fP is equivalent to
\fI(foo a b c)\fP.
Finally, if 
.i foo
is a macro then
.i (funcall\ 'foo\ '(foo\ a\ b\ c))
is equivalent to
.i (foo\ a\ b\ c) .
.Lf funcallhook "'l_form 'su_funcallfunc ['su_evalfunc]"
.Re 
the result of \fIfuncall\fPing 
the \fI(car\ l_form)\fP
on the already evaluated
arguments in the \fI(cdr\ l_form)\fP 
after lambda binding `funcallhook' to
su_funcallfunc and, if it is given, lambda binding `evalhook' to 
su_evalhook.
.No
This function is designed to continue the evaluation process 
with as little work as possible after a funcallhook trap has occurred. 
It is for this reason that the form of l_form is unorthodox: its 
.i car
is the name of the function to call and its 
.i cdr
are a list of arguments to stack (without evaluating again)
before calling the given function.
After stacking the arguments 
but
before calling
.i funcall
an internal switch is set to prevent \fIfuncall\fP
from passing the job of funcalling to su_funcallfunc.
If \fIfuncall\fP is called recursively in funcalling l_form and
if su_funcallfunc is non-null, then 
the arguments to 
.i funcall
will actually be given to su_funcallfunc (a lexpr) 
to be funcalled.
.br
In order for \fIevalhook\fP to work, \fI(*rset\ t)\fP and 
\fI(sstatus\ evalhook\ t)\fP must have been done previously.
A more detailed description of 
.i evalhook
and 
.i funcallhook
is given in Chapter 14.
.Lf function "u_func"
.Re
the function binding of u_func if it is an symbol with a function binding
otherwise u_func is returned.
.Lf getdisc "'y_func"
.Re
the discipline of the machine coded function (either lambda, nlambda
or macro).
.Lf go "g_labexp"
.Wh
g_labexp is either a symbol or an expression.
.Se
If g_labexp is an expression, that expression is evaluated and 
should
result in a symbol.
The locus of control moves to just following the symbol g_labexp in the
current prog or do body.
.No
this is only valid in the context of a prog or do body.
The interpreter and compiler will allow non-local 
.i go 's 
although the compiler won't allow a \fIgo\fP to leave a function body.
The compiler will not allow g_labexp to be an expression.
.Lf if "'g_a 'g_b"
.Lx if "'g_a 'g_b 'g_c ..."
.Lx if "'g_a \fBthen\fP  'g_b [...] [\fBelseif\fP 'g_c \fBthen\fP 'g_d ...] [\fBelse\fP 'g_e [...]"
.Lx if "'g_a \fBthen\fP  'g_b [...] [\fBelseif\fP 'g_c \fBthenret\fP] [\fBelse\fP 'g_d [...]"
.No
The various forms of \fIif\fP are intended to be a more readable
conditional statement, to be used in place of \fIcond\fP.  There
are two varieties of \fIif\fP, with keywords, and without.  The
keyword-less variety is inherited from common Maclisp usage.
A keyword-less, two argument \fIif\fP is equivalent to a one-clause
\fIcond\fP, i.e. (\fIcond\fP (a b)).   Any other keyword-less \fIif\fP
must have at least three arguments.  The first two arguments are the
first clause of the equivalent \fIcond\fP, and all remaining arguments
are shoved into a second clause beginning with \fBt\fP.  Thus, the
second form of \fIif\fP is equivalent to
.br
	(\fIcond\fP (a b) (t c ...)).
.br
.sp
The keyword variety has the following grouping of arguments:
a predicate, a then-clause, and optional
else-clause.  The predicate is evaluated, and if the result is
non-nil, the then-clause will be performed, in the sense
described below.  Otherwise, (i.e. the result of the predicate
evaluation was precisely nil), the else-clause will be performed.
.br
.sp
Then-clauses will either consist entirely
of the single keyword \fBthenret\fP, or will start with the keyword
\fBthen\fP, and be followed by at least one general expression.
(These general expressions must not be one of the keywords.)
To actuate a \fBthenret\fP means to cease further evaluation
of the \fIif\fP, and to return the value of the predicate just calculated.
The performance of the longer clause means to evaluate each general expression
in turn, and then return the last value calculated.
.br
.sp
The else-clause may begin with the keyword \fBelse\fP and be followed
by at least one general expression.
The rendition of this clause is just like that of a then-clause.
An else-clause
may begin alternatively with the keyword \fBelseif\fP, and be followed
(recursively) by a predicate, then-clause, and optional else-clause.
Evaluation of this clause, is just evaluation of an \fIif\fP-form, with
the same predicate, then- and else-clauses.
.Lf I-throw-err "'l_token"
.Wh
l_token is the \fIcdr\fP of the value returned from a \fI*catch\fP with
the tag ER%unwind-protect.
.Re
nothing (never returns in the current context)
.Se
The error or throw denoted by l_token is continued.
.No
This function is used to implement \fIunwind-protect\fP which allows the
processing of a transfer of control though a certain context to be
interrupted, a user function to be executed and than the transfer of
control to continue.
The form of l_token is either
.br
\fI(t tag value)\fP for a throw or
.br
\fI(nil type message valret contuab uniqueid [arg ...])\fP for an error.
.br
This function is not to be used for implementing throws or
errors and is only documented here for completeness.
.Lf let "l_args g_exp1 ... g_exprn"
.Re
the result of evaluating g_exprn within the bindings given by l_args.
.No
l_args is either nil (in which case 
.i let
is just like
.i progn )
or it is a list of binding objects.
A binding object is a list \fI(symbol\ expression)\fP.
When a 
.i let 
is entered,
all of the expressions are evaluated and then simultaneously
lambda-bound to the corresponding symbols.
In effect, a 
.i let
expression is just like a lambda expression except the symbols and
their initial values are next to each other, making the expression
easier to understand.
There are some added features to the 
.i let 
expression:
A binding object can just be a symbol, in which case the expression
corresponding to that symbol is `nil'.
If a binding object is a list and the first element of that list is
another list, then that list is assumed to be a binding template
and 
.i let
will do a 
.i desetq
on it.
.Lf let* "l_args g_exp1 ... g_expn"
.Re
the result of evaluating g_exprn within the bindings given by l_args.
.No
This is identical to 
.i let
except the expressions in the binding list l_args are evaluated
and bound sequentially instead of in parallel.
.Lf lexpr-funcall "'g_function ['g_arg1 ...] 'l_argn"
.No
This is a cross between funcall and apply.
The last argument, must be a list (possibly empty).
The element of list arg are stack and then the function is
funcalled.
.Ex
(lexpr-funcall 'list 'a '(b c d)) is the same as
 (funcall 'list 'a 'b 'c 'd)
.Lf listify "'x_count"
.Re
a list of x_count of the arguments to the current function (which
must be a lexpr).
.No
normally arguments 1 through x_count are returned. 
If x_count is negative then  a list of last abs(x_count) arguments are
returned.
.Lf map "'u_func 'l_arg1 ..."
.Re
l_arg1
.No
The function u_func is applied to successive sublists of the l_arg\fIi\fP.
All sublists should have the same length.  
.\".pg
.Lf mapc "'u_func 'l_arg1 ..."
.Re
l_arg1.
.No
The function u_func is applied to successive elements of the argument 
lists.
All of the lists should have the same length.
.Lf mapcan "'u_func 'l_arg1 ..."
.Re
nconc applied to the results of the functional evaluations.
.No
The function u_func is applied to successive elements of the 
argument lists.
All sublists should have the same length.
.Lf mapcar "'u_func 'l_arg1 ..."
.Re
a list of the values returned from the functional application.
.No
the function u_func is applied to successive elements of the
argument lists.
All sublists should have the same length.
.Lf mapcon "'u_func 'l_arg1 ..."
.Re
nconc applied to the results of the functional evaluation.
.No
the function u_func is applied to successive sublists of the
argument lists.
All sublists should have the same length.
.Lf maplist "'u_func 'l_arg1 ..."
.Re
a list of the results of the functional evaluations.
.No
the function u_func is applied to successive sublists of the arguments
lists.
All sublists should have the same length.
.lp
Readers may find the following summary table useful in remembering
the differences between the six mapping functions:

.TS
box;
c | c s s.
\	Value returned is

.T&
c | c c c.
T{
.na
Argument to functional is
.ad
T}	l_arg1	list of results	\fInconc\fP of results
_
.T&
c | c c c.

elements of list	mapc	mapcar	mapcan

sublists	map	maplist	mapcon
.TE
.sp 2v
.Lf mfunction "t_entry 's_disc"
.Re
a lisp object of type binary composed of t_entry and s_disc.
.No
t_entry is a pointer to the machine code for a function, and s_disc is the
discipline (e.g. lambda).
.\".pg
.Lf oblist
.Re
a list of all symbols on the oblist.
.Lf or "[g_arg1 ... ]"
.Re
the value of the first non-null argument  or nil if all arguments 
evaluate to nil.
.No
Evaluation proceeds left to right and stops as soon as one of the arguments
evaluates to a non-null value.
.Lf prog "l_vrbls g_exp1 ..."
.Re
the value explicitly given in a return form
or else nil if no return is done by the time the last g_exp\fIi\fP is
evaluated.
.No
the local variables are lambda-bound to nil,
then the g_exp\fIi\fP
are evaluated from left to right.
This is a prog body (obviously) and this means than 
any symbols seen are not evaluated,
but are treated as labels.
This also means that return's and go's are allowed.
.Lf prog1 "'g_exp1 ['g_exp2 ...]"
.Re
g_exp1
.Lf prog2 "'g_exp1 'g_exp2 ['g_exp3 ...]"
.Re
g_exp2
.No
the forms are evaluated from left to right and the value of g_exp2 is
returned.
.Lf progn "'g_exp1 ['g_exp2 ...]"
.Re
the last g_exp\fIi\fP.
.Lf progv "'l_locv 'l_initv g_exp1 ..."
.Wh
l_locv is a list of symbols and l_initv is a list of expressions.
.Re
the value of the last g_exp\fIi\fP evaluated.
.No
The expressions in l_initv are evaluated from left to right
and then lambda-bound to the symbols in l_locv.
If there are too few expressions in l_initv then the missing values
are assumed to be nil.
If there are too many expressions in l_initv then the extra ones are
ignored (although they are evaluated).
Then the g_exp\fIi\fP are evaluated left to right.
The body of a progv is like the body of a progn, it is 
.i not
a prog body.
(C.f. 
.i let )
.Lf purcopy "'g_exp"
.Re
a copy of g_exp with new pure cells allocated wherever possible.
.No
pure space is never swept up by the garbage collector, so this should
only be done on expressions which are not likely to become garbage
in the future.
In certain cases, data objects in pure space become read-only after
a 
.i dumplisp
and then an attempt to modify the object will result in an illegal memory
reference.
.Lf purep "'g_exp"
.Re
t iff the object g_exp is in pure space.
.Lf putd "'s_name 'u_func"
.Re
u_func
.Se
this sets the function binding of symbol s_name to u_func.
.Lf return "['g_val]"
.Re
g_val (or nil if g_val is not present) from the enclosing prog or do body.
.No
this form is only valid in the context of a prog or do body.
.Lf selectq "'g_key-form [l_clause1 ...]"
.No
This function is just like \fIcaseq\fP (see above), except that
the symbol \fBotherwise\fP has the same semantics as the
symbol \fBt\fP, when used as a comparator.
.Lf setarg "'x_argnum 'g_val"
.Wh
x_argnum is greater than zero and less than or equal to the number of
arguments to the lexpr.
.Re
g_val
.Se
the lexpr's x_argnum'th argument is set to g-val.
.No
this can only be used within the body of a lexpr.
.Lf throw "'g_val [s_tag]"
.Wh
if s_tag is not given, it is assumed to be nil.
.Re
the value of \fI(*throw 's_tag 'g_val)\fP.
.Lf *throw "'s_tag 'g_val"
.Re
g_val from the first enclosing catch with 
the tag s_tag or with no tag at all.
.No
this is used in conjunction with 
.i *catch
to cause a clean jump to an enclosing context.
.Lf unwind-protect "g_protected [g_cleanup1 ...]"
.Re
the result of evaluating g_protected.
.No
Normally g_protected is evaluated and its value
remembered, then the g_cleanup\fIi\fP
are evaluated and finally the saved value of g_protected is returned.
If something should happen when evaluating g_protected which causes
control to pass through g_protected  and thus through
the call to the unwind-protect,
then the g_cleanup\fIi\fP will still be evaluated.
This is useful if g_protected does  something sensitive which 
must be cleaned up whether or not g_protected completes.
EndOfFile
cat >  doc/ch5.n  << 'EndOfFile'
." $Header: ch5.n,v 1.3 83/07/23 12:40:05 layer Exp $
.Lc Input/Output 5
.pp
The following functions are used to read from and write to external devices
(e.g. files)
and programs (through pipes).
All I/O goes through the lisp data type called the port.
A port may be open for either reading or writing, but usually not both
simultaneously (see 
.i fileopen
).
There are only a limited number of ports (20) and they will not be reclaimed
unless they are 
.i close d.
All ports are reclaimed by a 
.i resetio
call,
but this drastic step won't be necessary if the program closes
what it uses.
.pp
If a port argument is not supplied to a function which requires one,
or if a bad port argument (such as nil) is given,
then 
.Fr
will use the default port according to this scheme:
If input is being done then the default port is the value
of the symbol
.b piport 
and if output is being done then the default port is the value 
of the symbol
.b poport .
Furthermore,
if the value of piport or poport is not a valid port,
then the standard input or standard output will be used, respectively.
.pp
The standard input and standard output are usually the keyboard and
terminal display unless your job is running in the background and its
input or output is connected to a pipe.
All output which goes to the standard output will also go to the 
port
.b ptport
if it is a valid port.
Output destined for the standard output will not reach 
the standard output if the symbol 
.b ^w
is non nil (although it will still go to 
.b ptport 
if 
.b ptport 
is a valid port).
.pp
Some of the functions listed below reference files directly.
.Fr
has borrowed a convenient shorthand notation from
.i /bin/csh ,
concerning naming files.
If a file name begins with ~ (tilde),
and the symbol
.b tilde-expansion

is bound to something other than nil,
then
.Fr
expands the file name.
It takes the string of characters between the leading tilde, and
the first slash as a user-name.
Then, that initial segment of the filename is replaced by the home
directory of the user.  The null username is taken to be the current
user.
.pp
.Fr
keeps a cache of user home directory information, to minimize
searching the password file.
Tilde-expansion is performed in the following functions:
\fIcfasl, chdir, fasl, ffasl, fileopen, infile, load, outfile,
probef, sys:access, sys:unlink\fP.
.Lf cfasl "'st_file 'st_entry 'st_funcname ['st_disc ['st_library]]"
.Re
t
.Se
This is used to load in a foreign function (see \(sc8.4).
The object file st_file is loaded into the lisp system.
St_entry should be an entry point in the file just loaded.
The function binding of the symbol s_funcname will be set to point
to st_entry, so that when the lisp function s_funcname is called,
st_entry will be run.
st_disc is the discipline to be given to s_funcname. 
st_disc defaults to "subroutine" if it is not given or if it is given as nil.
If st_library is non-null, then after st_file is loaded, the libraries
given in st_library will be searched to resolve external references.
The form of st_library should be something like "-lm".
The C library  (" -lc " ) is always searched so when loading in a C
file you probably won't need to specify a library.
For Fortran files, you should specify "-lF77" and if you are doing 
any I/O, the library entry should be "-lI77 -lF77".
For Pascal files "-lpc" is required.
.No
This function may be used to load the output of the assembler, C compiler,
Fortran compiler, and Pascal compiler  but NOT the lisp compiler (use 
.i fasl 
for that).
If a file has more than one entry point, then use 
.i getaddress 
to locate and setup other foreign functions.
.br
It is an error to load in a file which has a global entry point of the same
name as a global entry point in the running lisp.
As soon as you load in a file with 
.i cfasl , 
its global entry points become part of the 
lisp's entry points.
Thus you cannot 
.i cfasl
in the same file twice unless you 
use 
.i removeaddress
to change certain global entry points to local entry points.
.Lf close "'p_port" 
.Re 
t
.Se
the specified port is drained and closed, releasing the port.
.No
The standard defaults are not used in this case since you probably never
want to close the standard output or standard input.
.Lf cprintf "'st_format 'xfst_val ['p_port]"
.Re
xfst_val
.Se
The UNIX formatted output function printf is called with arguments st_format
and xfst_val.
If xfst_val is a symbol then its print name is passed to printf.
The format string may contain characters which are just printed literally
and it may contain special formatting commands preceded by a percent
sign.
The complete set of formatting characters is described in the UNIX manual.
Some useful ones are %d for printing a fixnum in decimal, %f or %e for printing
a flonum, and %s for printing a character string (or print name of a symbol).
.Ex
\fI(cprintf "Pi equals %f" 3.14159)\fP prints `Pi equals 3.14159'
.Lf drain "['p_port]"
.Re
nil
.Se
If this is an output port then
the characters in the output buffer are all sent to the device.
If this is an input port then all pending characters are flushed.
The default port for this function is the default output port.
.Lf ex "[s_filename]"
.Lx vi "[s_filename]"
.Lx exl "[s_filename]"
.Lx vil "[s_filename]"
.Re
nil
.Se
The lisp system starts up an editor on the file named as the argument.
It will try appending .l to the file if it can't find it.
The functions \fIexl\fP and \fIvil\fP will load the file after
you finish editing it.  These functions will also remember the name
of the file so that on subsequent invocations, you don't need to
provide the argument.
.No
These functions do not evaluate their argument.
.Lf fasl "'st_name ['st_mapf ['g_warn]]"
.Wh
st_mapf and g_warn default to nil.
.Re
t if the function succeeded, nil otherwise.
.Se
this function is designed to load in an object file generated by
the lisp compiler Liszt.
File names for object files usually end in `.o', so 
.i fasl
will append `.o' to st_name (if it is not already present).
If st_mapf is non nil, then it is the name of the map file to 
create.
.i Fasl 
writes in the map file the names and addresses of the functions
it loads and defines.
Normally the map file is created (i.e. truncated if it 
exists), but if \fI(sstatus\ appendmap\ t)\fP is done then the map file
will be appended.
If g_warn is non nil and if a function is loaded from  the file which
is already defined, then a warning message will be printed.
.No
.i fasl
only looks in the current directory for the file to load. 
The function
.i load
looks through a user-supplied search path and will call
.i fasl
if it finds a file with the same root name and a `.o' extension.
In  most cases the user 
would be better off using the function
.i load
rather than calling
.i fasl
directly.
.Lf ffasl "'st_file 'st_entry 'st_funcname ['st_discipline ['st_library]]"
.Re
the binary object created.
.Se
the Fortran object file st_file is loaded into the lisp system.
St_entry should be an entry point in the file just loaded. 
A binary object will be created and its entry field will be set to point 
to st_entry.
The discipline field of the binary will be set to st_discipline or
"subroutine" by default.
If st_library is present and non-null, then after st_file is loaded, the libraries
given in st_library will be searched to resolve external references.
The form of st_library should be something like "-lS -ltermcap".
In any case, the standard Fortran libraries will be
searched also to resolve external references.
.No
in F77 on Unix, the entry point for the fortran function foo
is named `_foo_'.
.Lf filepos "'p_port ['x_pos]"
.Re
the current position in the file if x_pos is not 
given or else x_pos if x_pos is given.
.Se
If x_pos is given, the next byte to be read or written to the
port will be at 
position x_pos.
.Lf filestat 'st_filename
.Re
a vector containing various numbers which the UNIX operating
system assigns to files.  if the file doesn't exist, an error is
invoked.  Use \fIprobef\fP to determine if the file exists.
.No
The individual entries can be accesed by mnemonic functions
of the form filestat:\fIfield\fP, where field may be any of
atime, ctime, dev, gid, ino, mode,mtime, nlink, rdev, size,
type, uid.  See the UNIX programmers manual for a more detailed
description of these quantities.
.Lf flatc "'g_form ['x_max]"
.Re
the number of characters required to print g_form using \fIpatom\fP.
If x_max is given and if \fIflatc\fP determines that it will return a value
greater than x_max, then it gives up and returns the current value it
has computed.
This is useful if you just want to see if an expression is larger than
a certain size.
.Lf flatsize "'g_form ['x_max]"
.Re
the number of characters required to print g_form using \fIprint\fP.
The meaning of x_max is the same as for flatc.
.No
Currently this just 
.i explode 's
g_form and checks its length.
.Lf fileopen "'st_filename 'st_mode"
.Re
a port for reading or writing (depending on st_mode) the file st_name.
.Se
the given file is opened (or created if opened for writing and it 
doesn't yet exist).
.No
this function call provides a direct
interface to the operating system's fopen function.
The mode may be more than just "r" for read, "w" for write or "a" for
append.  The modes "r+", "w+" and "a+" permit both reading and writing
on a port provided that
.i fseek
is done between changes in direction.
See the UNIX manual description of fopen for more details.
This routine does not look through a search path for a given file.
.Lf fseek "'p_port 'x_offset 'x_flag"
.Re
the position in the file after the function is performed.
.Se
this function positions the read/write pointer before a certain byte
in the file.
If x_flag is 0 then the pointer is set to x_offset bytes from the 
beginning of the file.
If x_flag is 1 then the pointer is set to x_offset bytes from the
current location in the file.
If x_flag is 2 then the pointer is set to x_offset bytes from the 
end of the file.
.Lf infile "'s_filename"
.Re
a port ready to read s_filename.
.Se
this tries to open s_filename and if it cannot or if there are no
ports available it gives an error message.
.No
to allow your program to continue on a file-not-found error,
you can use something like:
.br
\fI(cond ((null (setq myport (car (errset (infile name) nil))))
.br      
\ \ \ \ \ \ \ \ \ \ \ \ (patom '"couldn't open the file")))\fP
.br
which will set myport to the port to read from if the file exists
or will print a message if it couldn't open it and also set myport to nil.
To simply determine if a file exists, use
.i probef .
.Lf load "'s_filename ['st_map ['g_warn]]"
.Re
t
.No
The function of 
.i load
has changed since previous releases of 
.Fr 
and the following description should be read carefully.
.Se
.i load 
now serves the function of both
.i fasl
and the old 
.i load .
.i Load
will search a user defined search path for a lisp source or object file
with the filename s_filename (with the extension .l or .o added as
appropriate).
The search path which
.i load
uses is the value of \fI(status\ load-search-path)\fP.
The default is (|.|\ /usr/lib/lisp) which means look in the current
directory first and then /usr/lib/lisp.
The file which 
.i load
looks for depends on the last two characters of s_filename.
If s_filename ends with ".l" then 
.i load 
will only look for a file name
s_filename and will assume that this is a
.Fr
source file.
If s_filename ends with ".o" then 
.i load
will only look for a file named s_filename and will assume that this is
a 
.Fr 
object file to be 
.i fasl ed
in.
Otherwise, 
.i load
will first look for s_filename.o, then s_filename.l and finally
s_filename itself.
If it finds s_filename.o it will assume that this is an object file,
otherwise it will assume that it is a source file.
An object file is loaded using
.i fasl
and a source file is loaded by reading and evaluating each form in the
file.
The optional arguments st_map and g_warn are passed to 
.i fasl
should 
.i fasl
be called.
.No
\fIload\fP requires a port to open the file s_filename.
It then lambda binds the symbol piport to this port and reads and
evaluates the forms.
.Lf makereadtable "['s_flag]"
.Wh
if s_flag is not present it is assumed to be nil.
.Re
a readtable equal to the original readtable if s_flag is non-null, or else
equal to the current readtable.
See chapter 7 for a description of readtables and their uses.
.Lf msg "[l_option ...] ['g_msg ...]"
.No
This function is intended for printing short messages.
Any of the arguments or options
presented can be used any number of times, in any
order.  The messages themselves (g_msg) are evaluated, and then
they are transmitted to
.i patom .
Typically, they are strings, which evaluate to themselves.
The options are interpreted specially:
.Eb
\fImsg Option Summary\fP

\fI(P\ p_portname)\fP 		causes subsequent output to go to the port p_portname
				(port should be opened previously)

\fIB\fP			print a single blank.

\fI(B\ 'n_b)\fP\ \ 		evaluate n_b and print that many blanks.

\fIN\fP			print a single by calling \fIterpr\fP.

\fI(N\ 'n_n)\fP\ \ 		evaluate n_n and transmit
				that many newlines to the stream.

\fID\fP			\fIdrain\fP the current port.
.Ee
.Lf nwritn "['p_port]"
.Re
the number of characters in the buffer
of the given port but not yet written out to the file or device.
The buffer is flushed 
automatically when filled,
or when 
.i terpr
is called.
.Lf outfile "'s_filename ['st_type]"
.Re
a port or nil
.Se
this opens a port to write s_filename.
If st_type is given and if it is  a symbol or string whose name 
begins with `a', then the file will be opened in append mode, 
that is the current contents will not be lost and the next data
will be written at the end of the file.
Otherwise, 
the file opened is truncated by \fIoutfile\fP if it existed beforehand.
If there are no free ports, outfile returns nil.
If one cannot write on s_filename, an error is signalled.
.\".pg
.Lf patom "'g_exp ['p_port]"
.Re
g_exp
.Se
g_exp is printed to the given port or the default port.
If g_exp is a symbol or string, the print name is printed without
any escape characters around special characters in the print name.
If g_exp is a list then \fIpatom\fP has the same effect as \fIprint\fP.
.Lf pntlen "'xfs_arg"
.Re
the number of characters needed to print xfs_arg.
.Lf portp "'g_arg"
.Re
t iff g_arg is a port.
.Lf pp "[l_option] s_name1 ..."
.Re
t
.Se
If s_name\fIi\fP has a function binding, it is pretty-printed,
otherwise if s_name\fIi\fP has a value then that is pretty-printed.
Normally the output of the pretty-printer goes to the standard
output port poport.
The options allow you to redirect it.
.Eb
\fIPP Option Summary\fP

\fI(F\ s_filename)\fP 		direct future printing to s_filename

\fI(P\ p_portname)\fP 		causes output to go to the port p_portname
				(port should be opened previously)

\fI(E\ g_expression)\fP		evaluate g_expression and don't print
.Ee
.Lf princ "'g_arg ['p_port]"
.Eq
patom.
.Lf print "'g_arg ['p_port]"
.Re
nil
.Se
prints g_arg on the port p_port or the default port.
.Lf probef "'st_file"
.Re
t iff the file st_file exists.
.No
Just because it exists doesn't mean you can read it.
.Lf pp-form "'g_form ['p_port]"
.Re 
t
.Se
g_form is pretty-printed to the port p_port (or poport if
p_port is not given).
This is the  function which \fIpp\fP uses. 
\fIpp-form\fP does not look for
function definitions or values of variables, it just prints out the form
it is given.
.No
This is useful as a top-level-printer, c.f. 
.i top-level
in Chapter 6.
.Lf ratom  "['p_port ['g_eof]]"
.Re
the next atom read from the given or default port.
On end of file, g_eof (default nil) is returned.
.Lf read "['p_port ['g_eof]]"
.Re
the next lisp expression read from the given or default port.
On end of file, g_eof (default nil) is returned.
.No
An error will occur if the reader is given an ill formed expression.
The most common error is too many right parentheses (note that this is
not considered an error in Maclisp).
.Lf readc "['p_port ['g_eof]]"
.Re
the next character read from the given or default port.
On end of file, g_eof (default nil) is returned.
.Lf readlist "'l_arg"
.Re
the lisp expression read from the list of characters in l_arg.
.Lf removeaddress "'s_name1 ['s_name2 ...]"
.Re
nil
.Se
the entries for the s_name\fIi\fP in the Lisp symbol table are removed.
This is useful if you wish to 
.i cfasl
or
.i ffasl
in a file twice, since it is illegal for a symbol in the file you
are loading to already exist in the lisp symbol table.
.Lf resetio
.Re
nil
.Se
all ports except the standard input, output and error
are closed.
.Lf setsyntax "'s_symbol 's_synclass ['ls_func]"
.Re
t
.Se
this sets the code for s_symbol to sx_code in the current readtable.
If s_synclass is 
.i macro
or 
.i splicing
then ls_func is the associated function.
See Chapter  7 on the reader for more details.
.Lf sload "'s_file"
.Se
the file s_file (in the current directory) is opened for reading and
each form is read, printed and evaluated.
If the form is recognizable as a function definition, only its name
will be printed, otherwise the whole form is printed.
.No
This function is useful when a file refuses to load because
of a syntax error and you would like to narrow down
where the error is.
.Lf tab "'x_col ['p_port]"
.Se
enough spaces are printed to put the cursor on column x_col.
If the cursor is beyond x_col to start with, a 
.i terpr
is done first.
.Lf terpr "['p_port]"
.Re
nil
.Se
a terminate line  character sequence
is sent to the given port or the default port.
This will also drain the port.
.Lf terpri "['p_port]"
.Eq
terpr.
.Lf tilde-expand 'st_filename
.Re
a symbol whose pname is the tilde-expansion of the argument,
(as discussed at the beginning of this chapter).
If the argument does not begin with a tilde, the argument itself is
returned.
.Lf tyi "['p_port]"
.Re
the fixnum representation of the next character read.
On end of file, -1 is returned.
.Lf tyipeek "['p_port]"
.Re
the fixnum representation of the next character to be read.
.No
This does not actually read the character, it just peeks at it.
.Lf tyo "'x_char ['p_port]"
.Re
x_char.
.Se
the character whose fixnum representation is 
x_code, is printed as a
on the given output port or the default output port.
.Lf untyi "'x_char ['p_port]"
.Se
x_char is put back in the input buffer so a subsequent
.i tyi
or 
.i read
will read it first.
.No
a maximum of one character may be put back.
.Lf username-to-dir 'st_name
.Re
the home directory of the given user.
The result is stored, to avoid unnecessarily searching the 
password file.
.Lf zapline 
.Re
nil
.Se
all characters up to and including the line termination character
are read and discarded from the last port used
for input.
.No
this is used as the macro function for the semicolon character when
it acts as a comment character.
EndOfFile
cat >  doc/ch6.n  << 'EndOfFile'
." $Header: ch6.n,v 1.4 83/07/21 21:08:16 sklower Exp $
.Lc System\ Functions 6
.pp
This chapter describes the functions used to interact
with internal components of the Lisp system and operating system.
.Lf allocate "'s_type 'x_pages"
.Wh
s_type is one of the 
.Fr
data types described in \(sc1.3.
.Re
x_pages.
.Se
.Fr
attempts to allocate x_pages of type s_type.
If there aren't x_pages of memory left, no space will be 
allocated and an error will occur.
The storage that is allocated is not given to the caller, instead it is 
added to the free storage list of s_type.
The functions
.i segment
and 
.i small-segment 
allocate blocks  of storage and return it to the caller.
.Lf argv "'x_argnumb"
.Re
a symbol whose pname is the x_argnumb\fIth\fP argument (starting at 0)
on the command
line which invoked the current lisp.
.No
if x_argnumb is less than zero, a fixnum whose value is the number of arguments
on the command line is returned.
\fI(argv\ 0)\fP returns the name of the lisp you are running.
.Lf baktrace 
.Re
nil
.Se
the lisp runtime stack is examined and the name of (most) of the functions
currently in execution are printed, most active first.
.No
this will occasionally miss the names of compiled lisp functions due to
incomplete information on the stack.
If you are tracing compiled code, then \fIbaktrace\fP won't be able
to interpret the stack unless 
.i (sstatus\ translink\ nil)
was done.
See the function 
.i showstack 
for another way of printing the lisp runtime
stack.
This misspelling is from Maclisp.
.Lf chdir "'s_path"
.Re
t iff the system call succeeds.
.Se
the current directory set to s_path. 
Among other things, this will affect the default location
where the input/output functions look for and create files.
.No
\fIchdir\fP follows the standard UNIX conventions, if s_path does not begin
with a slash, the default path is changed to the current path with
s_path appended.
.i Chdir
employs tilde-expansion (discussed in Chapter 5).
.Lf command-line-args
.Re
a list of the arguments typed on the command line, either to the
lisp interpreter, or saved lisp dump, or application compiled
with the autorun option (liszt -r).
.Lf deref "'x_addr"
.Re
The contents of x_addr, when thought of as a longword memory
location.
.No
This may be useful in constructing arguments to C functions
out of `dangerous' areas of memory.
.Lf dumplisp "s_name"
.Re
nil
.Se
the current lisp is dumped to the named file.
When s_name is executed, you will be in a lisp in the
same state as when the dumplisp was done.
.No
dumplisp will fail if one tries to 
write over the current running file. 
UNIX does not allow you to modify the file you are running.
.Lf eval-when "l_time g_exp1 ..."
.Se
l_time may contain any combination of the symbols
.i load ,
.i eval ,
and
.i compile .
The effects of load and compile is discussed in \(sc12.3.2.1
compiler.
If eval is present however, this simply means that the expressions g_exp1
and so on are evaluated from left to right.
If eval is not present, the forms are not evaluated.
.Lf exit "['x_code]"
.Re
nothing (it never returns).
.Se
the lisp system dies with exit code x_code or 0 if x_code is not
specified.
.Lf fake "'x_addr"
.Re
the lisp object at address x_addr.
.No
This is intended to be used by people debugging the lisp system.
.Lf fork 
.Re
nil to the child process and the process number of the child to 
the parent.
.Se
A copy of the current lisp system is made in memory and both
lisp systems now begin to run.
This function can be used interactively to temporarily
save the state of Lisp (as shown below), but you must be careful that only one
of the lisp's interacts with the terminal after the fork.
The
.i wait 
function is useful for this.
.Eb
\-> \fI(setq foo 'bar)\fP		;; set a variable
bar
\-> \fI(cond ((fork)(wait)))\fP	;; duplicate the lisp system and
nil				;; make the parent wait
\-> \fIfoo\fP				;; check the value of the variable
bar
\-> \fI(setq foo 'baz)\fP		;; give it a new value
baz
\-> \fIfoo\fP 				;; make sure it worked
baz
\-> \fI(exit)\fP			;; exit the child
(5274 . 0) 			;; the \fIwait\fP function returns this
\-> \fIfoo\fP 				;; we check to make sure parent was
bar				;; not modified.
.Ee
.Lf gc
.Re
nil
.Se
this causes a garbage collection.
.No
The function
.i gcafter
is not called automatically after this function finishes.
Normally the user doesn't have to call
.i gc
since
garbage collection occurs automatically whenever internal free lists
are exhausted.
.Lf gcafter "s_type"
.Wh
s_type is one of the 
.Fr
data types listed in \(sc1.3.
.No
this function is called by the garbage collector
after a garbage collection which was caused by running out of 
data type s_type.
This function should determine if more space need be allocated
and if so should allocate it.
There is a default gcafter function but users who want control over
space allocation can define their own -- but note that it must be
an nlambda.
.Lf getenv "'s_name"
.Re
a symbol whose pname is the value of s_name in the current 
UNIX environment.
If s_name doesn't exist in the current environment, a symbol with a null pname
is returned.
.Lf hashtabstat
.Re
a list of fixnums representing the number of symbols in each bucket of
the oblist.
.No
the oblist is stored a hash table of buckets.
Ideally there would be the same number of symbols in each bucket.
.Lf help "[sx_arg]"
.Se
If sx_arg is a symbol then
the portion of this manual beginning with the description of sx_arg
is printed on the terminal.
If sx_arg is  a fixnum or the name of one of the appendicies, that
chapter or appendix is printed on the terminal.
If no argument is provided, 
.i help
prints the options that it recognizes.
The program `more' is used to print the manual on the terminal; it will
stop after each page and will continue after the space key is pressed.
.Lf include "s_filename"
.Re
nil
.Se
The given filename is 
.i load ed
into the lisp.
.No
this is similar to load except the argument is not evaluated.
Include means something special to the compiler.
.Lf include-if "'g_predicate s_filename"
.Re
nil
.Se
This has the same effect as include, but is only actuated
if the predicate is non-nil.
.Lf includef "'s_filename"
.Re
nil
.Se
this is the same as 
.i include
except the argument is evaluated.
.Lf includef-if "'g_predicate s_filename"
.Re
nil
.Se
This has the same effect as includef, but is only actuated
if the predicate is non-nil.
.Lf maknum "'g_arg"
.Re
the address of its argument converted into a fixnum.
.Lf monitor "['xs_maxaddr]"
.Re
t
.Se
If xs_maxaddr is t then profiling of the entire lisp system is begun.
If xs_maxaddr is a fixnum then profiling is done only up to address
xs_maxaddr.
If xs_maxaddr is not given, then profiling is stopped and the data
obtained is written to the file 'mon.out' where it can be analyzed
with the UNIX 'prof' program.
.No
this function only works if the lisp system has been compiled
in a special way, otherwise, an error is invoked.
.Lf opval "'s_arg ['g_newval]"
.Re
the value associated with s_arg before the call.
.Se
If g_newval is specified, the value associated with s_arg is changed to
g_newval.
.No
\fIopval\fP keeps track of storage allocation. If s_arg is one of the data types
then \fIopval\fP will return a list of three fixnums representing the number of
items of that type in use, the number of pages allocated and the number
of items of that type per page.  
You should never try to change the value \fIopval\fP associates
with a data type using
\fIopval\fP.
.br
If s_arg is 
.i pagelimit
then 
.i opval 
will return (and set if g_newval is given)
the maximum amount of lisp data pages
it will allocate.
This limit should remain small unless you know your program requires 
lots of space as this limit will catch programs in infinite loops which
gobble up memory.
.Lf *process "'st_command ['g_readp ['g_writep]]"
.Re
either a fixnum if one argument is given, or a list of two ports and a
fixnum if two or three arguments are given.
.No
\fI*process\fP starts another process by passing st_command to the shell
(it first tries /bin/csh, then it tries /bin/sh if /bin/csh doesn't exist).
If only one argument is given to \fI*process\fP,
\fI*process\fP waits for the new
process to die and then returns the exit code of the new process.
If more two or three arguments are given, \fI*process\fP starts the process
and then returns a list which, depending on the value of g_readp
and g_writep, may contain i/o ports for communcating with the new
process.
If g_writep is non-null, then a port will be created which the lisp program
can use to send characters to the new process.
If g_readp is non-null, then a port will be created which the lisp program
can use to read characters from the new process.
The value returned by \fI*process\fP is (readport\ writeport\ pid)
where readport and writeport are either nil or a port based on the value
of g_readp and g_writep.  Pid is the process id of the new process.
Since it is hard to remember the order of g_readp and g_writep, the
functions \fI*process-send\fP and \fI*process-receive\fP were written to
perform the common functions.
.Lf *process-receive "'st_command"
.Re
a port which can be read.
.Se
The command st_command is given to the shell and it is started running in the
background.
The output of that command is available for reading via the port returned.
The input of the command process is set to /dev/null.
.Lf *process-send "'st_command"
.Re
a port which can be written to.
.Se
The command st_command is given to the shell and it is started runing in the
background.
The lisp program can provide input for that command
by sending characters to the port returned by this function.
The output of the command process is set to /dev/null.
.Lf process "s_pgrm [s_frompipe s_topipe]"
.Re
if the optional arguments are
not present a fixnum which is the exit code when s_prgm dies.
If the optional arguments are present, it returns a fixnum which
is the process id of the child.
.No
This command is obsolete.
New programs should use one of the \fI*process\fP commands
given above.
.Se
If s_frompipe and s_topipe are given, they are bound to 
ports which are pipes which
direct characters from 
.Fr
to the new process
and to
.Fr
from the new process respectively.
.i Process
forks a process named s_prgm and waits for it to die iff there
are no pipe arguments given.
.Lf ptime 
.Re
a list of two elements.
The first is the amount of processor time used
by the lisp system so far, and the 
second is the amount of time used by the garbage collector so far.
.No
the time is measured in those units used by the
.i times (2)
system call, usually 60\fIth\fPs of a second.
The first number includes the second number.
The amount of time used by garbage collection is not recorded
until the first call to ptime.
This is done to prevent overhead when the user is not interested in
garbage collection times.
.Lf reset
.Se
the lisp runtime stack is cleared and the system restarts at the top level 
by executing a \fI(funcall\ top-level\ nil)\fP.
.Lf restorelisp "'s_name"
.Se
this reads in file s_name (which was created by 
.i savelisp )
and then does a \fI(reset)\fP.
.No
This is only used on VMS systems where 
.i dumplisp
cannot be used.
.Lf retbrk "['x_level]
.Wh
x_level is a small integer of either sign.
.Se
The default error handler keeps a notion of the current level
of the error caught.  If x_level is negative, control is thrown
to this default error handler whose level is that many less than
the present, or to \fItop-level\fP if there aren't enough.
If x_level is non-negative, control is passed to the handler at
that level.  If x_level is not present, the value -1 is taken by
default.
.Lf *rset "'g_flag"
.Re
g_flag
.Se
If g_flag is non nil then the lisp system will maintain extra information
about calls to \fIeval\fP and \fIfuncall\fP.
This record keeping slows down the evaluation but this is 
required  for the functions
\fIevalhook\fP, \fIfuncallhook\fP, and \fIevalframe\fP to work. 
To debug compiled lisp code the transfer tables should be unlinked:
\fI(sstatus\ translink\ nil)\fP
.Lf savelisp "'s_name"
.Re
t
.Se
the state of the Lisp system is saved in the file s_name.
It can be read in by 
.i restorelisp .
.No
This is only used on VMS systems where 
.i dumplisp
cannot be used.
.Lf segment "'s_type 'x_size"
.Wh
s_type is one of the data types given in \(sc1.3
.Re
a segment of contiguous lispvals of type s_type.
.No
In reality, 
.i segment 
returns a new data cell of type s_type and allocates
space for x_size \- 1 more s_type's beyond the one returned.
.i Segment 
always allocates new space and does so in 512 byte chunks.
If you ask for 2 fixnums, segment will actually allocate 128 of them
thus wasting 126 fixnums.
The function
.i small-segment
is a smarter space allocator and should be used whenever possible.
.Lf shell
.Re
the exit code of the shell when it dies.
.Se
this forks a new shell and returns when the shell dies.
.Lf showstack
.Re
nil
.Se
all forms currently in evaluation are printed, beginning with the most recent.
For compiled code the most that 
showstack will show is the function name and it may miss
some functions.
.Lf signal "'x_signum 's_name"
.Re
nil if no previous call to signal has been made, or the previously
installed s_name.
.Se
this declares that the function named s_name 
will handle the signal number x_signum.
If s_name is nil, the signal is ignored.  Presently only
four UNIX signals are caught.
They and their numbers are:
Interrupt(2), Floating exception(8), Alarm(14), and
Hang-up(1).
.Lf sizeof "'g_arg"
.Re
the number of bytes required to store one object of type g_arg, encoded
as a fixnum.
.Lf small-segment "'s_type 'x_cells"
.Wh
s_type is one of fixnum, flonum and value.
.Re
a segment of x_cells data objects of type s_type.
.Se
This may call
.i segment
to allocate new space or it may be able to fill the request on a page
already allocated.
The value returned by 
.i small-segment 
is usually stored in the data subpart
of an array object.
.Lf sstatus "g_type g_val"
.Re
g_val
.Se
If g_type is not one of the special sstatus codes described in the 
next few pages
this simply sets g_val as the value of status 
type g_type in the system status property list.
.Lf sstatus\ appendmap "g_val"
.Re
g_val
.Se
If g_val is non-null when 
.i fasl
is told to create a load map, it will append to the file name given in
the 
.i fasl
command, rather than creating a new map file.
The initial value is nil.
.Lf sstatus\ automatic-reset "g_val"
.Re
g_val
.Se
If g_val is non-null when an error occurs which no one wants to 
handle, a 
.i reset
will be done instead of entering a primitive internal break loop.
The initial value is t.
.Lf sstatus\ chainatom "g_val"
.Re
g_val
.Se
If g_val is non nil and a 
.i car
or 
.i cdr
of a symbol is done, then nil will be returned instead of an error
being signaled.
This only affects the interpreter, not the compiler.
The initial value is nil.
.Lf sstatus\ dumpcore "g_val"
.Re
g_val
.Se
If g_val is nil, 
.Fr 
tells UNIX that a segmentation violation or 
bus error should cause a core dump.
If g_val is non nil then 
.Fr
will catch those errors and print a message advising the user to reset.
.No
The initial value for this flag is nil, and only those knowledgeable of
the innards of the lisp system should ever set this flag non nil.
.Lf sstatus\ dumpmode "x_val"
.Re
x_val
.Se
All subsequent 
.i dumplisp 's
will be done in mode x_val.
x_val may be either 413 or 410 (decimal).
.No
the advantage of mode 413 is that the dumped Lisp can be demand paged in when
first started, which will make it start faster and disrupt other users less.
The initial value is 413.
.Lf sstatus\ evalhook "g_val"
.Re
g_val
.Se
When g_val is non nil, this enables the 
evalhook and funcallhook traps in the evaluator.
See \(sc14.4 for more details.
.Lf sstatus\ feature "g_val"
.Re
g_val
.Se
g_val is added to the \fI(status\ features)\fP list, 
.Lf sstatus\ gcstrings "g_val"
.Re
g_val
.Se
if g_val is non-null, and if string garbage collection was enabled when
the lisp system was compiled, string space will be garbage collected.
.No
the default value for this is nil since in most applications garbage
collecting strings is a waste of time.
.Lf sstatus\ ignoreeof "g_val"
.Re
g_val
.Se
If g_val is non-null when
an end of file (CNTL-D on UNIX) is typed to the standard top-level interpreter,
it will be ignored rather then cause the lisp system to exit.
If the the standard input is a file or pipe then this has no effect,
an EOF will always cause lisp to exit.
The initial value is nil.
.Lf sstatus\ nofeature "g_val"
.Re
g_val
.Se
g_val is removed from the status features list if it was present.
.Lf sstatus\ translink "g_val"
.Re
g_val
.Se
If g_val is nil then all transfer tables are cleared and further calls
through the transfer table will not cause the fast links to be set up.
If g_val is the symbol 
.i on
then all possible transfer table entries will be linked and the flag
will be set to cause fast links to be set up dynamically.
Otherwise all that is done is to set the flag to cause fast links
to be set up dynamically.
The initial value is nil.
.No
For a discussion of transfer tables, see \(sc12.8.
.Lf sstatus\ uctolc "g_val"
.Re
g_val
.Se
If g_val is not nil then all unescaped capital letters 
in symbols read by the reader will be converted to lower case.
.No
This allows 
.Fr
to be compatible with single case lisp
systems (e.g. Maclisp, Interlisp and UCILisp).
.Lf status "g_code"
.Re
the value associated with the status code g_code
if g_code is not one of the special cases given below
.Lf status\ ctime 
.Re
a symbol whose print name is the current time and date.
.Ex
\fI(status ctime)\fP = |Sun Jun 29 16:51:26 1980|
.No
This has been made obsolete by \fItime-string\fP, described below.
.Lf status\ feature "g_val"
.Re
t iff g_val is in the status features list.
.Lf status\ features 
.Re
the value of the features code, which is a list of features which
are present in this system.
You add to this list with \fI(sstatus\ feature\ 'g_val)\fP
and test if feature g_feat is present with \fI(status\ feature\ 'g_feat)\fP.
.Lf status\ isatty 
.Re
t iff the standard input is a terminal.
.Lf status\ localtime
.Re
a list of fixnums representing the current time.
.Ex
\fI(status localtime)\fP =  (3 51 13 31 6 81 5 211 1)
.br
means 3\fIrd\fP second, 51\fIst\fP minute, 13\fIth\fP hour (1 p.m),
31\fIst\fP day, month 6 (0\ =\ January), year 81 (0\ =\ 1900),
day of the week 5 (0\ =\ Sunday), 211\fIth\fP day of the year
and daylight savings time is in effect.
.Lf status\ syntax "s_char"
.No
This function should not be used.
See the description of
.i getsyntax
(in Chapter 7) for a replacement.
.Lf status\ undeffunc
.Re
a list of all functions which transfer table entries point to but which
are not defined at this point.
.No
Some of the undefined functions listed could be arrays which have yet
to be created.
.Lf status\ version
.Re
a string which is the current lisp version name.
.Ex
\fI(status version)\fP = "Franz Lisp, Opus 38.61"
.Lf syscall "'x_index ['xst_arg1 ...]"
.Re
the result of issuing the UNIX system call number x_index with arguments
xst_arg\fIi\fP.
.No
The UNIX system calls are described in section 2 of the
UNIX Programmer's manual. 
If xst_arg\fIi\fP is a fixnum, then 
its value is passed as an argument, if it is a symbol then 
its pname is passed and finally if it is a string then the string itself
is passed as an argument.
Some useful syscalls are:
.br
\fI(syscall\ 20)\fP returns process id.
.br
\fI(syscall\ 13)\fP returns the number of seconds since Jan 1, 1970.
.br
\fI(syscall\ 10\ 'foo)\fP will unlink (delete) the file foo.
.Lf sys:access "'st_filename 'x_mode"
.Lx sys:chmod "'st_filename 'x_mode"
.Lx sys:gethostname
.Lx sys:getpid
.Lx sys:getpwnam 'st_username
.Lx sys:link "'st_oldfilename 'st_newfilename"
.Lx sys:time
.Lx sys:unlink 'st_filename
.No
We have been warned that the actual system call numbers may vary
among different UNIX systems.  Users concerned about portability
may wish to use this group of functions.
Another advantage is that tilde-expansion is performed on
all filename arguments.
These functions do what is described
in the system call section of your UNIX manual.
.br
.sp
.i sys:getpwnam
returns a vector of four entries from the password file, being
the user name, user id, group id, and home directory.
.Lf time-string "['x_seconds]"
.Re
an ascii string giving the time and date which was
x_seconds after UNIX's idea of creation
(Midnight, Jan 1, 1970 GMT).  If no argument is given,
time-string returns the current date.
This supplants \fI(status ctime)\fP, and may be used
to make the results of \fIfilestat\fP more intelligible.
.Lf top-level
.Re
nothing (it never returns)
.No
This function is the top-level read-eval-print loop.
It never returns any value.
Its main utility is that if you redefine it, and do a (reset) then the
redefined (top-level) is then invoked.
The default top-level for Franz, allow one to specify
his own printer or reader, by binding the symbols \fBtop-level-printer\fP
and \fBtop-level-reader\fP.
One can let the default top-level do most of the drudgery in catching
.i reset 's,
and reading in .lisprc files,
by binding the symbol \fBuser-top-level\fP, to a routine that
concerns itself only with the read-eval-print loop.
.Lf wait
.Re
a dotted pair \fI(processid . status)\fP when the
next child process dies. 
EndOfFile
cat >  doc/ch61.n  << 'EndOfFile'
." %W% %G%
.Lc "Local functions" 61
.pp
This chapter describes functions which we found 
useful at Berkeley.
Some of these functions may be useful at other sites
EndOfFile
cat >  doc/ch7.n  << 'EndOfFile'
." $Header: ch7.n,v 1.3 83/07/01 11:22:58 layer Exp $
.Lc The\ Lisp\ Reader 7
.sh 2 Introduction \n(ch 1
.pp
The 
.i read
function is responsible for converting
a stream of 
characters into a Lisp expression.
.i Read 
is table driven and the table it uses is called a 
.i readtable.
The 
.i print
function does the
inverse of 
.i read ;
it converts a Lisp expression into a stream of 
characters.
Typically the conversion is done in such
a way that if that stream of characters were read by 
.i read ,
the 
result would be an expression equal to the one
.i print
was given.
.i Print
must also refer to the readtable in order to determine
how to format its output.
The 
.i explode
function, which returns a list of characters rather than
printing them,  must also refer to the readtable.
.pp
A readtable is created
with the
.i makereadtable 
function, modified with the
.i setsyntax
function and interrogated with the
.i getsyntax 
function.
The structure of a readtable is hidden from the user  - a
readtable should
only be manipulated with the three functions mentioned above.
.pp
There is one distinguished readtable called the 
.i current
.i readtable 
whose value determines what
.i read ,
.i print 
and 
.i explode 
do.
The current readtable is the value of the symbol 
.i readtable .
Thus it is  possible to rapidly change 
the current syntax by lambda binding 
a different readtable to the symbol 
.i readtable.
When the binding is undone, the syntax reverts to its old form.
.sh +0 Syntax\ Classes
.pp
The readtable describes how each of the 128 ascii characters should
be treated by the reader and printer.
Each character belongs to a 
.i syntax 
.i class 
which has three properties:
.ip character\ class\ - 
Tells what the reader should do when it sees this character.
There are a large number of character classes.  
They are described below.
.ip separator\ -
Most types of tokens the reader constructs are one character
long.
Four token types have an arbitrary length: number (1234), 
symbol print name (franz),
escaped symbol print name (|franz|), and string ("franz").
The reader can easily determine when it has
come to the
end of one of the last two types: it just looks for the
matching delimiter (| or ").
When the reader is reading a number or symbol print name, it 
stops reading when it comes to a character with the 
.i separator
property.
The separator character is pushed back into the input stream and will
be the first character read when the reader is called again.
.ip escape\ -
Tells the printer when to put escapes in front of, or around, a symbol
whose print name contains this character.
There are three possibilities: always escape a symbol with this character
in it, only escape a symbol if this is the only character in the symbol,
and only escape a symbol if this is the first character in the symbol.
[note: The printer will always escape a symbol which, if printed out, would
look like a valid number.]
.pp
When the Lisp system is built, Lisp code is added to a C-coded kernel
and the result becomes the standard lisp system.
The readtable present in the C-coded kernel, called the
.i raw
.i readtable ,
contains the bare necessities for reading in Lisp code.
During the 
construction of the complete Lisp system,
a copy is made of the raw readtable and 
then the copy  is modified by adding macro characters.
The result is what is called the
.i standard
.i readtable .
When a new readtable is created with 
.i makereadtable,
a copy is made of either the
raw readtable
or the current readtable (which is likely to be the standard readtable).
.sh +0 Reader\ Operations
.pp
The reader has a very simple algorithm.
It is either 
.i scanning 
for a token, 
.i collecting 
a token,
or 
.i processing 
a token.
Scanning involves reading characters and throwing
away those which don't start tokens (such as blanks and tabs).
Collecting means gathering the characters which make up a
token into a buffer.
Processing may involve creating symbols, strings, lists, 
fixnums, bignums or flonums or calling a user written function called 
a character macro.
.pp
The components of the syntax class determine when the reader
switches between the scanning, collecting and processing states.
The reader will continue scanning as long as the character class
of the characters it reads is 
.i cseparator.
When it reads a character whose character class is not 
.i cseparator
it stores that character in its buffer and begins the collecting phase.
.pp
If the character class of that first character is 
.i ccharacter ,
.i cnumber ,
.i cperiod ,
or 
.i csign .
then it will continue collecting until it runs into a character whose
syntax class has the 
.i separator
property.
(That last character will be pushed back into the input buffer and will
be the first character read next time.)
Now the reader goes into the processing phase, checking to see if the
token it read is a number or symbol.
It is important to note that  after
the first character is collected the component of the syntax class which 
tells the reader to  stop 
collecting is the 
.i separator
property, not the character class.
.pp
If the character class of the character which stopped the scanning is not 
.i ccharacter ,
.i cnumber ,
.i cperiod ,
or
.i csign .
then the reader processes that character immediately.
The character classes
.i csingle-macro ,
.i csingle-splicing-macro ,
and 
.i csingle-infix-macro
will act like 
.i ccharacter
if the following token is not a 
.i separator.
The processing which is done for a given character class 
is described in detail in the next section.
.sh +0 Character\ Classes
.de Cc
.sp 2v
.tl '\fI\\$1\fP''raw readtable:\\$2'
.tl '''standard readtable:\\$3'
..
.pc
.Cc ccharacter A-Z\ a-z\ ^H\ !#$%&*,/:;<=>?@^_`{}~ A-Z\ a-z\ ^H\ !$%&*/:;<=>?@^_{}~
.pc %
A normal character.
.Cc cnumber 0-9 0-9
This type is a digit.  
The syntax for an integer (fixnum or bignum) is a string of 
.i cnumber
characters optionally followed by a 
.i cperiod.
If the digits are not followed by a
.i cperiod ,
then they are interpreted in base
.i ibase
which must be eight or ten.
The syntax for a floating point number is
either zero or more
.i cnumber 's
followed by a
.i cperiod
and then followed by one or more 
.i cnumber 's.
A floating point number
may also be  an integer or floating point number followed
by 'e' or 'd', an optional '+' or '\-'
and then zero or more 
.i cnumber 's.
.Cc csign +\- +\-
A leading sign for a number.  
No other characters should be given this class.
.Cc cleft-paren ( (
A left parenthesis.
Tells the reader to begin forming a list.
.Cc cright-paren ) )
A right parenthesis.
Tells the reader that it has reached the end of a list.
.Cc cleft-bracket [ [
A left bracket.
Tells the reader that it should begin forming a list.
See the description of 
.i cright-bracket
for the difference between cleft-bracket and cleft-paren.
.Cc cright-bracket ] ]
A right bracket.
A 
.i cright-bracket 
finishes the formation of the current
list and all enclosing lists until it finds one which
begins with a 
.i cleft-bracket 
or until it reaches the 
top level list.
.Cc cperiod . .
The period is used to separate element of a cons cell 
[e.g. (a\ .\ (b\ .\ nil)) is the same as (a\ b)].
.i cperiod
is also used in numbers as described above.
.Cc cseparator ^I-^M\ esc\ space ^I-^M\ esc\ space
Separates tokens.  When the reader is scanning, these character
are passed over.
Note: there is a difference between the
.i cseparator 
character class and the 
.i separator 
property of a syntax class.
.Cc csingle-quote \\' \\'
This causes 
.i read
to be called recursively and the list
(quote <value read>) to be returned.
.Cc csymbol-delimiter | |
This causes the reader to begin collecting characters and to stop only
when another identical
.i csymbol-delimiter
is seen.  
The only way to escape a 
.i csymbol-delimiter 
within a symbol name is with a
.i  cescape 
character.
The collected characters are converted into a string which becomes
the print name of a symbol.
If a symbol with an identical print name already exists, then the
allocation is not done, rather the existing symbol is used.
.Cc cescape \e \e
This causes the next character to read in to be treated as a 
.b vcharacter .
A character whose syntax class is
.b vcharacter 
has a character class
.i ccharacter
and does not have
the 
.i separator
property so it will not separate symbols.
.Cc cstring-delimiter """" """"
This is the same as 
.i csymbol-delimiter
except the result is returned as a string instead of a symbol.
.Cc csingle-character-symbol none none
This returns a symbol whose print name is the the single character
which has been collected.
.Cc cmacro none `,
The reader calls the macro function associated with this character and 
the current readtable, passing it no arguments.
The result of the macro is added to the structure the reader is building,
just as if that form were directly read by the reader.
More details on macros are provided below.
.Cc csplicing-macro none #;
A 
.i csplicing-macro 
differs from a 
.i cmacro
in the way the result is incorporated in the structure the reader is 
building.
A 
.i csplicing-macro
must return a list of forms (possibly empty).
The reader acts as
if it read each element of
the list itself without
the surrounding parenthesis.
.Cc csingle-macro none none
This causes to reader to check the next character.
If it is a 
.i cseparator
then this acts like a 
.i cmacro.
Otherwise, it acts like a 
.i ccharacter.
.Cc csingle-splicing-macro none none
This is triggered like a 
.i csingle-macro
however the result is spliced in like a
.i csplicing-macro.
.Cc cinfix-macro none none
This is differs from a 
.i cmacro
in that the macro function is passed a form representing what the reader
has read so far. 
The result of the macro replaces what the reader had read so far.
.Cc csingle-infix-macro none none
This differs from the
.i cinfix-macro
in that the macro will only be triggered if the character following the
.i csingle-infix-macro
character is a 
.i cseparator .
.Cc cillegal ^@-^G^N-^Z^\e-^_rubout ^@-^G^N-^Z^\e-^_rubout
The characters cause the reader to signal an error if read.
.sh +0 Syntax\ Classes
.pp
The readtable maps each character into a syntax class.
The syntax class contains three pieces of information: 
the character class, whether this is a separator, and the escape
properties.
The first two properties are used by the reader, the last by 
the printer (and 
.i explode ).
The initial lisp system has the following syntax classes defined.
The user may add syntax classes with
.i add-syntax-class .
For each syntax class, we list the properties of the class and 
which characters have this syntax class by default.
More information about each syntax class can be found under the
description of the syntax class's character class.
.de Sy
.sp 1v
.tl '\fB\\$1\fP''raw readtable:\\$2'
.tl '\fI\\$4\fP''standard readtable:\\$3'
.tl '\fI\\$5\fP'''
.tl '\fI\\$6\fP'''
..
.pc
.Sy vcharacter A-Z\ a-z\ ^H\ !#$%&*,/:;<=>?@^_`{}~ A-Z\ a-z\ ^H\ !$%&*/:;<=>?@^_{}~  ccharacter
.pc %
.Sy vnumber 0-9 0-9 cnumber
.Sy vsign +- +- csign
.Sy vleft-paren ( ( cleft-paren escape-always separator
.Sy vright-paren ) ) cright-paren escape-always separator
.Sy vleft-bracket [ [ cleft-bracket escape-always separator 
.Sy vright-bracket ] ] cright-bracket escape-always separator 
.Sy vperiod . . cperiod escape-when-unique
.Sy vseparator ^I-^M\ esc\ space ^I-^M\ esc\ space cseparator escape-always separator 
.Sy vsingle-quote \\' \\' csingle-quote escape-always separator 
.Sy vsymbol-delimiter | | csingle-delimiter escape-always
.Sy vescape \e \e cescape escape-always
.Sy vstring-delimiter """" """" cstring-delimiter escape-always
.Sy vsingle-character-symbol none none csingle-character-symbol separator
.Sy vmacro none `, cmacro escape-always separator 
.Sy vsplicing-macro none #; csplicing-macro escape-always separator 
.Sy vsingle-macro none none csingle-macro escape-when-unique
.Sy vsingle-splicing-macro none none csingle-splicing-macro escape-when-unique
.Sy vinfix-macro none none cinfix-macro escape-always separator 
.Sy vsingle-infix-macro none none csingle-infix-macro escape-when-unique
.Sy villegal ^@-^G^N-^Z^\e-^_rubout ^@-^G^N-^Z^\e-^_rubout cillegal escape-always separator 
.sh +0 Character\ Macros
.pp
Character macros are 
user written functions which are executed during the reading process.
The value returned by a character macro may or may not be used by 
the reader, depending on the type of macro and the value returned.
Character macros are always attached to a single character with
the 
.i setsyntax 
function.
.sh +1 Types
There are three types of character macros: normal, splicing and infix.
These types differ in the arguments they are given or in what is done
with the result they return.
.sh +1 Normal
.pp
A normal macro
is passed no arguments.
The value returned by a normal macro is simply used by
the reader as if it had read the value itself.
Here is an example of a macro which returns the abbreviation 
for a given state.
.Eb
\->\fI(de\kAfun stateabbrev nil
 \h'|\nAu'(cdr (assq (read) '((california . ca) (pennsylvania . pa)))))\fP
stateabbrev
\-> \fI(setsyntax '\e! 'vmacro 'stateabbrev)\fP
t
\-> \fI'( ! california ! wyoming ! pennsylvania)\fP
(ca nil pa)
.Ee
Notice what happened to 
\fI ! wyoming\fP.
Since it wasn't in the table, the associated function
returned nil.
The creator of the macro may have wanted to leave the
list alone, in such a case, but couldn't with this
type of reader macro.
The splicing macro, described next, allows a character macro function
to return a value that is ignored.
.sh +0 Splicing
.pp
The value returned from a splicing macro must be a list or nil.
If the value is nil, then the value is ignored, otherwise the reader
acts as if it read each object in the list.
Usually the list only contains one element. 
If the reader is reading at the top level (i.e. not collecting elements
of list),
then it is illegal for a splicing macro to return more then one
element in the list.
The major advantage of a splicing macro over a normal macro is the
ability of the splicing macro to return nothing. 
The comment character (usually ;) is a splicing macro bound to a
function which reads to the end of the line and always returns nil.
Here is the previous example written as a splicing macro
.Eb
\-> \fI(de\kAfun stateabbrev nil
\h'|\nAu'(\kC(lam\kBbda (value)
 \h'|\nBu'(cond \kA(value (list value))
 \h'|\nAu'(t nil)))
 \h'|\nCu'(cdr (assq (read) '((california . ca) (pennsylvania . pa))))))\fP
\-> \fI(setsyntax '! 'vsplicing-macro 'stateabbrev)\fP
\-> \fI'(!pennsylvania ! foo !california)\fP
(pa ca)
\-> \fI'!foo !bar !pennsylvania\fP
pa
\-> 
.Ee
.sh +0 Infix
.pp
Infix macros are passed a 
.i conc
structure representing what has been read so far.
Briefly, a 
tconc
structure is a single list cell whose car points to 
a list and whose cdr points to the last list cell in that list.
The interpretation by the reader of the value 
returned by  an infix macro depends on
whether the macro is called while the reader is constructing a 
list or whether it is called at the top level of the reader.
If the macro is called while a list is
being constructed, then the value returned should be  a tconc
structure.
The car of that structure replaces the list of elements that the
reader has been collecting.
If the macro is called at top level, then it will be passed the
value nil, and the value it returns should either be nil
or a tconc structure.
If the macro returns nil, then the value is ignored and the reader
continues to read.
If the macro returns a tconc structure of one element (i.e. whose car
is a list of one element), then that single element is returned
as the value of 
.i read.
If the macro returns a tconc structure of more than one element,
then that list of elements is returned as the value of read.
.Eb
\-> \fI(de\kAfun plusop (x)
   \h'|\nAu'(cond \kB((null x) (tconc nil '\e+))
	 \h'|\nBu'(t (lconc nil (list 'plus (caar x) (read))))))\fP

plusop
\-> \fI(setsyntax '\e+ 'vinfix-macro 'plusop)\fP
t
\-> \fI'(a + b)\fP
(plus a b)
\-> \fI'+\fP
|+|
\-> 
.Ee
.sh -1 Invocations
.pp
There are three different circumstances in which you would like
a macro function to be triggered.
.ip \fIAlways\ -\fP
Whenever the macro character is seen, the macro should be invoked.
This is accomplished by using the character classes 
.i cmacro ,
.i csplicing-macro ,
or 
.i cinfix-macro ,
and by using the
.i separator 
property.
The syntax classes 
.b vmacro ,
.b vsplicing-macro ,
and 
.b vsingle-macro
are defined this way.
.ip \fIWhen\ first\ -\fP
The macro should only be triggered when the macro character is the first
character found after the scanning process.
A syntax class for a 
.i when
.i first
macro would
be defined
using
.i cmacro , 
.i csplicing-macro ,
or 
.i cinfix-macro
and not including the 
.i separator 
property.
.ip \fIWhen\ unique\ -\fP
The macro should only be triggered when the macro character is the only
character collected in the token collection
phase of the reader, 
i.e the macro character is preceeded by zero or more 
.i cseparator s
and followed by a 
.i separator.
A syntax class for a 
.i when
.i unique
macro would
be defined using
.i csingle-macro ,
.i csingle-splicing-macro ,
or 
.i csingle-infix-macro
and not including the
.i separator 
property.
The syntax classes so defined are
.b vsingle-macro ,
.b vsingle-splicing-macro ,
and
.b vsingle-infix-macro .
.sh -1 Functions
.Lf setsyntax 's_symbol\ 's_synclass\ ['ls_func]
.Wh
ls_func is the name of a function or a lambda body.
.Re
t
.Se
S_symbol should be a symbol whose print name is only one character.
The syntax class for 
that character is
set to s_synclass in the current readtable.
If s_synclass is a class that requires a character macro, then
ls_func must be supplied. 
.No
The symbolic syntax codes are new to Opus 38.
For compatibility, s_synclass can be one of the fixnum syntax codes
which appeared in older versions of the 
.Fr
Manual.
This compatibility is only temporary: existing code which uses the
fixnum syntax codes should be converted.
.Lf getsyntax 's_symbol
.Re
the syntax class of the first character 
of s_symbol's print name.
s_symbol's print name must be exactly one character long.
.No
This function is new to Opus 38.
It supercedes \fI(status\ syntax)\fP which no longer exists.
.Lf add-syntax-class 's_synclass\ 'l_properties
.Re
s_synclass
.Se
Defines the syntax class s_synclass to have properties l_properties.
The list l_properties should contain a character classes mentioned
above.
l_properties may contain one of the escape properties:
.i escape-always ,
.i escape-when-unique ,
or 
.i escape-when-first .
l_properties may contain the 
.i separator
property.
After a syntax class has been defined with 
.i add-syntax-class ,
the 
.i setsyntax
function can be used to give characters that syntax class.
.Eb
; Define a non-separating macro character.  
; This type of macro character is used in UCI-Lisp, and
; it corresponds to a  FIRST MACRO in Interlisp
\-> \fI(add-syntax-class 'vuci-macro '(cmacro escape-when-first))\fP
vuci-macro
\->
.Ee
EndOfFile
cat >  doc/ch8.n  << 'EndOfFile'
." $Header: ch8.n,v 1.4 83/07/27 15:12:22 layer Exp $
.Lc Functions,\ Fclosures,\ and\ Macros 8
.sh 2 valid\ function\ objects 8
.pp
There are many different objects which can occupy the function field of 
a symbol object.
Table 8.1, on the following page,
shows all of the possibilities, how to recognize them,
and where to look for documentation.
.(z
.sp 1v
.TS
box center ;
c | c | c .
informal name	object type	documentation 
=
interpreted	list with \fIcar\fP	8.2
lambda function	\fIeq\fP to lambda
_
interpreted	list with \fIcar\fP	8.2
nlambda function	\fIeq\fP to nlambda
_
interpreted	list with \fIcar\fP	8.2
lexpr function	\fIeq\fP to lexpr
_
interpreted	list with \fIcar\fP	8.3
macro	\fIeq\fP to macro
_
fclosure	vector with \fIvprop\fP	8.4
	\fIeq\fP to fclosure
_
compiled	binary with discipline	8.2
lambda or lexpr	\fIeq\fP to lambda
function
_
compiled	binary with discipline	8.2
nlambda function	\fIeq\fP to nlambda
_
compiled	binary with discipline	8.3
macro	\fIeq\fP to macro
_
foreign	binary with discipline	8.5
subroutine	of \*(lqsubroutine\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
function	of \*(lqfunction\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
integer function	of \*(lqinteger-function\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
real function	of \*(lqreal-function\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
C function	of \*(lqc-function\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
double function	of \*(lqdouble-c-function\*(rq\*[\(dg\*]
_
foreign	binary with discipline	8.5
structure function	of \*(lqvector-c-function\*(rq\*[\(dg\*]
_
array	array object	9
.TE
.tl ''Table 8.1''
.(f
\*[\(dg\*]Only the first character of the string is significant (i.e \*(lqs\*(rq
is ok for \*(lqsubroutine\*(rq)
.)f
.)z
.br
.sh 2 functions
.pp
The basic Lisp function is the lambda function.
When a lambda function is called, the actual arguments are
evaluated from left to right and are lambda-bound to the
formal parameters of the lambda function.
.pp
An nlambda function is usually used for functions which are invoked
by the user at top level.
Some built-in functions which evaluate their arguments in special ways are
also nlambdas (e.g \fIcond\fP, \fIdo\fP, \fIor\fP).
When an nlambda function is called, the list of unevaluated arguments
is lambda bound to the single formal parameter of the nlambda function.
.pp
Some programmers will use an nlambda function 
when they are not sure how many arguments
will be passed.
Then, the first thing the nlambda function does is map \fIeval\fP over
the list of unevaluated arguments it has been passed.
This is usually the wrong thing to do, as it will not work compiled if
any of the arguments are local variables. 
The solution is to use a lexpr.
When a lexpr function is called, the arguments
are evaluated and a fixnum whose value is
the number of arguments is lambda-bound to the single
formal parameter of the lexpr function.
The lexpr can then access the arguments using the \fIarg\fP function.
.pp
When a function is compiled,
.i special 
declarations may be needed to 
preserve its behavior.
An argument is not lambda-bound to the name of
the corresponding formal parameter 
unless that formal parameter has been declared 
.i special 
(see \(sc12.3.2.2).
.pp
Lambda and lexpr functions both compile into a binary object with
a discipline of lambda.
However, a compiled lexpr still acts like an interpreted lexpr.
.sh 2 macros
.pp
An important feature of Lisp 
is its ability to manipulate programs as data.
As a result of this, most Lisp implementations
have very powerful macro facilities.
The Lisp language's macro facility
can be used to incorporate popular features of the other
languages into Lisp.
For example, there are macro packages 
which allow one to create records (ala Pascal) 
and refer to elements of those records by the field names.
The 
.i struct
package imported from Maclisp does this.
Another popular use for macros is to create more readable control 
structures which expand into 
.i cond , 
.i or 
and 
.i and .
One such example is the If macro.
It allows you to write
.sp 1v
.nf
.ft I
(If (equal numb 0) then (print 'zero) (terpr)
\ elseif (equal numb 1) then (print 'one) (terpr)
\ else (print '|I give up|))
.ft P
.sp 1v
which expands to 
.sp 1v
.ft I
(cond 
\ \ \ \ ((equal numb 0) (print 'zero) (terpr))
\ \ \ \ ((equal numb 1) (print 'one) (terpr))
\ \ \ \ (t (print '|I give up|)))
.ft P
.sp 1v
.fi
.sh 3  macro\ forms
.pp
A macro is a function which accepts a Lisp expression as input and returns
another Lisp expression.
The action the macro takes is called macro expansion.
Here is a simple example:
.sp 1v
.nf
\-> \fI(def first (macro (x) (cons 'car (cdr x))))\fP
first
\-> \fI(first '(a b c))\fP
a
\-> \fI(apply 'first '(first '(a b c)))\fP
(car '(a b c))
.fi
.sp 1v
The first input line defines a macro called 
.i first .
Notice that the macro has one formal parameter, \fIx\fP.  
On the second input line, we ask the interpreter to evaluate
\fI(first\ '(a\ b\ c))\fP.
.i Eval 
sees that 
.i first
has a function definition of type macro, so it evaluates 
.i first 's 
definition,
passing to 
.i first ,
as an argument, the form 
.i eval 
itself
was trying to
evaluate: \fI(first\ '(a\ b\ c))\fP.
The 
.i first 
macro chops off the car of the argument with
.i cdr ,
cons' a 
.i car
at the beginning of the list and returns \fI(car\ '(a\ b\ c))\fP,
which
.i eval 
evaluates.
The value
.i a
is returned as the value of \fI(first\ '(a\ b\ c))\fP.
Thus whenever 
.i eval
tries to evaluate a list whose car has a macro definition
it ends up doing (at least) two operations, the first of which
is a call to the macro
to let it macro expand the form, and the other is the evaluation of the
result of the macro.
The result of the macro may be yet another call to a macro, so 
.i eval
may have to do even more evaluations until it can finally determine
the  value of an expression.
One way to see how a macro will expand is to use
.i apply
as shown on the third input line above.
.sh +0 defmacro
.pp
The macro 
.i defmacro
makes it easier to define macros because it allows you to name the arguments
to the macro call.
For example, suppose we find ourselves often writing code like
\fI(setq\ stack\ (cons\ newelt\ stack)\fP.
We could define a macro named \fIpush\fP to do this for us.
One way to define it is:
.nf
.sp 1v
\-> \fI(de\kAf push 
\h'|\nAu'(macro (x) (list 'setq (caddr x) (list 'cons (cadr x) (caddr x)))))\fP
push
.fi
.sp 1v
then \fI(push\ newelt\ stack)\fP will expand to the form mentioned above.
The same macro written using defmacro would be:
.nf
.sp 1v
\->\fI\kA (defmacro push (value stack)
  \h'|\nAu'(list 'setq ,stack (list 'cons ,value ,stack)))\fP
push
.fi
.sp 1v
Defmacro allows you to name the arguments of the macro call, and makes the 
macro definition look more like a function definition.
.sh +0 the\ backquote\ character\ macro
.pp
The default syntax for 
.Fr
has four characters with associated character macros.
One is semicolon for comments.
Two others are the backquote and comma which are
used by the backquote character
macro.
The fourth is the sharp sign macro described in the next section.
.pp
The backquote macro is used to create lists where many of the elements are
fixed (quoted). 
This makes it very useful for creating macro definitions.
In the simplest case, a backquote acts just like a single quote:
.sp 1v
.nf
\->\fI`(a b c d e)\fP
(a b c d e)
.fi
.sp 1v
If a comma precedes an element of a backquoted list then that element is
evaluated and its value is put in the list.
.sp 1v
.nf
\->\fI(setq d '(x y z))\fP
(x y z)
\->\fI`(a b c ,d e)\fP
(a b c (x y z) e)
.fi
.sp 1v
If a comma followed by an at sign precedes an element in a backquoted list,
then that element is evaluated and spliced into the list with 
.i append .
.nf
.sp 1v
\->\fI`(a b c ,@d e)\fP
(a b c x y z e)
.sp 1v
.fi
Once a list begins with a backquote, the commas may appear anywhere in the
list as this example shows:
.nf
.sp 1v
\->\fI`(a b (c d ,(cdr d)) (e f (g h ,@(cddr d) ,@d)))\fP
(a b (c d (y z)) (e f (g h z x y z)))
.sp 1v
.fi
It is also possible and sometimes even useful to use the 
backquote macro within itself.
As a final demonstration of the backquote macro, we shall define the 
first and push macros using all the power at our disposal: defmacro
and the backquote macro.
.sp 1v
.nf
\->\fI(defmacro first (list) `(car ,list))\fP
first
\->\fI(defmacro push (value stack) `(setq ,stack (cons ,value ,stack)))\fP
stack
.fi
.sh +0 sharp\ sign\ character\ macro
.pp
The sharp sign macro can perform a number of
different functions  at read time.
The character directly following the sharp sign determines which function
will be done, and following Lisp s-expressions may serve as arguments.
.sh +1 conditional\ inclusion
.lp
If you plan to run one source file in more than one environment then 
you may want to some pieces of code to be included  or not included
depending on the environment.  
The C language uses \*(lq#ifdef\*(lq and \*(lq#ifndef\*(rq for this 
purpose, and Lisp uses \*(lq#+\*(rq and \*(lq#\-\*(rq.
The environment that the sharp sign macro checks is the 
\fI(status\ features)\fP list which is initialized when the Lisp
system is built  and which may be  altered by 
\fI(sstatus\ feature\ foo)\fP and \fI(sstatus\ nofeature\ bar)\fP
The form  of conditional inclusion is
.br
.tl ''\fI#+when what\fP''
where 
.i when 
is either a symbol or an expression involving symbols and the functions
.i and ,
.i or ,
and
.i not .
The meaning is that 
.i what
will only be read in if  
.i when
is true.
A symbol in 
.i when
is true only if it appears in the 
.i (status\ features)
list.
.Eb
; suppose we want to write a program which references a file
; and which can run at ucb, ucsd and cmu where the file naming conventions
; are different.
;
\-> \fI(de\kAfun howold (name)
   \h'|\nAu'\kC(terpr)
   \h'|\nCu'\kB(load #\kA+(or ucb ucsd) "/usr/lib/lisp/ages.l"
          \h'|\nAu'#+cmu "/usr/lisp/doc/ages.l")
   \h'|\nBu'\kA(patom name)
   \h'|\nBu'\kA(patom " is ")
   \h'|\nAu'\kB(print (cdr (assoc name agefile)))
   \h'|\nBu'\kA(patom "years old")
   \h'|\nAu'(terpr))\fP
.Ee
The form
.br
.tl ''\fI#\-when what\fP''
is equivalent to
.br
.tl ''\fI#+(not when) what\fP''
.sh +0 fixnum\ character\ equivalents
.lp
When working with fixnum equivalents of characters, it is often hard to
remember the number corresponding to a character.
The form
.br
.tl ''\fI#/c\fP''
is equivalent to the fixnum representation of character c.
.Eb
; a function which returns t if the user types y else it returns nil.
;
\-> \fI(de\kBfun yesorno nil
   \h'|\nBu'(progn \kA(ans)
          \h'|\nAu'\kB(setq ans (tyi))
          \h'|\nBu'(cond \kA((equal ans #/y) t)
                \h'|\nAu'(t nil))))\fP
.Ee
.sh +0 read\ time\ evaluation
.lp
Occasionally you want to express a constant as a Lisp expression, yet you
don't want to pay the penalty of evaluating this expression each time it
is referenced.
The form
.br
.tl ''\fI#.expression\fP''
evaluates the expression at read time and returns its value.
.Eb
; a function to test if any of bits 1 3 or 12 are set in a fixnum.
;
\-> \fI(de\kCfun testit (num)
   \h'|\nCu'(cond \kA(\kB(zerop (boole 1 num #.(+ (lsh 1 1) (lsh 1 3) (lsh 1 12))))
          \h'|\nBu'nil)
         \h'|\nAu'(t t)))\fP
.Ee
.sh 2 fclosures
.pp
Fclosures are a type of functional object.
The purpose is to remember the values of some variables 
between invocations of the functional object and to protect this
data from being inadvertently overwritten by other Lisp functions.
Fortran programs usually exhibit this behavior for their variables.
(In fact, some versions of Fortran would require the
variables to be in COMMON).
Thus it is easy to write a linear congruent random number generator
in Fortran, merely by keeping the seed as a variable in the function.
It is much more risky to do so in Lisp, since any special variable you
picked, might be used by some other function.
Fclosures are an attempt to provide most of the same functionality as
closures in Lisp Machine Lisp, to users of
.Fr .
Fclosures are related to closures in this way:
.br
(fclosure '(a b) 'foo) <==>
.br
	(let ((a a) (b b)) (closure '(a b) 'foo))
.sh 3 an\ example
.sp 1v
.in 0
.nf
.sz -2
.hl
% \fBlisp\fP
Franz Lisp, Opus 38.60
\->\fB(defun code (me count)
  (print (list 'in x))
  (setq x (+ 1 x))
  (cond ((greaterp count 1) (funcall me me (sub1 count))))
  (print (list 'out x)))\fP
code
\->\fB(defun tester (object count)
  (funcall object object count) (terpri))\fP
tester
\->\fB(setq x 0)\fP
0
\->\fB(setq z (fclosure '(x) 'code))\fP
fclosure[8]
\->\fB (tester z 3)\fP
(in 0)(in 1)(in 2)(out 3)(out 3)(out 3)
nil
\->\fBx\fP
0
.hl
.fi
.sz +2
.sp 3v
.pp
The function \fIfclosure\fP creates a new object
that we will call an fclosure,
(although it is actually a vector).
The fclosure contains a functional object, and a set of symbols and
values for the symbols.  In the above example, the fclosure functional
object is the function code.
The set of symbols and values just contains the symbol `x' and
zero, the value of `x' when the fclosure was created.
.lp
When an fclosure is funcall'ed:
.ip 1)
The Lisp system lambda binds the symbols in the fclosure to their values in the fclosure.
.ip 2)
It continues the funcall on the functional object of the fclosure.
.ip 3)
Finally, it un-lambda binds the symbols in the fclosure and at the
same time stores the current values of the symbols in the fclosure.
.sp 1v
.pp
Notice that the fclosure is saving the value of the symbol `x'.
Each time a fclosure is created, new space is allocated for saving
the values of the symbols. Thus if we execute fclosure again, over
the same function, we can have two independent counters:
.sp 1v
.in 0
.nf
.sz -2
.hl
\-> \fB(setq zz (fclosure '(x) 'code))\fP
fclosure[1]
\-> \fB(tester zz 2)\fP
(in 0)(in 1)(out 2)(out 2)
\-> \fB(tester zz 2)\fP
(in 2)(in 3)(out 4)(out 4)
\-> \fB(tester z 3)\fP
(in 3)(in 4)(in 5)(out 6)(out 6)(out 6)
.hl
.fi
.sz +2
.sp 3v
.sh 3 useful\ functions
.pp
Here are some quick some summaries of functions dealing with closures.
They are more formally defined in \(sc2.8.4.
To recap, fclosures are made by
\fI(fclosure 'l_vars 'g_funcobj)\fP.
l_vars is a list of symbols (not containing nil),
g_funcobj is any object that can be funcalled.
(Objects which can be funcalled, include compiled Lisp functions,
lambda expressions, symbols, foreign functions, etc.)
In general, if you want a compiled function to be closed over a
variable, you must declare the variable to be special within the function.
Another example would be:
.(l
	(fclosure '(a b) #'(lambda (x) (plus x a)))
.)l
Here, the #' construction will make the compiler compile the lambda expression.
.pp
There are times when you want to share variables between fclosures.
This can be done if the fclosures are created at the same time using
\fIfclosure-list\fP.
The function \fIfclosure-alist\fP returns an assoc list giving
the symbols and values in the fclosure.  The predicate
\fIfclosurep\fP returns t iff its argument is a fclosure.
Other functions imported from Lisp Machine Lisp are
.i symeval-in-fclosure,
.i let-fclosed,
and
.i set-in-fclosure.
Lastly, the function \fIfclosure-function\fP returns the function argument.
.sh 3 internal\ structure
.pp
Currently, closures are implemented as vectors, with property being the
symbol fclosure.  The functional object is the first entry.
The remaining entries are structures which point to the symbols
and values for the closure, (with a reference count to determine
if a recursive closure is active).
.sh 2 foreign\ subroutines\ and\ functions
.pp
.Fr 
has the ability to dynamically load object files produced by other compilers
and to call functions defined in those files.
These functions are called 
.i foreign
functions.*
.(f
*This topic is also discussed in Report PAM-124 of the Center for
Pure and Applied Mathematics, UCB, entitled ``Parlez-Vous Franz?
An Informal Introduction to Interfacing Foreign Functions to Franz LISP'',
by James R. Larus
.)f
There are seven types of foreign functions.
They are characterized by
the type of result they return, and by differences in the interpretation
of their arguments.
They come from two families: a group suited for languages which pass
arguments by reference (e.g. Fortran), and a group suited for languages
which pass arguments by value (e.g. C).
.sp 1v
.lp
There are four types in the first group:
.ip \fBsubroutine\fP
This does not return anything. 
The Lisp system
always returns t after calling a subroutine.
.ip \fBfunction\fP
This returns whatever the function returns.
This must be a valid Lisp object or it may cause the Lisp system to fail.
.ip \fBinteger-function\fP
This returns an integer which the Lisp system makes into a fixnum and returns.
.ip \fBreal-function\fP
This returns a double precision real number which the Lisp
system makes into a flonum and returns.
.sp 1v
.lp
There are three types in the second group:
.ip \fBc-function\fP
This is like an integer function, except for its different interpretation
of arguments.
.ip \fBdouble-c-function\fP
This is like a real-function.
.ip \fBvector-c-function\fP
This is for C functions which return a structure.
The first argument to such functions must be a vector (of type vectori),
into which the result is stored.
The second Lisp argument
becomes the first argument to the C function, and so on
.lp
A foreign function is accessed through a binary object just like a 
compiled Lisp function.
The difference is that the discipline field of a binary object
for a foreign function is a string 
whose first character is given in the following table:
.sp 1v
.TS
box center ;
c | c .
letter	type
=
s	subroutine
_
f	function
_
i	integer-function
_
r	real-function.
_
c	c-function
_
v	vector-c-function
_
d	double-c-function
_
.TE
Two functions are provided for setting-up foreign functions.
.i Cfasl
loads an object file into the Lisp system and sets up one foreign
function binary object.
If there are more than one function in an object file, 
.i getaddress
can be used to set up additional foreign function objects.
.pp
Foreign  functions are called just like other functions, e.g 
\fI(funname\ arg1\ arg2)\fP.
When a function in the Fortran group is called,
the arguments are evaluated and then examined.
List, hunk and symbol arguments are passed unchanged to 
the foreign function.
Fixnum and flonum arguments are copied into a temporary location and
a pointer to the value is passed (this is because Fortran uses call
by reference and it is dangerous to modify the contents of a fixnum
or flonum which something else might point to).
If the argument is an array object,
the data field of the array object is
passed to the foreign function
(This is the easiest way to send large
amounts of data to and receive large amounts of data from a foreign
function).
If a binary object is an argument, the entry field of that object is
passed to the foreign function (the entry field is the address of a function,
so this amounts to passing a function as an argument).
.pp
When a function in the C group is called,
fixnum and flownum arguments are passed by value.
For almost all other arguments,
the address is merely provided to the C routine.
The only exception arises when you want to invoke a C routine
which expects a ``structure'' argument.  Recall that a (rarely used)
feature of the C language is the ability to pass structures by value.
This copies the structure onto the stack.  Since the Franz's nearest
equivalent to a C structure is a vector, we provide an escape clause
to copy the contents of an immediate-type vector by value.  If the
property field of a vectori argument, is the symbol
\*(lqvalue-structure-argument\*(rq,
then the binary data of this immediate-type vector is copied
into the argument list of the C routine.
.pp
The method a foreign function uses to access the arguments provided 
by Lisp is dependent on the language of the foreign function.
The following scripts demonstrate how how Lisp can interact with three
languages: C, Pascal and Fortran.
C and Pascal have pointer types and the first script shows how to use
pointers to extract information from Lisp objects.
There are two functions defined for each language.
The first (cfoo in C, pfoo in Pascal) is given four arguments, a 
fixnum, a flonum-block array, a hunk of at least two
fixnums and a list of 
at least two fixnums.
To demonstrate that the values were passed, each ?foo function prints
its arguments (or parts of them).
The ?foo function then modifies the second element of 
the flonum-block array and returns a 3 to Lisp.
The second function (cmemq in C, pmemq in Pascal) acts just like the
Lisp
.i memq
function (except it won't work for fixnums whereas the lisp 
.i memq
will work for small fixnums).
In the script, typed input is in 
.b bold ,
computer output is in roman
and comments are in
.i italic.
.in 0
.nf
.sp 2v
.sz -2
.hl
\fIThese are the C coded functions  \fP
% \fBcat ch8auxc.c\fP
/* demonstration of c coded foreign integer-function */

/* the following will be used to extract fixnums out of a list of fixnums */
struct listoffixnumscell
{    struct listoffixnumscell *cdr;
     int *fixnum;
};

struct listcell
{	struct listcell *cdr;
	int car;
};

cfoo(a,b,c,d)
int *a;
double b[];
int *c[];
struct listoffixnumscell *d;
{
    printf("a: %d, b[0]: %f, b[1]: %f\n", *a, b[0], b[1]);
    printf(" c (first): %d   c (second): %d\n",
	       *c[0],*c[1]);
    printf(" ( %d %d ... )\n ", *(d->fixnum), *(d->cdr->fixnum));
    b[1] = 3.1415926;
    return(3);
}

struct listcell *
cmemq(element,list)
int element;
struct listcell *list;
{   
   for( ; list && element != list->car ;  list = list->cdr);
   return(list);
}
.sp 2v
\fIThese are the Pascal coded functions \fP
% \fBcat ch8auxp.p\fP
type 	pinteger = ^integer;
	realarray = array[0..10] of real;
	pintarray = array[0..10] of pinteger;
	listoffixnumscell = record  
				cdr  : ^listoffixnumscell;
				fixnum : pinteger;
			    end;
	plistcell = ^listcell;
	listcell = record
		      cdr : plistcell;
		      car : integer;
		   end;

function pfoo ( var a : integer ; 
		var b : realarray;
		var c : pintarray;
		var d : listoffixnumscell) : integer;
begin
   writeln(' a:',a, ' b[0]:', b[0], ' b[1]:', b[1]);
   writeln(' c (first):', c[0]^,' c (second):', c[1]^);
   writeln(' ( ', d.fixnum^, d.cdr^.fixnum^, ' ...) ');
   b[1] := 3.1415926;
   pfoo := 3
end ;

{ the function pmemq looks for the Lisp pointer given as the first argument
  in the list pointed to by the second argument.
  Note that we declare " a : integer " instead of " var a : integer " since
  we are interested in the pointer value instead of what it points to (which
  could be any Lisp object)
}
function pmemq( a : integer; list : plistcell) : plistcell;
begin
 while (list <> nil) and (list^.car <> a) do list := list^.cdr;
 pmemq := list;
end ;
.sp 2v
\fIThe files are compiled\fP
% \fBcc -c ch8auxc.c\fP
1.0u 1.2s 0:15 14% 30+39k 33+20io 147pf+0w
% \fBpc -c ch8auxp.p\fP
3.0u 1.7s 0:37 12% 27+32k 53+32io 143pf+0w
.sp 2v
% \fBlisp\fP
Franz Lisp, Opus 38.60
.ft I
.fi
First the files are loaded and we set up one foreign function binary.
We have two functions in each file so we must choose one to tell cfasl about.
The choice is arbitrary.
.ft P
.br 
.nf
\->\fB (cfasl 'ch8auxc.o '_cfoo 'cfoo "integer-function")\fP
/usr/lib/lisp/nld -N -A /usr/local/lisp -T 63000 ch8auxc.o -e _cfoo -o /tmp/Li7055.0  -lc
#63000-"integer-function"
\->\fB (cfasl 'ch8auxp.o '_pfoo 'pfoo "integer-function" "-lpc")\fP
/usr/lib/lisp/nld -N -A /tmp/Li7055.0 -T 63200 ch8auxp.o -e _pfoo -o /tmp/Li7055.1 -lpc -lc
#63200-"integer-function"
.ft I
Here we set up the other foreign function binary objects
.ft P
\->\fB (getaddress '_cmemq 'cmemq "function" '_pmemq 'pmemq "function")\fP
#6306c-"function"
.ft I
.fi
We want to create and initialize an array to pass to the cfoo function.
In this case we create an unnamed array and store it in the value cell of
testarr. 
When we create an array to pass to the Pascal program we will use a named
array just to demonstrate the different way that named and unnamed arrays
are created and accessed.
.br
.nf
.ft P
\->\fB (setq testarr (array nil flonum-block 2))\fP
array[2]
\->\fB (store (funcall testarr 0) 1.234)\fP
1.234
\->\fB (store (funcall testarr 1) 5.678)\fP
5.678
\->\fB (cfoo 385 testarr (hunk 10 11 13 14) '(15 16 17))\fP
a: 385, b[0]: 1.234000, b[1]: 5.678000
 c (first): 10   c (second): 11
 ( 15 16 ... )
 3
.ft I
.fi
Note that cfoo has returned 3 as it should.
It also had the side effect of changing the second value of the array to
3.1415926  which check next.
.br
.nf
.ft P
\->\fB (funcall testarr 1)\fP
3.1415926
.sp 2v
.fi
.ft I
In preparation for calling pfoo we create an array.
.ft P
.nf
\->\fB (array test flonum-block 2)\fP
array[2]
\->\fB (store (test 0) 1.234)\fP
1.234
\->\fB (store (test 1) 5.678)\fP
5.678
\->\fB (pfoo 385 (getd 'test) (hunk 10 11 13 14) '(15 16 17))\fP
 a:       385 b[0]:  1.23400000000000E+00 b[1]:  5.67800000000000E+00
 c (first):        10 c (second):        11
 (         15        16 ...) 
3
\->\fB (test 1)\fP
3.1415926
.sp 1v
\fI Now to test out the memq's
\-> \fB(cmemq 'a '(b c a d e f))\fP
(a d e f)
\-> \fB(pmemq 'e '(a d f g a x))\fP
nil
.hl
.fi
.sz +2
.sp 3v
.pp
The Fortran example will be much shorter since in Fortran 
you can't follow pointers
as you can in other languages.
The Fortran function ffoo is given three arguments: a fixnum, a 
fixnum-block array and a flonum.
These arguments are printed out to verify that they made it and
then the first value of the array is modified.
The function returns a double precision value which is converted to a flonum
by lisp and printed.
Note that the entry point corresponding to the Fortran function ffoo is
_ffoo_ as opposed to the C and Pascal convention of preceding the name with
an underscore.
.sp 1v
.in 0
.nf
.sz -2
.hl

% \fBcat ch8auxf.f\fP
	double precision function ffoo(a,b,c)
	integer a,b(10)
	double precision c
	print 2,a,b(1),b(2),c
2	format(' a=',i4,', b(1)=',i5,', b(2)=',i5,' c=',f6.4)
	b(1) = 22
	ffoo = 1.23456
	return
	end
% \fBf77 -c ch8auxf.f\fP
ch8auxf.f:
   ffoo:
0.9u 1.8s 0:12 22% 20+22k 54+48io 158pf+0w
% \fBlisp\fP
Franz Lisp, Opus 38.60
\-> \fB(cfasl 'ch8auxf.o '_ffoo_ 'ffoo "real-function" "-lF77 -lI77")\fP
/usr/lib/lisp/nld -N -A /usr/local/lisp -T 63000 ch8auxf.o -e _ffoo_ 
-o /tmp/Li11066.0 -lF77 -lI77 -lc
#6307c-"real-function"
.sp 1v
\-> \fB(array test fixnum-block 2)\fP
array[2]
\->\fB (store (test 0) 10)\fP
10
\-> \fB(store (test 1) 11)\fP
11
\-> \fB(ffoo 385 (getd 'test) 5.678)\fP
 a= 385, b(1)=   10, b(2)=   11 c=5.6780
1.234559893608093
\-> \fB(test 0)\fP
22

.hl
EndOfFile
cat >  doc/ch9.n  << 'EndOfFile'
." $Header: ch9.n 1.4 83/07/21 21:08:57 sklower Exp $
.Lc Arrays\ and\ Vectors 9
.pp
Arrays and vectors are two means of expressing aggregate
data objects in
.Fr .
Vectors may be thought of as sequences of data.
They are intended as a vehicle for user-defined
data types.
This use of vectors is still experimental and subject
to revision.
As a simple data structure, they are similar to
hunks and strings.
Vectors are used to implement closures,
and are useful to communicate with foreign functions.
Both of these topics were discussed in Chapter 8.
Later in this chapter,
we describe the current implementation of vectors, and will
advise the user what is most likely to change.
.pp
Arrays in 
.Fr
provide a programmable data structure access mechanism.
One possible use for 
.Fr
arrays is to implement Maclisp style arrays which are simple vectors
of fixnums, flonums or general lisp values.
This is described in more detail in \(sc9.3 but first
we will describe how array references are handled by
the lisp system.
.pp
The structure of an array object is given in \(sc1.3.10 and reproduced here
for your convenience.
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
access function	getaccess	putaccess	binary, list
			or symbol
_
auxiliary	getaux	putaux	lispval
_
data	arrayref	replace	block of contiguous
		set	lispval
_
length	getlength	putlength	fixnum
_
delta	getdelta	putdelta	fixnum
.TE
.sh 2 "general arrays" \n(ch 1
Suppose the evaluator is told to evaluate \fI(foo\ a\ b)\fP
and the function cell of the symbol foo contains an array object
(which we will call foo_arr_obj).
First the evaluator will evaluate and stack the values of 
.i a 
and 
.i b .
Next it will stack the array object foo_arr_obj.
Finally it will call the access function of foo_arr_obj.
The access function should be a lexpr\*[\(dg\*]
or a symbol whose 
function cell contains a lexpr.
.(f
\*[\(dg\*]A lexpr is a function which accepts any number of arguments
which are evaluated before the function is called.
.)f
The access function is responsible for locating and returning 
a value from the array.
The array access function is free to interpret the arguments as it wishes.
The Maclisp compatible array access function which is provided 
in the standard
.Fr
system interprets the arguments as subscripts in the same way as 
languages like Fortran and Pascal.
.pp
The array access function will also be called upon to store elements in 
the array.
For example, \fI(store\ (foo\ a\ b)\ c)\fP
will automatically expand to (foo c a b) and when the evaluator is called
to evaluate this, it will evaluate the arguments 
.i c , 
.i b 
and
.i a .
Then it will
stack the array object (which is stored 
in the function cell of foo) and call the array access function
with (now) four arguments.
The array access function must be able to tell this is a store operation,
which it can do by checking the number of arguments it has been
given (a lexpr can do this very easily).
.sh 2 "subparts of an array object"
An array is created by allocating an
array object with
.i marray
and  filling in the fields.
Certain lisp functions interpret the values of the subparts 
of the array object in special
ways as described in the following text.
Placing illegal values in these subparts may cause
the lisp system to fail.
.sh 3 "access function"
The purpose of the access function has been described above.
The contents of the access function should be a lexpr, 
either a binary (compiled function) or a list (interpreted function).
It may also be a symbol whose function cell contains a function 
definition.
This subpart 
is used by 
.i eval , 
.i funcall , 
and 
.i apply
when evaluating array references.
.sh 3 auxiliary
This can be used for any purpose. If it is a list and the first element
of that list is the symbol unmarked_array then the data subpart will
not be marked by the garbage collector (this is used in the Maclisp
compatible array package and has the potential for causing strange errors
if used incorrectly).
.sh 3 data
This is either nil or points to a block of data space allocated by 
.i segment 
or 
.i small-segment.
.sh 3 length
This is a fixnum whose value is the number of elements in the
data block.  This is used by the garbage collector and by 
.i arrayref
to determine if your index is in bounds.
.sh 3 delta
This is a fixnum whose value is the number of bytes in each element of 
the data block.
This will be four for an array of fixnums or value cells, and eight
for an array of flonums.
This is used by the garbage collector and 
.i arrayref
as well.
.sh 2 "The Maclisp compatible array package"
.pp
A Maclisp style array is similar to what is known as arrays in other
languages: a block of homogeneous data elements which
is indexed by one or more integers called subscripts.
The data elements can be all fixnums, flonums or general lisp objects.
An array is created by a call to the function 
.i array 
or \fI*array\fP.
The only difference is that 
.i *array
evaluates its arguments.
This call: 
.i "(array foo t 3 5)"
sets up an array called foo of dimensions 3 by 5.
The subscripts are zero based. 
The first element is \fI(foo\ 0\ 0)\fP, the next is \fI(foo\ 0\ 1)\fP
and so on up to \fI(foo\ 2\ 4)\fP.
The t indicates a general lisp object array which means each element of
foo can be any type.
Each element can be any type since all that is stored in the array is
a pointer to a lisp object, not the object itself.
.i Array 
does this by allocating an array object
with
.i marray
and then allocating a segment of 15 consecutive value cells with
.i small-segment
and storing a pointer to that segment in the data subpart of the array
object.
The length and delta subpart of the array object are filled in (with 15
and 4 respectively) and the access function subpart is set to point to 
the appropriate  array access function.
In this case there is a special access function for two dimensional
value cell arrays called arrac-twoD, and this access function is used.
The auxiliary subpart is set to (t\ 3\ 5) which describes the type of array
and the bounds of the subscripts.  
Finally this array object is placed in the function cell of the symbol foo.
Now when 
.i "(foo 1 3)"
is evaluated, the array access function is invoked with three arguments:
1, 3 and the array object.  From the auxiliary field of the
array object it gets a description of the particular array.
It then determines which element \fI(foo\ 1\ 3)\fP refers to  and 
uses arrayref to extract that element.
Since this is an array of value cells, what arrayref returns is a
value cell whose value is what we want, so we evaluate the value cell
and return it as the value of \fI(foo\ 1\ 3)\fP.
.pp
In Maclisp the call \fI(array\ foo\ fixnum\ 25)\fP
returns an array whose data object is a block of 25 memory words.
When fixnums are stored in this array, the actual numbers are 
stored instead of pointers to the numbers as is done in general lisp
object arrays.
This is efficient under Maclisp but inefficient in
.Fr
since every time a value was referenced from an array it had to be copied
and a pointer to the copy returned to prevent aliasing\*[\(dg\*].
.(f
\*[\(dg\*]Aliasing is when two variables are share the same storage location.
For example if the copying mentioned weren't done then after 
\fI(setq\ x\ (foo\ 2))\fP was done, the value of x and 
(foo\ 2) would share the same 
location.
Then should the value of (foo\ 2) change, x's value would change as well.
This is considered dangerous and as a result pointers are never returned
into the data space of arrays.
.)f
Thus t, fixnum and flonum arrays are all implemented in the same 
manner.
This should not affect the compatibility of Maclisp
and 
.Fr .
If there is an application where a block of fixnums or flonums is required,
then the exact same effect of fixnum and flonum arrays in Maclisp
can be achieved by using fixnum-block and flonum-block arrays.
Such arrays are required if you want to pass a large number of arguments to a 
Fortran or C coded function and then get answers back.
.pp
The Maclisp compatible array package is 
just one example of how a general array scheme can be implemented.
Another type of array you could implement would be hashed arrays.
The subscript could be anything, not just a number.
The access function would hash the subscript and use the result to
select an array element.
With the generality of arrays also comes extra cost; if you just
want a simple aggregate of (less than 128) general lisp objects
you would be wise to look into using hunks.
.sh 2 vectors
Vectors were invented to fix two shortcommings with hunks.
They can be longer than 128 elements.  They also have a
tag associated with them, which is intended to say, for example,
"Think of me as an \fIBlobit\fP."  Thus a \fBvector\fP
is an arbitrary sized hunk with a property list.
.pp
Continuing the example,
the lisp kernel may not know how to print out
or evaluate \fIblobits\fP, but this is information which will
be common to all \fIblobits\fP.  On the other hand, for each
individual blobits there are particulars which are likely to change,
(height, weight, eye-color).  This is the part that would
previously have been stored in the individual entries in the hunk,
and are stored in the data slots of the vector.
Once again we summarize the structure of a vector in tabular form:
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
datum[\fIi\fP]	vref	vset	lispval
_
property	vprop	vsetprop	lispval
		vputprop
_
size	vsize	\-	fixnum
.TE
Vectors are created specifying size and optional fill value using the
function (\fInew-vector\fP  'x_size ['g_fill ['g_prop]]), or by
initial values: (\fIvector\fP ['g_val ...]).
.sh 2 "anatomy of vectors"
There are some technical details about vectors, that the user should
know:
.sh 3 size
The user is not free to alter this.  It is noted when the vector
is created, and is used by the garbage collector.  The garbage
collector will coallesce two free vectors, which are neighbors
in the heap.  Internally, this is kept as the number of bytes
of data.  Thus, a vector created by (\fIvector\fP 'foo), has a
size of 4.
.sh 3 property
Currently, we expect the property to be either a symbol, or a list
whose first entry is a symbol.  The symbols \fBfclosure\fP and
\fBstructure-value-argument\fP are magic, and their effect is described in
Chapter 8.  If the property is a (non-null) symbol, the vector
will be printed out as <symbol>[<size>].  
Another case is if the property is actually a (disembodied) property-list, which
contains a value for the indicator \fBprint\fP.
The value is taken to be a Lisp function, which the printer
will invoke with two arguments:  the vector and the current output port.
Otherwise, the vector will be printed as vector[<size>].
We have vague (as yet unimplemented) ideas
about similar mechanisms for evaluation properties.
Users are cautioned against putting anything other than nil
in the property entry of a vector.
.sh 3 "internal order"
In memory, vectors start with a longword containing the size
(which is immediate data within the vector).
The next cell contains a pointer to the property.
Any remaining cells (if any) are for data.
Vectors are handled differently from any other object in
.Fr,
in that a pointer to a vector is pointer to the first data
cell, i.e. a pointer to the \fIthird\fP longword of the structure.
This was done for efficiency in compiled code and for uniformity
in referencing immediate-vectors (described below).
The user should never return a pointer to any other part
of a vector, as this may cause the garbage collector to follow an
invalid pointer.
.sh 2 "immediate-vectors"
Immediate-vectors are similar to vectors.  They differ, in
that binary data are stored in space directly within the vector.
Thus the garbage collector will preserve the vector itself (if used),
and will only traverse the property cell.
The data may be referenced as longwords, shortwords, or even bytes.
Shorts and bytes are returned sign-extended.
The compiler open-codes such references,
and will avoid boxing the resulting integer data, where possible.
Thus, immediate vectors may be used for efficiently processing
character data.
They are also useful in storing results from functions written
in other languages.
.sp 1v
.TS
box center ;
c | c | c | c .
Subpart name	Get value	Set value	Type

=
datum[\fIi\fP]	vrefi-byte	vseti-byte	fixnum
	vrefi-word	vseti-word	fixnum
	vrefi-long	vseti-long	fixnum
_
property	vprop	vsetprop	lispval
		vputprop
_
size	vsize	\-	fixnum
	vsize-byte		fixnum
	vsize-word		fixnum
.TE
To create immediate vectors specifying size and fill data,
you can use the functions
\fInew-vectori-byte\fP,
\fInew-vectori-word\fP,
or \fInew-vectori-long\fP.
You can also use the functions
\fIvectori-byte\fP,
\fIvectori-word\fP,
or \fIvectori-long\fP.
All of these functions are described in
chapter 2.
EndOfFile
cat >  doc/ch10.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/ch10.n,v 1.1 83/01/31 07:08:20 jkf Exp $
.Lc Exception\ Handling 10
.sh 2 Errset\ and\ Error\ Handler\ Functions 10
.pp
.Fr
allows the user to handle in a number of ways the errors
which arise during computation.
One way is through the use of the
.i errset
function.
If an error occurs during the evaluation of the 
.i errset 's
first argument, then
the locus of control will return to the errset which will
return nil (except in special cases, such as
.i err ).
The other method of error handling is through an error handler 
function.
When an error occurs, the error handler is called and 
is given as an argument a description  of the
error which just occurred.
The error handler may take one of the following actions:
.nr $p 0
.np
it could take some drastic action like a 
.i reset 
or a 
.i throw .
.np
it could, assuming that the error is continuable,
return 
to the function which noticed the error.
The error handler indicates that it wants to return a value from
the error by returning a list whose 
.i car
is the value it wants to return.
.np
it could decide not to handle the error and return a non-list to
indicate this fact.
.sh 2 "The Anatomy of an error"
.pp
Each error is described by a list of these items:
.nr $p 0
.np
error type - This is a symbol which indicates the 
general classification of the error.
This classification may determine which function handles this
error.
.np
unique id - This is a fixnum unique to this error.
.np
continuable - If this is non-nil then this error is continuable.
There are some who feel that every error should be continuable
and the reason that some (in fact most) errors in 
.Fr
are not continuable is due to the laziness of the programmers.
.np
message string - This is a symbol whose print name is  a 
message describing the error.
.np
data - There may be from zero to three lisp values which help
describe this particular  error.
For example, the unbound variable error contains one datum value,
the symbol whose value is unbound.
The list describing that error might look like:
.br
.ce
(ER%misc 0 t |Unbound Variable:| foobar)
.sh 2 "Error handling algorithm"
.pp
This is the sequence of operations which is done when an
error occurs:
.nr $p 0
.np
If the symbol 
.b ER%all 
has a non nil value
then this value is the name of an error handler function.
That function is called with a description of the error.
If that function returns (and of course it may choose not to)
and the value is a list and this error is continuable, then
we return the
.i car
of the list to the function which called the error.
Presumably the function  will use this value to retry the operation.
On the other hand, if the error handler returns a non list, then
it has chosen not to handle this error, so  we go on to step (2).
Something special happens before we call the 
.b ER%all 
error
handler which does not happen in any of the
other cases we will describe below.
To help insure that we don't get infinitely recursive 
errors  if 
.b ER%all 
is set to a bad value,
the value of 
.b ER%all 
is set to nil before the 
handler is called.
Thus it is the responsibility of the 
.b ER%all 
handler to `reenable'
itself by storing its name in 
.b ER%all.
.np
Next the specific error handler for the type of error 
which just occurred is called  (if one exists) to see if 
it wants to handle the error.
The names of the handlers for the specific types of errors are stored
as the values of the symbols whose names are the types.
For example the handler for miscellaneous errors is stored as the
value of 
.b ER%misc.  
Of course, if 
.b ER%misc 
has a value of nil, then there is no error
handler for this type of error.
Appendix B contains list of all error types.
The process of classifying the errors is not complete and thus most
errors are lumped into the \fBER%misc\fP category.
Just as in step (1),
the error handler function may choose not to handle the error
by returning a non-list, and then we go to step (3).
.np
Next a check is made to see if there is an 
.i errset
surrounding this error.
If so the second argument to the 
.i errset
call 
is examined. 
If the second argument was not given or is non nil
then the error message associated with this error is printed.
Finally  the stack is popped 
to the context of the 
.i errset
and then the
.i errset 
returns nil.
If there was no
.i errset
we go to step (4).
.np
If the symbol 
.b ER%tpl 
has a value then it is the
name of an error handler which is called in a manner similar
to that discussed above.
If it chooses not to handle the error, we go to step (5).
.np
At this point it has been determined that the user doesn't 
want to handle this error.
Thus the error message is printed out and
a 
.i reset
is done to send the flow of control to the top-level.
.pp
To summarize the error handling system:
When an error occurs, you have two chances to handle it before
the search for an
.i errset
is done.
Then, if there is no
.i errset ,
you have one more chance to handle the error before control
jumps to the top level.
Every  error handler works in the same way:
It is given a description of the error (as described in the
previous section).
It may or may not return.
If it returns, then it returns
either a list or a non-list.
If it returns a list and the error is continuable, then 
the 
.i car
of the list is returned to the function which noticed the error.
Otherwise the error handler has decided not to handle the error
and we go on to something else.
.sh 2 "Default aids"
.pp
There are two standard error handlers  which will probably 
handle the needs of most users.
One of these is the lisp coded function
.i break-err-handler
which is the default value of 
.b ER%tpl.
Thus when all other handlers have ignored an error, 
.i break-err-handler
will take over.
It will print out the error message and 
go into a read-eval-print loop.
The other standard error handler is 
.i debug-err-handler .
This handler is designed to be connected to
.b ER%all and
is useful if your program uses
.i errset
and you want to 
look at the error  before
it is thrown up to the
.i errset .
.sh +0 Autoloading
.pp
When 
.i eval ,
.i apply 
or 
.i funcall
are told to call an undefined function, an \fBER%undef\fP
error is signaled.
The default handler for this error is 
.i undef-func-handler .
This function checks the property list of the undefined function for
the indicator autoload.
If present, the value of that indicator should be the name of the file
which contains the definition of the undefined function.
.i Undef-func-handler
will load the file and check if it has defined the function which caused
the error.
If it has, the error handler will return and the computation will continue
as if the error did not occur.
This provides a way for the user to tell the lisp system about the location
of commonly used functions.
The trace package sets up an autoload property to point to /usr/lib/lisp/trace.
.sh +0 Interrupt\ processing
.pp
The  UNIX operating system provides one user interrupt character which
defaults to ^C.\*[\(dg\*]
.(f
\*[\(dg\*]Actually there are two but the lisp system does not allow you
to catch the QUIT interrupt.
.)f
The user may select a lisp function to run when an interrupt occurs.
Since this interrupt could occur at any time, and in particular could
occur at a time when the internal stack pointers were in an inconsistent
state, the processing of the interrupt may be delayed until a safe
time.
When the first ^C is typed, the lisp system sets a flag that an interrupt
has been requested.
This flag is  checked at safe places within the interpreter
and in the
.i qlinker
function.
If the lisp system doesn't respond to the first ^C, another ^C should
be typed.
This will cause all of the transfer tables to be cleared forcing
all calls from compiled code to go through the 
.i qlinker 
function where the interrupt flag will be checked.
If the lisp system still doesn't respond, a third ^C will cause 
an immediate interrupt.
This interrupt will not necessarily be in a safe place so the
user should
.i reset
the lisp system as soon as possible.
EndOfFile
cat >  doc/ch11.n  << 'EndOfFile'
." $Header: ch11.n 1.1 83/01/31 07:08:25 jkf Exp $
.Lc The\ Joseph\ Lister\ Trace\ Package 11
.de Tf
.sp 2v
.ti -.5i
\fB\\$1\fP - 
..
.pp
The Joseph Lister\*[\(dg\*] Trace package is an 
important tool for the interactive debugging of a Lisp
program.
.(f
\*[\(dg\*]\fILister, Joseph\fP\ \ \ \ 
1st Baron Lister of Lyme Regis,
1827-1912; English surgeon: introduced antiseptic surgery.
.)f
It allows you to examine selected  calls to a function or functions, and
optionally to stop execution of the Lisp program to examine the values
of variables.
.pp
The trace package is a set of Lisp programs located in the Lisp program 
library (usually in the file /usr/lib/lisp/trace.l).
Although not normally loaded in the Lisp system, the package will
be loaded in when the first call to \fItrace\fP is made.
.Lf trace "[ls_arg1 ...]"
.Wh
the form of the ls_arg\fIi\fP is described below.
.Re
a list of the function sucessfully modified for tracing.
If no arguments are given to 
.i trace ,
a list of all functions currently being traced is returned.
.Se
The function definitions of the functions to trace are modified.
.sp 2v
.in 0
The ls_arg\fIi\fP can have one of the following forms:
.in .75i
.Tf "foo"
when foo is entered and exited, the trace information will be printed.
.Tf "(foo break)"
when foo is entered and exited the trace information will be printed.
Also, just after the trace information for foo is printed upon entry,
you will be put in  a special break loop.
The prompt is `T>' and you may type any Lisp expression, and see its
value printed.
The 
.i i th 
argument to the function just called can be accessed as (arg \fIi\fP).
To leave the trace loop, just type ^D or (tracereturn)
and execution will continue.
Note that ^D will work only on UNIX systems.
.Tf "(foo if expression)"
when foo is entered and the expression evaluates to non-nil, then the
trace information will be printed for both exit and entry.
If expression evaluates to nil, then no trace information will be
printed.
.Tf "(foo ifnot expression)"
when foo is entered and the expression evaluates to nil, then the
trace information will be printed for both entry and exit.
If both \fBif\fP and 
.b ifnot 
are specified, then the 
.b if 
expression must evaluate
to non nil AND the 
.b ifnot 
expression must evaluate to nil for the trace
information to be printed out.
.Tf "(foo evalin expression)"
when foo is entered and after the entry trace information is printed,
expression will be evaluated. 
Exit trace information will be printed when foo exits.
.Tf "(foo evalout expression)"
when foo is entered, entry trace information will be printed.
When foo exits, and before the exit trace information is printed,
expression will be evaluated.
.Tf "(foo evalinout expression)"
this has the same effect as (trace (foo evalin expression evalout expression)).
.Tf "(foo lprint)"
this tells 
.i trace 
to use the level printer when printing the arguments to
and the result of  a call to foo.
The level printer prints only the top levels of list structure. 
Any structure
below three levels is printed as a &.
This allows you to trace functions with massive arguments or results.
.sp 2v
.pp
The following trace options permit one to have greater control over each
action which takes place when a function is traced.
These options are only meant to be used by people who need special hooks
into the trace package.
Most people should skip reading this section.
.in .75i
.Tf "(foo traceenter tefunc)"
this tells 
.i trace 
that the function to be called when foo is entered is 
tefunc.
tefunc should be a lambda of two arguments, the first argument will be 
bound to the name of the function being traced, foo in this case.
The second argument will be bound to the list of arguments to which 
foo should be applied.
The function tefunc should print some sort of "entering foo" message.
It should not apply foo to the arguments, however. 
That is done later on.
.Tf "(foo traceexit txfunc)"
this tells 
.i trace 
that the function to be called when foo is exited is
txfunc.
txfunc should be a lambda of two arguments, the first argument will be
bound to the name of the function being traced, foo in this case.
The second argument will be bound to the result of the call to foo.
The function txfunc should print some sort of "exiting foo" message.
.Tf "(foo evfcn evfunc)"
this tells 
.i trace 
that the form evfunc should be evaluated to get the value
of foo applied to its arguments.  
This option is a bit different from the other special options since evfunc
will usually be an expression, not just the name of a function, and that
expression will be specific to the evaluation of function foo.
The argument list to be applied will be available as T-arglist.
.Tf "(foo printargs prfunc)"
this tells 
.i trace 
to used prfunc to print the arguments  to be
applied to the function foo.
prfunc should be a lambda of one argument.
You might want to use this option if you wanted a print function which could
handle circular lists.
This option will work only if you do not specify your own 
.b traceenter 
function.
Specifying the option 
.b lprint 
is just a simple way of changing the printargs
function to the level printer.
.Tf "(foo printres prfunc)"
this tells 
.i trace 
to use prfunc to print the result of evaluating foo.
prfunc should be a lambda of one argument.
This option will work only if you do not specify your own 
.b traceexit 
function.
Specifying the option 
.b lprint 
changes printres to the level printer.
.sp 2v
.pp
You may specify more than one option for each function traced.  
For example:
.sp 1v
.ti .5i
\fI(trace (foo if\ (eq 3 (arg 1)) break lprint) (bar evalin (print xyzzy)))\fP
.sp 1v
This tells 
.i trace 
to trace two more functions, foo and bar.
Should foo be called with the first argument 
.i eq
to 3, then the entering foo message will be printed with the level printer.
Next it will enter a trace break loop, allowing you to evaluate any 
lisp expressions.
When you exit the trace break loop, foo will be applied to its arguments
and the resulting value will be printed, again using the level printer.
Bar is also traced, and each time bar is entered, an entering bar message
will be printed and then the value of xyzzy will be printed.
Next bar will be applied to its arguments and the result will be printed.
If you tell 
.i trace 
to trace a function which is already traced, it will first
.i untrace 
it.  Thus if you want to specify more than one trace option for
a function, you must do it all at once.
The following is 
.i not 
equivalent to the preceding call to 
.i trace 
for foo:
.sp 1v
\fI(trace (foo if (eq 3 (arg 1))) (foo break) (foo lprint))\fP
.sp 1v.
In this example, only the last option, lprint, will be in effect.
.pp
If the symbol $tracemute is given a non nil value, printing of the 
function name and arguments on entry and exit will be surpressed.
This is particularly useful if the function you are tracing fails
after many calls to it.  In this case you would tell 
.i trace 
to
trace the function, set $tracemute to t, and begin the computation.
When an error occurs you can use
.i tracedump
to print out the current trace frames.
.pp
Generally the trace package has its own internal names for the the lisp
functions it uses, so that you can feel free to trace system functions like
.i cond 
and not worry about adverse interaction with the actions of the trace
package.
You can trace any type of function: lambda, nlambda, lexpr or macro whether
compiled or interpreted and you can even trace array references (however
you should not attempt to store in an array which has been traced).
.pp
When tracing compiled code keep in mind that many function calls are translated 
directly to machine language  or other equivalent  function calls.
A full list of open coded functions is listed at the beginning of the 
liszt compiler source.
.i Trace 
will do a \fI(sstatus\ translink\ nil)\fP to insure that the 
new traced definitions it defines are called instead of the old untraced ones.
You may notice that compiled code will run slower after this is done.
.Lf traceargs "s_func [x_level]"
.Wh
if x_level is missing it is assumed to be 1.
.Re
the arguments to the x_level\fIth\fP call to traced
function s_func are returned.
.Lf tracedump ""
.Se
the currently active trace frames are printed on the terminal.
returns a list of functions untraced.
.Lf untrace "[s_arg1 ...]"
.Re
a list of the functions which were untraced.
.No
if no arguments are given, all functions are untraced.
.Se
the old function definitions of all 
traced functions are restored
except in the case where it appears that 
the current definition of a function was not created by trace.
EndOfFile
cat >  doc/ch12.n  << 'EndOfFile'
." $Header: ch12.n 1.2 83/07/23 12:41:32 layer Exp $
.Lc Liszt\ -\ the\ lisp\ compiler 12
.sh 2 "General strategy of the compiler" \n(ch 1
.pp
The purpose of the lisp compiler, Liszt, is to create an object module which
when brought into the lisp system using
.i fasl
will have the same effect as bringing in the corresponding lisp coded source
module with
.i load  
with one important exception,
functions will be defined as sequences of machine language instructions, instead
of lisp S-expressions.
Liszt is not a function compiler, it is a 
.i file
compiler.
Such a file   can contain more than function definitions; it can
contain other lisp S-expressions which are evaluated
at load time.
These other S-expressions will also be stored in the object
module produced by Liszt and will be evaluated at fasl time.
.pp
As is almost universally true of Lisp compilers, the main pass of Liszt
is written in Lisp.
A subsequent pass is the assembler, for which we use the 
standard UNIX assembler.
.sh 2 "Running the compiler"
.pp
The compiler is normally run in this manner:
.br
% \fBliszt foo\fP
.br
will compile the file foo.l or foo (the preferred way to indicate a lisp 
source file is to end the file name with `.l').
The result of the compilation will be placed in the file foo.o  if no
fatal errors were detected.
All messages which Liszt generates go to the standard output.
Normally each function name is printed before it is compiled (the \-q
option suppresses this).
.sh 2 "Special forms"
.pp
Liszt makes one pass over the source file. 
It processes each form in this way:
.sh 3  macro\ expansion
.pp
If the form is a macro invocation (i.e it is a list whose car is a symbol
whose function binding is a macro), then that macro invocation is expanded.
This is repeated until the top level form is not a macro invocation.
When Liszt begins, there are already some macros defined, in fact some
functions (such as defun) are actually macros.
The user may define his own macros as well.
For a macro to be used it must be defined in the Lisp system
in which Liszt runs.
.sh +0 classification
.pp
After all macro expansion is done, the form is classified according to its
.i car 
(if the form is not a list, then it is classified as an
.i other ).
.sh +1 "eval-when"
.pp
The form of eval-when is 
\fI(eval-when\ (time1\ time2\ ...)\ form1\ form2\ ...)\fP
where the time\fIi\fP are one of 
.i eval ,
.i compile ,
or
.i load .
The compiler examines the form\fIi\fP in sequence and the action taken
depends on what is in the time list.
If 
.i compile
is in the list then the compiler will invoke 
.i eval
on each form\fIi\fP as it examines it.
If 
.i load
is in the list then the compile will recursively call itself to compile
each form\fIi\fP as it examines it.
Note that if 
.i compile
and
.i load
are in the time list, then the compiler will both evaluate and compile
each form.
This is useful if you need a function to be defined in the compiler
at both compile time (perhaps to aid macro expansion) and at run time
(after the file is 
.i fasl ed 
in).
.sh +0 "declare"
.pp
Declare is used to provide information about functions and variables to
the compiler.  
It is (almost) equivalent to \fI(eval-when\ (compile)\ ...)\fP.
You may declare functions to be one of three types: lambda (*expr),
nlambda (*fexpr), lexpr (*lexpr).
The names in parenthesis are the Maclisp names and are accepted by the
compiler as well (and not just when the compiler is in Maclisp mode).
Functions are assumed to be lambdas until they are declared otherwise
or are defined differently.  
The compiler treats calls to lambdas and lexprs equivalently, so you needn't 
worry about declaring lexprs either.  
It is important to declare nlambdas or define them before calling them.
Another attribute you can declare for a function is localf which
makes the function `local'.
A local function's name is 
known only to the functions defined
within the file itself.  The
advantage of a local function is that is can be entered 
and exited very quickly and it can have the same name as a function in 
another file and there will be no name conflict.
.pp
Variables may be declared special or unspecial.
When a special variable is lambda bound (either in a lambda,
prog or do expression), its old value is stored away on a stack for the
duration of the lambda, prog or do expression.
This takes time and is often not necessary.
Therefore the default classification for variables is unspecial.
Space for unspecial variables is dynamically allocated on a stack.
An unspecial variable can only be accessed from within the function
where it is created by its presence in a lambda, prog or do 
expression variable list.
It is possible to declare that all variables are special as will be
shown below.
.pp
You may declare any number of things in each declare statement.
A sample declaration is 
.ft I
.nf
(declare
\ \ \ \ \ (lambda func1 func2)
\ \ \ \ \ (*fexpr func3)
\ \ \ \ \ (*lexpr func4)
\ \ \ \ \ (localf func5)
\ \ \ \ \ (special var1 var2 var3)
\ \ \ \ \ (unspecial var4))
.fi
.ft R
.pp
You may also declare all variables to be special with
\fI(declare\ (specials\ t))\fP.
You may declare that macro definitions should be compiled as well as
evaluated at compile time by \fI(declare\ (macros\ t))\fP.
In fact, as was mentioned above, declare is much like 
\fI(eval-when\ (compile)\ ...)\fP.
Thus if the compiler sees \fI(declare\ (foo\ bar))\fP
and foo is defined, then it will evaluate \fI(foo\ bar)\fP.
If foo is not defined then an undefined declare attribute warning will
be issued.  
.sh +0 "(progn 'compile \fRform1 form2 ... formn\fB)\fP"
.pp
When the compiler sees this it simply compiles form1 through formn as if
they too were seen at top level.
One use for this is to allow a macro at top-level to 
expand into more than one function definition for the compiler to compile.
.sh +0 "include/includef"
.pp
.i Include 
and 
.i includef 
cause another file to be read and compiled by
the compiler.  The result is the same as if the included file were
textually inserted into the original file.  The only difference
between 
.i include 
and 
.i includef 
is that include doesn't evaluate its
argument and includef does.  Nested includes are allowed.
.sh +0 "def"
.pp
A def form is used to define a function.  The macros
.i defun 
and 
.i defmacro 
expand to a def form.
If the function being defined is a lambda, nlambda or lexpr then
the compiler converts the lisp definition to a sequence of machine
language instructions.
If the function being defined is a macro, then the compiler will evaluate
the definition, thus defining the macro withing the running Lisp compiler.
Furthermore, if the variable 
.i macros 
is set to a non nil value, then the macro definition will also be translated
to machine language and thus will be defined when the object file is
fasled in.
The variable
.i macros
is set to t by
\fI(declare\ (macros\ t))\fP.
.pp
When a function or macro definition is compiled, macro expansion is
done whenever possible.
If the compiler can determine that a form would be evaluated if this
function were interpreted then it will macro expand it.
It will not macro expand arguments to a nlambda unless the characteristics
of the nlambda is known (as is the case with
.i cond).
The map functions (
.i map ,
.i mapc ,
.i mapcar ,
and so on)
are expanded to a 
.i do 
statement.
This allows the first argument to the map function to be a lambda
expression which references local variables of the function being
defined.
.sh +0 "other forms"
.pp
All other forms are simply stored in the object file and are evaluated
when the file is 
.i fasl ed
in.
.sh 2 "Using the compiler"
.pp
The previous section describes exactly what the compiler does with its 
input.
Generally you won't have to worry about all that detail as files which
work interpreted will work compiled.
Following is a list of steps you should follow to insure that a file
will compile correctly.
.ip [1]
Make sure all macro definitions precede their use in functions or other
macro definitions.
If you want the macros to be around when you 
.i fasl
in the object file you should include this statement at the beginning
of the file: \fI(declare\ (macros\ t))\fP
.ip [2]
Make sure all nlambdas are defined or declared before they are used.
If the compiler comes across a call to a
function which has not been defined in the current file, 
which does not currently have a function binding, 
and whose type  has not been declared then it will assume that the function
needs  its arguments evaluated 
(i.e. it is a lambda or lexpr) and will generate code
accordingly.
This means that you do not have to declare nlambda functions like
.i status
since they have an nlambda function binding.
.ip [3]
Locate all variables which are used for communicating values between
functions.
These variables must be declared special at the beginning of a file.
In most cases there won't be many special declarations but if you 
fail to declare a variable special that should be, the compiled code
could fail in mysterious ways.
Let's look at a common problem, assume that a file contains just
these three lines:
.sp 2v
.ft I
(def aaa (lambda (glob loc) (bbb loc)))
.br
(def bbb (lambda (myloc) (add glob myloc)))
.br
(def ccc (lambda (glob loc) (bbb loc)))
.sp 2v
.ft R
We can see that if we load in these two definitions then (aaa 3 4) is
the same as (add 3 4) and will give us 7.
Suppose we compile the file containing these definitions.
When Liszt compiles aaa, it will assume that both glob and loc are local
variables and will allocate space on the temporary stack for their values
when aaa is called.
Thus the values of the local variables glob and loc 
will not affect the values of the symbols glob and loc in the Lisp system.
Now Liszt moves on to function bbb.
Myloc is assumed to be local.
When it sees the add statement, it find a reference to a variable called
glob.
This variable is not a local variable to this function and therefore
glob must refer to the value of the symbol glob.
Liszt will automatically declare glob to be special and it will print
a warning to that effect.
Thus subsequent uses of glob will always refer to the symbol glob.
Next Liszt compiles ccc and treats glob as a special and loc
as a local.
When the object file is
.i fasl 'ed
in, and (ccc 3 4) is evaluated, 
the symbol glob will be lambda bound to 3
bbb will be called and will return 7.
However (aaa 3 4) will fail since when bbb is called, glob will be unbound.
What should be done here is to put
\fI(declare\ (special\ glob)\fP
at the beginning of the file.
.ip [4]
Make sure that all calls to 
.i arg
are within the lexpr whose arguments they reference.
If \fIfoo\fP is a compiled lexpr and it calls \fIbar\fP then \fIbar\fP cannot
use \fIarg\fP to get at \fIfoo\fP's arguments.
If both
.i foo
and 
.i bar
are interpreted this will work however.
The macro
.i listify
can be used to put all of some of a lexprs arguments in a list which 
then can be passed to other functions.
.sh 2 "Compiler options"
.pp
The compiler recognizes a number of options which are described below.
The options are typed anywhere on the command line preceded by a minus sign.
The entire command line is scanned and all options recorded before any action
is taken.  Thus
.br
% liszt -mx foo
.br
% liszt -m -x foo
.br
% liszt foo -mx
.br
are all equivalent.  
Before scanning the command line for options, liszt looks for in the
environment for the variable LISZT, and if found scans its value
as if it was a string of options.
The meaning of the options are:
.ip \fBC\fP
The assembler language output of the compiler is commented.
This is useful when debugging the compiler and is not normally done since
it slows down compilation.
.ip \fBI\fP
The next command line argument is taken as a filename, and loaded prior
to compilation.
.ip \fBe\fP
Evaluate the next argument on the command line before starting compilation.
For example
.br
% liszt -e '(setq foobar "foo string")' foo
.br
will evaluate the above s-expression.  Note that the shell requires
that the arguments be surrounded by single quotes.
.ip \fBi\fP
Compile this program in interlisp compatibility mode.  
This is not implemented yet.
.ip \fBm\fP
Compile this program in Maclisp mode.
The reader syntax will be changed to the Maclisp syntax and a file of 
macro definitions will be loaded in (usually named /usr/lib/lisp/machacks).
This switch brings us sufficiently close to Maclisp to allow us to compile
Macsyma, a large Maclisp program.
However Maclisp is a moving target and we can't guarantee that this switch
will allow you to compile any given program.
.ip \fBo\fP
Select a different object or assembler language file name.
For example
.br
% liszt foo -o xxx.o
.br
will compile foo and into xxx.o instead of the default foo.o, and
.br
% liszt bar -S -o xxx.s
.br
will compile to assembler language into xxx.s instead of bar.s.
.ip \fBp\fP
place profiling code at the beginning of each non-local function.
If the lisp system is also created with profiling in it, this allows
function calling frequency to be determined (see \fIprof(1)\fP)
.ip \fBq\fP
Run in quiet mode. 
The names of functions being compiled and various 
"Note"'s are not printed.
.ip \fBQ\fP
print compilation statistics and warn of strange constructs. 
This is the inverse of the \fBq\fP switch and is the default.
.ip \fBr\fP
place bootstrap code at the beginning of the object file, which when
the object file is executed will cause a lisp system to be invoked 
and the object file \fIfasl\fPed in.  
This is known as `autorun' and is described below.
.ip \fBS\fP
Create an assembler language file only.
.br
% liszt -S foo
.br
will create the file assembler language file foo.s and will not attempt
to assemble it.
If this option is not specified, the assembler language file will be put
in the temporary disk area under a automatically generated name based on
the lisp compiler's process id.
Then if there are no compilation errors, the assembler will be invoked to
assemble the file.
.ip \fBT\fP
Print the assembler language output on the standard output file.
This is useful when debugging the compiler.
.ip \fBu\fP
Run in UCI-Lisp mode.
The character syntax is changed to that of UCI-Lisp and a UCI-Lisp compatibility
package of macros is read in.
.ip \fBw\fP
Suppress warning messages.
.ip \fBx\fP
Create an cross reference file.
.br
% liszt -x foo 
.br
not only compiles foo into foo.o but also generates the file foo.x\ .
The file foo.x  is lisp readable and lists for each function all functions
which that function could call.
The program lxref reads one or more of these ".x" files and produces a 
human readable cross reference listing.
.sh 2 autorun
.pp
The object  file
which liszt writes does not contain all the functions necessary
to run the lisp program which was compiled.
In order to use the object file, a lisp system must be started and
the object file 
.i fasl ed
in.
When the -r switch is given to liszt, the object file created will
contain a small piece of bootstrap code at the beginning, and the
object file will be made executable.
Now, when the name of the object file is given to the UNIX command
interpreter (shell) to run, the bootstrap code at the beginning
of the object file will cause a lisp system to be started and 
the first action the lisp system will  take is to
.i fasl
in the object file which started it.
In effect the object file has created an environment in which it can run.
.pp
Autorun is an alternative to 
.i dumplisp .
The advantage of autorun is that the object file which starts the whole 
process is typically small, whereas the minimum 
.i dumplisp ed
file is very large (one half megabyte).
The disadvantage of autorun is that the file must be 
.i fasl ed
into a lisp each time it is used whereas the file which 
.i dumplisp
creates can be run as is.
liszt itself is a 
.i dumplisp ed
file since it is used so often and is large enough that
too much time  would be wasted 
.i fasl ing
it in each time it was used.
The lisp cross reference program, lxref, uses 
.i autorun
since it is a small and rarely used program.
.pp
In order to have the program 
.i fasl ed
in begin execution
(rather than starting a lisp top level),
the value of the symbol user-top-level should be set to the name of the
function to get control.  An example of this is shown next.
.Eb
\fIwe want to replace the unix date program with one written in lisp.\fP

% \fBcat lispdate.l\fP
(de\kBfun mydate nil
   \h'|\nBu'\kA(patom "The date is ")
   \h'|\nAu'\kB(patom (status ctime))
   \h'|\nBu'\kA(terpr)
   \h'|\nAu'(exit 0))
(se\kAtq user-top-level 'mydate)

% \fBliszt -r lispdate\fP
Compilation begins with Lisp Compiler 5.2
source: lispdate.l, result: lispdate.o
mydate
%Note: lispdate.l: Compilation complete
%Note: lispdate.l:  Time: Real: 0:3, CPU: 0:0.28, GC: 0:0.00 for 0 gcs
%Note: lispdate.l: Assembly begins
%Note: lispdate.l: Assembly completed successfully
3.0u 2.0s 0:17 29%

\fI We change the name to remove the ".o", (this isn't necessary) \fP
% \fBmv lispdate.o lispdate\fP

\fI Now we test it out \fP
% \fBlispdate\fP
The date is Sat Aug  1 16:58:33 1981
%
.Ee
.sh 2 "pure literals"
.pp
Normally the quoted lisp objects (literals) which appear in functions are
treated as constants. 
Consider this function:
.br
.ft I

(de\kCf foo
   \h'|\nCu'(lambda nil (cond \kA(\kB(not (eq 'a (car (setq x '(a b)))))
                      \h'|\nBu'(print 'impossible!!))
                     \h'|\nAu'(t (rplaca x 'd)))))

.ft P
.br
At first glance it seems that the first cond clause will never be
true, since the \fIcar\fP of \fI(a\ b)\fP should always be
.i a .
However if you run this function twice, it will print 'impossible!!' the
second time.
This is because the following clause modifies the 'constant' list \fI(a\ b)\fP
with the \fIrplaca\fP function.
Such modification of literal lisp objects can cause programs to behave
strangely as the above example shows, but more importantly it can cause
garbage collection problems if done to compiled code.
When a file is \fIfasl\fPed in, if the
symbol $purcopylits is non nil, the literal lisp data is put
in 'pure' space, that is it put in space which needn't be looked at
by the garabage collector.  This reduces the work the garbage collector
must do but it is dangerous since if the literals are modified to point
to non pure objects, the marker may not mark the non pure objects.
If the symbol $purcopylits is nil then the literal lisp data is put in
impure space and the compiled code will act like the interpreted
code when literal data is modified.
The default value for $purcopylits is t.
.sh 2 "transfer tables"
.pp
A transfer table is setup by 
.i fasl 
when the object file is loaded in.
There is one entry in the transfer table for each function which is
called in that object file.
The entry for a call to the function 
.i foo
has two parts whose contents are:
.ip [1] 
function address \- 
This will initially point to the internal  function 
.i qlinker .
It may some time in the future point to the function
.i foo
if certain conditions are satisfied (more on this  below).
.ip [2]
function name \-
This is a pointer to the symbol
.i foo .
This will be used by 
.i qlinker. 
.sp 2v
.lp
When a call is made to the function 
.i foo
the call will actually be made to the address in the
transfer table entry and will end up in the 
.i qlinker
function.
.i Qlinker
will determine that 
.i foo 
was the function being called by locating the function name
entry in the transfer table\*[\(dg\*].
.(f
\*[\(dg\*]\fIQlinker\fP does this by tracing back the call stack until it
finds the \fIcalls\fP machine instruction which called it.  The address
field of the \fIcalls\fP contains the address of the transfer table entry.
.)f
If the function being called is not compiled then 
.i qlinker
just calls 
.i funcall
to perform the function call.
If 
.i foo 
is compiled and if \fI(status\ translink)\fP is non nil, then 
.i qlinker 
will modify the function address part of the transfer table to point directly
to the function 
.i foo .
Finally 
.i qlinker
will call 
.i foo
directly .
The next time a call is made to 
.i foo 
the call will go directly to 
.i foo 
and not through
.i qlinker .
This will result in a substantial speedup in compiled code to compiled code
transfers.
A disadvantage is that no debugging information is left on the stack,
so 
.i showstack
and
.i baktrace
are useless.
Another disadvantage is that if you redefine a compiled function either
through loading in a new version or interactively defining it, then
the old version may still be called from compiled code if the fast linking
described above has already been done.
The solution to these problems is to use \fI(sstatus\ translink\ value)\fP.
If value is 
.ip \fInil\fP
All transfer tables will be cleared, i.e. all function
addresses will be set to point to 
.i qlinker .
This means that the next time a function is called 
.i qlinker
will be called and will look at the current definition.
Also, no fast links will be set up since \fI(status\ translink)\fP
will be nil.
The end result is that 
.i showstack
and 
.i baktrace 
will work and the function definition at the time of call will always be used.
.ip \fIon\fP
This causes the lisp system to go through all transfer tables and set up
fast links wherever possible.
This is normally used after you have 
.i fasl ed
in all of your files. 
Furthermore since \fI(status\ translink)\fP is not nil, 
.i qlinker
will make new fast links if the situation arises (which isn't likely unless
you
.i fasl
in another file).
.ip \fIt\fP
This or any other value not previously mentioned will just make 
\fI(status\ translink)\fP be non nil, and as a result fast links will
be made  by 
.i qlinker
if the called function is compiled.
.sh +0 "Fixnum functions"
.pp
The compiler will generate inline arithmetic code for fixnum only functions.
Such functions include \(pl, \(mi, *,  /, \\, 1\(pl and 1\-.
The code generated will be much faster than using \fIadd\fP, \fIdifference\fP,
etc.
However it will only work if the arguments to and results of the functions
are fixnums.
No type checking is done.
EndOfFile
cat >  doc/ch13.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/ch13.n,v 1.1 83/01/31 07:08:37 jkf Exp $
.Lc The\ CMU\ User\ Toplevel\ and\ the\ File\ Package 13
.ch 2 Introduction
This documentation was written by Don Cohen, and the functions described below
were imported from PDP-10 CMULisp.
.sp 1v
\fINon CMU users note:\fP this is not the default top level for your Lisp
system.  In order to start up this top level, you should type
\fI(load\ 'cmuenv)\fP.

.sh 2 User\ Command\ Input\ Top\ Level 13

The top-level is the function that reads what you type, evaluates it
and prints the result.  The \fInewlisp\fP top-level was inspired by the
CMULisp top-level (which was inspired by interlisp) but is much
simpler.  The top-level is a function (of zero arguments) that can be
called by your program.  If you prefer another top-level, just redefine
the top-level function and type "(reset)" to start running it.  The
current top-level simply calls the functions tlread, tleval and tlprint
to read, evaluate and print.  These are supposed to be replaceable by
the user.  The only one that would make sense to replace is tlprint,
which currently uses a function that refuses to go below a certain
level and prints "...]" when it finds itself printing a circular list.
One might want to prettyprint the results instead.  The current
top-level numbers the lines that you type to it, and remembers the last
n "events" (where n can be set but is defaulted to 25).  One can refer
to these events in the following "top-level commands":
.Eb
\fITOPLEVEL COMMAND SUMMARY\fP

??	prints events - both the input and the result.  If you just type
	"??" you will see all of the recorded events.  "?? 3" will show
	only event 3, and "?? 3 6" will show events 3 through 6.

redo	pretends that you typed the same thing that was typed before.  If
	you type "redo 3" event number 3 is redone.  "redo -3" redoes the
	thing 3 events ago.  "redo" is the same as "redo -1".

ed	calls the editor and then does whatever the editor returns.  Thus
	if you want to do event 5 again except for some small change, you
	can type "ed 5", make the change and leave the editor.  "ed -3"
	and "ed" are analogous to redo.
.Ee
Finally, you can get the value of event 7 with the function (valueof 7).
The other interesting feature of the top-level is that it makes outermost
parentheses superfluous for the most part.  This works the same way as in
CMULisp, so you can use the help for an explanation.  If you're not sure
and don't want to risk it you can always just include the parentheses.

.Lf top-level
.Se
.i top-level
is the  LISP top level function.   As well
as  being the  top level  function with  which  the user
interacts, it can be  called recursively by the  user or
any function.  Thus, the  top level can be  invoked from
inside the editor, break package, or a user  function to
make its commands available to the user.
.No
The  CMU
.Fr
top-level   uses  
.i lineread
rather  than  
.i read.
The difference will not usually be noticeable.  The principal thing to be
careful  about is that input  to the function or  system being called
cannot appear  on the same line as the  top-level call.  For example,
typing \fI(editf foo)fP on one  line will edit 
.i foo  
and evaluate P, not edit
.i foo 
and execute the  p command in the editor.  
.i top-level
specially recognizes the following commands:

.Lf valueof "'g_eventspec"
.Re
the value(s) of the event(s) specified by g_eventspec.  If a single
event is specified, its value will be returned.  If more than one event
is specified, or an event has more than one subevent (as for
.i redo,
etc), a list of vlaues will be returned. 

.sh 2 The\ File\ Package

Users typically define functions in lisp and then want to save them for
the next session.  If you do \fI(changes)\fP, a list of the functions that are
newly defined or changed will be printed.  When you type \fI(dskouts)\fP, the
functions associated with files will be saved in the new versions of
those files.  In order to associate functions with files you can either
add them to the \fIfilefns\fP list of an existing file or create a new file to
hold them.  This is done with the 
.i file
function.  If you type \fI(file new)\fP
the system will create a variable called 
.i newfns.  
You may add the names of the functions to go into that file to 
.i newfns.  
After you do \fI(changes)\fP,
the functions which are in no other file are stored in the value of the
atom
.i changes.  
To put these all in the new file, \fI(setq newfns (append newfns changes))\fP.
Now if you do \fI(changes)\fP, all of the changed functions
should be associated with files.  In order to save the changes on the
files, do \fI(dskouts)\fP.  All of the changed files (such as NEW) will be 
written.  To recover the new functions the next time you run 
.Fr , 
do \fI(dskin new)\fP.
.Eb
Script started on Sat Mar 14 11:50:32 1981
$ newlisp
Welcome to newlisp...
1.(defun square (x) (* x x))		; define a new function
square
2.(changes)				; See, this function is associated
					; with no file.
<no-file>      (square)nil
3.(file 'new)				; So let's declare file NEW.
new
4.newfns				; It doesn't have anything on it yet.
nil
5.(setq newfns '(square))		; Add the function associated
(square)				; with no file to file NEW.
6.(changes)				; CHANGES magically notices this fact.

new            (square)nil
7.(dskouts)				; We write the file.
creating new
(new)
8.(dskin new)				; We read it in!
(new)
14.Bye
$ 
script done on Sat Mar 14 11:51:48 1981

.Ee

.Lf changes "s_flag"
.Re
Changes computes a list containing an entry for each file which
defines atoms that have been marked changed.  The entry contains the
file name and the changed atoms defined therein.  There is also a 
special entry for changes to atoms which are not defined in any known
file.  The global variable 
.i filelst
contains the list of "known" files.  If no flag is passed this result 
is printed in human readable form and the value returned is t if there
were any changes and nil if not.  Otherwise nothing is printed and the
computer list is returned.  The global variable
.i changes
contains the atoms which are marked changed but not yet associated
with any file.  The
.i changes
function attempts to associate these names with files, and any that are not
found are considered to belong to no file.  The
.i changes
property is the means by which changed functions are associated with
files.  When a file is read in or written out its
.i changes
property is removed.
.Lf dc "s_word s_id [ g_descriptor1  ... ] <text> <esc>"
.Re
.i dc
defines comments.  It is exceptional in that its behavior is very
context dependent.  When 
.i dc
is executed from 
.i dskin
it simply records the
fact that the comment exists.  It is expected that in interactive mode
comments will be found via 
.i getdef
- this allows large
comments which do not take up space in your core image.  When 
.i dc
is executed from the terminal it expects you to type a comment.  
.i dskout
will write out the comments that you define and also copy the comments on the
old version of the file, so that the new version will keep the old comments
even though they were never actually brought into core.
The optional id is a mechanism for distinguishing among several
comments associated with the same word.  It defaults to nil.  However
if you define two comments with the same id, the second is considered
to be a replacement for the first.  
The behavior of
.i dc
is determined by the value of the global variable
.i def-comment.
.i def-comment
contains the name of a function that is run.
Its arguments are the word, id and attribute list.  
.i def-comment
is initially 
.i dc-define.
Other functions rebind it to 
.i dc-help,
.i dc-userhelp,
and the value of 
.i dskin-comment.
The comment property of an atom is a list of entries, each representing
one comment.  Atomic entries are assumed to be identifiers of comments on
a file but not in core.  In-core comments are represented by a list of the
id, the attribute list and the comment text.  The comment text is an
uninterned atom.  Comments may be deleted or reordered by editing the
comment property.

.Lf dskin "l_filenames"
.Se
READ-EVAL-PRINTs the contents of  the given files.  This
is the function to use to read files created by 
.i dskout.
.i dskin
also declares the files that it reads (if a 
.i file-fns
list is defined and the file is otherwise declarable by 
.i file
), so that changes to it can be recorded.

.Lf dskout "s_file1 ..."
.Se
For each file specified,
.i dskout
assumes  the  list named
filenameFNS (i.e.,  the file name,  excluding extension,
concatenated  with  
.i fns
)  contains  a  list  of function
names, etc., to be loaded
Any previous version of the file will be renamed  to have extension
".back".
.Lf dskouts "s_file1 ..."
.Se
applies
.i dskout
to and  prints the name  of each
s_filei   (with   no   additional    arguments,   assuming
filenameFNS to be a list to be loaded) for  which s_file\fIi\fP
is either not in \fIfilelst\fP  (meaning it is a new  file not
previously declared by \fIfile\fP  or given as an  argument to
\fIdskin\fP, \fIdskouts\fP, or \fIdskouts\fP) or is in \fIfilelst\fP and has some
recorded changes to definitions of atoms in filenameFNS,
as recorded by \fImark!changed\fP and noted by changes.
If \fIfile\fPi  is not  specified, \fIfilelst\fP  will be
used.  This  is the  most common  way of  using dskouts.
Typing  \fI(dskouts)\fP  will  save  every  file  reported  by
\fI(changes)\fP to have changed definitions.

.Lf dv  "s_atom g_value"
.Eq
\fI(setq atom 'value)\fP.
.i dv
calls  
.i mark!changed.
.Lf file "'s_file"
.Se
declares its argument to be a file to be used for reporting and saving
changes to functions by adding the file name to a list of files, 
.i filelst.
.i file
is called for each file argument of 
.i dskin,
.i dskout,
and 
.i dskouts.
.Lf file-fns "'s_file"
.Re
the name of the fileFNS list for its file argument s_file.
.Lf getdef "'s_file ['s_i1 ...]"
.Se
selectively executes definitions for atoms s_i1 ... from the
specified file.  Any of the words to be defined which end with "@"
will be treated as patterns in which the @ matchs any suffix
(just like the editor).  
.i getdef
is driven by
.i getdeftable
(and thus may be programmed).  It looks for lines in the file that start
with a word in the table.  The first character must be a "(" or "["
followed by the word, followed by a space, return or something else that will
not be considered as part of the identifier by 
.i read,
e.g., "(" is unacceptable.  When one is found the next word is read.  If
it matches one of the identifiers in the call to 
.i getdef 
then the table entry is executed.  The table entry is a function of the
expression starting in this line.  Output from
.i dskout
is in acceptable format for 
.i getdef.
.i getdef
.Re
a list of the words which match the ones it looked for, for which it found
(but, depending on the table, perhaps did not execute) in the file.
.No
.i getdeftable
is the table that drives 
.i getdef.
It is in the form of an association list.  Each element is a dotted pair
consisting of the name of a function for which
.i getdef
searches and a function of one argument to be executed when it is found.
.Lf mark!changed "'s_f"
.Se
records the fact that the definition of s_f has been changed.  It is
automatically called by 
.i def,
.i defun,
.i de,
.i df,
.i defprop,
.i dm,
.i dv,
and the editor when a definition is altered.



EndOfFile
cat >  doc/ch14.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/ch14.n,v 1.1 83/01/31 07:08:43 jkf Exp $
.Lc The\ LISP\ Stepper 14
.sh 2 Simple\ Use\ Of\ Stepping 14
.Lf step "s_arg1..."
.No
The LISP "stepping" package is intended to give the LISP programmer
a facility analogous to the Instruction Step mode of running a
machine language program.  
The user interface is through the function (fexpr) step, which sets
switches to put the LISP interpreter in and out of "stepping" mode.
The most common \fIstep\fP invocations follow.  These invocations are 
usually typed at the top-level, and will take effect
immediately (i.e. the next S-expression typed in will be evaluated in stepping
mode).
.Eb
\fI(step t)\fP				; Turn on stepping mode.
\fI(step nil)\fP			; Turn off stepping mode.
.Ee
.Se
In stepping mode, the LISP evaluator will print out each S-exp to
be evaluated before evaluation, and the returned value after evaluation,
calling itself recursively to display the stepped evaluation of each
argument, if the S-exp is a function call.  In stepping mode, the
evaluator will wait after displaying each S-exp before evaluation
for a command character from the console.
.Eb
\fISTEP COMMAND SUMMARY\fP

<return>			Continue stepping recursively.

c				Show returned value from this level
				only, and continue stepping upward.

e				Only step interpreted code.

g				Turn off stepping mode. (but continue
				evaluation without stepping).

n <number>			Step through <number> evaluations without 
				stopping

p				Redisplay current form in full
				(i.e. rebind prinlevel and prinlength to nil)

b				Get breakpoint

q				Quit

d				Call debug
.Ee
.sh 2 Advanced\ Features
.sh 3 Selectively\ Turning\ On\ Stepping.

If
       \fI(step foo1 foo2 ...)\fP

is typed at top level, stepping will not commence
immediately, but rather when the evaluator first encounters an S-expression
whose car is one of \fIfoo1, foo2\fP, etc.  This form will then display
at the console, and the evaluator will be in stepping mode waiting
for a command character.
.pp
Normally the stepper intercepts calls to \fIfuncall\fP and \fIeval\fP.
When \fIfuncall\fP is intercepted, the arguments to the function
have already been evaluated but when \fIeval\fP is intercepted, the
arguments have not been evaluated.  To differentiate the two cases, 
when printing the form in evaluation, the stepper preceded intercepted
calls to 
.i funcall
with "f:".
Calls to \fIfuncall\fP are normally caused by compiled lisp code calling
other functions, whereas calls to \fIeval\fP 
usually occur when lisp code is interpreted.
To step only calls to eval use:
	\fI(step e)\fP

.sh 3 Stepping\ With\ Breakpoints.
.pp
For the moment, step is turned off inside of error breaks, but not by
the break function.  Upon exiting the error, step is reenabled.
However, executing \fI(step nil)\fP inside a error loop will turn off
stepping globally, i.e. within the error loop, and after return has
be made from the loop.
.sh 2 Overhead\ of\ Stepping.
.pp
If stepping mode has been turned off by \fI(step nil)\fP, 
the execution overhead
of having the stepping packing in your LISP is identically nil.
If one stops stepping by typing "g", every call to eval
incurs a small overhead--several machine instructions, corresponding
to the compiled code for a simple cond and one function pushdown.
Running with \fI(step foo1 foo2 ...)\fP can be more expensive, since a
member of the car of the current form into the list \fI(foo1 foo2 ...)\fP
is required at each call to eval.
.sh 2 Evalhook\ and\ Funcallhook
.pp
There are hooks in the
.Fr
interpreter to permit a user written function to gain control of the
evaluation process.
These hooks are used by the Step package just described.
There are two hooks and they have been strategically placed in the
two key functions in the interpreter:
.i eval
(which all interpreted code goes through)
and  
.i funcall
(which all compiled code goes through if \fI(sstatus\ translink\ nil)\fP
has been done).
The hook in
.i eval
is compatible with Maclisp, but there is no
Maclisp equivalent of the hook in 
.i funcall .
.pp
To arm the hooks two forms must be evaluated: \fI(*rset\ t)\fP and
\fI(sstatus\ evalhook\ t)\fP.
Once that is done, 
.i eval
and
.i funcall
do a special check when they enter.
.pp
If 
.i eval 
is given a form to evaluate, say \fI(foo\ bar)\fP, 
and the symbol `evalhook' is non nil, say its value is `ehook',
then
.i eval
will lambda bind the symbols `evalhook' and `funcallhook'
to nil and will call ehook passing \fI(foo\ bar)\fP as the argument.
It is ehook's responsibility to evaluate \fI(foo\ bar)\fP and
return its value.
Typically ehook will call the function `evalhook' 
to evaluate \fI(foo\ bar)\fP.
Note that `evalhook' is a symbol whose function binding is a system function
described in Chapter 4, and whose value binding, if non nil, is the
name of a user written
function (or a lambda expression, or a binary object) which
will gain control whenever eval is called.
`evalhook' is also the name of the 
.i status 
tag which must be set for
all of this to work.
.pp
If 
.i funcall
is given a function, say foo, and a set of already evaluated 
arguments, say barv and bazv, and if the symbol `funcallhook'
has a non nil value, say `fhook', then
.i funcall
will lambda bind `evalhook' and `funcallhook' to nil
and will call fhook with arguments barv, bazv and foo.
Thus fhook must be a lexpr since it may be given any number
of arguments.  
The function to call, foo in this case, will be the
.i last
of the arguments given to fhook.
It is fhooks responsibility to do the function call and return the
value.
Typically fhook will call the function
.i funcallhook
to do the funcall.
This is an example of a funcallhook function which  just prints
the arguments on each entry to funcall and the return value.
.Eb
-> \fI(defun fhook n (let ((form (cons (arg n) (listify (1- n))))
			(retval))
		       (patom "calling ")(print form)(terpr)
		       (setq retval (funcallhook form 'fhook))
		       (patom "returns ")(print retval)(terpr)
		       retval))\fP
fhook
-> \fI(*rset t) (sstatus evalhook t) (sstatus translink nil)\fP
-> \fI(setq funcallhook 'fhook)\fP
calling (print fhook)		;; now all compiled code is traced
fhookreturns nil
calling (terpr)

returns nil
calling (patom "-> ")
-> returns "-> "
calling (read nil Q00000)
\fI(array foo t 10)\fP		;; to test it, we see what happens when
returns (array foo t 10) 	;; we make an array
calling (eval (array foo t 10))
calling (append (10) nil)
returns (10)
calling (lessp 1 1)
returns nil
calling (apply times (10))
returns 10
calling (small-segment value 10)
calling (boole 4 137 127)
returns 128
 ... there is plenty more ...
.Ee
EndOfFile
cat >  doc/ch15.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/ch15.n,v 1.1 83/01/31 07:08:47 jkf Exp $
.Lc The\ FIXIT\ Debugger 15
.sh 2 Introduction 15
FIXIT is a debugging environment for
.Fr
users doing program development.  This documentation and FIXIT
were written by David S. Touretzky
of Carnegie-Mellon University for MACLisp, and adapted to
.Fr
by Mitch Marcus of Bell Labs.  One of
FIXIT's goals is to get the program running again as quickly
as possible.  The user is assisted in making changes to his
functions "on the fly", i.e. in the midst of execution, and
then computation is resumed.
.pp
To enter the debugger type \fI(debug)\fP.
The debugger goes into its own
read-eval-print loop.  Like the top-level, the debugger understands
certain special commands.  One of these is help, which prints a list of
the available commands.  The basic idea is that you are somewhere in a
stack of calls to eval.  The command "bka" is probably the most appropriate
for looking at the stack.  There are commands to move up and down.  If
you want to know the value of "x" as of some place in the stack, move to
that place and type "x" (or (cdr x) or anything else that you might want
to evaluate).  All evaluation is done as of the current stack position.
You can fix the problem by changing the values of variables, editing
functions or expressions in the stack etc.  Then you can continue from
the current stack position (or anywhere else) with the "redo" command.
Or you can simply return the right answer with the "return" command.
.pp
When it is not immediately obvious why an error has occurred
or how the program got itself into its current state, FIXIT
comes to the rescue by providing a powerful debugging loop
in which the user can:

-  examine the stack

-  evaluate expressions in context

-  enter stepping mode

-  restart the computation at any point

The result is that program errors can be located and fixed
extremely rapidly, and with a minimum of frustration.
.pp
The debugger can only work effectively when extra information is kept
about forms in evaluation by the lisp system.
Evaluating \fI(*rset\ t)\fP tells the lisp system to maintain this
information. 
If you are debugging compiled code you should also be sure that the
compiled code to compiled code linkage tables are unlinked, i.e
do \fI(sstatus\ translink\ nil)\fP.

.Lf debug "[ s_msg ]"
.No
Within a program, you may enter a debug loop directly by
putting in a call to 
.i debug
where you would normally put
a call to
.i break.
Also, within a break loop you may enter
FIXIT by typing 
.i debug.  
If an argument is given to DEBUG,
it is treated as a message to be printed before the debug loop
is entered.  Thus you can put \fI(debug |just before loop|)\fP into
a program to indicate what part of the program is being debugged.

.Eb
\fIFIXIT Command Summary\fP

TOP     go to top of stack (latest expression)
BOT     go to bottom of stack (first expression)
P       show current expression (with ellipsis)
PP      show current expression in full
WHERE   give current stack position
HELP    types the abbreviated command summary found
        in /usr/lisp/doc/fixit.help.  H and ? work too.
U       go up one stack frame
U n     go up n stack frames
U f     go up to the next occurrence of function f
U n f   go up n occurrences of function f
UP      go up to the next user-written function
UP n    go up n user-written functions
 ...the DN and DNFN commands are similar, but go down
 ...instead of up.
OK      resume processing; continue after an error or debug loop
REDO    restart the computation with the current stack frame.
        The OK command is equivalent to TOP followed by REDO.
REDO f  restart the computation with the last call to function f.
        (The stack is searched downward from the current position.)
STEP    restart the computation at the current stack frame,
        but first turn on stepping mode.  (Assumes Rich stepper is loaded.)
RETURN e   return from the current position in the computation
           with the value of expression e.
BK..    print a backtrace.  There are many backtrace commands,
        formed by adding suffixes to the BK command.  "BK" gives
        a backtrace showing only user-written functions, and uses
        ellipsis.  The BK command may be suffixed by one or more
        of the following modifiers:
 ..F..   show function names instead of expressions
 ..A..   show all functions/expressions, not just user-written ones
 ..V..   show variable bindings as well as functions/expressions
 ..E..   show everything in the expression, i.e. don't use ellipsis
 ..C..   go no further than the current position on the stack
        Some of the more useful combinations are BKFV, BKFA,
        and BKFAV.
BK.. n    show only n levels of the stack (starting at the top).
          (BK n counts only user functions; BKA n counts all functions.)
BK.. f    show stack down to first call of function f
BK.. n f  show stack down to nth call of function f
.Ee
.sh 2 Interaction\ with\ \fItrace\fP
FIXIT knows about the standard Franz 
trace package, and tries to make
tracing invisible while in the debug loop.  However, because
of the way
.i trace
works, it may sometimes be the case that the
functions on the stack are really un\fIintern\fPed atoms that have
the same name as a traced function.  (This only happens when
a function is traced WHEREIN another one.)  FIXIT will call
attention to 
.i trace's 
hackery by printing an appropriate tag
next to these stack entries.

.sh 2 Interaction\ with\ \fIstep\fP 
The 
.i step
function may be invoked
from within FIXIT via the STEP command.  FIXIT initially turns off 
stepping when the debug loop is entered.  If you step through a function
and get an error, FIXIT will still be invoked normally.  At
any time during stepping, you may explicitly enter FIXIT
via the "D" (debug) command.

.sh 2 Multiple\ error\ levels
FIXIT will evaluate arbitrary LISP 
expressions in its debug loop.  The evaluation is not done within an 
.i errset,
so, if an error occurs, another invocation of the debugger
can be made.  When there are multiple errors on the stack,
FIXIT displays a barrier symbol between each level that
looks something like <------------UDF-->.  The UDF in
this case stands for UnDefined Function.  Thus, the upper
level debug loop was invoked by an undefined function error
that occurred while in the lower loop.
EndOfFile
cat >  doc/ch16.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/ch16.n,v 1.1 83/01/31 07:08:55 jkf Exp $
.Lc The\ LISP\ Editor 16

.sh 2 The\ Editors 16

It is quite possible to use VI, Emacs or other standard editors to edit your
lisp programs, and many people do just that.
However there is a lisp
structure editor which is particularly good for the editing
of lisp programs, and operates in a rather different fashion, namely
within a lisp environment.
application.  It
is handy to know how to use it for fixing problems without exiting
from the lisp system (e.g. from the debugger
so you can continue to execute rather than having to start over.)  The
editor is not quite like the top-level and debugger, in that it expects
you to type editor commands to it.  It will not evaluate whatever you
happen to type.  (There is an editor command to evaluate things, though.)

The editor is available (assuming your system is set up correctly with
a lisp library) by typing (load 'cmufncs) and (load 'cmuedit).

The  most  frequent  use of the editor is to change function
definitions by starting the editor with one of the commands described in
section 16.14. (see \fIeditf\fP), values (\fIeditv\fP), properties
(\fIeditp\fP), and  expressions  (\fIedite\fP).  The beginner  is
advised to start with the following (very basic) commands: \fIok,
undo, p, #\fP, under which are explained two different basic commands
which  start with numbers, and f.  

This documentation, and the editor, were imported from PDP-10 CMULisp
by Don Cohen.  PDP-10 CMULisp is based on UCILisp, and the editor
itself was derived from an early version of Interlisp.  Lars
Ericson, the author of this section,
has provided this very concise summary.
Tutorial examples and implementation details
may be found in the Interlisp Reference Manual,
where a similar editor is described.

.sh 2 Scope\ of\ Attention

Attention-changing commands allow you to look at a different
part of a Lisp expression you are editing.
The sub-structure upon which the editor's attention is
centered is called "the current expression".   Changing the
current expression means shifting attention and not actually modifying
any structure.
.Fb
.fi
\fISCOPE OF ATTENTION COMMAND SUMMARY\fP

\fIn (n>0) \fP. Makes the nth element of the current expression be the
new current expression.

\fI-n (n>0)\fP. Makes the nth element from the end of the current
expression be the new current expression.  

\fI0\fP. Makes the  next  higher expression  be  the  new  correct
expression.  If the intention is to go back to the next higher left
parenthesis, use the command !0.

\fIup\ \fP.  If a p command would cause the editor to
type ...  before typing the current expression, (the current
expression is a tail of the next higher expression) then has no effect;
else, up makes the old current expression the first element in the new
current expression.

\fI!0 \fP. Goes back to the next higher left parenthesis.

\fI^\ \fP.
Makes the top level expression be the current expression.  

\fInx\ \fP.
Makes the current expression be the next expression.  

\fI(nx n)\fP equivalent to n nx commands.

\fI!nx \fP.  Makes current expression be the next
expression at a higher level.  Goes through any number of right
parentheses to get to the next expression.

\fI bk\ \fP.
Makes the current expression be the previous expression in the next
higher expression.  

\fI(nth n) n>0 \fP.  Makes the list starting with
the nth element of the current expression be the current expression.

\fI(nth $) - generalized nth command.\fP nth locates $, and then backs
up to the current level, where the new current expression is the tail
whose first element contains, however deeply, the expression that was
the terminus of the location operation.

\fI:: \fP.  (pattern ::  .  $)  e.g., (cond ::
return).  finds a cond that contains a return, at any depth.

\fI(below com x) \fP.  The below command is useful for
locating a substructure by specifying something  it contains.  (below
cond) will cause the cond clause containing  the current  expression to
become the new current expression.  Suppose you are editing a list
of lists, and want to find a sublist that contains a foo (at any
depth).  Then simply executes f foo (below \).

\fI(nex x) \fP.  same as \fI(below x)\fP followed by
nx.  For example, if you are deep inside of a selectq clause, you
can advance to the next clause with \fI(nex selectq)\fP.

\fInex\fP.  The  atomic  form  of  \fInex\fP is useful
if you will be performing repeated  executions  of  \fI(nex  x)\fP.  By
simply  marking  the  chain corresponding to x,  you can use \fInex\fP to step
through the sublists.	
.Fe
.br
.sh 2 Pattern\ Matching\ Commands

Many editor commands that search take patterns.
A pattern \fIpat\fP matches with x if:
.Fb
.fi
\fIPATTERN SPECIFICATION SUMMARY\fP

- \fIpat\fP is \fIeq\fP to x.  

- \fIpat\fP is &.  

- \fIpat\fP is a number and equal to x.  

- if (car \fIpat\fP) is the atom *any*, (cdr \fIpat\fP) is a list of patterns, and
\fIpat\fP matches x if and only if one of the patterns on (cdr \fIpat\fP) matches x.

- if \fIpat\fP is a literal atom or string, and (nthchar \fIpat\fP -1) is @, then
\fIpat\fP matches with any literal atom or string which has the same initial
characters as \fIpat\fP, e.g.  ver@ matches with verylongatom, as well as
"verylongstring".

- if (car \fIpat\fP) is the atom --, \fIpat\fP matches x if (a) (cdr \fIpat\fP)=nil, i.e.
\fIpat\fP=(--), e.g., (a --) matches (a) (a b c) and (a .  b) in other words,
-- can match any tail of a list.  (b) (cdr \fIpat\fP) matches with some tail
of x, e.g.  (a -- (&)) will match with (a b c (d)), but not (a b c d),
or (a b c (d) e).  however, note that (a -- (&) --) will match with (a b
c (d) e).  in other words, -- will match any interior segment of a list.

- if (car \fIpat\fP) is the atom ==, \fIpat\fP matches x if and only if (cdr \fIpat\fP)
is \fIeq\fP to x.  (this pattern is for use by programs that call the editor
as a subroutine, since any non-atomic expression in a command typed in
by the user obviously cannot be \fIeq\fP to existing structure.)
- otherwise if x is a list, \fIpat\fP matches x if (car \fIpat\fP) matches (car
x), and (cdr \fIpat\fP) matches (cdr x).

- when searching, the pattern matching routine is called only to match
with elements in the structure, unless the pattern begins with :::, in
which case cdr of the pattern is matched against tails in the
structure.  (in this case, the tail does not have to be a proper tail,
e.g.  (:::  a --) will match with the element (a b c) as well as with cdr
of (x a b c), since (a b c) is a tail of (a b c).)   
.Fe
.sh 3 Commands\ That\ Search
.Fb
.fi
\fISEARCH COMMAND SUMMARY\fP

\fIf pattern \fP.  f informs the editor that the next
command is to be interpreted as a pattern.  If no pattern is given on
the same line as the f then the last pattern is used.  f pattern means
find the next instance of pattern.

\fI(f pattern n)\fP.  Finds the next instance of pattern.

\fI(f pattern t)\fP.  similar to f pattern, except, for example, if the
current expression is (cond ..), f cond will look for the next cond,
but (f cond t) will 'stay here'.

\fI(f pattern n) n>0\fP.  Finds the nth place that pattern matches.
If the current expression is (foo1 foo2 foo3), (f f00@ 3) will find foo3.

\fI(f pattern) or (f pattern nil)\fP.  only matches with elements at
the top level of the current expression.  If the current expression is
\fI(prog nil (setq x (cond & &)) (cond &) ...)\fP f (cond --) will find
the cond inside the setq, whereas (f (cond --)) will find the top level
cond, i.e., the second one.

\fI(second . $) \fP.
same as (lc .  $) followed by another (lc .  $) except that if the
first succeeds and second fails, no change is made to the edit chain.

\fI(third . $) \fP.  Similar to second.

\fI(fs pattern1 ... patternn) \fP.
equivalent to f pattern1 followed by f pattern2 ...  followed by f
pattern n, so that if f pattern m fails, edit chain is left at place
pattern m-1 matched.

\fI(f= expression x) \fP.  Searches for a structure eq
to expression.

\fI(orf pattern1 ... patternn) \fP.  Searches for an
expression that is matched by either pattern1 or ...  patternn.

\fIbf pattern \fP.  backwards find.   If the current
expression is \fI(prog nil (setq x (setq y (list z))) (cond ((setq w
--) --)) --)\fP f list followed by bf setq will leave the current
expression as (setq y (list z)), as will f cond followed by bf setq

\fI(bf pattern t)\fP. backwards find.  Search always includes current
expression, i.e., starts at end of current expression and works
backward, then ascends and backs up, etc.
.Fe
.sh 4 Location\ Specifications
.
Many editor commands use a 
method of specifying position called a location specification.  The
meta-symbol $ is used to denote a location specification.   $ is a
list of commands interpreted as described above.  $ can also be atomic,
in which case it is interpreted as (list $).  a location specification
is a list of edit commands that are executed in the normal fashion with
two exceptions.  first, all commands not recognized by the editor are
interpreted as though they had been preceded by f.  
The location specification
(cond 2 3) specifies the 3rd element in the first clause of the next
cond.

the if command and the ## function provide a way of using in location
specifications arbitrary predicates applied to elements in the current
expression.

In insert, delete, replace and change, if $ is nil (empty), the
corresponding operation is performed on the current edit chain, i.e.
(replace with (car x)) is equivalent to (:(car x)).  for added
readability, here is also permitted, e.g., (insert (print x) before
here) will insert (print x) before the current expression (but not
change the edit chain).  It is perfectly legal to ascend to insert,
replace, or delete.  for example (insert (\fIreturn\fP) after ^ prog
-1) will go to the top, find the first prog, and insert a
(\fIreturn\fP) at its end, and not change the current edit chain.

The a, b, and :  commands all make special checks in e1 thru em for
expressions of the form (## . coms).  In this case, the expression used
for inserting or replacing is a copy of the current expression after
executing coms, a list of edit commands.   (insert (## f cond -1 -1)
after3)  will make a copy of the last form in the last clause of the
next cond, and insert it after the third element of the current 
expression.

\fI$\fP.  In descriptions of the editor, the meta-symbol $ is used to
denote a location specification.   $ is a list of commands interpreted
as described above.  $ can also be atomic.
.Fb
.fi
\fILOCATION COMMAND SUMMARY\fP

\fI(lc . $) \fP.
Provides a way of explicitly invoking the location operation.
(lc cond 2 3) will perform search.

\fI(lcl . $) \fP.  Same as lc except search is confined
to current expression.  To find a cond containing a \fIreturn\fP, one
might use the location specification (cond (lcl \fIreturn\fP) \) where
the \ would reverse the effects of the lcl command, and make the final
current expression be the cond.
.Fe
.sh 3 The\ Edit\ Chain
The edit-chain is a list of which the first element is the the one you
are now editing ("current expression"), the next element is what would
become the current expression if you were to do a 0, etc., until the
last element which is the expression that was passed to the editor.
.Fb
.fi
\fIEDIT CHAIN COMMAND SUMMARY\fP

\fImark \fP.
Adds the current edit chain to the front of the list marklst.

\fI_ \fP.
Makes the new edit chain be (car marklst).  

\fI(_ pattern) \fP.  Ascends the edit chain looking for
a link which matches pattern.  for example:

\fI__ \fP.
Similar to _ but also erases the mark.

\fI\\ \fP. Makes the edit chain be the value of unfind.
unfind is set to the current edit chain by each command that makes a
"big jump", i.e., a command that usually performs more than a single
ascent or descent, namely ^, _, __, !nx, all commands that involve a
search, e.g., f, lc, ::, below, et al and \ and \p themselves.     if
the user types f cond, and then f car, \ would take him back to the
cond.  another \ would take him back to the car, etc.

\fI\\p \fP.  Restores the edit chain to its state as of
the last print operation.  If the edit chain has not changed since the
last printing, \\p restores it to its state as of the printing before
that one.  If the user types p followed by 3 2 1 p, \\p will return to
the first p, i.e., would be equivalent to 0 0 0.  Another \\p would
then take him back to the second p.
.Fe
.sh 2 Printing\ Commands
.Fb
.fi
\fIPRINTING COMMAND SUMMARY\fP

\fIp \fP Prints current expression in abbreviated
form.  (p m) prints mth element of current expression in abbreviated
form.  (p m n) prints mth element of current expression as though
printlev were given a depth of n.  (p 0 n) prints current expression as
though printlev were given a depth of n.  (p cond 3) will work.

\fI?  \fP.  prints the current expression as though
printlev were given a depth of 100.

\fIpp \fP.  pretty-prints the current expression.

\fIpp*\fP.  is like pp, but forces comments to be shown.
.Fe
.sh 2 Structure\ Modification\ Commands

All structure modification commands are undoable.  See \fIundo\fP.

.Fb
.fi
\fISTRUCTURE MODIFICATION COMMAND SUMMARY\fP

\fI# [editor commands]\fP (n)  n>1 deletes the
corresponding element from the current expression.

\fI(n e1 ...  em) n,m>1\fP replaces the nth element in the current
expression with e1 ...  em.

\fI(-n e1 ...  em) n,m>1\fP inserts e1 ...  em before the n element in the
current expression.

\fI(n e1 ...  em)\fP (the letter "n" for "next" or "nconc", not a number)
m>1 attaches e1 ...  em at the end of the current expression.

\fI(a e1 ... em) \fP.  inserts e1 ...  em after the
current expression (or after its first element if it is a tail).

\fI(b e1 ... em) \fP.  inserts e1 ...  em before the
current expression.  to insert foo before the last element in the
current expression, perform -1 and then (b foo).

\fI(: e1 ... em) \fP.  replaces the current expression
by e1 ...  em.    If the current expression is a tail then replace its
first element.

\fIdelete or (:)  \fP.  deletes the current expression,
or if the current expression is a tail, deletes its first element.

\fI(delete . $)\fP.  does a (lc .  $) followed by delete.  current edit
chain is not changed.

\fI(insert e1 ... em before . $) \fP.  similar to (lc.
$) followed by (b e1 ... em).

\fI(insert e1 ...  em after .  $)\fP.  similar to insert before except
uses a instead of b.

\fI(insert e1 ...  em for .  $)\fP.  similar to insert before except
uses :  for b.

\fI(replace $ with e1 ... em) \fP.  here $ is the
segment of the command between replace and with.  

\fI(change $ to e1 ... em) \fP.  same as replace with.
.Fe
.sh 2 Extraction\ and\ Embedding\ Commands
.Fb
.fi
\fIEXTRACTION AND EMBEDDING COMMAND SUMMARY\fP

\fI(xtr . $) \fP.  replaces the original current
expression with the expression that is current after performing (lcl . $).

\fI(mbd x) \fP.  x is a list, substitutes the current
expression for all instances of the atom * in x, and replaces the
current expression with the result of that substitution.  (mbd x) :  x
atomic, same as (mbd (x *)).

\fI(extract $1 from $2) \fP.  extract is an editor
command which replaces the current expression with one of its
subexpressions (from any depth).  ($1 is the segment between extract
and from.)    example:  if the current expression is (print (cond
((null x) y) (t z))) then following (extract y from cond), the current
expression will be (print y).  (extract 2 -1 from cond), (extract y
from 2), (extract 2 -1 from 2) will all produce the same result.

\fI(embed $ in . x) \fP.  embed replaces the current
expression with a new expression which contains it as a subexpression.
($ is the segment between embed and in.)   example:  (embed print in
setq x), (embed 3 2 in \fIreturn\fP), (embed cond 3 1 in (or * (null x))). 
.Fe
.sh 2 Move\ and\ Copy\ Commands
.Fb
.fi
\fIMOVE AND COPY COMMAND SUMMARY\fP

\fI(move $1 to com . $2) \fP.  ($1 is the segment
between move and to.)  where com is before, after, or the name of a
list command, e.g., :, n, etc.  If $2 is nil, or (here), the current
position specifies where the operation is to take place.  If $1 is nil,
the move command allows the user to specify some place the current
expression is to be moved to.   if the current expression is (a b d c),
(move 2 to after 4) will make the new current expression be (a c d b).

\fI(mv com . $) \fP.  is the same as (move here to com . $).

\fI(copy $1 to com . $2)\fP  is like move except that the source
expression is not deleted.

\fI(cp com . $)\fP.  is like mv except that the source expression is
not deleted.
.Fe
.sh 2 Parentheses\ Moving\ Commands
The commands presented in this section permit modification of the
list structure itself, as opposed to modifying components thereof.
their effect can be described as inserting or removing a single left or
right parenthesis, or pair of left and right parentheses.  
.Fb
.fi
\fIPARENTHESES MOVING COMMAND SUMMARY\fP

\fI(bi n m) \fP.  both in.  inserts parentheses before
the nth element and after the mth element in the current expression.
example:  if the current expression is (a b (c d e) f g), then (bi 2 4)
will modify it to be (a (b (c d e) f) g).  (bi n) :  same as (bi n n).
example:  if the current expression is (a b (c d e) f g), then (bi -2)
will modify it to be (a b (c d e) (f) g).

\fI(bo n) \fP.  both out.  removes both parentheses
from the nth element.  example:  if the current expression is (a b (c d
e) f g), then (bo d) will modify it to be (a b c d e f g).

\fI(li n) \fP.  left in.  inserts a left parenthesis
before the nth element (and a matching right parenthesis at the end of
the current expression).  example:  if the current expression is (a b
(c d e) f g), then (li 2) will modify it to be (a (b (c d e) f g)).

\fI(lo n) \fP.  left  out.  removes  a  left
parenthesis  from the nth element. all elements following the nth
element are deleted.  example: if the current expression is (a b (c d
e) f g), then  (lo  3) will modify it to be (a b c d e).

\fI(ri n m) \fP.  right  in.  move  the  right
parenthesis at the end of the nth element in to after the mth element.
inserts  a  right parenthesis  after  the mth element of the nth
element.  The rest of the nth element is brought up to the level of
the  current expression.   example: if the current expression is (a (b
c d e) f g), (ri 2 2) will modify it to be (a (b c) d e f g).

\fI(ro n) \fP.  right  out.  move the right parenthesis
at the end of the nth element out to the  end of the current
expression.  removes the right parenthesis from the nth element, moving
it to the end of the current expression. all elements following the
nth  element  are moved  inside of  the  nth element.  example: if the
current expression is (a b (c d e) f  g),  (ro  3) will modify  it to
be (a b (c d e f g)).

\fI(r x y) \fP replaces  all  instances  of x by y in
the current expression, e.g., (r caadr cadar).  x can be the
s-expression (or atom) to be substituted for, or can be a pattern which
specifies that s-expression (or atom).

\fI(sw n m) \fP switches the nth and mth elements of
the current expression.  for example, if the current expression is
(list (cons (car x) (car y)) (cons (cdr y))),  (sw  2 3)  will  modify
it to be (list (cons (cdr x) (cdr y)) (cons (car x) (car y))).   (sw
car  cdr) would produce the same result.
.Fe
.sh 3 Using\ to\ and\ thru

to, thru, extract, embed, delete, replace, and move can be made to
operate on several contiguous elements, i.e., a segment of a list, by
using the to or thru command in their respective location
specifications.  thru and to are intended to be used  in conjunction
with extract, embed, delete, replace, and move.    to and thru can also
be used directly with xtr (which takes after a location specification),
as in (xtr (2 thru 4)) (from the current expression).
.Fb
.fi
\fITO AND THRU COMMAND SUMMARY\fP

\fI($1 to $2)   \fP.  same as thru except last element
not included.

\fI($1 to)\fP.  same as ($1 thru -1)

\fI($1 thru $2)  \fP.  If the current expression is (a
(b (c d) (e) (f g h) i) j k), following (c thru g), the current
expression will be ((c d) (e) (f g h)).  If both $1 and $2 are numbers,
and $2 is greater than $1, then $2 counts from the beginning of the
current expression, the same as $1.  in other words, if the current
expression is (a b c d e f g), (3 thru 4) means (c thru d), not (c thru
f).  in this case, the corresponding bi command is (bi 1 $2-$1+1).

\fI($1 thru)\fP. same as \fI($1 thru -1)\fP.
.Fe
.sh 2 Undoing\ Commands
each command that causes structure modification automatically adds an
entry to the front of undolst containing the information required to
restore all pointers that were changed by the command.  The undo
command undoes the last, i.e., most recent such command.
.Fb
.fi
\fIUNDO COMMAND SUMMARY\fP

\fIundo \fP.  the undo command undoes most recent, structure
modification command that has not yet been undone, and prints the name
of that command, e.g., mbd undone.  The edit chain is then exactly what
it was before the 'undone' command had been performed.

\fI!undo \fP.  undoes all modifications performed during this editing
session, i.e., this call to the editor.

\fIunblock \fP.  removes  an  undo-block. If executed at a non-blocked
state, i.e., if undo or !undo could operate, types not blocked.

\fItest \fP.  adds an undo-block at the front of undolst.  note  that
test  together  with !undo  provide  a  'tentative'  mode  for editing,
i.e., the user can perform a number of changes, and then undo all of
them with a single !undo command.

\fIundolst [value]\fP.  each editor command that causes structure
modification automatically adds an entry to the front of undolst
containing the information required to restore all pointers that were
changed by the command.

\fI??  \fP prints the entries on undolst.  The entries are listed most
recent entry first.
.Fe
.sh 2 \Commands\ that\ Evaluate
.Fb
.fi
\fIEVALUATION COMMAND SUMMARY\fP

\fIe \fP.  only when typed in, (i.e., (insert d before e) will treat
e  as  a  pattern) causes  the  editor  to  call  the lisp interpreter
giving it the next input as argument.

\fI(e  x)\fP  evaluates  x, and prints the result.  (e x t) same as (e
x) but does not print.  

\fI(i c x1 ... xn) \fP same as (c y1 ...  yn) where yi=(eval xi).
example:  (i 3 (cdr foo)) will replace the 3rd element of the current
expression with the cdr of the value of foo.  (i n foo (car fie)) will
attach the value of foo and car of the value of fie to the end of the
current expression.  (i f= foo t) will search for an expression eq to
the value of foo.  If c is not an atom, it is evaluated as well.

\fI(coms x1 ... xn) \fP.  each  xi  is evaluated and its value executed
as a command.  The i command is not very convenient for computing an
entire edit command for  execution,  since it computes the command name
and its arguments separately. also, the i command cannot be used to
compute an  atomic  command.  The  coms  and comsq  commands provide
more  general ways of computing commands.  (coms (cond (x (list 1 x))))
will replace the first element of the current expression with the value
of x if non-nil, otherwise do nothing. (nil as a command is a nop.)

\fI(comsq com1 ... comn) \fP.  executes com1 ... comn.  comsq is mainly
useful in conjunction with the  coms command.    for example,  suppose
the user wishes to compute an entire list of commands for evaluation,
as opposed to computing each command one at a time  as does  the coms
command. he would then write (coms (cons (quote comsq) x)) where x
computed the list of commands, e.g.,  (coms  (cons  (quote comsq)
(get  foo (quote commands))))
.Fe
.sh 2 Commands\ that\ Test
.Fb
.fi
\fITESTING COMMAND SUMMARY\fP

\fI(if x) \fP generates an error unless the value of (eval x) is
non-nil, i.e., if (eval x) causes an error or (eval x)=nil, if will
cause an error.  (if x coms1 coms2) if (eval  x) is non-nil, execute
coms1; if (eval x) causes an error or is equal to nil, execute coms2.
(if x coms1)  if  (eval  x)  is  non-nil,  execute  coms1; otherwise
generate  an  error.

\fI(lp . coms) \fP.  repeatedly executes coms, a list of commands,
until an  error  occurs.      (lp  f  print (n  t))  will  attach  a
t  at the end of every print expression. (lp f print (if (## 3) nil ((n
t)))) will attach a t at the end  of each print expression which does
not already have a second argument.  (i.e.  the form  (## 3) will cause
an error if the edit command 3 causes an error, thereby selecting ((n
t)) as the list of commands to be executed.  The if could also  be
written  as  (if  (cddr (##)) nil ((n t))).).

\fI(lpq . coms) \fP same as lp but does not print n occurrences.

\fI(orr coms1 ... comsn) \fP.  orr begins by executing coms1, a list of
commands.  If no error occurs, orr is finished.  otherwise, orr
restores the edit chain to  its  original  value,  and continues by
executing coms2, etc.  If none of the command lists execute without
errors,  i.e., the orr "drops off the end", orr generates an error.
otherwise, the edit chain is left as of the completion of the first
command  list  which executes  without error.
.Fe
.sh 2 Editor\ Macros

Many of the more sophisticated branching commands in the editor, such
as orr, if,  etc.,  are  most  often  used  in  conjunction with edit
macros.  The macro feature permits the user to define new commands and
thereby expand the editor's repertoire. (however, built in commands
always  take  precedence  over  macros, i.e.,  the  editor's
repertoire can be expanded, but not modified.) macros are defined by
using the m command.

\fI(m c . coms) \fP for c an atom, m defines c as an
atomic command.  (if a macro  is  redefined, its new definition
replaces its old.) executing c is then the same as executing the  list
of  commands  coms.    macros  can  also define list commands, i.e.,
commands that take arguments.  (m (c) (arg[1] ... arg[n]) . coms) c an
atom.  m defines c as a list command.  executing (c e1 ...  en)  is
then  performed  by substituting  e1  for  arg[1],  ...    en  for
arg[n] throughout coms, and then executing coms.  a list command can be
defined via a macro  so  as  to  take  a fixed  or  indefinite  number
of 'arguments'.  The form given above specified a macro with a fixed
number of arguments, as indicated by its argument list.   if the
'argument  list'  is  atomic,  the  command  takes an indefinite number
of arguments.  (m (c) args . coms) c,  args  both  atoms,  defines  c
as  a  list command.  executing  (c  e1 ...  en) is performed by
substituting (e1 ...  en), i.e., cdr of the command, for args
throughout coms, and then executing coms.

(m bp bk up p) will define bp as an atomic  command  which  does three
things,  a bk, an up, and a p. note that macros can use commands
defined by macros as well as built in commands in  their
definitions.    for  example, suppose  z  is  defined by (m z -1 (if
(null (##)) nil (p))), i.e. z does a -1, and then if the current
expression is not nil, a p. now we can define zz by  (m zz  -1 z), and
zzz by (m zzz -1 -1 z) or (m zzz -1 zz).  we could define a more
general bp by (m (bp) (n) (bk n) up p).    (bp 3)  would  perform  (bk
3), followed  by  an  up,  followed  by a p.  The command second can be
defined as a macro by (m (2nd) x (orr ((lc .  x) (lc .  x)))).

Note  that  for  all editor commands, 'built in' commands as well as
commands defined by macros, atomic  definitions  and  list
definitions  are  completely independent.  in other words, the
existence of an atomic definition for c in no way  affects  the
treatment of c when it appears as car of a list command, and the
existence of a list definition for c in no way affects the treatment
of  c when it appears as an atom.  in particular, c can be used as the
name of either an atomic command, or a list command, or both. in the
latter case, two entirely different  definitions  can  be  used.   note
also that once c is defined as an atomic command via a macro
definition, it will not be searched for when used in a location
specification, unless c is preceded by an f.  (insert --  before
bp) would not search for bp, but instead perform a bk, an up, and a p,
and then do the insertion.  The corresponding also holds true for list
commands.

\fI(bind . coms) \fP bind  is  an  edit  command which
is useful mainly in macros.  it binds three dummy variables #1, #2, #3,
(initialized to nil), and then  executes  the  edit commands  coms.
note that these bindings are only in effect while the commands are
being executed, and that bind can be used recursively; it will  rebind
#1, #2,  and  #3 each time it is invoked.

\fIusermacros [value]\fP.  this  variable  contains the users editing
macros .   if you want to save your macros then you should save
usermacros.  you  should  probably  also  save editcomsl.

\fIeditcomsl [value]\fP.
editcomsl  is  the  list of "list commands" recognized by the editor.  (these
are the ones of the form (command arg1 arg2 ...).)

.sh 2 Miscellaneous\ Editor\ Commands
.Fb
.fi
\fIMISCELLANEOUS EDITOR COMMAND SUMMARY\fP

\fIok \fP.  Exits from the editor.

\fInil \fP.  Unless preceded by f or bf, is always a null operation.

\fItty:  \fP.  Calls  the  editor  recursively.  The user can then type
in commands, and have them executed.  The tty:  command is completed
when  the  user exits  from  the lower  editor  (with  ok  or  stop).
the tty:  command is extremely useful. it enables the user to  set  up
a complex  operation,  and  perform  interactive attention-changing
commands part way through it. for example the command (move 3 to after
cond 3 p tty:) allows the user to interact, in  effect,  within  the
move  command.      he can verify for himself that the correct location
has been found, or complete the specification "by hand". in effect,
tty: says "I'll tell you what you should do when you get there."

\fIstop \fP.  exits from the editor with an error.  mainly for use in
conjunction with tty:  commands that the user wants to abort.  since
all of the commands in the editor are  errset protected, the user must
exit from the editor via a command.  stop provides a way of
distinguishing between a successful  and unsuccessful  (from the
user's  standpoint) editing session.

\fItl \fP.  tl  calls (top-level).  to return to the editor just use
the \fIreturn\fP top-level command.

\fIrepack \fP.  permits the 'editing' of an atom or string.

\fI(repack $)\fP does (lc . $) followed by repack, e.g. (repack this@).

\fI(makefn form args n m) \fP.  makes (car form) an expr with the nth
through mth  elements  of  the  current expression with  each
occurrence  of  an element of (cdr form) replaced by the corresponding
element of args.  The nth through mth  elements  are replaced  by form.

\fI(makefn form args n)\fP.  same as (makefn form args n n).

\fI(s var . $) \fP.  sets var (using setq) to the current expression
after performing (lc .    $).    (s  foo)  will  set foo to the current
expression, (s foo -1 1) will set foo to the first element in the last
element of the current expression.
.Fe
.sh 2 Editor\ Functions

.Lf editf "s_x1 ..."
.Se
edits a function. s_x1 is the name of the function,
any additional arguments are an optional list of commands.
.Re
s_x1.
.No
if s_x1 is not an editable function, editf generates an fn not editable error.

.Lf edite "l_expr l_coms s_atm)"
edits an expression.  its value is the last element of (editl (list
l_expr) l_coms s_atm nil nil).  

.Lf editracefn "s_com"
is available to help the user debug complex edit macros, or subroutine
calls to  the  editor. editracefn is to be defined by the user.
whenever the value of editracefn  is  non-nil,  the  editor  calls
the  function  editracefn  before executing  each command (at any
level), giving it that command as its argument.  editracefn is
initially equal to nil, and undefined.

.Lf editv "s_var [ g_com1 ... ]"
.Se
similar to editf, for editing values.  editv sets the variable to the value
returned.
.Re
the name of the variable whose value was edited.

.Lf editp "s_x"
.Se
similar to editf for editing property lists.  
used if x is nil.  
.Re
the atom whose property list was edited.

.Lf editl "coms atm marklst mess"
.Se
editl is the editor.  its first argument is the edit chain, and its
value is an edit chain, namely the value of l at the time editl is
exited.  (l is a special variable, and so can be examined or set by
edit commands.   ^ is equivalent to (e (setq l(last l)) t).)  coms is
an optional list of commands.  for interactive editing, coms is nil.
in this case, editl types edit and then waits for input from the
teletype.  (if mess is not nil editl types it instead of edit.  for
example, the tty:  command is essentially (setq l (editl l nil nil nil
(quote tty:))).)  exit occurs only via an ok, stop, or save command.
If coms is not nil, no message is typed, and each member of coms is
treated as a command and executed.  If an error occurs in the execution
of one of the commands, no error message is printed , the rest of the
commands are ignored, and editl exits with an error, i.e., the effect
is the same as though a stop command had been executed.  If all
commands execute successfully, editl returns the current value of l.
marklst is the list of marks.  on calls from editf, atm is the name of
the function being edited; on calls from editv, the name of the
variable, and calls from editp, the atom of which some property of its
property list is being edited.  The property list of atm is used by the
save command for saving the state of the edit.   save will not save
anything if atm=nil i.e., when editing arbitrary expressions via edite
or editl directly.

.Lf editfns "s_x [ g_coms1 ... ]" 
fsubr function, used to perform the same editing operations on
several functions.  
editfns maps down the list of
functions, prints the name of each function, and calls the editor (via
editf) on that function.
.Ex
editfns foofns (r fie fum)) will change every  fie  to  fum  in
each of the functions on foofns.
.No
the  call  to  the  editor is errset protected, so that if the editing of one
function causes an error, editfns will proceed to the next  function.    in
the above example, if one of the functions did not contain a fie, the r command
would  cause  an error, but editing would continue with the next function.  The
value of editfns is nil.

.Lf edit4e "pat y"
.Se
is the pattern match routine. 
.Re
t if pat matches y. see edit-match for definition of 'match'.
.No
before each search operation in the editor begins, the  entire  pattern
is  scanned  for  atoms  or strings that end in at-signs.  These are replaced by
patterns of the form  (cons  (quote  /@)  (explodec  atom)).      from  the
standpoint  of  edit4e, pattern type 5, atoms or strings ending in at-signs, is
really "if car[pat] is the atom @ (at-sign), pat will match  with  any  literal
atom  or  string  whose  initial  character codes (up to the @) are the same as
those in cdr[pat]."
if  the  user  wishes  to call edit4e directly, he must therefore convert any
patterns which contain  atoms  or  strings  ending  in  at-signs  to  the  form
recognized by edit4e.  this can be done via the function editfpat.
.Lf editfpat "pat flg"
makes a copy of pat with all patterns of type 5 (see edit-match) converted to
the form expected by edit4e. flg should be passed as nil (flg=t is for internal
use by the editor).

.Lf editfindp "x pat flg"
.No
Allows a program to use the edit find command as a pure predicate
from outside the editor.  x is an expression, pat a pattern.  The value
of editfindp is t if the command f pat would succeed, nil otherwise.
editfindp calls editfpat to convert pat to the form expected by edit4e,
unless flg=t.    if the program is applying editfindp to several
different expressions using the same pattern, it will be more efficient
to call editfpat once, and then call editfindp with the converted
pattern and flg=t.

.Lf ## "g_com1 ..."
.Re  
what the current expression would be after executing the edit commands
com1 ...  starting from the present edit chain.  generates an error
if any of comi cause errors.  The current edit chain is never
changed.  example:  (i r (quote x) (## (cons ..z))) replaces all x's in
the current expression by the first cons containing a z.  
EndOfFile
cat >  doc/ch17.n  << 'EndOfFile'
." $Header: ch17.n,v 40.1 84/08/08 21:36:08 layer Exp $
." (c) Copyright 1984, Franz Inc., Berkeley California
.Lc Hash\ Tables 17
.sh 2 Overview
.pp
A hash table is an object that can efficiently map a given object to another.
Each hash table is a collection of entries,
each of which associates a unique \fIkey\fP with a \fIvalue\fP.
There are elemental functions to add, delete, and find entries
based on a particular key.
Finding a value in a hash table is relatively fast compared to
looking up values in, for example, an assoc list or property list.
.pp
Adding a key to a hash table modifies the hash table, and so
it is a descructive operation.
.pp
There are two different kinds of hash tables:  those that use the
function \fIequal\fP for the comparing of keys, and those that
use \fIeq\fP, the default.
If a key is "eq" to another object, then a match is assumed.
Likewise with "equal".
.sh 2 Functions
.Lf makeht "'x_size ['s_test]" 
.Re
A hash table of x_size hash buckets.
If present, s_test is used as the test to compare keys in the
hash table, the default being \fBeq\fP.
\fIEqual\fP might be used to create a hash table where the
keys are to be lists (or any lisp object).
.No
At this time, hash tables are implemented on top of vectors.
.Lf hash-table-p "'H_arg"
.Re
t if H_arg is a hash table.
.No
Since hash tables are really vectors, the lisp type of a hash table
is a vector, so that given a vector, this function will return t.
.Lf gethash "'g_key 'H_htable ['g_default]"
.Re
the value associated the key g_key in hash table H_htable.
If there is not an entry given by the key and g_default is specified,
then g_default is returned, otherwise, a symbol that is unbound
is returned.
This is so that \fBnil\fP can be a associated with a key.
.No
\fIsetf\fP may be used to set the value assocaited with a key.
.Lf remhash "'g_key 'H_htable"
.Re
t if there was an entry for g_key in the hash table
H_htable, nil otherwise.  In the case of a match, the
entry and associated object are removed from the hash
table.
.Lf maphash "'u_func 'H_htable"
.Re
nil.
.No
The function u_func is applied to every element in the
hash table H_htable.  The function is called with two arguments:
the key and value of an element.
The mapped function should not add or delete object from the
table because the results would be unpredicable.
.Lf clrhash "'H_htable"
.Re
the hash table cleared of all entries.
.Lf hash-table-count "'H_htable"
.Re
the number of entries in H_htable.  Given a new hash table
with no entries, this function returns zero.
.Eb
; make a vanilla hash table using "eq" to compare items...
\-> (setq black-box (makeht 20))
hash-table[26]
\-> (hash-table-p black-box)
t
\-> (hash-table-count black-box)
0
\-> (setf (gethash 'key black-box) '(the value associated with the key))
key
\-> (gethash 'key black-box)
(the value associated with the key)
\-> (hash-table-count black-box)
1
\-> (addhash 'composer black-box 'franz)
composer
\-> (gethash 'composer black-box)
franz
\-> (maphash '(lambda (key val) (msg "key " key " value " val N)) black-box)
key composer value franz
key key value (the value associated with the key)
nil
\-> (clrhash black-box)
hash-table[26]
\-> (hash-table-count black-box)
0
\-> (maphash '(lambda (key val) (msg "key " key " value " val N)) black-box)
nil

; here is an example using "equal" as the comparator
\-> (setq ht (makeht 10 'equal))
hash-table[16]
\-> (setf (gethash '(this is a key) ht) '(and this is the value))
(this is a key)
\-> (gethash '(this is a key) ht)
(and this is the value)
; the reader makes a new list each time you type it...
\-> (setq x '(this is a key))
(this is a key)
\-> (setq y '(this is a key))
(this is a key)
; so these two lists are really different lists that compare "equal"
; not "eq"
\-> (eq x y)
nil
; but since we are using "equal" to compare keys, we are OK...
\-> (gethash x ht)
(and this is the value)
\-> (gethash y ht)
(and this is the value)
.Ee
EndOfFile
cat >  doc/chb.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/chb.n,v 1.1 83/01/31 07:11:40 jkf Exp $
.Ap 2 Special\ Symbols
.pp
The values of these symbols  have a predefined meaning.
Some values are counters 
while others are simply flags whose value the user can change to affect
the operation of lisp system.
In all cases, only the value cell of the symbol is important, the function
cell is not.
The value of some of the symbols (like \fBER%misc\fP) 
are functions - what this means is that the value cell of those symbols
either contains a lambda expression,
a binary object,
or symbol with a function binding.
.pp 
The values of the special symbols are:
.in .5i
.de Sa
.sp 1v
.ti -.5i
\fB\\$1\fP\ \-\ \\
..
.Sa $gccount$
The number of garbage collections which have occurred.
.Sa $gcprint
If bound to  a non nil value, then after each garbage collection and 
subsequent storage allocation a summary of storage allocation will
be printed.
.Sa $ldprint
If bound to a non nil value, then during each 
.i fasl
or 
.i cfasl
a diagnostic message will be printed.
.Sa ER%all
The function which is the error handler for all errors (see \(sc10)
.Sa ER%brk
The function which is the handler for the 
error signal generated by the evaluation of the 
.i break 
function (see \(sc10).
.Sa ER%err
The function which is the handler for the error 
signal generated by the evaluation of the
.i err
function (see \(sc10).
.Sa ER%misc
The function which is the handler of the error 
signal generated by one of the unclassified errors (see \(sc10).
Most errors are unclassified at this point.
.Sa ER%tpl
The function which is the handler to be called
when an error has occurred which 
has not been handled (see \(sc10). 
.Sa ER%undef
The function which is the handler for the 
error signal generated when a call to an undefined function
is made.
.Sa ^w
When bound to a non nil value this will prevent output to the standard
output port (poport) from reaching the standard output (usually a terminal).
Note that ^w is a two character symbol and should not be confused
with ^W which is how we would denote control-w.
The value of ^w is checked when the standard output buffer is flushed
which occurs after a 
.i terpr , 
.i drain 
or when the buffer overflows.
This is most useful in conjunction with ptport described below.
System error handlers rebind ^w to nil when they are invoked to assure
that error messages are not lost.
(This was introduced for Maclisp compatibility).
.Sa defmacro-for-compiling
The has an effect during compilation.  
If non-nil it causes macros defined by defmacro to be 
compiled and included in the
object file.
.Sa environment
The UNIX environment in assoc list form.
.Sa errlist
When a 
.i reset
is done, the value of errlist is saved away and control is thrown to
the top level.
\fIEval\fP
is then mapped over the saved away 
value of this list.
.Sa errport
This port is initially bound to the standard error file.
.Sa evalhook
The value of this symbol, if bound, is the name of a function to handle
evalhook traps (see \(sc14.4)
.Sa float-format
The value of this symbol is a string which is the format to be used
by print to print flonums.
See the documentation on the UNIX function printf for a list
of allowable formats.
.Sa funcallhook
The value of this symbol, if bound, is the name of a function to handle
funcallhook traps (see \(sc14.4).
.Sa gcdisable
If non nil, then garbage collections will not be done automatically when
a collectable data type runs out.
.Sa ibase
This is the input radix used by the lisp reader.
It may be either eight or ten. 
Numbers followed by a decimal point are assumed to be decimal regardless
of what ibase is.
.Sa linel
The line length used by the pretty printer, pp.
This should be used by 
.i print 
but it is not at this time.
.Sa nil
This symbol represents the null list and thus can be written ().
Its value is always nil.
Any attempt to change the value will result in an error.
.Sa piport
Initially bound to the standard input (usually the keyboard).
A read with no arguments reads from piport.
.Sa poport
Initially bound to the standard output (usually the terminal console).
A print with no second argument writes to poport.
See also: ^w and ptport.
.Sa prinlength
If this is a positive fixnum, then the \fIprint\fP function will print
no more than prinlength elements of a list or hunk and further elements
abbreviated as `...'.
The initial value of prinlength is nil.
.Sa prinlevel
If this is a positive fixnum, then the \fIprint\fP function will print
only prinlevel levels of nested lists or hunks.
Lists below this level will be abbreviated by `&' and hunks below this 
level will be abbreviated by a `%'.
The initial value of prinlevel is nil.
.Sa ptport
Initially bound to nil.
If bound to a port, then all output sent to the standard output will
also be sent to this port as long as this port is not also 
the standard output (as this would cause a loop).
Note that ptport will not get a copy of whatever is sent to poport
if poport is not bound to the standard output.
.Sa readtable
The value of this is the current readtable.
It is an array but you should NOT try to change the value of the elements
of the array using the array functions.
This is because the readtable is an array of bytes and the smallest 
unit the array functions work with is a full word (4 bytes).
You can use 
.i setsyntax 
to change the values and
.i "(status syntax ...)"
to read the values.
.Sa t
This symbol always has the value t.
It is possible to change the value of this symbol for short
periods of time but you are strongly advised against it.
.Sa top-level
In a lisp system without /usr/lib/lisp/toplevel.l loaded, after a 
.i reset
is done, the lisp system will 
.i funcall 
the value of top-level if it is
non nil.
This provides a way for the user to introduce his own top level interpreter.
When /usr/lib/lisp/toplevel.l is loaded, it sets top-level to franz-top-level
and changes the 
.i reset 
function so that once franz-top-level starts, it cannot
be replaced by changing top-level.
Franz-top-level  does provide a way of changing 
the top level however, and that is 
through user-top-level.
.Sa user-top-level
If this is bound then after a 
.i reset ,
the top level function will
.i funcall 
the value of this symbol rather than go through a read eval print
loop.
EndOfFile
cat >  doc/chc.n  << 'EndOfFile'
." $Header: /na/franz/doc/RCS/chc.n,v 1.1 83/01/31 07:11:44 jkf Exp $
.Ap 3 Short\ Subjects.
.sp 2v
.tl ''\fB\s+2The Garbage Collector\s0\fP'
.pp
The garbage collector is invoked automatically whenever a collectable
data type runs out.
All data types are collectable except strings and atoms are not.
After a garbage collection finishes, the collector will call the function 
.i gcafter
which should be a lambda of one argument.
The argument passed to 
.i gcafter
is the name of the data type which ran out and caused the garbage collection.
It is 
.i gcafter 's
responsibility to 
allocate more pages of free space.
The default 
.i gcafter 
makes its decision based on the percentage of space still in 
use after the garbage collection.
If there is a large percentage of space still in use, 
.i gcafter
allocates a larger amount of free space than if only a small percentage of
space is still in use.
The default 
.i gcafter
will also print a summary of the space in use if the variable 
.i $gcprint
is non nil.
The summary always includes the state of the list and fixnum space and 
will include another type if it caused the garbage collection.
The type which caused the garbage collection is preceded by an asterisk.
.sp 4v
.tl ''\s+2\fBDebugging\fP\s0''
.pp
There are two simple functions to help you debug your programs:
.i baktrace 
and 
.i showstack .
When an error occurs (or when you type the interrupt character),
you will be left at a break level with the state of the computation
frozen in the stack.
At this point, calling  the function
.i showstack
will cause the contents of the lisp evaluation stack to be printed in
reverse chronological order (most recent first).
When the programs you are running are interpreted or traced, the output
of 
.i showstack 
can be very verbose.
The function
.i baktrace
prints a summary of what 
.i showstack 
prints.
That is, if showstack would print a list, 
.i baktrace
would only print the first element of the list.
If you are running compiled code with the \fI(status\ translink)\fP non
nil, then fast links are being made.
In this case, 
there is not enough information on the stack for 
.i showstack
and 
.i baktrace .
Thus, if you are debugging compiled code you should probably do 
\fI(sstatus\ translink\ nil)\fP.
.pp
If the contents of the stack don't tell you enough about your problem, the
next thing you may 
want to try is to run your program with
certain functions traced.
You can direct the trace package to stop program execution when it enters
a function, allowing you to examine the contents of variables or 
call other functions.
The trace package is documented in Chapter 11.
.pp
It is also possible to single step the evaluator and to look at stack
frames within lisp.
The programs which 
perform these actions are described in Chapters 14 and 15.
.bp
.tl ''\fB\s+2The Interpreter\'s Top Level\s0\fP''
.pp
The default top level interpreter for Franz, named 
.i franz-top-level
is defined in /usr/lib/lisp/toplevel.l
It is given control when the lisp system starts up because the 
variable top-level is bound to the symbol
.i franz-top-level .
The first action 
.i franz-top-level 
takes is to print out the name of the current
version of the lisp system.
Then it loads the file .lisprc from the HOME directory of the person
invoking the lisp system if that file exists.
The .lisprc file allows you to set up your own defaults, read in files,
set up autoloading  or anything else you might want to do to personalize
the lisp system.
Next, the top level goes into a prompt-read-eval-print loop.
Each time around the loop, before printing the prompt it checks 
if the variable user-top-level is bound.
If so, then the value of user-top-level will be 
.i funcall ed.
This provides a convenient way for a user to introduce his own top level
(Liszt, the lisp compiler, is an example of a program which uses this).
If the user types a ^D (which is the end of file character), and  the
standard input is not from a keyboard, the lisp system will exit.
If the standard input is a keyboard and if the value of 
.i "(status\ ignoreeof)"
is nil, the lisp system will also exit.
Otherwise the end of file will be ignored.
When a 
.i reset 
is done
the current value of 
.i errlist
is saved away and control is thrown back up to the top level where 
.i eval
is mapped over the saved value of 
.i errlist.
EndOfFile
cat >  doc/Makefile  << 'EndOfFile'
# $Header: Makefile 1.4 83/07/21 21:27:16 sklower Exp $
#	makefile for the franz lisp manual
#
# sources: lmacs: macros for the franz documents
#	   ch1.n  intro and description of types
#	   ch2.n  data structure access
#	   ch3.n  on arithmetic functions.
#	   ch4.n  special functions.
#	   ch5.n  i/o
#	   ch6.n  system functions
#	   ch7.n  reader
#	   ch8.n  functions and macros 
#	   ch9.n  arrays 
#	   ch10.n exception handling 
#	   ch11.n trace package 
#	   ch12.n liszt 
#	   ch13.n cmu top level
#	   ch14.n stepper 
#	   ch15.n fixit package
#	   ch16.n lisp editor
#	   chb.n special symbols
#	   chc.n  short subjects


.SUFFIXES: .n .t .x .v .r .rx .q .qx .sp

# the syntax's have this meaning:
#  .n  nroff/troff source file
#  .t  troff output file, can be vpr -t 'ed 
#  .x  index file from a troff run, when collected and run through troff
#	again, an index is produced.
#  .v  this file never exists, but asking for it will cause a .t file to
#	be created and then vpr'ed.  the .t file will not be deleted.
#  .p  this file also never exists, but asking for it will cause TROFF
#	(usually vtroff or itroff) to be run directly on the file, leaving
#	no .t around.  This is used in /usr/doc for people who want to
#	run off a manual and are too lazy to read this makefile.
#  .r  nroff output file.
#  .rx  special index output from nroff run.  These files should be catted
#       together and then left around for lisp to read when given the help
#	command.
#
#  .q  nroff output file compatible with model 37
#  .qx index file for .q files.
#
#  .sp spell errors
#
# make install will install the nroff versions of the manual in the
# directory (LibDir/manual) where the auxfns0.l help command can find them.
#
LibDir = /usr/lib/lisp
CcodeDir = ../franz
CopyTo = /dev/null
TROFF=	/usr/ucb/vtroff
NROFF=  nroff
O =
Append = ${LibDir}/append
# Rmt = is unecessary; you can say, make rall NROFF="'dali nroff'".
# better to just copy the doc directory to the remote machine and
# run it all there.

#--- Sources: 
#	We use the suffixes to tell make how to make a file.  Thus
#  we only specify the root and let the append function add the
#  appropriate suffix.

MacroSrc = lmacs

RootGenSrc = ch0 ch1 ch2 ch3 ch4 ch5 ch6 ch61 ch7 ch8 \
      ch9 ch10 ch11 ch12 ch13 ch14 ch15 ch16 ch17 chb chc

UtilSrc = Makefile indexsed mantags extrnames.awk fixmks.sed \
	franz.n

#-- can't get a expression for all source at make read time. must use
#   append to add .n to RootGenSrc


all:
	make rall

rall: ${Append}
	make NROFF=${NROFF} O=${O} `${Append} .r ${RootGenSrc}` helpindex

vall: ${Append}
	make TROFF=${TROFF} O=${O} `${Append} .v ${RootGenSrc}` index.v

tall: ${Append}
	make TROFF=${TROFF} O=${O} `${Append} .t ${RootGenSrc}` index.t

cctall:
	make TROFF="troff -s12" tall

pall: ${Append}
	make TROFF=${TROFF} O=${O} `${Append} .p ${RootGenSrc}` pindex

troff: pall
      
qall: ${Append}
	make NROFF=${NROFF} O=${O} `${Append} .q ${RootGenSrc}` index.t

spall: ${Append}
	make TROFF=${TROFF} O=${O} `${Append} .q ${RootGenSrc}` index.t

# only a few files describe functions which are indexed.

.t.v:
	vpr -t $*.t

.n.t:	
	tbl lmacs $*.n | ${TROFF} -me ${O} -t 1> $*.t 2> $*.x

.n.p:
	tbl lmacs $*.n | ${TROFF} -me ${O} 2> $*.x

.n.x:
	tbl lmacs $*.n | ${TROFF} -me -z 2> $*.x

.n.r:
	tbl lmacs $*.n | ${NROFF} -rb3 -me ${O} 1> $*.r 2> $*.rx
	rm -f helpindex

.n.rx:
	tbl lmacs $*.n | ${NROFF} -rb3 -me 1> $*.r 2> $*.rx
	rm -f helpindex

.n.q:
	tbl lmacs $*.n | ${NROFF} -me -T37 2> $*.qx | col > $*.q

.n.sp:
	spell $*.n > $*.sp
	
install: 
	make O=${O} rall
	cp `${Append} .r ${RootGenSrc}` helpindex ${LibDir}/manual

clean:
	-rm -f *.r 
	-rm -f *.rx 
	-rm -f helpindex 
	-rm -f *.t 
	-rm -f *.q 
	-rm -f *.x


findex:  ${Append}
	make `${Append} .x ${RootGenSrc}`
	echo ".Ib" > index
	sort +3 -o index index `${Append} .x ${RootGenSrc}`
	sed -f indexsed index > indexx 
	${Rmt} ${TROFF} -me lmacs indexx

index.t: 
	make `${Append} .x ${RootGenSrc}`
	echo ".Ib" > index
	sort +3 -o index index `${Append} .x ${RootGenSrc}`
	sed -f indexsed index > indexx
	${TROFF} -me -x -t lmacs indexx > index.t

pindex: ${Append}
	make `${Append} .x ${RootGenSrc}`
	echo ".Ib" > index
	sort +3 -o index index `${Append} .x ${RootGenSrc}`
	sed -f indexsed index > indexx
	${TROFF} -me lmacs indexx

helpindex: ${Append}
	make `${Append} .rx ${RootGenSrc}`
	cat `${Append} .rx ${RootGenSrc}` | tr '\227' ' ' > helpindex

tags:	/dev/tty ${Append}
	awk -f mantags `${Append} .n ${RootGenSrc}` | sort > tags


${Append}: 
	(cd ../utils  ; make LibDir=${LibDir} ${Append})

# to create a database for lxref to use:
C-database: ${CcodeDir}/sysat.c
	grep "^	MK" ${CcodeDir}/sysat.c > mks
	sed -f fixmks.sed < mks > mks.fixed
	(echo "(Chome)" ; cat mks.fixed ) > C-database
	rm -f mks mks.fixed

doc-database: 
	awk -f extrnames.awk `${Append} .n ${RootGenSrc}`\
 	   | sed -f fixmks.sed > doc-database


bigxref: C-database doc-database
	${Append} -p ${LibDir}/ `(cd ${LibDir} ; make echorequired)` | \
		sed 's/\.l/.x/g' > lisplibfiles
	lxref doc-database  C-database  `cat lisplibfiles` > bigxref

# simple table of contents, just a listing of which function is
# documented in which chapter
tofc:  
	egrep "^.Lc|^.Lf|^.Lx|^.sh" `${Append} .n  ${RootGenSrc}` > tofc


copysource:
	(tar cf - ${MacroSrc} `${Append} .n ${RootGenSrc}` ${UtilSrc} | \
	 (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc} ${Append}
	@(cd .. ; scriptcat doc doc ${MacroSrc} `${Append} .n ${RootGenSrc}` ${UtilSrc})
	@(cd .. ; scriptcat doc lisplib/manual \
	      `${Append} .r ${RootGenSrc}` helpindex)

copymanual: ${Append}
	( cd ${FromDir}/manual ; \
	  cp `${Append} .r ${RootGenSrc}` helpindex ${CopyTo})


EndOfFile
cat >  doc/indexsed  << 'EndOfFile'
// s//\\ /
EndOfFile
cat >  doc/mantags  << 'EndOfFile'
/^\.Lf/	{ print $2, FILENAME, "?^\.Lf " $2 "?" }
/^\.Lx/	{ print $2, FILENAME, "?^\.Lx " $2 "?" }
EndOfFile
cat >  doc/extrnames.awk  << 'EndOfFile'
BEGIN { print "(Doc)" }
/^\.Lf/ { print "(" $2 " " substr(FILENAME,1,length(FILENAME)-2) ")" }
/^\.Lx/ { print "(" $2 " " substr(FILENAME,1,length(FILENAME)-2) ")" }
EndOfFile
cat >  doc/fixmks.sed  << 'EndOfFile'
/	MK/s///
/"/s///g
/,/s// /g
/;.*/s///
/\\(pl/s//+/
/\\(mi/s//-/
/\\(\*\*/s//*/
/\\(eq/s//=/

EndOfFile
cat >  doc/franz.n  << 'EndOfFile'
."  franz.n				-[Thu Jun 17 11:01:27 1982 by jkf]-
." this file will contain a description of the franz lisp system.
." sort of a systems manual.
.de Fr
F\s-2RANZ\s0 L\s-2ISP\s0
..
.tp
.(l C
.sz +2
\fBThe Franz Lisp System\fP
.sz -2
.sp 2v
\fIby
\fIJohn K. Foderaro\fP
.)l
.sp 3v
.tl ''Abstract''
.br
This document describes the 
.Fr
system written at The University of California 
at Berkeley.
Included are descriptions of the memory management, interpreter
and compiler, the conventions used within the C coded kernel
and those within the compiled code.
This does not duplicate the information found in The Franz Lisp Manual.
.++ C '\s-2Draft\s+2'\fBThe\ Franz\ Lisp\ System\fP'%'
.+c Characteristics\ of\ \F\s-2RANZ\ \s0L\s-2ISP\s0
.ls 1
.pp
There is no formal standard for lisp systems, thus each lisp
system is almost guaranteed to be different from any other lisp system.
In this section we will examine the design decisions which most often
characterize a lisp system.
This
focus does  not imply that all other parts of the language are generally
agreed upon.
In fact, there is nothing sacred to lisp system designers.
For example, one usually identifies the symbol 
.i nil 
with the empty list,
and one usually thinks of lisp as a dynamically scoped language.
Both of these conventions are are not true in the lisp dialect 
.i NIL
currently being written at MIT.
As another example, one imagines that a lisp system must 
use  garbage collection to reclaim storage.
The lisp dialect
.i ZetaLisp
that is running on Lisp Machines doesn't
normally use a garbage collector
because of the way in which it allocates its address space.
It is faster to reboot the machine than to do a garbage collection.
In most lisp dialects the lisp expressions are written in 
parenthesised form.  In 
.i Portable
.i Standard
.i Lisp
(PSL) at the University of Utah, programs are written 
primarily 
in an Algol-like
syntax.
.pp
Thus some of the discussion to follow indicates not so much 
.i unique
charateristics of 
.Fr
but instead, how decisions were made.
.sh 2 Scoping\ and\ Binding
.pp
The 
.Fr
interpreter
uses 
.i dynamic 
.i scoping , 
that is, after A calls B, B can access all of the
variables that  A allocated
as well
as those that A can access, provided B doesn't allocate variables of the same
names.
There are two popular ways of implementing dynamic scoping: 
.i deep
.i binding
and 
.i shallow
.i binding .
Note that we will use the terms variable allocation and lambda
binding interchangeably in this report.
The former term is less language-specific than the latter.
.sh +1 Deep\ Binding
.pp
In a deep binding implementation, when a variable is  allocated,
the name of the variable and a space for its value are pushed on the
top of a stack.
When a program asks for the value of a variable, 
the lisp system must search down the stack for the first occurrence of
the variable.
This system offers great flexibility for the 
programmer since  the state of his program 
can be described by the contents of the stack.
It is thus possible to save the context of a program by just saving
the stack or in some cases just a pointer to
a place in  the stack.
The problem with deep binding is that it is time-consuming to search
down the stack for the value of a variable, and, 
as a result, most systems 
modify the deep binding model by giving variables a global value
cell and allowing programs to set and access the global cell.
Some implementations of Interlisp use deep binding.
.sh +0 Shallow\ Binding
.pp
In a shallow binding implementation, each variable has a global value cell
which contains the current value of the variable.
When a variable is allocated inside a program, its name 
and old value are pushed on a stack called a
.i bindstack .
The variable is then given a new value. 
Throughout the lifetime of the allocation, the current value of the
variable can be found in the global value cell associated with the variable.
When leaving the context of the variable's allocation, the old value
is restored from the 
.i bindstack .
A shallow binding scheme makes it much cheaper to access 
the values of variables, however it is much more difficult to 
save the state and to restore it. 
.pp
.Fr
and most other lisps which are not derived from Interlisp
use shallow binding.
Some versions of Interlisp use shallow binding.
.sh -1 Lisp\ Compiler
.pp
Dynamic scoping often is not necessary and it is never cheap, even
in a shallow binding implementation.
Thus the 
.Fr  
compiler prefers to do lexical scoping rather than dynamic
scoping.
If the user does not specify otherwise,  when a 
function is compiled, all variables 
allocated will be 
put on a local stack and will 
.i not 
be accessible by any
function that this function calls.
This
convention results in faster code being generated by
the compiler, but if the
user is not careful, it can result in compiled and interpreted code
working differently.
In some of the new lisp designs, such as 
.i NIL 
and
.i Common
.i Lisp
the semantics of compiled and interpreted code have been
unified by
transferring the compiler semantics (lexical scoping) to the interpreter.
This is a rather large step
if dynamic scoping is no
longer an option, and it is not clear whether the resulting
language should be called 'lisp'.
.sh +0 Data\ Types
.pp
A complete list of data types in 
.Fr 
can be found in the first chapter of the 
.Fr
Manual.
The most important ones are described below.
.pp
Lisp is a list processing language and the basic data type is the list
cell. 
A list cell also goes by the name of cons cell, pair, or dotted pair (dtpr).
It contains pointers to two lisp objects, and these pointers can
be accessed via the 
.i car
and
.i cdr 
functions.
Each pointer requires four (8-bit) bytes and thus the list cell is 
eight bytes large.
The cdr pointer is stored first since this makes it easier 
to 'cdr down a list' using the addressing modes of the VAX.
.pp
The symbol cell is used to implement variables.  It contains  a pointer
to a string that is the print name, a cell to store a value, a cell to
store the function definition, a cell to store a pointer to  the property
list and one pointer that the list system uses if it stores
the symbol in the oblist.
.sh +0 Memory\ Management
.pp
A lisp system must be able to determine the type of an
object at run time.
The method used to determine the type influences the
way storage is managed and garbage collection is done.
Next, we will look at three possible places
to store the type information.
.sh +1 Typed\ data
.pp
The type of the data object could be placed in the object itself, much
as Pascal stores the type of a variant record in the record itself.
This could result is a large amount of storage being used to store
type information.
No lisp system that we know of uses this method exclusively.
.sh +0 Typed\ pointers
.pp
Every reference to a lisp object could contain the type of the object
referenced.
This is a good idea in a machine like an IBM 370 where only
part of  machine word is used by the addressing hardware.
Lisps that use typed pointers generally use a
.i heap
memory management scheme and a 
.i copying 
garbage collector.
In a heap scheme, 
all memory is divided by a pointer (called the
heap pointer) separating lisp
data and free space.  
When a new lisp object is needed, it is formed at the
dividing line and then  
the heap pointer is incremented
past the new object.
Garbage collection is done by maintaining two separate spaces for lisp
data, only one of which is used at any one time.
When one fills up, all active lisp objects are copied to the 
other space, leaving the first space totally free. 
Subsequent allocations are done from the second space, until it fills up,
at which point 
all active data in the second space is copied to the first space.
The advantage of the copying garbage collector is that the data space
is compacted, which will improve virtual memory behavior.
The disadvantage is that
half the data space is always unused.
.pp
PSL on a PDP-10 uses this scheme, as does Lisp 370 on 
an IBM 370.
PSL  and NIL on the VAX will also use this scheme.  
Since the VAX hardware 
uses the entire word for address 
calculation, 
PSL and NIL 
must mask off the type bits
of a pointer before using it to reference memory.
.sh +0 Typed\ pages
.pp
The final alternative is to allocate data objects by pages rather than
individually.
Each page contains only one type of object and there is a table that 
keeps track of the type of data object in each page.
The address of an object tells which page the object is on and 
the page number tells which type the object is.
Since a whole page of objects is allocated when only one 
object is necessary,
the rest of the objects in the page are put on a free list.
This method of allocation is sometimes referred to as
.i bibop
for BIg Bag Of Pages.
The garbage collector for bibop is usually
a traditional
.i mark
and
.i sweep
algorithm.
All active data objects are marked  and
then each page is swept linearly with
the free cells being put on the free list and the used cells 
left alone.
The advantage of mark and sweep over a copying garbage collector is that
the mark phase is cheaper because data objects do not have to be copied.
Also, all of memory can be used since there is no requirement for two spaces.
The disadvantage is that a sweep phase is required in a mark and sweep
but one is not required in a copying garbage collector.
The sweep phase is expensive because it has to alter most data pages 
while building a free list.
This operation 
can be expensive in a virtual memory environment.  
Alternatives to the sweep phase have been proposed in
[Foderaro+Fateman Characterization of Vax Macsyma].
.pp
.Fr
uses a bibop memory allocator and a mark and sweep garbage collector,
as does Maclisp (on a PDP-10).
The reason that
.Fr 
uses bibop is primarily due to the VAX architecture,
which makes typed pointers
expensive to implement.
Also, typed pointers would make it difficult to pass lisp values
to  programs written in other languages, some of which may not have
the ability to extract the address of a lisp object from a typed pointer.
.sh -1 Construction
.pp
The
.Fr
system is built by adding lisp code to a C-coded kernel.
The C-coded kernel is a working lisp interpreter, although it has few of
the functions a lisp system needs.
The lisp code provides most of the functions, the top level and error
handlers.
The lisp compiler is also written in lisp, 
but is usually 
run as a separate process.
.sh +0 Unique\ features
.pp
.Fr
can dynamically load and execute functions defined in the other languages
which run on the VAX.
It uses two different dynamic loaders.
One is part of the lisp system and is used for lisp only, it is called 
.i fasl
(for fast loader).
The other is the Unix loader, ld, which is used for loading in 
C, Fortran or Pascal code.
Loading code with fasl
is much faster than with ld
since fasl benefits from 
the simplicity of a lisp object file.
.+c Data\ Structures
.sh 0 _
.nr $1 \n(ch
.pp
In this chapter we shall examine the data structures which are most 
important to the 
.Fr
system.
First, though we will see how the lisp system uses the address space.
.sh 2 Physical\ layout
.pp
As a Unix process, lisp has three address regions: text, data and stack.
Text begins at location 0 and continues up to 0x3b73c (0x means hex number).
The data segment begins on the next page boundary and continues
up to a limit set by the configuration parameters (currently 0x2fd000).
Lisp does not begin running with such a large data segment,  rather it grows
when necessary.
The stack segment begins at address 0x7fffffff and grows downward to a 
maximum size of one-half megabyte.
.pp
The text segment stores the instructions for the C kernel as well as read-only
data.
The read-only data for lisp are 
the symbol nil, the i/o ports, and the small integer
table.
The symbol nil is stored at location 0 which makes it very easy to test
whether a value is nil.
The problem with storing nil in read-only space is that a special case
must be made for nil's property list, which is the only thing in the
nil symbol that the user is permitted to alter.
.pp
The fixnums -1024 through 1023 are stored sequentially, with 0 being
stored at 0x1400.
.Fr
doesn't have any 'immediate' lisp data, that is data whose value is 
stored as part of the reference to the data. 
But, by storing some of the fixnums in a known place, we can achieve
some of the benefits of immediate data: 
A program  can use 
.i eq
as a test for a fixnum in the range -1024 to 1023.
In the majority of cases, when asked
to allocate a fixnum, the system can  return a pointer into this table
and bypass the memory allocator.
.sh +0 Typetable
.pp
.Fr
uses the typed pages (or bibop)
method of type determination.
The 
.i typetable
is an array of bytes (
.i chars 
in  C lingo).
This table describes the type of all pages, from page 0 where nil is stored,
up to the end of data space.
Thus there are many entries that describe the types of the pages which
make up the C kernel.
In order to reduce the wasted space in the typetable,
we could have made the typetable begin typing pages at the start of data
space and  make a special case of the pages that contain nil and
the small integer table.
However, the
effect of this change would be that type checks 
(which are done in-line in compiled code) would
be longer and slower.  Since type checking happens quite
frequently, we felt it was better to waste the space in the
typetable in order to save execution time  and instruction space.
.pp
Each page on a VAX is 512 bytes, and thus to find the type of an 
object given the address of it, 
it is only necessary to shift the address right 9 bits
and index the typetable array offset by one.
The offset by one is required because the value -4, which is an illegal
address, is used as a sentinel value to indicate an illegal value.
Thus when we take the type of -4 we will be indexing the table by -1
and we want to retrieve the first byte in the table (which contains
the value UNBOUND).
The C macro which retrieves the type is this (from file h/global.h):
.(b I

#define	TYPE(a1)	((typetable+1)[(int)(a1) >> 9])

.)b
This is code generated by the lisp compiler to check if the type
code of an argument (stored at 0(r10)) is a symbol (which is type
code 1):
.(b I

ashl	$-9,0(r10),r0
cmpb	_typetable+1[r0],$1

.)b
.pp
The type codes which are stored in the typetable are these:
.ts 2i 4i 6i
.(b I
UNBO     -1\tSTRNG     0\tATOM     1\tINT       2
DTPR      3\tDOUB      4\tBCD      5\tPORT      6
ARRAY     7\tOTHER     8\tSDOT     9\tVALUE    10
HUNK2    11\tHUNK4    12\tHUNK8   13\tHUNK16   14
HUNK32   15\tHUNK64   16\tHUNK128 17
.)b
The names given above are the C kernel internal names.
ATOM is symbol, INT is fixnum, DTPR is list cell, 
DOUB is flonum, BCD is binary,
SDOT is bignum and all the HUNKn types are just known as hunk to
the user.
.sh +0 Stacks
.pp
.Fr
uses three stacks: the 
.i C 
.i runtime 
stack, the 
.i namestack
and the
.i bindstack .
The C runtime stack is the stack part of the address space 
and the other two stacks are stored in the data space.
.sh +1 C\ runtime\ stack
The C-coded kernel uses this
stack in the same way as a typical  C program
use the stack:
storing return addresses
and non-lisp-object arguments to  subroutines,
saving registers,
and storing  local variables within a function.
The lisp system stores 
.i catch
.i frames
on this stack as well (to be described later).
.pp
The lisp system assumes that there are no lisp data on the stack and
thus  the use of this stack 
by a program is unrestricted.
As will be discussed later on, the 
.b calls
and 
.b ret
instructions are used for most subroutine calls and returns.
These instructions expect the stack to look a certain way.
.sh +0 Namestack
.pp
The namestack contains only lisp data.
It is used to pass arguments to functions and to  hold
local (lexically scoped) data within lisp functions.
It is also used as a temporary storage spot for lisp data
which must be protected from garbage collection.
.pp
A slight digression on the garbage collector:
The person who writes code for the lisp system must always be aware of
his greatest enemy: the garbage collector.  
Whenever a function is called that could possibly allocate more lisp
data, one must assume that it 
when it attempts to allocate space,  the garbage collector
will be invoked and that it will take away everything that isn't protected
from garbage collection.
The objects that are protected from garbage collection are: the
namestack, the bindstack, the oblist (table of interned symbols),
and the compiler literals.  Objects that are only 
referred to by values in registers or
the C runtime stack will not be seen by the mark phase of the
garbage collector and will be swept up during the sweep phase.
.pp
Back to the namestack:
The first free element on the namestack is pointed to by the
C variable 
.i np .
This variable is always stored in the VAX register r6.
Another pointer into the namestack is the C variable
.i lbot .
It is always stored in VAX register r7.
Its use will be described in the section on calling conventions.
.sh +0 Bindstack
.pp
The bindstack is a stack of lisp object pairs: symbol and
value.
It is used to implement shallow binding.
When a symbol is lambda-bound, the symbol and its current value are put
on this stack.
Then the symbol can be given a new value.
When the context of the lambda binding is over, the symbol and value pair
are popped from the stack and the symbol is given its old value.
The C variable
.i bnp
points to the first free entry on the bindstack.
In the C code, the following macros lambda-bind a symbol to a value
and restore the old value:
.(b
#define PUSHDOWN(atom,value)\e
	{bnp->atm=(atom);\e
         bnp++->val=(atom)->a.clb;\e
 	 (atom)->a.clb=value;\e
	if(bnp>bnplim) binderr();}

#define POP\e
	{--bnp;  bnp->atm->a.clb=bnp->val;}
.)b
.sh -1 Bitmap
.pp
The bitmap is used in garbage collection to hold
the mark bits for the mark and sweep garbage collector.
As its names implies, it is viewed as a collection of bits.
The minimum size of a lisp data object is 4 bytes, thus
there are 128 of those on a VAX page of 512 bytes.
Since there are 8 bits in a byte, it takes 16 bytes to obtain 128 bits.
Therefore the size of the bitmap in bytes is 16 
times the maximum number of
pages.
Like the typetable, the bitmap  keeps track of marks from the
bottom of memory, not the bottom of data space.
The bitmap and the typetable are static structures.
It is their size, which is determined when the C kernel is built,
which determines the size to which the data segment can grow.
.sh +0 Transfer\ Tables
.pp
Transfer tables are used by compiled lisp code as a transfer vector to
other functions.
A transfer table consists of pairs of entries: symbol and pointer to
function.
When a compiled lisp function  calls another (non-local) function, it
calls indirectly through an entry in the transfer table.
Depending on the setting of certain status variables, the call may
bring control into a function linkage routine or directly to
the function desired (if that function is a compiled lisp or C function).
.pp
Transfer tables serve a number of useful purposes.
.np
They allow compiled code to call interpreted code
or compiled code using the same calling sequence.
.np
They allow the selection of which function to call to be determined
at runtime based on the name of the function.
In most other languages, this selection process is done at either
compile or load time.
.np
They allow the user to run in a debugging mode where all calls
from compiled code go through the interpreter.
Once control reaches the interpreter, it is easier to debug.
.np
They allow the user to run in a production mode, where all calls
from compiled to other compiled code are done without function
lookup overhead.
.np
They allow the user to switch between debugging and production modes
at runtime with one function call.
.pp
Transfer tables will be described further  in the section on 
the lisp compiler.
.sh +0 Catch\ frames
.pp
Lisp has a number of forms of non-local transfers.
Among them are 
.i throw ,
.i error ,
.i return 
and
.i go .
If a program is willing to accept a non-local transfer, it puts a 
.i catch
.i frame
on the stack which describes which type of transfer it 
accepts.
The catch frame describes the current state of the registers,
the variables np, lbot, and bnp, and also contains entries that describe
what kinds of non-local transfers the function will accept.
After creating a catch frame, the program  goes on to evaluate forms.
Should the evaluation of one of those forms result in a non-local
transfer to the catch frame that this program has set up, the 
system will restore the namestack and bindstack to the way
they were when the program put the catch frame on the stack (by using
np and bnp) and will return control to the program (setting 
the variable retval to describe why it returned).
This is described further in the 
section on interpreter conventions.
.pp
The C variable 
.i errp
points to the most recent catch frame, and then each catch frame points
to the previous catch frame.
.sh +0 oblist
.pp
Normally when symbols are created they are
.i interned ,
that is they are put in a hash table called an oblist (or obarray).
The purpose of the oblist is to insure that if you type a
symbol's name to the reader, you will always get  the  same symbol.
Also it protects the symbol from garbage collection.
The oblist is simply a hash table with buckets, with a hash link being
part of the symbol data structure.
Currently the hash table is not accessible to a lisp program, but with
a little work it could be.
.+c Interpreter
.sh 0 _
.nr $1 \n(ch
.pp
The interpreter is composed of these parts:
.ip \fIcore:\fP
The functions eval, apply and funcall.
.ip \fIstack\ management:\fP
The code to create catch frames and handle non-local transfers.
.ip \fImemory\ management:\fP
The code to allocate and garbage collect memory.
.ip \fIthe\ functions:\fP
The user callable functions that expect lisp arguments and return
lisp values.
.pp
In the above list, the first three are written mainly in C (with a little
assembler) and the last is written mainly in Lisp with a little 
bit in C
and a very small amount in assembler.
.pp
The core functions are the center of activity  in the interpreter.
The 
.i eval 
function given a lisp expression  to evaluate.  
It must determine if it is a simple expression such as a symbol or number
whose value eval can determine immediately, or if it is an function
calling expression.
If the form is a function call, eval must determine if the arguments should
be evaluated and if so eval must recursively call itself to evaluate the
arguments and then stack them.
If the function called is to be interpreted, eval must lambda-bind the
formal variables of the function to the arguments just stacked.
If the function being called is compiled, eval just calls the function and
lets the function do the lambda binding if it wants to.
.pp
The 
.i apply 
function is passed two lisp objects: 
a function to call (either a symbol or a functional object)
and a list of arguments already evaluated.
It will do lambda binding if the function to call is to
be interpreted.
.pp
The 
.i funcall
function is passed any number of lisp objects,
the first of which is the function to call, and the rest are the
arguments to the function 
which have already been evaluated and stacked.
Funcall will  do lambda binding if the function to call is
to be interpreted.
.pp
When compiled lisp code calls a function 
which must be interpreted, it enters the interpreter through the
funcall function.
The interpreter may go to compiled code through either eval, apply or
funcall, though most often it goes through eval.
.sh 2 Conventions
.pp
These are the conventions used in interpreted and compiled code.
.sh +1 C\ conventions
.pp
Our conventions are extensions of the C calling conventions, so we
describe here the conventions for C.
The VAX has 16 general
purpose registers.
Registers r12 through r15 are reserved
for use by the hardware because we use the
.i calls
subroutine call.
Registers r0-r5 can be used by a program without saving them first.
The result of a function call is returned in r0.
Registers r11-r6 are allocated  (from high to low)
by the C compiler when a 
.i register
declaration is made in the C code.
Registers r11-r6 must be
saved upon entry and restored upon exit if they are used within a function.
On the VAX it is very easy to preserve registers
since it is done automatically
by the hardware if the
.i calls
(or 
.i callg ) 
instruction is used.
The first short word (two bytes) of a subroutine is a 
register save mask which
tells which registers should be saved (on the C runtime stack) upon
entry and restored when a 
.i ret
instruction is done.
.sh +0 np\ and\ lbot
.pp
Earlier we  mentioned that the C variables np and lbot are 
always stored in
registers r6 and r7.
It is very difficult to globally assign a variable to a register
in the C language (no external register declarations
are permitted)
and thus we have to filter
the output of the  C compiler and convert all occurrences of 'np' to 'r6'
and all occurrences of 'lbot' to 'r7'.
This is only half the job, though.
We also must modify  the register save masks for those routines which 
alter the value of np or lbot to insure that those registers get 
saved and restored upon function entry and exit.
This is done in the C code by putting 
.(b C
Savestack(n)
.)b
at the beginning of a routine which will alter np or lbot and which
also allocates n register variables.
Also in that routine, before the function returns, we put 
.(b C
Restorestack()
.)b
This is not really necessary in the VAX, but it is there for other 
machine implementations which don't have a 
.i ret
function which restores registers.
The calls to Savestack are recognized by a filter which processes
the output
of the C compiler and fixes up 
the save masks.
.sh +0 Function\ calling
.pp
The following text describes what the conventions are for 
calling
compiled lisp functions, whether they were written in lisp or C.
We look at it from the viewpoint of the called function.
.pp
Upon entry
to the compiled functon,
lbot points to the first argument and np points to the
first free spot on the namestack.
If np equals lbot then there are no arguments.
Recall that np will be in r6 and lbot in r7.
The function is free to alter registers r0 through r5 and should return
the result in r0.
The function may alter registers r6 through r11 as long as their 
original values
are restored when the function returns.
The value of np should always 
point to the first free entry in the namestack.
This is all that is required.
The extra conventions followed by 
the lisp compiler 
in the code it generates are described in the next chapter.
.sh +0 Catch\ frames
.pp
A catch frame saves the state of execution that a program
might  want to return to at some later time.
A catch frame  is stored on the C runtime stack, with the most recent 
frame pointed to by the C global variable errp.
The information saved is 
.ip \fIargs\fP
- one or two optional arguments. The lisp compiler always 
stacks two 
arguments since it must know exactly how large the frame is.
.ip \fIclass\fP
- the class describes what type of frame this is (described below).
.ip \fIretaddr\fP
- address to return to if returning from this frame
.ip \fIolderrp\fP
- pointer to next older catch frame on the stack
.ip \fIbnp\fP
- value of bnp (bindstack pointer) when the frame was created
.ip \fInp\fP
- value of np when the frame was created
.ip \fIlbot\fP
- value of lbot when the frame was created. 
.ip \fIsystem\ dependent\fP
- the rest of the information stacked depends on the particular machine.
In the case of the VAX, registers r13 through r8 are stacked. (r14 and
r15 are the stack pointer and program counter; they are not saved since
they can be calculated from the other information).
.pp
The information in a catch frame is put on the C runtime stack
in the precise order given above, and the variable errp points not
at the beginning of the entire frame, but to the lbot entry.
Thus errp\ +\ 4 points to np.
The classes of frames are described below.
Each class is defined as a constant in the C code (h/frame.h) whose value
is a small integer. 
.ip F_PROG\ [1]
- takes no arguments.  This frame marks the beginning of a piece of
code which can accept a 
.i return
or a 
.i go .
The interpreter uses this to implement
.i prog
and 
.i do
and for its primative break loop.
The lisp compiler does not use catch frames for progs since it only
permits 
.i returns
and
.i gos
to occur within
.i progs 
or 
.i dos
and thus it can determine how to do the non-local transfer
at compile time.
.ip F_CATCH\ [2]
- this takes one or two arguments and is used to implement both
.i catch
and 
.i errset .
In both cases 
the first argument is the tag which is being caught,
which in the case of an 
.i errset
is symbol ER%all.
An 
.i errset
also
supplies a second argument which is non nil if the error message
should be printed.
.ip F_RESET\ [3]
- in the C kernel, the reset function 
is implemented as a non local transfer to a F_RESET catchframe.
When the lisp system is built, the reset function is redefined to
do a 
.i throw.
Thus this type of catch frame is rarely used.
.ip F_EVAL\ [4]
- this has one argument, the form being evaluated. 
Since stacking this
on every eval would be expensive,
this type of catch frame is only stacked if a \fI(*rset\ t)\fP
has been done and if the value of the symbol 
.i *rset
is non nil.
The form being evaluated is stacked  so that 
the necessary information for the
.i evalframe
function is available and so that 
.i freturn
can return from the context of any pending evaluation.
.ip F_FUNCALL\ [5]
- this is much like F_EVAL, 
except the one argument it takes is the
name of the function to call.  
It has the same restrictions on when it is stacked as  F_EVAL
and for the same reasons.
.pp
In C, a frame is pushed on the stack with Pushframe, with a call
of one of these forms:
.(b
errp = Pushframe(class);
errp = Pushframe(class,arg1);
errp = Pushframe(class,arg1,arg2);
.)b
After the call the C variable 
.i retval
contains the value which describes why this function returned.
You must remember that it is possible for this one function call to
return more than once! 
The reasons it can return are these (from h/frame.h):
.ip C_INITIAL\ [0]
This is the initial call to set up the frame.
.ip C_GO\ [1]
This will only happen for F_PROG frames. 
In this case, 
the C variable lispretval contains a lisp symbol which is the tag
to which control should be transferred.
If the tag cannot be found in this prog or do body, the
tag should be again thrown up the stack to a next higher prog or do.
.ip C_RET\ [2]
This will only happen for F_PROG frames.
In this case, lispretval contains the value to return from this prog.
.ip C_THROW\ [3]
This will only happen for F_CATCH frames.
In this case lispretval contains the value to return from this catch.
.ip C_RESET\ [4]
This will only happen for F_RESET frames.
It simply means that a reset is being done.
.ip C_FRETURN\ [5]
This will only happen for F_EVAL and F_FRETURN frames.
The variable lispretval contains the value to return from this
call to 
.i eval
or
.i funcall .
.pp
The call to Pushframe is turned into a simple subroutine call (using
the 
.i jsb
instruction instead of the
.i calls )
by the filters which alter the code coming out of the C compiler.
Thus it may be useful to see what stacking a catch frame really looks
like.  
Here is what the lisp compiler generates 
to stack the frame for \fI(*catch\ 'tag\ x)\fP
.(b
movl	0(r8),r0	#move 'tag to r0
pushl	$0		# dummy argument
pushl	r0		# put tag argument on C runtime stack
pushl	$2		# push F_CATCH
jsb	_qpushframe	# call Pushframe
movl	r0,_errp	# move result into errp
.)b
.pp
Every function which does a Pushframe() must also do a Popframe()
before it returns to its caller.
This simply removes the frame from the stack.
In C it is written:
.br
.tl ''errp = Popframe()''
in the code generated by the lisp compiler it looks like:
.(b
movl	_errp,r1	# put current errp in r1
movl	12(r1),_errp	# put previous errp in errp
addl3	$32,r1,sp	# pop frame from stack
.)b
.pp
Non-local transfers are done with the Inonlocalgo
function. This function always takes three arguments. 
The
first is the return type (one of the types mentioned
above which begin with 'C_'). It will be assigned to retval.
The second argument is the value to be assigned to lispretval,
except in the case of a C_THROW, where the second argument
is the tag to throw to and the third argument is the value
to assign to lispretval.
This function never returns. 
If it doesn't find a catch frame
which matches what it is looking for, it signals an error.
The function is called with 
.i calls
and the arguments are stacked on the C runtime stack, not the 
namestack.
.+c Liszt:\ The\ Lisp\ Compiler
.sh 0 _
.nr $1 \n(ch
.pp
The purpose of compiling a lisp function is to create a representation of 
the function which can be evaluated in less time and perhaps take
up less space.
There are two approaches to lisp compilers.
One is to convert the functions to a compact form, often called 
.i bytecodes
which can be rapidly interpreted.
Each bytecode represents a primitive operation in the lisp system.
This approach is simple to implement but there is an time penalty
in using an  interpreter.
The other approach is to compiled to  machine code.
In general, this is not as portable as the bytecode  approach but the result
generally runs faster.
There are two ways of compiling to  machine code. 
One is to place arguments to functions in registers. 
If there are more arguments than registers, the arguments are put on
a stack and a special type of call is made.
This method is used in Maclisp.
The other method is to assume a stack model, in which
arguments to a function are placed on a stack.
This is what the 
.Fr
compiler Liszt does.
The stack model made it much easier to write parts of the lisp
system in the C langauge.
It also simplifies the garbage collector since the mark phase doesn't
have to locate and peruse all saved registers looking for lisp data.
.sh 2 File\ Compiler
.pp
When a file of lisp expressions is loaded,
the 
.i load 
function repeatedly reads and evaluates the forms in the
file.
Some of these evaluations may result in functions being defined, 
and others may use the functions just defined or previously defined.
The job of the lisp compiler is to create an object file, which,
when read in 
by 
.i fasl,
acts just like it was 
.i load ed
in, except when a function is defined it is defined in machine
code, not as a lisp expression.
This is quite a bit different from what compilers do in other languages
and it is done this way to make it easier to 
switch between compiled and
interpreted code.
.sh +0 Differences\ between\ compiled\ and\ interpreted
.pp
There are some differences, though, between compiled and interpreted code.
Local variables in compiled code are lexically scoped (put on the
namestack and inaccessible to other functions) unless the variable
has been declared 
.i special.
The declaration:
.(b
\fI(declare (special x y))\fP
.)b
declares both x and y to be special from this point in the file on.
The declaration 
.(b
\fI(declare (specials t))\fP
.)b
declares all variables to be special.
.pp
Lisp has a very powerful macro definition system.
The compiler will macro expand all it can, whereas the interpreter
expands macros when necessary but never replaces a macro call with
its expansion.
Thus if you redefine a macro, the compiled code that uses it will
still work the same way, but the interpreted code will use the 
new definition. 
Also, when compiling a file, macro definitions must be
done before any call on the macro  is encountered during compiling.
In the interpreter, 
macros can be defined or redefined anytime up until
they are used.
Thus the interpreter is far freer about macro definitions than 
the compiler.
This could cause programs which work interpreted to
fail compiled.
.sh +0 Top\ level\ algorithm
.pp
The top level algorithm of the compiler is simply this: 
.np 
read a lisp expression from the input file
.np 
macro expand the top level of the form as much as possible
.np 
if the form is a function definition (a list beginning with
the symbol 'def')
then compile it.
.np 
if the form is not a function definition then put it on a list of 
forms that will be evaluated when the file is 
.i fasl ed
in.
.np
if not at end of file, go to step 1.
.pp
In reality, step 3 is a bit more complex.
If the definition is of a macro, then the form will be evaluated
immediately, thus adding the macro definition to the compiler's 
environment.
If the lisp variable 
.i macros 
is t then the macro will also be compiled.
There are also some forms like \fI(progn\ 'compile\ ...)\fP
and \fI(eval-when\ ()\ )\fP which determine when the 
forms get compiled and evaluated.  
See the lisp manual for details.
.sh +0 Expression\ Compilation
.pp
Just as the interpreter is centered around the 
.i eval
function, the lisp compiler is centered around the function
.i d-exp
whose job it is to compile the expression passed to it.
The lisp compiler is one pass.
Before a call to d-exp returns,
all the compiled code for a form has been computed and written
to a file.
One reason that the lisp compiler can be a single pass compiler
is that the assembler which reads the compiler's output is 
a two pass assembler.
.sh +1 global\ state\ variables
.pp
There are a number of variables that maintain the state of
the compilation process.
These variables are declared special and are thus dynamically scoped
and visible to any function within the compiler.
When d-exp 
is called their meanings are:
.ip \fIv-form\fP
- contains the expression to be compiled.
.ip \fIg-loc\fP
- tells where the result of evaluating this expression should be put.
If g-loc is nil, then the value returned is unimportant and shouldn't
be put anywhere.
.ip \fIg-cc\fP
- controls conditional branches.
If g-cc is non nil, then it is a list cell whose value has
either a non-null car or non-null cdr but not both. 
If the car is non-nil then
if  the  value  of  the expression held in 
v-form  is  non-nil, a branch should be done to the symbol
stored  in  \fI(car\ g-cc)\fP. 
If the cdr is non-nil  then if the value of v-form
is  nil,  a branch should be done to the symbol stored in 
\fI(cdr\ g-cc)\fP. Since at
every  conditional  
branch  control should  either jump or continue, the car and cdr will
never both be specified.
.ip   \fIg-ret\fP
- is non nil if the result of evaluating v-form will be returned as the
value of the function we are evaluating. 
This is used to allow liszt to detect
when tail recursion removal is possible.
.ip  \fIg-locs\fP
- maintains current information about the state of the stacks:
the bindstack (for specials), the namestack (for locals) and the
C runtime stack (for catch frames)
The form of g-locs is a stack of tokens stored as a list.
The meaning of each token is as follows:
.br
\fInil\fP - this represents an unnamed object on the namestack.  This happens
when calling functions, when the arguments are stacked prior
to a function call.
.br
\fI<symbol>\fP - the given symbol is the name of a local variable on the namestack.
.br
\fI(prog . <n>)\fP - prog statement which binds <n> special variables
.br
\fI(do . <n>)\fP - head of a do statement which binds <n> special variables
.br
\fI(catcherrset . 0)\fP - catch or errset frame on stack
.br
\fI(lambda . <n>)\fP - lambda expression which binds <n> special variables
.ip \fIg-labs\fP
- this is a stack of labels. 
There is one entry in g-labs for every entry which is a list
in g-locs.
the forms of the entries are:
.br
\fInil\fP - no labels in this form
.br
\fI(endlab (real . gen) (real2 . gen2) ...)\fP - endlab is the label to go to
to get out of this body.  After this label will be code
to unbind specials and pop off locals.
The 'real' labels are those found in the code. the gen
labels are those generated and put in the assembler code.
.sh +0 Function\ compilation
.pp
The action d-exp takes when compiling an expression depends on the
type of expression.
For atoms (symbols and numbers) the compilation is very simple, it
is just a matter of putting the value where g-loc specifies and 
then jumping if specified by g-cc.
When the expression is a list, d-exp first macro
expands the form and then looks at the first element of 
the list (if the list has not macro expanded to an atom).
If the first element is a symbol  then the list is
is a function call.
If the function is one of the functions which liszt knows how to open compile
then liszt will call the particular routine designated to open
compile this function.
There are two classes of functions within liszt that
do open compiling.
The first class, the fl-expr class, are distinguished by names which
begin with c-.
These functions always generate
code which returns the result in r0.
They are not equipped to obey the contents of g-loc and g-cc.
Thus d-exp, after calling one of these functions, must do what
is necessary to obey g-loc and g-cc.
The other class of open compiling functions, the fl-exprcc class (whose
names begin with cc-),
handle g-loc and g-cc.
As a result these are usually much more complex and generate better code.
.sh -1 Register\ Conventions
.pp
The register conventions used by liszt are an extension of those
used by the C code.
.ip \fIr0\fP
- return value placed here
.ip \fIr1,r2,r3,r4\fP
- scratch registers.
When long strings of 
.i car's
or
.i cdr's
are done (such as
.i caddadr )
these registers are used in a least-recently-used fashion to access down
the list. 
The compiler keeps track of the values in these registers but must
assume that they are garbage after a function is called.
.ip \fIr5\fP
- fixnum accumulator.
There a number of functions which work on fixnum's only and these
usually put their result in r5.
The assembler code function 
.i qnewint
which returns a pointer to a cell containing a fixnum value (after
checking if it is in the fixnum table), expects its argument to be
in r5.
.ip \fIr6\fP
np
.ip \fIr7\fP
lbot.
When calling a function, this register is set just before the function
call, and after the function call its value is used to reset the value
of np in order to pop the arguments off the namestack.
.ip \fIr8\fP
the literal table pointer.
The compiler generates a table of all the literal lisp data
which the compiled code might access.
Upon function entry a pointer to the base of this table is put in r8.
For example, if we compile \fI(setq\ x\ 'foo)\fP then we will
need a pointer to the lisp symbol
.i foo
and if the symbol
.i x
as been declared special we will also need a pointer to 
.i x .
.ip \fIr10\fP
- upon function entry the value of lbot (r7) is put in r10.  
This allows us to reference the arguments to our function while
using lbot to call other function.
.sh +0 Addresses
There are four types of addresses used internally in Franz: 
symbolic, intermediate addresses (iadr), extended intermediate (eiadr)
and vax assembler format.
.sh +1 Symbolic
.pp
These are the names of lisp objects, such as `a', `foo', 34,
or 3.234234.
A name is either a local variable, a special variable or a
number.  A number is either a small fixnum, large fixnum,
bignum or floating point number.
.sh +0 Intermediate\ address\ (IADR)
.pp
This type of address is generated from a symbolic address by
.i d-loc, 
.i d-loclit 
and the routines 
.i d-simple
and 
.i d-rsimple 
which
call them. The forms are
.ip \fINil\fP
- the location or value of nil.
.ip \fIT\fP   
- the location or value of t.
.ip \fIreg\fP
- register r0, which is where the result of function calls
are stored.
.ip \fIstack\fP
- the address pointed to by np with np incremented after
the value is stored.  (i.e  (r6)+)
.ip \fIunstack\fP
- the address one word below np (np is decremented before
accessing. (i.e. -(r6))
.ip \fI<symbol>\fP
- this is just <symbol>.  This allows strange forms to be
represented directly.
.ip \fI(stack\ n)\fP
- The n'th value on the namestack for this function.
The first value 0(r10) is (stack 1).
.ip \fI(vstack\ n)\fP
- The cdr of the n'th value on the namestack.  
That is, (stack 1) is *0(r10)
.ip \fI(bind\ n)\fP
- The value of the n'th value in 
the literal table.  If 
this refers to a symbol, then this is the value
of the symbol.
If this refers to a list then this
this is the cdr of the list (although this is a rare
use). (bind 1) corresponds to *0(r8).
.ip \fI(lbind\ n)\fP
- The n'th value in the literal table.  If 
this refers to 
object foo then this is the address of foo
in memory.
.ip \fI(fixnum\ n)\fP
- This is the address of small fixnum n in memory.
A small fixnum is in the range -1024 to 1023.
.ip \fI(immed\ n)\fP
- The is the immediate constant n. 
.sh +0 extended\ intermediate\ address\ (EIADR)
.pp
This address is generated from an IADR by e-cvt.  It 
symbolically represents a vax address.  
.ip \fI<atom>\fP
- This corresponds to <atom>.
.ip \fI(n\ <atom>)\fP
- This corresponds to n(<atom>)
(stack n+1) and (lbind n+1) are converted to these forms.
.ip \fI(n\ <atom1>\ <atom2>)\fP
- This corresponds to n(<atom1>)[<atom2>]
There is currently no IADR which generates this.
.ip \fI(*\ n\ <atom>)\fP
-This corresponds to *n(<atom>)
(vstack n+1) and (bind n+1) are converted to these forms.
.ip \fI(+\ <atom>)\fP
- This corresponds to (<atom>)+.
stack is converted to this form.
.ip \fI(-\ <atom>)\fP
- This corresponds to -(<atom>)
unstack is converted to this form.
.ip \fI($\ <numb>)\fP
- This corresponds to $<atom>
(immed <numb>) is converted to this form.
.ip \fI(#\ <numb>)\fP
- This corresponds to $<loc> where <loc> equals 
the base of the fixnums (0x1400) plus 4 * <numb>
(fixnum <numb>) is converted to this form
.ip \fI(*\ #\ <numb>)\fP
- This corresponds to $<numb>.  It is generated
by d-rsimple occasionally when you ask for the
cdr of a number (which you do sometimes when you
are compiling fixnum operators).
.sh +0 Vax\ Unix\ assembler\ addresses
.pp
The addresses are printed from a EIADR by e-cvtas.  The conversions
are shown in the above section.
.sh -1 Function\ calling\ convention
.sh +1 Function\ linkages
.pp
The function associated with a symbol is stored in the function 
definition slot of the symbol.  If the function slot contains a
list then the function is to be interpreted and its 'car' will 
be lambda, nlambda, lexpr or macro.  If the function is compiled then 
the function definition slot will contain a binary object. 
A binary object 
is composed of two independent parts: the discipline and the entry.
The discipline is one of:
.ip \fIlambda\fP
- a function whose arguments should be evaluated.
.ip \fInlambda\fP
- a function whose arguments should not be evaluated but
which should be passed as a list
.ip  \fImacro\fP
- a function which should be passed the unevaluated form
being evaluated and whose result should be evaluated.
.ip \fI\"subroutine\"\fP
- a foreign function subroutine
.ip  \fI\"integer-function\"\fP
- a foreign function returning an integer
.ip \fI\"real-function"\fP
- a foreign function returning a flonum.
.pp   
A lexpr is not in the list as there is no difference to the caller
between compiled lambda's and compiled lexprs.
.sh +0 Transfer\ tables
Most calls from compiled code to other lisp functions go through
transfer tables.  A transfer table entry is a pair: symbol, address
of routine. 
When another lisp function is called it uses the 
.i calls 
instruction which will
indirectly jump through the address in the transfer table.  This
address may point to the desired function or it may point to the
interface routine.  If a call ends up in the interface routine, 
then that routine will trace back through the call stack and eventually
reach the tranfer table entry that it was 'called through'. Since the
transfer table entry contains a symbol which names the function
to be called, the interface routine can determine which routine
was to have been called.  If that routine is compiled then the 
interface routine can modify the transfer table so that a call
through that table entry will go directly to the desired function.
If the routine to be called is interpreted, or if the user has
requested that transfer linkages should be disabled, then the
interface routine will go through the 'funcall' function 
in the interpreter to continue the call.  
.sh +0 calling\ sequence\ in\ the\ compiler:
.pp
When transfer tables are used
.(b
	\fBforeach\fP arg
	 \fBcompute\fP arg and stack result using (r6)+
	 for example: movl r0,(r6)+
	movab -n(r6),r7    where n = 4*number of args to fcn
	calls  $0,*trantb+m      where m is the index of the function
				 in the transfer table.
	movl r7,r6		restore r6
.)b
.pp
The compiler supports local functions, which are function accessible
only within one file.
Because they are not accessible from C code, we can use a very fast
call and return sequence when calling them.
To call a local function
.(b
	\fBforeach\fP arg
	 \fBcompute\fP and stack using (r6)+
	jsb	LOCALNAME	go directly to the function, it will 
				restore r6 before it returns.
.)b
.pp
The beginning of each function looks as follows. 
First for a non-lexpr function called in the standard way
(topsim is the label jumped to when tail merging, it will be unique
for each function; the brackets indicate the optional code which
exists if the -p switch is given to liszt);
.(b
	.word	0x5c0		# save r6, r7, r8, r10
    [   movab	mcounts,r0	# if profiling, mcounts replaced by fasl
	jsb	mcount	]
	movab	linker,r8	# set up r8
	movl	r7,r10		# set up oldlbot
	movab	n(r10),r6	# n = 4*Number of args expected.
topsim:
.)b
.pp
Now for lexprs:
.(b
	.word	0x5c0
    [   movab	mcounts,r0	# if profiling. [mcounts replaced by fasl]
	jsb	mcount	]
	movab	linker,r8	# set up r8
	subl3	$4,r7,-(sp)	# address one word below bottom of args
topsim:
	movl	r6,r10		# first free addr to arg base
	subl3	r7,r6,r0	# number of args * 4 into r0
	movab 	0x1400(r0),(r6)+ # stack boxed number of args
	movl	0(r10),-(sp)	# also store on stack so user can't clobber
.)b
.pp
And finally for local functions:
.(b
	movl	r10,-(sp)	# save r10
	movab	-n(r6),r10	# set up arg base using arg top
topsim:
.)b
.sh -1 Assembler\ file\ format
.pp
The liszt compiler generates a file which is in Unix assembler format.
The Unix assembler converts that file into an object file which fasl
then reads.
Although the object file generated is a standard Unix object
file (as defined in /usr/include/a.out.h), it is not of a 
format that  the Unix ld loader can understand.
This is because the requirements  of a lisp object file are different
from an object file of other languages.
The 
run time semantics of lisp and the fact that lisp data must be protected
from garbage collection are the principal differences.
The unconventional object file created by the unix assembler 
is a result of the
unconventional assembler input file.
Next we will look at what must be put in the assembler file and how
it is put there.
.pp
The assembler file must contain
.ip \fIinstructions\fP
- vax assembler code for the compiled functions. 
If there aren't any functions compiled, this can be empty.
.ip \fIliterals\fP
- lisp data which is referred to by compiled code
.ip \fItransfer\ table\fP
- the names of the functions which correspond to the calls through
the transfer table.
The instructions simply say 'call indirect through the nth transfer
table entry'.
.ip \fIfunction\ names\fP
- the names of the functions which are being 
defined.
.ip \fIload\ time\ forms\fP
- in order to mimic the 
.i load
function, fasl has to be able to evaluate lisp expressions at fasl 
time, so we must be able to store lisp expressions in the assembler
file and indicate when they should be evaluated.
.pp
Based on the requirements above, the form of the assembler file
is as described below.
The assembler  builds two segments: text and data.
We put all of our information in the text segment.
The compiler places some annotation strings in the data segment
so that the object file can be identified, however the data segment
is ignored by fasl.
The format is
.ip \fIcompiled\ instructions\fP
The instructions for each compiled  (non-local) function begins with
.(b
    .globl F00003
    F00003:
   .word 0x5c0
.)b
The globl declaration and the fact that the symbol name begins
with a F will tell fasl that this is the beginning of a lisp
function.
The symbols beginning with F must be unique within a file
but may be duplicated in other files.
The lisp  name of the function will appear later.
Next the instructions for the function are given.
Only a small fixed set of external symbols may be referenced.
The list is found in the code for nfasl.c and the common
ones will be described below (soon).
Labels should be given a name beginning with L and should
be unique within the file.
.ip \fItable\ sizes\fP
somewhere in the file there should be a pair of 'set' assembler
pseudo ops which describe the sizes of the literal table and
transfer table.
The form is this
.(b
    .set linker_size  4
    .set trans_size 3
.)b
where linker_size is the number of entries in the literal table
which will be required and trans_size is the number of entries
in the transfer table which will be required.
Those tables will be built by  fasl.
.ip \fIbinder\ table\fP
- this table describes  the order that the functions should be
defined and forms evaluated.
It is a table of longwords  beginning at the symbol bind_org
and ending when a -1 entry is seen.
The meaning of the entries will be described below.
.ip \fIlisp\ expression\ table\fP
- this is a table of null terminated strings beginning at the 
symbol lit_org and ending at the symbol lit_end.
Each string is read by the lisp read function (using the
raw readtable).
The first linker_size expressions are put in the literal table.
The next trans_size expressions are the names  of the
functions to put in the transfer table.
The remaining expressions correspond to the entries in the
binder table.
The binder entries are processed, one by one. 
Provided that the binder entry is not -1,  an expression
is read from the lisp expression table.
Then if the binder table entry is 0, that expression is the name of
a lambda type lisp function.
A binary object is created, the discipline is set to lambda and
the function address is set to the lexically next function 
defined in the
file.
If the binder entry is 1 then this is an nlambda function, and
if the entry is 2 then this is a macro function.
If the entry is 99 then the expression just read should be evaluated
by the lisp function eval.
.pp
The lisp compiler normally puts the assembler format output file in /tmp
and removes it when it is done. 
The -S switch will tell liszt to write the 
assembler file in the same place as
the source file, and with the same root name but a .s extension.
The -C file will tell the lisp compiler to comment the file as it
generates it, making it easier to understand what is going on.
Assume that the following is file foo.l:
.(b
(defun foo (x) (bar y) (baz k))
(print (foo 3))
(def test (nlambda (l) (print 'hithere) (foo 3)))
.)b
we now compile it with -SC
.(b
    .globl	F00007	#(fcn lambda foo)
    F00007:
    .word	0x5c0
    movab	linker,r8
    movl	r7,r10
    movab	4(r10),r6
    L00008:
    movl	*0(r8),(r6)+	#(calling bar)
	    #(from y to stack)
    movab	-4(r6),r7
    calls	$0,*trantb+0
    movl	r7,r6
    movl	*4(r8),(r6)+	#(calling baz)
	    #(from k to stack)
    movab	-4(r6),r7
    calls	$0,*trantb+8
    movl	r7,r6
    ret
    .globl	F00009	#(fcn nlambda test)
    F00009:
    .word	0x5c0
    movab	linker,r8
    movl	r7,r10
    movab	4(r10),r6
    L00010:
    movl	8(r8),(r6)+	#(calling print)
	    #(from 'hithere to stack)
    movab	-4(r6),r7
    calls	$0,*trantb+16
    movl	r7,r6
    movl	$5132,(r6)+	#(calling foo)
	    #(from (fixnum 3) to stack)
    movab	-4(r6),r7
    calls	$0,*trantb+24
    movl	r7,r6
    ret
    bind_org:
    .set linker_size,	3
    .set trans_size,	4
    .long	0
    .long	99
    .long	1
    .long -1
    lit_org:
    .asciz "y"
    .asciz "k"
    .asciz "hithere"
    .asciz "bar"
    .asciz "baz"
    .asciz "print"
    .asciz "foo"
    .asciz "foo"
    .asciz "(print (foo 3))"
    .asciz "test"
    lit_end:
    .data  # this is just for documentation 
    .asciz "@(#)Compiled by Lisp Compiler 7.1 on Sun Feb 21 17:51:54 1982"
    .asciz "@(#)decl.l	1.5	2/10/82"
    .asciz "@(#)array.l	1.1	9/25/81"
    .asciz "@(#)datab.l	1.1	9/25/81"
    .asciz "@(#)expr.l	1.1	9/25/81"
    .asciz "@(#)io.l	1.1	9/25/81"
    .asciz "@(#)funa.l	1.3	2/10/82"
    .asciz "@(#)funb.l	1.2	2/10/82"
    .asciz "@(#)func.l	1.2	2/10/82"
    .asciz "@(#)tlev.l	1.4	10/24/81"
    .asciz "@(#)fixnum.l	1.6	10/21/81"
    .asciz "@(#)util.l	1.2	10/7/81"
.)b
.sh +0 functions\ callable\ from\ compiled\ lisp\ code
.sh +0 Object\ File\ Format
.sh +0 Fasl





EndOfFile
cat >  lisplib/manual/ch0.r  << 'EndOfFile'




















                   The FRANZ LISP Manual

                             by


                      _J_o_h_n _K_. _F_o_d_e_r_a_r_o


                      _K_e_i_t_h _L_. _S_k_l_o_w_e_r


                        _K_e_v_i_n _L_a_y_e_r












                         June 1983












                                               A document in
                                              four movements
9

9










                       _O_v_e_r_t_u_r_e


     _A  _c_h_o_r_u_s  _o_f  _s_t_u_d_e_n_t_s  _u_n_d_e_r  _t_h_e  _d_i_r_e_c_t_i_o_n  _o_f
     _R_i_c_h_a_r_d _F_a_t_e_m_a_n _h_a_v_e _c_o_n_t_r_i_b_u_t_e_d _t_o _b_u_i_l_d_i_n_g _F_R_A_N_Z
     _L_I_S_P _f_r_o_m _a _m_e_r_e _m_e_l_o_d_y _i_n_t_o  _a  _f_u_l_l  _s_y_m_p_h_o_n_y  .
     _T_h_e  _m_a_j_o_r _c_o_n_t_r_i_b_u_t_o_r_s _t_o _t_h_e _i_n_i_t_i_a_l _s_y_s_t_e_m _w_e_r_e
     _M_i_k_e _C_u_r_r_y,  _J_o_h_n  _B_r_e_e_d_l_o_v_e  _a_n_d  _J_e_f_f  _L_e_v_i_n_s_k_y.
     _B_i_l_l  _R_o_w_a_n  _a_d_d_e_d _t_h_e _g_a_r_b_a_g_e _c_o_l_l_e_c_t_o_r _a_n_d _a_r_r_a_y
     _p_a_c_k_a_g_e.  _T_o_m _L_o_n_d_o_n _w_o_r_k_e_d _o_n _a_n  _e_a_r_l_y  _c_o_m_p_i_l_e_r
     _a_n_d   _h_e_l_p_e_d  _i_n  _o_v_e_r_a_l_l  _s_y_s_t_e_m  _d_e_s_i_g_n.   _K_e_i_t_h
     _S_k_l_o_w_e_r _h_a_s _c_o_n_t_r_i_b_u_t_e_d _m_u_c_h _t_o _F_R_A_N_Z _L_I_S_P, _a_d_d_i_n_g
     _t_h_e  _b_i_g_n_u_m _p_a_c_k_a_g_e _a_n_d _r_e_w_r_i_t_i_n_g _m_o_s_t _o_f _t_h_e _c_o_d_e
     _t_o _i_n_c_r_e_a_s_e  _i_t_s  _e_f_f_i_c_i_e_n_c_y  _a_n_d  _c_l_a_r_i_t_y.   _K_i_p_p
     _H_i_c_k_m_a_n  _a_n_d  _C_h_a_r_l_e_s  _K_o_e_s_t_e_r _a_d_d_e_d _h_u_n_k_s.  _M_i_t_c_h
     _M_a_r_c_u_s _a_d_d_e_d *_r_s_e_t, _e_v_a_l_h_o_o_k _a_n_d  _e_v_a_l_f_r_a_m_e.   _D_o_n
     _C_o_h_e_n  _a_n_d  _o_t_h_e_r_s  _a_t  _C_a_r_n_e_g_i_e-_M_e_l_l_o_n  _m_a_d_e _s_o_m_e
     _i_m_p_r_o_v_e_m_e_n_t_s _t_o  _e_v_a_l_f_r_a_m_e  _a_n_d  _p_r_o_v_i_d_e_d  _v_a_r_i_o_u_s
     _f_e_a_t_u_r_e_s  _m_o_d_e_l_l_e_d  _a_f_t_e_r  _U_C_I/_C_M_U _P_D_P-_1_0 _L_i_s_p _a_n_d
     _I_n_t_e_r_l_i_s_p  _e_n_v_i_r_o_n_m_e_n_t_s  (_e_d_i_t_o_r,  _d_e_b_u_g_g_e_r,  _t_o_p-
     _l_e_v_e_l).  _J_o_h_n _F_o_d_e_r_a_r_o _w_r_o_t_e _t_h_e _c_o_m_p_i_l_e_r, _a_d_d_e_d _a
     _f_e_w _f_u_n_c_t_i_o_n_s, _a_n_d _w_r_o_t_e _m_u_c_h _o_f _t_h_i_s  _m_a_n_u_a_l.  _O_f
     _c_o_u_r_s_e,  _o_t_h_e_r  _a_u_t_h_o_r_s  _h_a_v_e _c_o_n_t_r_i_b_u_t_e_d _s_p_e_c_i_f_i_c
     _c_h_a_p_t_e_r_s _a_s _i_n_d_i_c_a_t_e_d.  _K_e_v_i_n _L_a_y_e_r  _m_o_d_i_f_i_e_d  _t_h_e
     _c_o_m_p_i_l_e_r  _t_o  _p_r_o_d_u_c_e _c_o_d_e _f_o_r _t_h_e _M_o_t_o_r_o_l_a _6_8_0_0_0,
     _a_n_d _h_e_l_p_e_d _m_a_k_e _F_R_A_N_Z _L_I_S_P _p_a_s_s ``_L_i_n_t''.
     _T_h_i_s _m_a_n_u_a_l _m_a_y _b_e _s_u_p_p_l_e_m_e_n_t_e_d _o_r  _s_u_p_p_l_a_n_t_e_d  _b_y
     _l_o_c_a_l _c_h_a_p_t_e_r_s _r_e_p_r_e_s_e_n_t_i_n_g _a_l_t_e_r_a_t_i_o_n_s, _a_d_d_i_t_i_o_n_s
     _a_n_d _d_e_l_e_t_i_o_n_s.  _W_e _a_t _U._C. _B_e_r_k_e_l_e_y _a_r_e _p_l_e_a_s_e_d _t_o
     _l_e_a_r_n  _o_f  _g_e_n_e_r_a_l_l_y  _u_s_e_f_u_l  _s_y_s_t_e_m _f_e_a_t_u_r_e_s, _b_u_g
     _f_i_x_e_s, _o_r _u_s_e_f_u_l _p_r_o_g_r_a_m  _p_a_c_k_a_g_e_s,  _a_n_d  _w_e  _w_i_l_l
     _a_t_t_e_m_p_t _t_o _r_e_d_i_s_t_r_i_b_u_t_e _s_u_c_h _c_o_n_t_r_i_b_u_t_i_o_n_s.










98c9 1980, 1981, 1983 by the Regents of the University of Cali-
fornia.   (exceptions:  Chapters 13, 14 (first half), 15 and
16 have separate copyrights, as indicated. These are  repro-
duced by permission of the copyright holders.)
Permission to copy without fee all or part of this  material
is  granted provided that the copies are not made or distri-
buted for direct commercial  advantage,  and  the  copyright
notice  of  the Regents, University of California, is given.
All rights reserved.



9










Work reported herein was supported in  part  by  the  U.  S.
Department  of  Energy,  Contract DE-AT03-76SF00034, Project
Agreement DE-AS03-79ER10358, and the National Science  Foun-
dation under Grant No.  MCS 7807291


UNIX is a trademark of Bell Laboratories.  VAX and  PDP  are
trademarks  of  Digital Equiptment Coporation.  MC68000 is a
trademark of Motorola Semiconductor Products, Inc.











































9

9










                           Score



                    First Movement (_a_l_l_e_g_r_o _n_o_n _t_r_o_p_p_o)

     1. FRANZ LISP
          _I_n_t_r_o_d_u_c_t_i_o_n _t_o _F_R_A_N_Z _L_I_S_P, _d_e_t_a_i_l_s _o_f _d_a_t_a _t_y_p_e_s,
          _a_n_d _d_e_s_c_r_i_p_t_i_o_n _o_f _n_o_t_a_t_i_o_n
     2. Data Structure Access
          _F_u_n_c_t_i_o_n_s _f_o_r _t_h_e _c_r_e_a_t_i_o_n, _d_e_s_t_r_u_c_t_i_o_n _a_n_d  _m_a_n_i_-
          _p_u_l_a_t_i_o_n _o_f _l_i_s_p _d_a_t_a _o_b_j_e_c_t_s.
     3. Arithmetic Functions
          _F_u_n_c_t_i_o_n_s _t_o _p_e_r_f_o_r_m _a_r_i_t_h_m_e_t_i_c _o_p_e_r_a_t_i_o_n_s.
     4. Special Functions
          _F_u_n_c_t_i_o_n_s _f_o_r _a_l_t_e_r_i_n_g _f_l_o_w _o_f _c_o_n_t_r_o_l.  _F_u_n_c_t_i_o_n_s
          _f_o_r _m_a_p_p_i_n_g _o_t_h_e_r _f_u_n_c_t_i_o_n_s _o_v_e_r _l_i_s_t_s.
     5. I/O Functions
          _F_u_n_c_t_i_o_n_s _f_o_r  _r_e_a_d_i_n_g  _a_n_d  _w_r_i_t_i_n_g  _f_r_o_m  _p_o_r_t_s.
          _F_u_n_c_t_i_o_n_s  _f_o_r  _t_h_e  _m_o_d_i_f_i_c_a_t_i_o_n  _o_f _t_h_e _r_e_a_d_e_r'_s
          _s_y_n_t_a_x.
     6. System Functions
          _F_u_n_c_t_i_o_n_s _f_o_r _s_t_o_r_a_g_e _m_a_n_a_g_e_m_e_n_t,  _d_e_b_u_g_g_i_n_g,  _a_n_d
          _f_o_r  _t_h_e _r_e_a_d_i_n_g _a_n_d _s_e_t_t_i_n_g _o_f _g_l_o_b_a_l _L_i_s_p _s_t_a_t_u_s
          _v_a_r_i_a_b_l_e_s.   _F_u_n_c_t_i_o_n_s  _f_o_r  _d_o_i_n_g   _U_N_I_X-_s_p_e_c_i_f_i_c
          _t_a_s_k_s _s_u_c_h _a_s _p_r_o_c_e_s_s _c_o_n_t_r_o_l.


                    Second Movement (_L_a_r_g_o)

     7. The Reader
          _A _d_e_s_c_r_i_p_t_i_o_n _o_f _t_h_e  _s_y_n_t_a_x  _c_o_d_e_s  _u_s_e_d  _b_y  _t_h_e
          _r_e_a_d_e_r.  _A_n _e_x_p_l_a_n_a_t_i_o_n _o_f _c_h_a_r_a_c_t_e_r _m_a_c_r_o_s.
     8. Functions, Fclosures, and Macros
          _A  _d_e_s_c_r_i_p_t_i_o_n  _o_f  _v_a_r_i_o_u_s  _t_y_p_e_s  _o_f  _f_u_n_c_t_i_o_n_a_l
          _o_b_j_e_c_t_s.   _A_n  _e_x_a_m_p_l_e _o_f _t_h_e _u_s_e _o_f _f_o_r_e_i_g_n _f_u_n_c_-
          _t_i_o_n_s.
     9. Arrays and Vectors
          _A _d_e_t_a_i_l_e_d _d_e_s_c_r_i_p_t_i_o_n _o_f _t_h_e _p_a_r_t_s  _o_f  _a_n  _a_r_r_a_y
          _a_n_d _o_f _M_a_c_l_i_s_p _c_o_m_p_a_t_i_b_l_e _a_r_r_a_y_s.
     10. Exception Handling
          _A _d_e_s_c_r_i_p_t_i_o_n _o_f _t_h_e _e_r_r_o_r _h_a_n_d_l_i_n_g  _s_e_q_u_e_n_c_e  _a_n_d
          _o_f _a_u_t_o_l_o_a_d_i_n_g.









9

9










                    Third Movement (_S_c_h_e_r_z_o)

     11. The Joseph Lister Trace Package
          _A _d_e_s_c_r_i_p_t_i_o_n _o_f _a _v_e_r_y _u_s_e_f_u_l _d_e_b_u_g_g_i_n_g _a_i_d.
     12. Liszt, the lisp compiler
          _A _d_e_s_c_r_i_p_t_i_o_n _o_f _t_h_e _o_p_e_r_a_t_i_o_n _o_f _t_h_e _c_o_m_p_i_l_e_r _a_n_d
          _h_i_n_t_s _f_o_r _m_a_k_i_n_g _f_u_n_c_t_i_o_n_s _c_o_m_p_i_l_a_b_l_e.
     13. CMU Top Level and File Package
          _A _d_e_s_c_r_i_p_t_i_o_n  _o_f  _a  _t_o_p  _l_e_v_e_l  _w_i_t_h  _a  _h_i_s_t_o_r_y
          _m_e_c_h_a_n_i_s_m _a_n_d _a _p_a_c_k_a_g_e _w_h_i_c_h _h_e_l_p_s _y_o_u _k_e_e_p _t_r_a_c_k
          _o_f _f_i_l_e_s _o_f _l_i_s_p _f_u_n_c_t_i_o_n_s.
     14 Stepper
          _A _d_e_s_c_r_i_p_t_i_o_n _o_f _a _p_r_o_g_r_a_m _w_h_i_c_h  _p_e_r_m_i_t_s  _y_o_u  _t_o
          _p_u_t  _b_r_e_a_k_p_o_i_n_t_s  _i_n  _l_i_s_p _c_o_d_e _a_n_d _t_o _s_i_n_g_l_e _s_t_e_p
          _i_t.  _A _d_e_s_c_r_i_p_t_i_o_n _o_f _t_h_e _e_v_a_l_h_o_o_k _a_n_d _f_u_n_c_a_l_l_h_o_o_k
          _m_e_c_h_a_n_i_s_m.
     15 Fixit
          _A _p_r_o_g_r_a_m _w_h_i_c_h _p_e_r_m_i_t_s _y_o_u _t_o _e_x_a_m_i_n_e _a_n_d  _m_o_d_i_f_y
          _e_v_a_l_u_a_t_i_o_n _s_t_a_c_k _i_n _o_r_d_e_r _t_o _f_i_x _b_u_g_s _o_n _t_h_e _f_l_y.
     16 Lisp Editor
          _A _s_t_r_u_c_t_u_r_e _e_d_i_t_o_r _f_o_r _i_n_t_e_r_a_c_t_i_v_e _m_o_d_i_f_i_c_a_t_i_o_n _o_f
          _l_i_s_p _c_o_d_e.


                    Final Movement (_a_l_l_e_g_r_o)

     Appendix A - Function Index
     Appendix B - List of Special Symbols
     Appendix C - Short Subjects
          _G_a_r_b_a_g_e _c_o_l_l_e_c_t_o_r, _D_e_b_u_g_g_i_n_g, _D_e_f_a_u_l_t _T_o_p _L_e_v_e_l






















9

9



EndOfFile
cat >  lisplib/manual/ch1.r  << 'EndOfFile'







                         CHAPTER  1


                         FRANZ LISP






   1.1.  FRANZ LISP[|-] was created  as  a  tool  to  further
      research   in  symbolic  and  algebraic  manipulation,
      artificial intelligence, and programming languages  at
      the University of California at Berkeley.   Its  roots
      are in a PDP-11 Lisp system which originally came from
      Harvard.  As it grew it adopted  features  of  Maclisp
      and Lisp Machine Lisp.  Substantial compatibility with
      other Lisp dialects (Interlisp, UCILisp,  CMULisp)  is
      achieved  by  means  of  support packages and compiler
      switches.  The heart of FRANZ LISP is  written  almost
      entirely in the programming language C.  Of course, it
      has been greatly  extended  by  additions  written  in
      Lisp.   A  small  part  is  written  in  the  assembly
      language for the current host machines,  VAXen  and  a
      couple  of  flavors  of  68000.  Because FRANZ LISP is
      written in C, it is relatively portable  and  easy  to
      comprehend.

           FRANZ LISP is capable of running large lisp  pro-
      grams in a timesharing environment, has facilities for
      arrays and user defined structures, has  a  user  con-
      trolled reader with character and word macro  capabil-
      ities, and can interact directly with  compiled  Lisp,
      C, Fortran, and Pascal code.

           This document is a reference manual for the FRANZ
      LISP  system.  It is not a Lisp primer or introduction
      to the language.  Some parts will be of interest  pri-
      marily  to  those maintaining FRANZ LISP at their com-
      puter site.  There is an additional document  entitled
      _T_h_e  _F_r_a_n_z  _L_i_s_p  _S_y_s_t_e_m, _b_y _J_o_h_n _F_o_d_e_r_a_r_o, _w_h_i_c_h _p_a_r_-
      _t_i_a_l_l_y _d_e_s_c_r_i_b_e_s  _t_h_e  _s_y_s_t_e_m  _i_m_p_l_e_m_e_n_t_a_t_i_o_n.   _F_R_A_N_Z
      _L_I_S_P,  _a_s  _d_e_l_i_v_e_r_e_d  _b_y _B_e_r_k_e_l_e_y, _i_n_c_l_u_d_e_s _a_l_l _s_o_u_r_c_e
      _c_o_d_e _a_n_d _m_a_c_h_i_n_e _r_e_a_d_a_b_l_e _v_e_r_s_i_o_n _o_f _t_h_i_s  _m_a_n_u_a_l  _a_n_d
      _s_y_s_t_e_m  _d_o_c_u_m_e_n_t.   _T_h_e _s_y_s_t_e_m _d_o_c_u_m_e_n_t _i_s _i_n _a _s_i_n_g_l_e
      _f_i_l_e _n_a_m_e_d "_f_r_a_n_z._n" _i_n _t_h_e "_d_o_c" _s_u_b_d_i_r_e_c_t_o_r_y.
____________________
9   [|-]It is rumored that this name has something to do  with
Franz  Liszt  [F_rants List] (1811-1886) a Hungarian composer
and keyboard virtuoso. These  allegations  have  never  been
proven.



9FRANZ LISP                                               1-1







FRANZ LISP                                               1-2


           This document is divided into four Movements.  In
      the first one we will attempt to describe the language
      of FRANZ LISP  precisely  and  completely  as  it  now
      stands  (Opus  38.69, June 1983).  In the second Move-
      ment we will  look  at  the  reader,  function  types,
      arrays  and exception handling.  In the third Movement
      we will look at several large support packages written
      to help the FRANZ LISP user, namely the trace package,
      compiler, fixit and  stepping  package.   Finally  the
      fourth  movement  contains   an  index  into the other
      movements.  In the rest of this chapter we shall exam-
      ine  the  data  types  of FRANZ LISP.  The conventions
      used in the description of the  FRANZ  LISP  functions
      will  be  given  in  1.3  -- it is very important that
      these conventions are  understood.



   1.2.  Data Types   FRANZ LISP has  fourteen  data  types.
      In  this  section we shall look in detail at each type
      and if a type is divisible we shall  look  inside  it.
      There  is  a  Lisp function _t_y_p_e which will return the
      type name of a lisp  object.   This  is  the  official
      FRANZ  LISP  name  for  that type and we will use this
      name and this name only in the manual to avoid confus-
      ing  the  reader.   The  types  are listed in terms of
      importance rather than alphabetically.



      1.2.0.  lispval   This is the name we use to  describe
         any  Lisp  object.   The  function  _t_y_p_e will never
         return `lispval'.



      1.2.1.  symbol   This object corresponds to a variable
         in most other programming languages.  It may have a
         value or may be `unbound'.  A symbol may be  _l_a_m_b_d_a
         _b_o_u_n_d meaning that its current value is stored away
         somewhere and the symbol  is given a new value  for
         the  duration  of a certain context.  When the Lisp
         processor   leaves  that  context,   the   symbol's
         current  value  is thrown away and its old value is
         restored.
9         A symbol may also have a  _f_u_n_c_t_i_o_n  _b_i_n_d_i_n_g.   This
         function  binding  is  static;  it cannot be lambda
         bound.  Whenever the symbol is used  in  the  func-
         tional  position  of a Lisp expression the function
         binding of the symbol is examined  (see  Chapter  4
         for more details on  evaluation).
9         A symbol may also have  a  _p_r_o_p_e_r_t_y  _l_i_s_t,  another


                                   Printed: January 31, 1984







FRANZ LISP                                               1-3


         static  data structure.  The property list consists
         of a list of an even number of elements, considered
         to  be  grouped  as pairs. The first element of the
         pair is the _i_n_d_i_c_a_t_o_r the second the _v_a_l_u_e of  that
         indicator.
9         Each symbol has a print name (_p_n_a_m_e) which  is  how
         this  symbol is accessed from input and referred to
         on  (printed) output.
9         A symbol also has a hashlink used to  link  symbols
         together  in the oblist -- this field is inaccessi-
         ble to the lisp user.
9         Symbols are created by the reader and by the  func-
         tions  _c_o_n_c_a_t,  _m_a_k_n_a_m and their derivatives.  Most
         symbols live  on  FRANZ  LISP's  sole  _o_b_l_i_s_t,  and
         therefore  two symbols with the same print name are
         usually the  exact same object (they are _e_q).  Sym-
         bols  which  are  not  on the oblist are said to be
         _u_n_i_n_t_e_r_n_e_d.  The function _m_a_k_n_a_m creates uninterned
         symbols while _c_o_n_c_a_t creates _i_n_t_e_r_n_e_d ones.


8    ____________________________________________________________
     Subpart name   Get value   Set value          Type

8    ________________________________________________________________________________________________________________________
        value         eval         set            lispval
                                  setq
8    ____________________________________________________________
       property       plist     setplist        list or nil
         list          get       putprop
                                 defprop
8    ____________________________________________________________
       function       getd        putd      array, binary, list
       binding                     def            or nil
8    ____________________________________________________________
      print name    get_pname                     string
8    ____________________________________________________________
      hash link
8    ____________________________________________________________
7   |7|7|7|7|7|7|7|7|7|7|7|7|7|












                 |7|7|7|7|7|7|7|7|7|7|7|7|7|












                             |7|7|7|7|7|7|7|7|7|7|7|7|7|












                                         |7|7|7|7|7|7|7|7|7|7|7|7|7|












                                                               |7|7|7|7|7|7|7|7|7|7|7|7|7|

















      1.2.2.  list   A list cell has two parts,  called  the
         car  and  cdr.  List cells are created by the func-
         tion _c_o_n_s.


8          ________________________________________________
           Subpart name   Get value   Set value    Type

8          ________________________________________________________________________________________________
               car           car       rplaca     lispval
8          ________________________________________________
               cdr           cdr       rplacd     lispval



9                                   Printed: January 31, 1984







FRANZ LISP                                               1-4


8          ________________________________________________
799         |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777777777799                       |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777777777799                                   |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777777777799                                               |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777777777799                                                         |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
777777777777777777777777777777777777777777777


      1.2.3.  binary   This type acts as a  function  header
         for  machine  coded functions.  It has two parts, a
         pointer to the start of the function and  a  symbol
         whose print name describes the argument _d_i_s_c_i_p_l_i_n_e.
         The discipline (if _l_a_m_b_d_a, _m_a_c_r_o or _n_l_a_m_b_d_a) deter-
         mines  whether  the arguments to this function will
         be evaluated by the caller before this function  is
         called.   If  the  discipline is a string (specifi-
         cally "_s_u_b_r_o_u_t_i_n_e", "_f_u_n_c_t_i_o_n", "_i_n_t_e_g_e_r-_f_u_n_c_t_i_o_n",
         "_r_e_a_l-_f_u_n_c_t_i_o_n", "_c-_f_u_n_c_t_i_o_n", "_d_o_u_b_l_e-_c-_f_u_n_c_t_i_o_n",
         or "_v_e_c_t_o_r-_c-_f_u_n_c_t_i_o_n" ) then this  function  is  a
         foreign  subroutine  or  function (see 8.5 for more
         details on this).  Although the type of  the  _e_n_t_r_y
         field  of a binary type object is usually string or
         other, the object pointed to is actually a sequence
         of machine instructions.
         Objects of type binary are  created  by  _m_f_u_n_c_t_i_o_n,
         _c_f_a_s_l, and _g_e_t_a_d_d_r_e_s_s.


8      _________________________________________________________
       Subpart name   Get value   Set value         Type

8      __________________________________________________________________________________________________________________
          entry       getentry                string or fixnum
8      _________________________________________________________
        discipline     getdisc     putdisc    symbol or fixnum
8      _________________________________________________________
7     |8|7|7|7|7|



9                   |8|7|7|7|7|



9                               |8|7|7|7|7|



9                                           |8|7|7|7|7|



9                                                              |8|7|7|7|7|





9


      1.2.4.  fixnum   A fixnum is an  integer  constant  in
         the  range -2[31] to 2[31]-1.  Small fixnums (-1024
         to 1023) are stored in  a  special  table  so  they
         needn't  be  allocated each time one is needed.  In
         principle, the range for fixnums is machine  depen-
         dent,  although  all  current  implementations  for
         franz have this range.



      1.2.5.  flonum   A flonum is a double  precision  real
         number.  On  the  VAX, the range is +_2.9x10[-37] to
         +_1.7x10[38].   There  are   approximately   sixteen
         decimal  digits  of  precision.  Other machines may
         have other ranges.





9                                   Printed: January 31, 1984







FRANZ LISP                                               1-5


      1.2.6.  bignum   A bignum is an integer of potentially
         unbounded  size.   When  integer arithmetic exceeds
         the limits of fixnums mentioned above, the calcula-
         tion  is  automatically  done with bignums.  Should
         calculation with bignums give a result which can be
         represented  as a fixnum, then the fixnum represen-
         tation will be used[|-].  This contraction is  known
         as  _i_n_t_e_g_e_r  _n_o_r_m_a_l_i_z_a_t_i_o_n.   Many  Lisp  functions
         assume that integers are normalized.   Bignums  are
         composed  of  a  sequence  of list cells and a cell
         known as an sdot.  The user should consider a  big-
         num structure indivisible and use functions such as
         _h_a_i_p_a_r_t, and _b_i_g_n_u_m-_l_e_f_t_s_h_i_f_t to extract  parts  of
         it.



      1.2.7.   string    A  string  is  a  null   terminated
         sequence  of characters.  Most functions of symbols
         which operate on the symbol's print name will  also
         work  on strings.  The default reader syntax is set
         so that a sequence of characters surrounded by dou-
         ble quotes is a string.



      1.2.8.  port   A port is a structure which the  system
         I/O routines can reference to transfer data between
         the Lisp system and external media.   Unlike  other
         Lisp  objects  there  are  a very limited number of
         ports (20).  Ports are allocated by _i_n_f_i_l_e and _o_u_t_-
         _f_i_l_e  and  deallocated  by  _c_l_o_s_e and _r_e_s_e_t_i_o.  The
         _p_r_i_n_t function prints a port as a percent sign fol-
         lowed  by  the  name of the file it is connected to
         (if the port was opened  by  _f_i_l_e_o_p_e_n,  _i_n_f_i_l_e,  _o_r
         _o_u_t_f_i_l_e).   During initialization, FRANZ LISP binds
         the symbol piport to a port attached to  the  stan-
         dard  input  stream.   This port prints as %$stdin.
         There are ports connected to  the  standard  output
         and  error  streams,  which  print  as %$stdout and
         %$stderr.  This is discussed in more detail at  the
         beginning of Chapter 5.




____________________
9   [|-]The current algorithms for integer  arithmetic  opera-
tions will return (in certain cases) a result between +_2[30]
and 2[31] as a bignum although this could be represented  as
a fixnum.



9                                   Printed: January 31, 1984







FRANZ LISP                                               1-6


      1.2.9.  vector    Vectors  are  indexed  sequences  of
         data.   They  can  be used to implement a notion of
         user-defined types via  their  associated  property
         list.    They  make  hunks  (see  below)  logically
         unnecessary, although hunks  are  very  efficiently
         garbage  collected.  There is a second kind of vec-
         tor,  called  an  immediate-vector,  which   stores
         binary  data.   The  name  that  the  function _t_y_p_e
         returns   for   immediate-vectors    is    vectori.
         Immediate-vectors   could   be  used  to  implement
         strings and block-flonum arrays, for example.  Vec-
         tors  are  discussed  in  chapter 9.  The functions
         _n_e_w-_v_e_c_t_o_r, and _v_e_c_t_o_r, can be used to create  vec-
         tors.


8          ________________________________________________
           Subpart name   Get value   Set value    Type

8          ________________________________________________________________________________________________
             datum[_i]       vref        vset      lispval
8          ________________________________________________
             property       vprop     vsetprop    lispval
                                      vputprop
8          ________________________________________________
               size         vsize         -       fixnum
8          ________________________________________________
7         |7|7|7|7|7|7|7|






                       |7|7|7|7|7|7|7|






                                   |7|7|7|7|7|7|7|






                                               |7|7|7|7|7|7|7|






                                                         |7|7|7|7|7|7|7|











      1.2.10.  array   Arrays are rather  complicated  types
         and  are  fully  described  in Chapter 9.  An array
         consists of a block of contiguous data, a  function
         to  access  that data, and auxiliary fields for use
         by  the  accessing  function.   Since  an   array's
         accessing function is created by the user, an array
         can  have  any  form  the  user  chooses  (e.g.  n-
         dimensional, triangular, or hash table).
         Arrays are created by the function _m_a_r_r_a_y.


8   _______________________________________________________________
     Subpart name     Get value   Set value          Type

8   ______________________________________________________________________________________________________________________________
    access function   getaccess   putaccess      binary, list
                                                   or symbol
8   _______________________________________________________________
       auxiliary       getaux      putaux           lispval
8   _______________________________________________________________
         data         arrayref     replace    block of contiguous
                                     set            lispval
8   _______________________________________________________________
        length        getlength   putlength         fixnum
8   _______________________________________________________________
         delta        getdelta    putdelta          fixnum



9                                   Printed: January 31, 1984







FRANZ LISP                                               1-7


8   _______________________________________________________________
799  |9|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777899                   |9|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777899                               |9|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777899                                           |9|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
7777777777777777777777777777777777777777899                                                                 |9|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
777777777777777777777777777777777777778


      1.2.11.  value   A value cell contains a pointer to  a
         lispval.   This  type  is  used mainly by arrays of
         general lisp objects.  Value cells are created with
         the  _p_t_r  function.   A  value  cell  containing  a
         pointer  to  the  symbol  `foo'   is   printed   as
         `(ptr to)foo'



      1.2.12.  hunk   A hunk is a vector of from  1  to  128
         lispvals.   Once  a  hunk  is  created  (by _h_u_n_k or
         _m_a_k_h_u_n_k) it cannot grow or shrink.  The access time
         for an element of a hunk is slower than a list cell
         element but faster than an array.  Hunks are really
         only  allocated  in  sizes which are powers of two,
         but can appear to the user to be any size in the  1
         to  128  range.   Users  of hunks must realize that
         (_n_o_t (_a_t_o_m '_l_i_s_p_v_a_l)) will return true  if  _l_i_s_p_v_a_l
         is  a hunk.  Most lisp systems do not have a direct
         test for a list cell and instead use the above test
         and  assume  that  a true result means _l_i_s_p_v_a_l is a
         list cell.  In FRANZ LISP you can use _d_t_p_r to check
         for  a  list  cell.   Although  hunks  are not list
         cells, you can still access the first two hunk ele-
         ments  with _c_d_r and _c_a_r and you can access any hunk
         element with _c_x_r[|-].  You can set the value of  the
         first two elements of a hunk with _r_p_l_a_c_d and _r_p_l_a_c_a
         and you can set the value of  any  element  of  the
         hunk  with  _r_p_l_a_c_x.   A hunk is printed by printing
         its contents surrounded by { and }.  However a hunk
         cannot  be read in in this way in the standard lisp
         system.  It is easy to write a reader macro  to  do
         this if desired.



      1.2.13.   other    Occasionally,  you  can  obtain   a
         pointer  to  storage not allocated by the lisp sys-
         tem.  One example of this is  the  entry  field  of
         those  FRANZ  LISP  functions  written  in C.  Such
         objects are classified as of type  other.   Foreign
         functions  which  call malloc to allocate their own
         space, may also inadvertantly create such  objects.
         The  garbage  collector  is supposed to ignore such
____________________
9   [|-]In a hunk, the function _c_d_r references the first  ele-
ment and _c_a_r the second.



                                   Printed: January 31, 1984







FRANZ LISP                                               1-8


         objects.



   1.3.  Documentation   The conventions used in the follow-
      ing  chapters  were  designed  to give a great deal of
      information in a brief space.  The  first  line  of  a
      function  description  contains  the  function name in
      bold face and then lists the arguments, if  any.   The
      arguments all have names which begin with a letter  or
      letters and an underscore.  The  letter(s)  gives  the
      allowable  type(s) for that argument according to this
      table.


8     _______________________________________________________
      Letter                Allowable type(s)

8     ______________________________________________________________________________________________________________
      g        any type
8     _______________________________________________________
      s        symbol (although nil may not be allowed)
8     _______________________________________________________
      t        string
8     _______________________________________________________
      l        list (although nil may be allowed)
8     _______________________________________________________
      n        number (fixnum, flonum, bignum)
8     _______________________________________________________
      i        integer (fixnum, bignum)
8     _______________________________________________________
      x        fixnum
8     _______________________________________________________
      b        bignum
8     _______________________________________________________
      f        flonum
8     _______________________________________________________
      u        function type (either binary or lambda body)
8     _______________________________________________________
      y        binary
8     _______________________________________________________
      v        vector
8     _______________________________________________________
      V        vectori
8     _______________________________________________________
      a        array
8     _______________________________________________________
      e        value
8     _______________________________________________________
      p        port (or nil)
8     _______________________________________________________
      h        hunk
8     _______________________________________________________
7    |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


























            |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|


























                                                           |7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|





























      In the first line of  a  function  description,  those
      arguments preceded by a quote mark are evaluated (usu-
      ally before the function is called).  The quoting con-
      vention  is  used  so  that  we can give a name to the
      result of evaluating the argument and we can  describe
      the  allowable types.  If an argument is not quoted it
      does  not  mean  that  that  argument  will   not   be


9                                   Printed: January 31, 1984







FRANZ LISP                                               1-9


      evaluated,  but  rather  that  if it is evaluated, the
      time at which it is  evaluated  will  be  specifically
      mentioned in the function description.  Optional argu-
      ments are surrounded by square brackets.  An  ellipsis
      (...) means zero or more occurrences of an argument of
      the directly preceding type.














































9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch2.r  << 'EndOfFile'







                         CHAPTER  2


                   Data Structure Access




     The following functions allow one to create and manipu-
late  the  various  types of lisp data structures.  Refer to
1.2 for details of the data structures known to FRANZ LISP.



   2.1.  Lists

           The following functions exist  for  the  creation
      and  manipulating  of  lists.  Lists are composed of a
      linked list of objects  called  either  'list  cells',
      'cons cells' or 'dtpr cells'.  Lists are normally ter-
      minated with the special symbol nil.  nil  is  both  a
      symbol and a representation for the empty list ().



      2.1.1.  list creation

(cons 'g_arg1 'g_arg2)

     RETURNS: a new list cell whose car is g_arg1 and  whose
              cdr is g_arg2.

(xcons 'g_arg1 'g_arg2)

     EQUIVALENT TO: (_c_o_n_s '_g__a_r_g_2 '_g__a_r_g_1)

(ncons 'g_arg)

     EQUIVALENT TO: (_c_o_n_s '_g__a_r_g _n_i_l)

(list ['g_arg1 ... ])

     RETURNS: a list whose elements are the g_arg_i.









9

9Data Structure Access                                    2-1







Data Structure Access                                    2-2


(append 'l_arg1 'l_arg2)

     RETURNS: a list containing the elements of l_arg1  fol-
              lowed by l_arg2.

     NOTE: To generate the result, the top level list  cells
           of  l_arg1 are duplicated and the cdr of the last
           list cell is set to point to l_arg2.   Thus  this
           is  an  expensive  operation  if l_arg1 is large.
           See the  descriptions  of  _n_c_o_n_c  and  _t_c_o_n_c  for
           cheaper  ways  of  doing  the  _a_p_p_e_n_d if the list
           l_arg1 can be altered.

(append1 'l_arg1 'g_arg2)

     RETURNS: a list like l_arg1 with  g_arg2  as  the  last
              element.

     NOTE: this  is  equivalent  to  (append  'l_arg1  (list
           'g_arg2)).


    ____________________________________________________

    ; A common mistake is using append to add one element to the end of a list
    -> (_a_p_p_e_n_d '(_a _b _c _d) '_e)
    (a b c d . e)
    ; The user intended to say:
    -> (_a_p_p_e_n_d '(_a _b _c _d) '(_e))
    (_a _b _c _d _e)
    ; _b_e_t_t_e_r _i_s _a_p_p_e_n_d_1
    -> (_a_p_p_e_n_d_1 '(_a _b _c _d) '_e)
    (_a _b _c _d _e)
    ____________________________________________________




(quote! [g_qform_i] ...[! 'g_eform_i] ...  [!! 'l_form_i] ...)

     RETURNS: The list  resulting  from  the   splicing  and
              insertion process described below.

     NOTE: _q_u_o_t_e!  is the complement of the  _l_i_s_t  function.
           _l_i_s_t  forms  a list by evaluating each for in the
           argument list; evaluation is  suppressed  if  the
           form  is _q_u_o_t_eed.  In _q_u_o_t_e!, each form is impli-
           citly _q_u_o_t_eed.  To be evaluated, a form  must  be
           preceded  by one of the evaluate operations ! and
           !!. ! g_eform evaluates g_form and the  value  is
           inserted  in  the  place  of  the call; !! l_form
           evaluates l_form and the value  is  spliced  into
           the place of the call.


                                   Printed: January 31, 1984







Data Structure Access                                    2-3


           `Splicing in' means  that  the  parentheses  sur-
           rounding  the  list  are  removed  as the example
           below shows.  Use of the evaluate  operators  can
           occur at any level in a form argument.

           Another way to get the effect of the _q_u_o_t_e! func-
           tion is to use the backquote character macro (see
            8.3.3).


    ____________________________________________________

    (_q_u_o_t_e! _c_o_n_s ! (_c_o_n_s _1 _2) _3) = (_c_o_n_s (_1 . _2) _3)
    (_q_u_o_t_e! _1 !! (_l_i_s_t _2 _3 _4) _5) = (_1 _2 _3 _4 _5)
    (_s_e_t_q _q_u_o_t_e_d '_e_v_a_l_e_d)(_q_u_o_t_e! ! ((_I _a_m  ! _q_u_o_t_e_d))) = ((_I _a_m _e_v_a_l_e_d))
    (_q_u_o_t_e! _t_r_y ! '(_t_h_i_s ! _o_n_e)) = (_t_r_y (_t_h_i_s ! _o_n_e))
    ____________________________________________________





(bignum-to-list 'b_arg)

     RETURNS: A list  of  the  fixnums  which  are  used  to
              represent the bignum.

     NOTE: the inverse of this function is _l_i_s_t-_t_o-_b_i_g_n_u_m.

(list-to-bignum 'l_ints)

     WHERE:   l_ints is a list of fixnums.

     RETURNS: a bignum constructed of the given fixnums.

     NOTE: the inverse of this function is _b_i_g_n_u_m-_t_o-_l_i_s_t.




      2.1.2.  list predicates











9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-4


(dtpr 'g_arg)

     RETURNS: t iff g_arg is a list cell.

     NOTE: that (dtpr '()) is nil.  The name dtpr is a  con-
           traction for ``dotted pair''.

(listp 'g_arg)

     RETURNS: t iff g_arg is a list object or nil.

(tailp 'l_x 'l_y)

     RETURNS: l_x, if a list cell _e_q  to  l_x  is  found  by
              _c_d_ring down l_y zero or more times, nil other-
              wise.


    ____________________________________________________

    -> (_s_e_t_q _x '(_a _b _c _d) _y (_c_d_d_r _x))
    (c d)
    -> (_a_n_d (_d_t_p_r _x) (_l_i_s_t_p _x))     ; x and y are dtprs and lists
    t
    -> (_d_t_p_r '())           ; () is the same as nil and is not a dtpr
    nil
    -> (_l_i_s_t_p '())          ; however it is a list
    t
    -> (_t_a_i_l_p _y _x)
    (c d)
    ____________________________________________________




(length 'l_arg)

     RETURNS: the number of elements in  the  top  level  of
              list l_arg.



      2.1.3.  list accessing









9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-5


(car 'l_arg)
(cdr 'l_arg)

     RETURNS: _c_o_n_s cell.  (_c_a_r (_c_o_n_s x y)) is always x, (_c_d_r
              (_c_o_n_s  x  y)) is always y.  In FRANZ LISP, the
              cdr portion is located first in memory.   This
              is  hardly  noticeable, and we mention it pri-
              marily as a curiosity.

(c..r 'lh_arg)

     WHERE:   the .. represents any positive number  of  a's
              and d's.

     RETURNS: the result of accessing the list structure  in
              the  way determined by the function name.  The
              a's and d's are read from right to left,  a  d
              directing  the access down the cdr part of the
              list cell and an a down the car part.

     NOTE: lh_arg may also be nil, and it is guaranteed that
           the  car  and  cdr of nil is nil.  If lh_arg is a
           hunk,  then  (_c_a_r '_l_h__a_r_g)   is   the   same   as
           (_c_x_r _1 '_l_h__a_r_g) and  (_c_d_r '_l_h__a_r_g) is the same as
           (_c_x_r _0 '_l_h__a_r_g).
           It is generally hard to read and  understand  the
           context  of  functions  with large strings of a's
           and d's, but these  functions  are  supported  by
           rapid  accessing  and open-compiling (see Chapter
           12).

(nth 'x_index 'l_list)

     RETURNS: the nth element of l_list, assuming zero-based
              index.   Thus  (nth  0  l_list) is the same as
              (car l_list).  _n_t_h is both a function,  and  a
              compiler  macro,  so  that more efficient code
              might be generated than for _n_t_h_e_l_e_m (described
              below).

     NOTE: If x_arg1 is non-positive  or  greater  than  the
           length of the list, nil is returned.










9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-6


(nthcdr 'x_index 'l_list)

     RETURNS: the result of  _c_d_ring  down  the  list  l_list
              x_index times.

     NOTE: If    x_index    is    less    than    0,    then
           (_c_o_n_s _n_i_l '_l__l_i_s_t) is returned.

(nthelem 'x_arg1 'l_arg2)

     RETURNS: The x_arg1'_s_t element of the list l_arg2.

     NOTE: This function comes from the PDP-11 Lisp system.

(last 'l_arg)

     RETURNS: the last list cell in the list l_arg.

     EXAMPLE: _l_a_s_t does NOT return the  last  element  of  a
              list!
              (_l_a_s_t '(_a _b)) = (b)

(ldiff 'l_x 'l_y)

     RETURNS: a  list  of all elements in l_x but not in l_y
              , i.e., the list difference of l_x and l_y.

     NOTE: l_y must be a tail of l_x, i.e., _e_q to the result
           of  applying  some  number  of _c_d_r's to l_x. Note
           that  the  value   of   _l_d_i_f_f   is   always   new
           list  structure  unless l_y is nil, in which case
           (_l_d_i_f_f _l__x _n_i_l) is l_x itself.  If l_y   is   not
           a  tail  of  l_x, _l_d_i_f_f generates an error.

     EXAMPLE: (_l_d_i_f_f '_l__x (_m_e_m_b_e_r '_g__f_o_o  '_l__x))  gives  all
              elements in l_x up to the first g_foo.



      2.1.4.  list manipulation

(rplaca 'lh_arg1 'g_arg2)

     RETURNS: the modified lh_arg1.

     SIDE EFFECT: the car of lh_arg1 is set to  g_arg2.   If
                  lh_arg1  is a hunk then the second element
                  of the hunk is set to g_arg2.




9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-7


(rplacd 'lh_arg1 'g_arg2)

     RETURNS: the modified lh_arg1.

     SIDE EFFECT: the cdr of lh_arg2 is set to  g_arg2.   If
                  lh_arg1  is  a hunk then the first element
                  of the hunk is set to g_arg2.


(attach 'g_x 'l_l)

     RETURNS: l_l whose _c_a_r is now g_x, whose  _c_a_d_r  is  the
              original (_c_a_r _l__l), and whose _c_d_d_r is the ori-
              ginal (_c_d_r _l__l).

     NOTE: what happens is that g_x is added to  the  begin-
           ning  of  list l_l  yet maintaining the same list
           cell  at the beginning of the list.

(delete 'g_val 'l_list ['x_count])

     RETURNS: the result of  splicing  g_val  from  the  top
              level of l_list no more than x_count times.

     NOTE: x_count defaults to a very large number, thus  if
           x_count  is  not  given, all occurrences of g_val
           are removed from the top level of l_list.   g_val
           is compared with successive _c_a_r's of l_list using
           the function _e_q_u_a_l.

     SIDE EFFECT: l_list is modified using  rplacd,  no  new
                  list cells are used.

(delq 'g_val 'l_list ['x_count])
(dremove 'g_val 'l_list ['x_count])

     RETURNS: the result of  splicing  g_val  from  the  top
              level of l_list no more than x_count times.

     NOTE: _d_e_l_q (and _d_r_e_m_o_v_e) are the same as _d_e_l_e_t_e  except
           that _e_q is used for comparison instead of _e_q_u_a_l.











9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-8



    ____________________________________________________

    ; note that you should use the value returned by _d_e_l_e_t_e or _d_e_l_q
    ; and not assume that g_val will always show the deletions.
    ; For example

    -> (_s_e_t_q _t_e_s_t '(_a _b _c _a _d _e))
    (a b c a d e)
    -> (_d_e_l_e_t_e '_a _t_e_s_t)
    (b c d e)         ; the value returned is what we would expect
    -> _t_e_s_t
    (a b c d e)       ; but test still has the first a in the list!
    ____________________________________________________




(remq 'g_x 'l_l ['x_count])
(remove 'g_x 'l_l)

     RETURNS: a _c_o_p_y of l_l  with  all  top  level  elements
              _e_q_u_a_l to g_x removed.  _r_e_m_q uses _e_q instead of
              _e_q_u_a_l for comparisons.

     NOTE: remove does not modify its arguments like _d_e_l_e_t_e,
           and _d_e_l_q do.

(insert 'g_object 'l_list 'u_comparefn 'g_nodups)

     RETURNS: a list consisting of l_list with g_object des-
              tructively  inserted  in a place determined by
              the ordering function u_comparefn.

     NOTE: (_c_o_m_p_a_r_e_f_n '_g__x  '_g__y)  should  return  something
           non-nil  if  g_x can precede g_y in sorted order,
           nil if g_y must precede g_x.  If  u_comparefn  is
           nil, alphabetical order will be used. If g_nodups
           is non-nil, an element will not be inserted if an
           equal  element  is  already  in the list.  _i_n_s_e_r_t
           does binary search to determine where  to  insert
           the new element.










9

9                                   Printed: January 31, 1984







Data Structure Access                                    2-9


(merge 'l_data1 'l_data2 'u_comparefn)

     RETURNS: the merged list of the two input sorted  lists
              l_data1  and  l_data1  using binary comparison
              function u_comparefn.

     NOTE: (_c_o_m_p_a_r_e_f_n '_g__x  '_g__y)  should  return  something
           non-nil  if  g_x can precede g_y in sorted order,
           nil if g_y must precede g_x.  If  u_comparefn  is
           nil,    alphabetical    order   will   be   used.
           u_comparefn should be thought of as "less than or
           equal".   _m_e_r_g_e  changes  both  of its data argu-
           ments.

(subst 'g_x 'g_y 'l_s)
(dsubst 'g_x 'g_y 'l_s)

     RETURNS: the result of substituting g_x for  all  _e_q_u_a_l
              occurrences of g_y  at all levels in l_s.

     NOTE: If g_y is a symbol, _e_q will be used for comparis-
           ons.   The function _s_u_b_s_t does not modify l_s but
           the function  _d_s_u_b_s_t  (destructive  substitution)
           does.

(lsubst 'l_x 'g_y 'l_s)

     RETURNS: a copy of l_s  with l_x spliced in  for  every
              occurrence  of  of g_y at all levels. Splicing
              in means that the parentheses surrounding  the
              list  l_x  are  removed  as  the example below
              shows.


    ____________________________________________________

    -> (_s_u_b_s_t '(_a _b _c) '_x '(_x _y _z (_x _y _z) (_x _y _z)))
    ((a b c) y z ((a b c) y z) ((a b c) y z))
    -> (_l_s_u_b_s_t '(_a _b _c) '_x '(_x _y _z (_x _y _z) (_x _y _z)))
    (a b c y z (a b c y z) (a b c y z))
    ____________________________________________________











9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-10


(subpair 'l_old 'l_new 'l_expr)

     WHERE:   there are  the  same  number  of  elements  in
              l_old as l_new.

     RETURNS: the list l_expr  with  all  occurrences  of  a
              object  in l_old replaced by the corresponding
              one in l_new.  When a substitution is made,  a
              copy  of  the  value  to  substitute in is not
              made.

     EXAMPLE: (_s_u_b_p_a_i_r '(_a _c)' (_x _y) '(_a _b _c _d)) = (_x _b _y _d)


(nconc 'l_arg1 'l_arg2 ['l_arg3 ...])

     RETURNS: A list consisting of the  elements  of  l_arg1
              followed by the elements of l_arg2 followed by
              l_arg3 and so on.

     NOTE: The _c_d_r of  the  last  list  cell  of  l_arg_i  is
           changed to point to l_arg_i+_1.


    ____________________________________________________

    ; _n_c_o_n_c is faster than _a_p_p_e_n_d because it doesn't allocate new list cells.
    -> (_s_e_t_q _l_i_s_1 '(_a _b _c))
    (a b c)
    -> (_s_e_t_q _l_i_s_2 '(_d _e _f))
    (d e f)
    -> (_a_p_p_e_n_d _l_i_s_1 _l_i_s_2)
    (a b c d e f)
    -> _l_i_s_1
    (a b c)       ; note that lis1 has not been changed by _a_p_p_e_n_d
    -> (_n_c_o_n_c _l_i_s_1 _l_i_s_2)
    (a b c d e f) ; _n_c_o_n_c returns the same value as _a_p_p_e_n_d
    -> _l_i_s_1
    (a b c d e f) ; but in doing so alters lis1
    ____________________________________________________












9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-11


(reverse 'l_arg)
(nreverse 'l_arg)

     RETURNS: the list l_arg with the elements  at  the  top
              level in reverse  order.

     NOTE: The function _n_r_e_v_e_r_s_e does the reversal in place,
           that is the list structure is modified.

(nreconc 'l_arg 'g_arg)

     EQUIVALENT TO: (_n_c_o_n_c (_n_r_e_v_e_r_s_e '_l__a_r_g) '_g__a_r_g)




   2.2.  Predicates

           The following functions test  for  properties  of
      data  objects.  When  the result of the test is either
      'false' or 'true',  then  nil  will  be  returned  for
      'false' and something other than nil (often t) will be
      returned for 'true'.

(arrayp 'g_arg)

     RETURNS: t iff g_arg is of type array.

(atom 'g_arg)

     RETURNS: t iff g_arg is not a list or hunk object.

     NOTE: (_a_t_o_m '()) returns t.

(bcdp 'g_arg)

     RETURNS: t iff g_arg is a data object of type binary.

     NOTE: This function is a throwback to the  PDP-11  Lisp
           system.   The  name stands for binary code predi-
           cate.











9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-12


(bigp 'g_arg)

     RETURNS: t iff g_arg is a bignum.

(dtpr 'g_arg)

     RETURNS: t iff g_arg is a list cell.

     NOTE: that (dtpr '()) is nil.

(hunkp 'g_arg)

     RETURNS: t iff g_arg is a hunk.

(listp 'g_arg)

     RETURNS: t iff g_arg is a list object or nil.

(stringp 'g_arg)

     RETURNS: t iff g_arg is a string.

(symbolp 'g_arg)

     RETURNS: t iff g_arg is a symbol.

(valuep 'g_arg)

     RETURNS: t iff g_arg is a value cell

(vectorp 'v_vector)

     RETURNS: t iff the argument is a vector.

(vectorip 'v_vector)

     RETURNS: t iff the argument is an immediate-vector.

(type 'g_arg)
(typep 'g_arg)

     RETURNS: a symbol whose pname  describes  the  type  of
              g_arg.









9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-13


(signp s_test 'g_val)

     RETURNS: t iff g_val is a number  and  the  given  test
              s_test on g_val returns true.

     NOTE: The fact that _s_i_g_n_p simply returns nil  if  g_val
           is  not  a  number is probably the most important
           reason that _s_i_g_n_p is used.  The permitted  values
           for  s_test  and what they mean are given in this
           table.

8                         ____________________
                          s_test   tested

8                         ________________________________________
                          l        g_val < 0
                          le       g_val <_ 0
                          e        g_val = 0
                          n        g_val =/ 0
                          ge       g_val >_ 0
                          g        g_val > 0
8                         ____________________
7                        |7|7|7|7|7|7|7|7|







                                            |7|7|7|7|7|7|7|7|










(eq 'g_arg1 'g_arg2)

     RETURNS: t if g_arg1 and g_arg2 are the exact same lisp
              object.

     NOTE: _E_q simply tests if g_arg1 and g_arg2 are  located
           in  the exact same place in memory.  Lisp objects
           which print the same are not necessarily _e_q.  The
           only  objects  guaranteed  to  be _e_q are interned
           symbols with the same print name.  [Unless a sym-
           bol  is  created  in  a special way (such as with
           _u_c_o_n_c_a_t or _m_a_k_n_a_m) it will be interned.]

(neq 'g_x 'g_y)

     RETURNS: t if g_x is not _e_q to g_y, otherwise nil.

(equal 'g_arg1 'g_arg2)
(eqstr 'g_arg1 'g_arg2)

     RETURNS: t iff g_arg1 and g_arg2 have the  same  struc-
              ture as described below.

     NOTE: g_arg and g_arg2 are _e_q_u_a_l if

     (1)  they are _e_q.

     (2)  they are both fixnums with the same value




9                                   Printed: January 31, 1984







Data Structure Access                                   2-14


     (3)  they are both flonums with the same value

     (4)  they are both bignums with the same value

     (5)  they are both strings and are identical.

     (6)  they are both lists and their cars  and  cdrs  are
          _e_q_u_a_l.


    ____________________________________________________

    ; _e_q is much faster than _e_q_u_a_l, especially in compiled code,
    ; however you cannot use _e_q to test for equality of numbers outside
    ; of the range -1024 to 1023.  _e_q_u_a_l will always work.
    -> (_e_q _1_0_2_3 _1_0_2_3)
    t
    -> (_e_q _1_0_2_4 _1_0_2_4)
    nil
    -> (_e_q_u_a_l _1_0_2_4 _1_0_2_4)
    t
    ____________________________________________________





(not 'g_arg)
(null 'g_arg)

     RETURNS: t iff g_arg is nil.


(member 'g_arg1 'l_arg2)
(memq 'g_arg1 'l_arg2)

     RETURNS: that part of the  l_arg2  beginning  with  the
              first  occurrence of g_arg1.  If g_arg1 is not
              in the top level of l_arg2, nil is returned.

     NOTE: _m_e_m_b_e_r tests for equality with _e_q_u_a_l, _m_e_m_q  tests
           for equality with _e_q.




   2.3.  Symbols and Strings

           In many of the following functions  the  distinc-
      tion  between symbols and strings is somewhat blurred.
      To remind ourselves of the difference, a string  is  a
      null terminated sequence of characters, stored as com-
      pactly as possible.  Strings are used as constants  in


                                   Printed: January 31, 1984







Data Structure Access                                   2-15


      FRANZ  LISP.   They  _e_v_a_l to themselves.  A symbol has
      additional structure: a value, property list, function
      binding,  as  well  as its external representation (or
      print-name).  If a symbol  is  given  to  one  of  the
      string  manipulation  functions  below, its print name
      will be used as the string.

           Another popular way to represent strings in  Lisp
      is  as  a  list of fixnums which represent characters.
      The suffix 'n' to a string manipulation function indi-
      cates that it returns a string in this form.



      2.3.1.  symbol and string creation

(concat ['stn_arg1 ... ])
(uconcat ['stn_arg1 ... ])

     RETURNS: a symbol whose print name  is  the  result  of
              concatenating  the print names, string charac-
              ters  or  numerical  representations  of   the
              sn_arg_i.

     NOTE: If no arguments are given, a symbol with  a  null
           pname  is  returned.   _c_o_n_c_a_t  places  the symbol
           created on the oblist, the function _u_c_o_n_c_a_t  does
           the  same thing but does not place the new symbol
           on the oblist.

     EXAMPLE: (_c_o_n_c_a_t '_a_b_c (_a_d_d _3 _4) "_d_e_f") = abc7def

(concatl 'l_arg)

     EQUIVALENT TO: (_a_p_p_l_y '_c_o_n_c_a_t '_l__a_r_g)


(implode 'l_arg)
(maknam 'l_arg)

     WHERE:   l_arg is a list of symbols, strings and  small
              fixnums.

     RETURNS: The symbol whose print name is the  result  of
              concatenating  the  first  characters  of  the
              print names of the symbols and strings in  the
              list.    Any  fixnums  are  converted  to  the
              equivalent ascii character.  In order to  con-
              catenate  entire  strings  or print names, use
              the function _c_o_n_c_a_t.

     NOTE: _i_m_p_l_o_d_e interns the  symbol  it  creates,  _m_a_k_n_a_m
           does not.


                                   Printed: January 31, 1984







Data Structure Access                                   2-16


(gensym ['s_leader])

     RETURNS: a new uninterned atom beginning with the first
              character  of  s_leader's  pname, or beginning
              with g if s_leader is not given.

     NOTE: The  symbol  looks  like  x0nnnnn  where   x   is
           s_leader's  first  character  and  nnnnn  is  the
           number of times you have called gensym.

(copysymbol 's_arg 'g_pred)

     RETURNS: an uninterned symbol with the same print  name
              as  s_arg.   If  g_pred  is  non nil, then the
              value, function binding and property  list  of
              the new symbol are made _e_q to those of s_arg.


(ascii 'x_charnum)

     WHERE:   x_charnum is between 0 and 255.

     RETURNS: a symbol whose print name is the single  char-
              acter    whose    fixnum   representation   is
              x_charnum.


(intern 's_arg)

     RETURNS: s_arg

     SIDE EFFECT: s_arg is put on the oblist if  it  is  not
                  already there.

(remob 's_symbol)

     RETURNS: s_symbol

     SIDE EFFECT: s_symbol is removed from the oblist.

(rematom 's_arg)

     RETURNS: t if s_arg is indeed an atom.

     SIDE EFFECT: s_arg is  put  on  the  free  atoms  list,
                  effectively reclaiming an atom cell.

     NOTE: This function does _n_o_t check to see if  s_arg  is
           on  the  oblist  or is referenced anywhere.  Thus
           calling _r_e_m_a_t_o_m on an  atom  in  the  oblist  may
           result in disaster when that atom cell is reused!

9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-17


      2.3.2.  string and symbol predicates

(boundp 's_name)

     RETURNS: nil  if s_name is unbound:  that  is,  it  has
              never  been  given a value.  If x_name has the
              value g_val, then (nil . g_val)  is  returned.
              See also _m_a_k_u_n_b_o_u_n_d.

(alphalessp 'st_arg1 'st_arg2)

     RETURNS: t iff the `name' of st_arg1 is  alphabetically
              less  than the name of st_arg2. If st_arg is a
              symbol then its `name' is its print name.   If
              st_arg  is  a  string,  then its `name' is the
              string itself.



      2.3.3.  symbol and string accessing

(symeval 's_arg)

     RETURNS: the value of symbol s_arg.

     NOTE: It is illegal to ask for the value of an  unbound
           symbol.   This  function  has  the same effect as
           _e_v_a_l, but compiles into much more efficient code.

(get_pname 's_arg)

     RETURNS: the string which is the print name of s_arg.

(plist 's_arg)

     RETURNS: the property list of s_arg.

(getd 's_arg)

     RETURNS: the function definition of  s_arg  or  nil  if
              there is no function definition.

     NOTE: the function definition may turn  out  to  be  an
           array header.








9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-18


(getchar 's_arg 'x_index)
(nthchar 's_arg 'x_index)
(getcharn 's_arg 'x_index)

     RETURNS: the x_index_t_h character of the print  name  of
              s_arg  or  nil  if  x_index  is less than 1 or
              greater than the length of s_arg's print name.

     NOTE: _g_e_t_c_h_a_r and _n_t_h_c_h_a_r return a symbol with a single
           character print name, _g_e_t_c_h_a_r_n returns the fixnum
           representation of the character.

(substring 'st_string 'x_index ['x_length])
(substringn 'st_string 'x_index ['x_length])

     RETURNS: a string of length at most  x_length  starting
              at x_index_t_h character in the string.

     NOTE: If x_length is not given, all of  the  characters
           for   x_index  to  the  end  of  the  string  are
           returned.  If  x_index  is  negative  the  string
           begins  at  the x_index_t_h character from the end.
           If x_index is out of bounds, nil is returned.

     NOTE: _s_u_b_s_t_r_i_n_g returns a list of  symbols,  _s_u_b_s_t_r_i_n_g_n
           returns  a  list  of  fixnums.   If _s_u_b_s_t_r_i_n_g_n is
           given a 0 x_length argument then a single  fixnum
           which is the x_index_t_h character is returned.



      2.3.4.  symbol and string manipulation

(set 's_arg1 'g_arg2)

     RETURNS: g_arg2.

     SIDE EFFECT: the value of s_arg1 is set to g_arg2.

(setq s_atm1 'g_val1 [ s_atm2 'g_val2 ... ... ])

     WHERE:   the arguments are  pairs  of  atom  names  and
              expressions.

     RETURNS: the last g_val_i.

     SIDE EFFECT: each s_atm_i  is  set  to  have  the  value
                  g_val_i.

     NOTE: _s_e_t evaluates all of its arguments, _s_e_t_q does not
           evaluate the s_atm_i.

9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-19


(desetq sl_pattern1 'g_exp1 [... ...])

     RETURNS: g_expn

     SIDE EFFECT: This  acts  just  like  _s_e_t_q  if  all  the
                  sl_pattern_i  are  symbols.  If sl_pattern_i
                  is a list then it   is  a  template  which
                  should  have  the same structure as g_exp_i
                  The symbols in sl_pattern are assigned  to
                  the  corresponding  parts  of g_exp.  (See
                  also _s_e_t_f )

     EXAMPLE: (_d_e_s_e_t_q (_a _b (_c . _d)) '(_1 _2 (_3 _4 _5)))
              sets a to 1, b to 2, c to 3, and d to (4 5).


(setplist 's_atm 'l_plist)

     RETURNS: l_plist.

     SIDE EFFECT: the property  list  of  s_atm  is  set  to
                  l_plist.

(makunbound 's_arg)

     RETURNS: s_arg

     SIDE EFFECT: the value of s_arg is made `unbound'.   If
                  the interpreter attempts to evaluate s_arg
                  before it  is  again  given  a  value,  an
                  unbound variable error will occur.

(aexplode 's_arg)
(explode 'g_arg)
(aexplodec 's_arg)
(explodec 'g_arg)
(aexploden 's_arg)
(exploden 'g_arg)

     RETURNS: a list of the characters  used  to  print  out
              s_arg or g_arg.

     NOTE: The functions beginning  with  'a'  are  internal
           functions  which are limited to symbol arguments.
           The functions _a_e_x_p_l_o_d_e and _e_x_p_l_o_d_e return a  list
           of  characters which _p_r_i_n_t would use to print the
           argument. These characters include all  necessary
           escape   characters.    Functions  _a_e_x_p_l_o_d_e_c  and
           _e_x_p_l_o_d_e_c return a list of characters which  _p_a_t_o_m
           would  use  to print the argument (i.e. no escape
           characters).  Functions  _a_e_x_p_l_o_d_e_n  and  _e_x_p_l_o_d_e_n
           are similar to _a_e_x_p_l_o_d_e_c and _e_x_p_l_o_d_e_c except that
           a list of fixnum equivalents  of  characters  are


                                   Printed: January 31, 1984







Data Structure Access                                   2-20


           returned.


    ____________________________________________________

    -> (_s_e_t_q _x '|_q_u_o_t_e _t_h_i_s _\| _o_k?|)
    |quote this \| ok?|
    -> (_e_x_p_l_o_d_e _x)
    (q u o t e |\\| | | t h i s |\\| | | |\\| |\|| |\\| | | o k ?)
    ; note that |\\| just means the single character: backslash.
    ; and |\|| just means the single character: vertical bar
    ; and | | means the single character: space

    -> (_e_x_p_l_o_d_e_c _x)
    (q u o t e | | t h i s | | |\|| | | o k ?)
    -> (_e_x_p_l_o_d_e_n _x)
    (113 117 111 116 101 32 116 104 105 115 32 124 32 111 107 63)
    ____________________________________________________






   2.4.  Vectors

           See Chapter 9 for a discussion of vectors.   They
      are  less efficient that hunks but more efficient than
      arrays.



      2.4.1.  vector creation

(new-vector 'x_size ['g_fill ['g_prop]])

     RETURNS: A vector of length x_size.  Each data entry is
              initialized to g_fill, or to nil, if the argu-
              ment g_fill is not present.  The vector's pro-
              perty is set to g_prop, or to nil, by default.

(new-vectori-byte 'x_size ['g_fill ['g_prop]])
(new-vectori-word 'x_size ['g_fill ['g_prop]])
(new-vectori-long 'x_size ['g_fill ['g_prop]])

     RETURNS: A vectori with x_size  elements  in  it.   The
              actual  memory requirement is two long words +
              x_size*(n  bytes),  where  n  is  1  for  new-
              vector-byte,  2  for new-vector-word, or 4 for
              new-vectori-long.  Each data entry is initial-
              ized  to  g_fill,  or to zero, if the argument
              g_fill is not present.  The vector's  property
              is set to g_prop, or nil, by default.


                                   Printed: January 31, 1984







Data Structure Access                                   2-21


     Vectors may be created by specifying  multiple  initial
     values:

(vector ['g_val0 'g_val1 ...])

     RETURNS: a vector, with as many data elements as  there
              are arguments.  It is quite possible to have a
              vector with no data  elements.   The  vector's
              property will be a null list.

(vectori-byte ['x_val0 'x_val2 ...])
(vectori-word ['x_val0 'x_val2 ...])
(vectori-long ['x_val0 'x_val2 ...])

     RETURNS: a vectori, with as many data elements as there
              are  arguments.  The arguments are required to
              be fixnums.  Only the low order byte  or  word
              is  used  in  the  case  of  vectori-byte  and
              vectori-word.  The vector's property  will  be
              null.



      2.4.2.  vector reference

(vref 'v_vect 'x_index)
(vrefi-byte 'V_vect 'x_bindex)
(vrefi-word 'V_vect 'x_windex)
(vrefi-long 'V_vect 'x_lindex)

     RETURNS: the desired data element from a  vector.   The
              indices  must  be  fixnums.  Indexing is zero-
              based.  The vrefi functions  sign  extend  the
              data.

(vprop 'Vv_vect)

     RETURNS: The Lisp property associated with a vector.

(vget 'Vv_vect 'g_ind)

     RETURNS: The value stored under g_ind if the Lisp  pro-
              perty  associated  with 'Vv_vect is a disembo-
              died property list.








9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-22


(vsize 'Vv_vect)
(vsize-byte 'V_vect)
(vsize-word 'V_vect)

     RETURNS: the number of data  elements  in  the  vector.
              For  immediate-vectors,  the  functions vsize-
              byte and vsize-word return the number of  data
              elements,  if one thinks of the binary data as
              being comprised of bytes or words.



      2.4.3.  vector modfication

(vset 'v_vect 'x_index 'g_val)
(vseti-byte 'V_vect 'x_bindex 'x_val)
(vseti-word 'V_vect 'x_windex 'x_val)
(vseti-long 'V_vect 'x_lindex 'x_val)

     RETURNS: the datum.

     SIDE EFFECT: The indexed element of the vector  is  set
                  to  the value.  As noted above, for vseti-
                  word and vseti-byte,  the  index  is  con-
                  strued  as  the number of the data element
                  within the  vector.   It  is  not  a  byte
                  address.   Also,  for those two functions,
                  the low order byte or  word  of  x_val  is
                  what is stored.

(vsetprop 'Vv_vect 'g_value)

     RETURNS: g_value.  This should be either a symbol or  a
              disembodied  property list whose _c_a_r is a sym-
              bol identifying the type of the vector.

     SIDE EFFECT: the property list of  Vv_vect  is  set  to
                  g_value.

(vputprop 'Vv_vect 'g_value 'g_ind)

     RETURNS: g_value.

     SIDE EFFECT: If the vector property  of  Vv_vect  is  a
                  disembodied  property  list, then vputprop
                  adds the value g_value under the indicator
                  g_ind.  Otherwise, the old vector property
                  is made the first element of the list.




9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-23


   2.5.  Arrays

           See Chapter  9  for  a  complete  description  of
      arrays.  Some of these functions are part of a Maclisp
      array compatibility package representing only one sim-
      ple way of using the array structure of FRANZ LISP.



      2.5.1.  array creation

(marray 'g_data 's_access 'g_aux 'x_length 'x_delta)

     RETURNS: an array type with the fields set up from  the
              above  arguments  in  the  obvious  way  (see
              1.2.10).

(*array 's_name 's_type 'x_dim1 ... 'x_dim_n)
(array s_name s_type x_dim1 ... x_dim_n)

     WHERE:   s_type may be one of t, nil,  fixnum,  flonum,
              fixnum-block and flonum-block.

     RETURNS: an array of type s_type with n  dimensions  of
              extents given by the x_dim_i.

     SIDE EFFECT: If s_name is non nil, the function defini-
                  tion  of s_name is set to the array struc-
                  ture returned.

     NOTE: These  functions  create  a  Maclisp   compatible
           array.  In FRANZ LISP arrays of type t, nil, fix-
           num and flonum are equivalent and the elements of
           these  arrays  can  be  any  type of lisp object.
           Fixnum-block and  flonum-block  arrays  are  res-
           tricted  to  fixnums and flonums respectively and
           are used mainly to communicate with foreign func-
           tions (see 8.5).

     NOTE: *_a_r_r_a_y evaluates its arguments, _a_r_r_a_y does not.



      2.5.2.  array predicate








9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-24


(arrayp 'g_arg)

     RETURNS: t iff g_arg is of type array.



      2.5.3.  array accessors


(getaccess 'a_array)
(getaux 'a_array)
(getdelta 'a_array)
(getdata 'a_array)
(getlength 'a_array)

     RETURNS: the field of the array object a_array given by
              the function name.

(arrayref 'a_name 'x_ind)

     RETURNS: the  x_ind_t_h  element  of  the  array   object
              a_name.  x_ind of zero accesses the first ele-
              ment.

     NOTE: _a_r_r_a_y_r_e_f uses the data, length and  delta  fields
           of a_name to determine which object to return.

(arraycall s_type 'as_array 'x_ind1 ... )

     RETURNS: the element selected by  the indices from  the
              array a_array of type s_type.

     NOTE: If as_array is a symbol then the function binding
           of this symbol should contain an array object.
           s_type is ignored by _a_r_r_a_y_c_a_l_l  but  is  included
           for compatibility with Maclisp.

(arraydims 's_name)

     RETURNS: a list of the type and  bounds  of  the  array
              s_name.











9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-25


(listarray 'sa_array ['x_elements])

     RETURNS: a  list  of  all  of  the  elements  in  array
              sa_array.   If  x_elements is given, then only
              the first x_elements are returned.



    ____________________________________________________

    ; We will create a 3 by 4 array of general lisp objects
    -> (_a_r_r_a_y _e_r_n_i_e _t _3 _4)
    array[12]

    ; the array header is stored in the function definition slot of the
    ; symbol ernie
    -> (_a_r_r_a_y_p (_g_e_t_d '_e_r_n_i_e))
    t
    -> (_a_r_r_a_y_d_i_m_s (_g_e_t_d '_e_r_n_i_e))
    (t 3 4)

    ; store in ernie[2][2] the list (test list)
    -> (_s_t_o_r_e (_e_r_n_i_e _2 _2) '(_t_e_s_t _l_i_s_t))
    (test list)

    ; check to see if it is there
    -> (_e_r_n_i_e _2 _2)
    (test list)

    ; now use the low level function _a_r_r_a_y_r_e_f to find the same element
    ; arrays are 0 based and row-major (the last subscript varies the fastest)
    ; thus element [2][2] is the 10th element , (starting at 0).
    -> (_a_r_r_a_y_r_e_f (_g_e_t_d '_e_r_n_i_e) _1_0)
    (ptr to)(test list)    ; the result is a value cell (thus the (ptr to))
    ____________________________________________________






      2.5.4.  array manipulation










9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-26


(putaccess 'a_array 'su_func)
(putaux 'a_array 'g_aux)
(putdata 'a_array 'g_arg)
(putdelta 'a_array 'x_delta)
(putlength 'a_array 'x_length)

     RETURNS: the second argument to the function.

     SIDE EFFECT: The field of the array object given by the
                  function  name  is  replaced by the second
                  argument to the function.

(store 'l_arexp 'g_val)

     WHERE:   l_arexp is an expression which  references  an
              array element.

     RETURNS: g_val

     SIDE EFFECT: the array location which contains the ele-
                  ment  which  l_arexp references is changed
                  to contain g_val.

(fillarray 's_array 'l_itms)

     RETURNS: s_array

     SIDE EFFECT: the array s_array is filled with  elements
                  from l_itms.  If there are not enough ele-
                  ments in l_itms to fill the entire  array,
                  then the last element of l_itms is used to
                  fill the remaining parts of the array.



   2.6.  Hunks

           Hunks are  vector-like  objects  whose  size  can
      range  from  1 to 128 elements.  Internally, hunks are
      allocated in sizes which are powers of 2.  In order to
      create  hunks  of  a  given size, a hunk with at least
      that many elements is allocated  and  a  distinguished
      symbol   EMPTY   is   placed  in  those  elements  not
      requested.  Most hunk  functions  respect  those  dis-
      tinguished  symbols,  but  there are two (*_m_a_k_h_u_n_k and
      *_r_p_l_a_c_x) which will overwrite the  distinguished  sym-
      bol.





9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-27


      2.6.1.  hunk creation

(hunk 'g_val1 ['g_val2 ... 'g_val_n])

     RETURNS: a hunk of length n whose elements are initial-
              ized to the g_val_i.

     NOTE: the maximum size of a hunk is 128.

     EXAMPLE: (_h_u_n_k _4 '_s_h_a_r_p '_k_e_y_s) = {4 sharp keys}

(makhunk 'xl_arg)

     RETURNS: a hunk of length  xl_arg  initialized  to  all
              nils  if  xl_arg  is a fixnum.  If xl_arg is a
              list,  then  we  return   a   hunk   of   size
              (_l_e_n_g_t_h '_x_l__a_r_g)  initialized  to the elements
              in xl_arg.

     NOTE: (_m_a_k_h_u_n_k '(_a _b _c))     is      equivalent      to
           (_h_u_n_k '_a '_b '_c).

     EXAMPLE: (_m_a_k_h_u_n_k _4) = {_n_i_l _n_i_l _n_i_l _n_i_l}

(*makhunk 'x_arg)

     RETURNS: a hunk of size 2[x_arg] initialized to EMPTY.

     NOTE: This is only to be used by such functions as _h_u_n_k
           and _m_a_k_h_u_n_k which create and initialize hunks for
           users.



      2.6.2.  hunk accessor

(cxr 'x_ind 'h_hunk)

     RETURNS: element x_ind (starting at 0) of hunk h_hunk.

(hunk-to-list 'h_hunk)

     RETURNS: a list consisting of the elements of h_hunk.



      2.6.3.  hunk manipulators





9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-28


(rplacx 'x_ind 'h_hunk 'g_val)
(*rplacx 'x_ind 'h_hunk 'g_val)

     RETURNS: h_hunk

     SIDE EFFECT: Element x_ind (starting at 0) of h_hunk is
                  set to g_val.

     NOTE: _r_p_l_a_c_x will not modify one of  the  distinguished
           (EMPTY) elements whereas *_r_p_l_a_c_x will.

(hunksize 'h_arg)

     RETURNS: the size of the hunk h_arg.

     EXAMPLE: (_h_u_n_k_s_i_z_e (_h_u_n_k _1 _2 _3)) = 3



   2.7.  Bcds

           A bcd object contains a pointer to compiled  code
      and  to  the type of function object the compiled code
      represents.

(getdisc 'y_bcd)
(getentry 'y_bcd)

     RETURNS: the field of the bcd object given by the func-
              tion name.

(putdisc 'y_func 's_discipline)

     RETURNS: s_discipline

     SIDE EFFECT: Sets the discipline  field  of  y_func  to
                  s_discipline.



   2.8.  Structures

           There are three common structures constructed out
      of  list  cells: the assoc list, the property list and
      the tconc list.  The functions below manipulate  these
      structures.



      2.8.1.  assoc list

              An `assoc list' (or alist) is  a  common  lisp
         data structure.  It has the form


                                   Printed: January 31, 1984







Data Structure Access                                   2-29


         ((key1 . value1) (key2 . value2) (key3 . value3) ... (keyn . valuen))

(assoc 'g_arg1 'l_arg2)
(assq 'g_arg1 'l_arg2)

     RETURNS: the first top level element  of  l_arg2  whose
              _c_a_r is _e_q_u_a_l (with _a_s_s_o_c) or _e_q (with _a_s_s_q) to
              g_arg1.

     NOTE: Usually l_arg2 has an _a-_l_i_s_t structure and g_arg1
           acts as key.

(sassoc 'g_arg1 'l_arg2 'sl_func)

     RETURNS: the                 result                  of
              (_c_o_n_d ((_a_s_s_o_c '_g__a_r_g '_l__a_r_g_2) (_a_p_p_l_y '_s_l__f_u_n_c _n_i_l)))

     NOTE: sassoc is written as a macro.

(sassq 'g_arg1 'l_arg2 'sl_func)

     RETURNS: the                 result                  of
              (_c_o_n_d ((_a_s_s_q '_g__a_r_g '_l__a_r_g_2) (_a_p_p_l_y '_s_l__f_u_n_c _n_i_l)))

     NOTE: sassq is written as a macro.



    ____________________________________________________

    ; _a_s_s_o_c or _a_s_s_q is given a key and an assoc list and returns
    ; the key and value item if it exists, they differ only in how they test
    ; for equality of the keys.

    -> (_s_e_t_q _a_l_i_s_t '((_a_l_p_h_a . _a) ( (_c_o_m_p_l_e_x _k_e_y) . _b) (_j_u_n_k . _x)))
    ((alpha . a) ((complex key) . b) (junk . x))

    ; we should use _a_s_s_q when the key is an atom
    -> (_a_s_s_q '_a_l_p_h_a _a_l_i_s_t)
    (alpha . a)

    ; but it may not work when the key is a list
    -> (_a_s_s_q '(_c_o_m_p_l_e_x _k_e_y) _a_l_i_s_t)
    nil

    ; however _a_s_s_o_c will always work
    -> (_a_s_s_o_c '(_c_o_m_p_l_e_x _k_e_y) _a_l_i_s_t)
    ((complex key) . b)
    ____________________________________________________



9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-30


(sublis 'l_alst 'l_exp)

     WHERE:   l_alst is an _a-_l_i_s_t.

     RETURNS: the list l_exp with every occurrence  of  key_i
              replaced by val_i.

     NOTE: new list structure is returned to prevent modifi-
           cation  of l_exp.  When a substitution is made, a
           copy of the value to substitute in is not made.



      2.8.2.  property list

              A property list  consists  of  an  alternating
         sequence  of  keys and values.  Normally a property
         list is stored on a symbol. A list is  a  'disembo-
         died' property list if it contains an odd number of
         elements, the first of which is ignored.

(plist 's_name)

     RETURNS: the property list of s_name.

(setplist 's_atm 'l_plist)

     RETURNS: l_plist.

     SIDE EFFECT: the property  list  of  s_atm  is  set  to
                  l_plist.


(get 'ls_name 'g_ind)

     RETURNS: the value under indicator g_ind  in  ls_name's
              property list if ls_name is a symbol.

     NOTE: If there is no indicator g_ind in ls_name's  pro-
           perty list nil is returned.  If ls_name is a list
           of an odd number of elements then it is a  disem-
           bodied  property list. _g_e_t searches a disembodied
           property list by starting at its _c_d_r, and compar-
           ing every other element with g_ind, using _e_q.








9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-31


(getl 'ls_name 'l_indicators)

     RETURNS: the property list  ls_name  beginning  at  the
              first  indicator which is a member of the list
              l_indicators, or nil if none of the indicators
              in  l_indicators  are  on  ls_name's  property
              list.

     NOTE: If ls_name is a list, then it is assumed to be  a
           disembodied property list.


(putprop 'ls_name 'g_val 'g_ind)
(defprop ls_name g_val g_ind)

     RETURNS: g_val.

     SIDE EFFECT: Adds to the property list of  ls_name  the
                  value g_val under the indicator g_ind.

     NOTE: _p_u_t_p_r_o_p evaluates it arguments, _d_e_f_p_r_o_p does not.
           ls_name  may  be a disembodied property list, see
           _g_e_t.

(remprop 'ls_name 'g_ind)

     RETURNS: the portion of  ls_name's property list begin-
              ning  with  the  property  under the indicator
              g_ind.  If there  is  no  g_ind  indicator  in
              ls_name's plist, nil is returned.

     SIDE EFFECT: the value under indicator g_ind and  g_ind
                  itself  is  removed from the property list
                  of ls_name.

     NOTE: ls_name may be a disembodied property  list,  see
           _g_e_t.















9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-32



    ____________________________________________________

    -> (_p_u_t_p_r_o_p '_x_l_a_t_e '_a '_a_l_p_h_a)
    a
    -> (_p_u_t_p_r_o_p '_x_l_a_t_e '_b '_b_e_t_a)
    b
    -> (_p_l_i_s_t '_x_l_a_t_e)
    (alpha a beta b)
    -> (_g_e_t '_x_l_a_t_e '_a_l_p_h_a)
    a
    ; use of a disembodied property list:
    -> (_g_e_t '(_n_i_l _f_a_t_e_m_a_n _r_j_f _s_k_l_o_w_e_r _k_l_s _f_o_d_e_r_a_r_o _j_k_f) '_s_k_l_o_w_e_r)
    kls
    ____________________________________________________






      2.8.3.  tconc structure

              A tconc structure is a special  type  of  list
         designed to make it easy to add objects to the end.
         It consists of a list cell whose _c_a_r  points  to  a
         list  of the elements added with _t_c_o_n_c or _l_c_o_n_c and
         whose _c_d_r points to the last list cell of the  list
         pointed to by the _c_a_r.

(tconc 'l_ptr 'g_x)

     WHERE:   l_ptr is a tconc structure.

     RETURNS: l_ptr with g_x added to the end.

(lconc 'l_ptr 'l_x)

     WHERE:   l_ptr is a tconc structure.

     RETURNS: l_ptr with the list l_x spliced in at the end.











9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-33



    ____________________________________________________

    ; A _t_c_o_n_c structure can be initialized in two  ways.
    ; nil can be given to _t_c_o_n_c in which case _t_c_o_n_c will generate
    ; a _t_c_o_n_c structure.

    ->(_s_e_t_q _f_o_o (_t_c_o_n_c _n_i_l _1))
    ((1) 1)

    ; Since _t_c_o_n_c destructively adds to
    ; the list, you can now add to foo without using _s_e_t_q again.

    ->(_t_c_o_n_c _f_o_o _2)
    ((1 2) 2)
    ->_f_o_o
    ((1 2) 2)

    ; Another way to create a null  _t_c_o_n_c structure
    ; is to use (_n_c_o_n_s _n_i_l).

    ->(_s_e_t_q _f_o_o (_n_c_o_n_s _n_i_l))
    (nil)
    ->(_t_c_o_n_c _f_o_o _1)
    ((1) 1)

    ; now see what _l_c_o_n_c can do
    -> (_l_c_o_n_c _f_o_o _n_i_l)
    ((1) 1)            ; no change
    -> (_l_c_o_n_c _f_o_o '(_2 _3 _4))
    ((1 2 3 4) 4)
    ____________________________________________________






      2.8.4.  fclosures

              An  fclosure  is  a  functional  object  which
         admits some data manipulations.  They are discussed
         in 8.4.  Internally, they are constructed from vec-
         tors.








9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-34


(fclosure 'l_vars 'g_funobj)

     WHERE:   l_vars is a list of variables, g_funobj is any
              object that can be funcalled (including, fclo-
              sures).

     RETURNS: A vector which is the fclosure.

(fclosure-alist 'v_fclosure)

     RETURNS: An association list representing the variables
              in  the  fclosure.   This is a snapshot of the
              current state of the fclosure.  If  the  bind-
              ings  in  the fclosure are changed, any previ-
              ously  calculated  results  of  _f_c_l_o_s_u_r_e-_a_l_i_s_t
              will not change.

(fclosure-function 'v_fclosure)

     RETURNS: the functional object part of the fclosure.

(fclosurep 'v_fclosure)

     RETURNS: t iff the argument is an fclosure.

(symeval-in-fclosure 'v_fclosure 's_symbol)

     RETURNS: the current binding of a particular symbol  in
              an fclosure.

(set-in-fclosure 'v_fclosure 's_symbol 'g_newvalue)

     RETURNS: g_newvalue.

     SIDE EFFECT: The variable  s_symbol  is  bound  in  the
                  fclosure to g_newvalue.



   2.9.  Random functions

           The following functions don't fall  into  any  of
      the classifications above.









9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-35


(bcdad 's_funcname)

     RETURNS: a fixnum which is the address in memory  where
              the function s_funcname begins.  If s_funcname
              is not a machine coded function (binary)  then
              _b_c_d_a_d returns nil.

(copy 'g_arg)

     RETURNS: A structure _e_q_u_a_l to g_arg but with  new  list
              cells.

(copyint* 'x_arg)

     RETURNS: a fixnum with the same value as x_arg but in a
              freshly allocated cell.

(cpy1 'xvt_arg)

     RETURNS: a new cell of the same type  as  xvt_arg  with
              the same value as xvt_arg.

(getaddress 's_entry1 's_binder1  'st_discipline1  [...  ...
...])

     RETURNS: the binary object which s_binder1's   function
              field is set to.

     NOTE: This looks in the running lisp's symbol table for
           a symbol with the same name as s_entry_i.  It then
           creates a binary object whose entry field  points
           to    s_entry_i    and    whose    discipline   is
           st_discipline_i.  This binary object is stored  in
           the    function    field    of   s_binder_i.    If
           st_discipline_i is nil, then "subroutine" is  used
           by  default.  This is especially useful for _c_f_a_s_l
           users.

(macroexpand 'g_form)

     RETURNS: g_form after all macros in it are expanded.

     NOTE: This function will only  macroexpand  expressions
           which  could  be  evaluated  and it does not know
           about the special nlambdas such as _c_o_n_d  and  _d_o,
           thus it misses many macro expansions.






9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-36


(ptr 'g_arg)

     RETURNS: a value cell initialized to point to g_arg.

(quote g_arg)

     RETURNS: g_arg.

     NOTE: the reader allows you to abbreviate  (quote  foo)
           as 'foo.

(kwote 'g_arg)

     RETURNS:  (_l_i_s_t (_q_u_o_t_e _q_u_o_t_e) _g__a_r_g).

(replace 'g_arg1 'g_arg2)

     WHERE:   g_arg1 and g_arg2 must be  the  same  type  of
              lispval and not symbols or hunks.

     RETURNS: g_arg2.

     SIDE EFFECT: The effect of _r_e_p_l_a_c_e is dependent on  the
                  type  of  the  g_arg_i  although  one  will
                  notice a similarity in  the  effects.   To
                  understand what _r_e_p_l_a_c_e does to fixnum and
                  flonum arguments, you  must  first  under-
                  stand  that  such  numbers  are `boxed' in
                  FRANZ LISP.  What this means  is  that  if
                  the  symbol  x  has a value 32412, then in
                  memory the value  element  of  x's  symbol
                  structure  contains the address of another
                  word of memory (called a box)  with  32412
                  in it.

                  Thus, there are two ways of  changing  the
                  value  of  x:  the  first is to change the
                  value element of x's symbol  structure  to
                  point to a word of memory with a different
                  value.  The second way is  to  change  the
                  value  in  the box which x points to.  The
                  former method is used almost  all  of  the
                  time,  the  latter is used very rarely and
                  has the potential to  cause  great  confu-
                  sion.   The function _r_e_p_l_a_c_e allows you to
                  do the latter, i.e.,  to  actually  change
                  the value in the box.

                  You should watch out for these situations.
                  If  you  do  (_s_e_t_q _y _x), then both x and y
                  will point to the same box.   If  you  now
                  (_r_e_p_l_a_c_e _x _1_2_3_4_5),  then  y will also have
                  the value 12345.  And, in fact, there  may


                                   Printed: January 31, 1984







Data Structure Access                                   2-37


                  be many other pointers to that box.

                  Another problem with replacing fixnums  is
                  that  some  boxes are read-only.  The fix-
                  nums between -1024 and 1023 are stored  in
                  a  read-only  area and attempts to replace
                  them will result  in  an  "Illegal  memory
                  reference"  error  (see the description of
                  _c_o_p_y_i_n_t* for a way around this problem).

                  For the other valid types, the  effect  of
                  _r_e_p_l_a_c_e is easy to understand.  The fields
                  of g_val1's structure are made eq  to  the
                  corresponding  fields  of  g_val2's struc-
                  ture.  For example,  if  x   and   y  have
                  lists   as   values  then  the  effect  of
                  (_r_e_p_l_a_c_e _x _y)    is    the     same     as
                  (_r_p_l_a_c_a _x (_c_a_r _y)) and (_r_p_l_a_c_d _x (_c_d_r _y)).

(scons 'x_arg 'bs_rest)

     WHERE:   bs_rest is a bignum or nil.

     RETURNS: a bignum whose first bigit is x_arg and  whose
              higher order bigits are bs_rest.

(setf g_refexpr 'g_value)

     NOTE: _s_e_t_f is a generalization  of  setq.   Information
           may  be  stored  by  binding variables, replacing
           entries of arrays, and vectors, or being  put  on
           property  lists,  among  others.  Setf will allow
           the user to store data  into  some  location,  by
           mentioning  the  operation  used  to refer to the
           location.  Thus, the first argument may  be  par-
           tially  evaluated,  but only to the extent needed
           to calculate a reference.  _s_e_t_f returns  g_value.
           (Compare to _d_e_s_e_t_q )


    ____________________________________________________

      (setf x 3)        =  (setq x 3)
      (setf (car x) 3)  = (rplaca x 3)
      (setf (get foo 'bar) 3) = (putprop foo 3 'bar)
      (setf (vref vector index) value) = (vset vector index value)
    ____________________________________________________





9

9                                   Printed: January 31, 1984







Data Structure Access                                   2-38


(sort 'l_data 'u_comparefn)

     RETURNS: a list of the elements of  l_data  ordered  by
              the comparison function u_comparefn.

     SIDE EFFECT: the list l_data is  modified  rather  than
                  allocated in new storage.

     NOTE: (_c_o_m_p_a_r_e_f_n '_g__x  '_g__y)  should  return  something
           non-nil  if  g_x can precede g_y in sorted order;
           nil if g_y must precede g_x.  If  u_comparefn  is
           nil, alphabetical order will be used.

(sortcar 'l_list 'u_comparefn)

     RETURNS: a list of the  elements  of  l_list  with  the
              _c_a_r's    ordered    by   the   sort   function
              u_comparefn.

     SIDE EFFECT: the list l_list is  modified  rather  than
                  copied.

     NOTE: Like _s_o_r_t, if u_comparefn  is  nil,  alphabetical
           order will be used.




























9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch3.r  << 'EndOfFile'







                         CHAPTER  3


                    Arithmetic Functions




     This chapter describes FRANZ LISP's functions for doing
arithmetic.  Often the same function is known by many names.
For example, _a_d_d is also _p_l_u_s, and _s_u_m.  This is  caused  by
our  desire  to  be  compatible with other Lisps.  The FRANZ
LISP user should avoid using functions with names such as  +
and * unless their arguments are fixnums.  The Lisp compiler
takes advantage of these implicit declarations.

     An attempt to divide or to generate  a  floating  point
result  outside  of the range of floating point numbers will
cause a floating exception signal from  the  UNIX  operating
system.   The  user  can catch and process this interrupt if
desired (see the description of the _s_i_g_n_a_l function).



   3.1.  Simple Arithmetic Functions

(add ['n_arg1 ...])
(plus ['n_arg1 ...])
(sum ['n_arg1 ...])
(+ ['x_arg1 ...])

     RETURNS: the sum of the arguments. If no arguments  are
              given, 0 is returned.

     NOTE: if the size of the partial sum exceeds the  limit
           of a fixnum, the partial sum will be converted to
           a bignum.  If any of the arguments  are  flonums,
           the  partial  sum  will  be converted to a flonum
           when that argument is processed  and  the  result
           will thus be a flonum.  Currently, if in the pro-
           cess of doing the addition a bignum must be  con-
           verted  into  a  flonum  an  error  message  will
           result.









9

9Arithmetic Functions                                     3-1







Arithmetic Functions                                     3-2


(add1 'n_arg)
(1+ 'x_arg)

     RETURNS: its argument plus 1.

(diff ['n_arg1 ... ])
(difference ['n_arg1 ... ])
(- ['x_arg1 ... ])

     RETURNS: the result of subtracting from n_arg1 all sub-
              sequent  arguments. If no arguments are given,
              0 is returned.

     NOTE: See the description of add for  details  on  data
           type conversions and restrictions.

(sub1 'n_arg)
(1- 'x_arg)

     RETURNS: its argument minus 1.

(minus 'n_arg)

     RETURNS: zero minus n_arg.

(product ['n_arg1 ... ])
(times ['n_arg1 ... ])
(* ['x_arg1 ... ])

     RETURNS: the product  of  all  of  its  arguments.   It
              returns 1 if there are no arguments.

     NOTE: See the  description  of  the  function  _a_d_d  for
           details  and  restrictions  to the automatic data
           type coercion.

(quotient ['n_arg1 ...])
(/ ['x_arg1 ...])

     RETURNS: the result of dividing the first  argument  by
              succeeding ones.

     NOTE: If there are no arguments, 1  is  returned.   See
           the  description  of the function _a_d_d for details
           and restrictions of data type coercion.  A divide
           by zero will cause a floating exception interrupt
           -- see the description of the _s_i_g_n_a_l function.





9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-3


(*quo 'i_x 'i_y)

     RETURNS: the integer part of i_x / i_y.

(Divide 'i_dividend 'i_divisor)

     RETURNS: a list whose car is  the  quotient  and  whose
              cadr  is  the  remainder  of  the  division of
              i_dividend by i_divisor.

     NOTE: this is restricted to integer division.

(Emuldiv 'x_fact1 'x_fact2 'x_addn 'x_divisor)

     RETURNS: a list of the quotient and remainder  of  this
              operation:
              ((x_fact1 * x_fact2) + (sign extended) x_addn) / x_divisor.

     NOTE: this  is  useful for creating a bignum arithmetic
           package in Lisp.



   3.2.  predicates

(numberp 'g_arg)

(numbp 'g_arg)

     RETURNS: t iff g_arg is a  number  (fixnum,  flonum  or
              bignum).

(fixp 'g_arg)

     RETURNS: t iff g_arg is a fixnum or bignum.

(floatp 'g_arg)

     RETURNS: t iff g_arg is a flonum.

(evenp 'x_arg)

     RETURNS: t iff x_arg is even.









9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-4


(oddp 'x_arg)

     RETURNS: t iff x_arg is odd.

(zerop 'g_arg)

     RETURNS: t iff g_arg is a number equal to 0.

(onep 'g_arg)

     RETURNS: t iff g_arg is a number equal to 1.

(plusp 'n_arg)

     RETURNS: t iff n_arg is greater than zero.

(minusp 'g_arg)

     RETURNS: t iff g_arg is a negative number.

(greaterp ['n_arg1 ...])
(> 'fx_arg1 'fx_arg2)
(>& 'x_arg1 'x_arg2)

     RETURNS: t iff the arguments are in a strictly decreas-
              ing order.

     NOTE: In functions _g_r_e_a_t_e_r_p and > the function  _d_i_f_f_e_r_-
           _e_n_c_e  is  used to compare adjacent values. If any
           of the arguments are non-numbers, the error  mes-
           sage will come from the _d_i_f_f_e_r_e_n_c_e function.  The
           arguments to > must  be fixnums or both  flonums.
           The arguments to >& must both be fixnums.

(lessp ['n_arg1 ...])
(< 'fx_arg1 'fx_arg2)
(<& 'x_arg1 'x_arg2)

     RETURNS: t iff the arguments are in a strictly increas-
              ing order.

     NOTE: In functions _l_e_s_s_p and < the function  _d_i_f_f_e_r_e_n_c_e
           is used to compare adjacent values. If any of the
           arguments are non numbers, the error message will
           come from the _d_i_f_f_e_r_e_n_c_e function.  The arguments
           to < may be either fixnums or flonums but must be
           the  same type.  The arguments to <& must be fix-
           nums.




9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-5


(= 'fx_arg1 'fx_arg2)

(=& 'x_arg1 'x_arg2)

     RETURNS: t iff the arguments have the same value.   The
              arguments to = must be the either both fixnums
              or both flonums.  The arguments to =& must  be
              fixnums.



   3.3.  Trignometric Functions

           Some of these funtcions are taken from  the  host
      math  library,  and  we take no further responsibility
      for their accuracy.

(cos 'fx_angle)

     RETURNS: the (flonum)  cosine  of  fx_angle  (which  is
              assumed to be in radians).

(sin 'fx_angle)

     RETURNS: the sine of fx_angle (which is assumed  to  be
              in radians).

(acos 'fx_arg)

     RETURNS: the (flonum) arc cosine of fx_arg in the range
              0 to J.

(asin 'fx_arg)

     RETURNS: the (flonum) arc sine of fx_arg in  the  range
              -J/2 to J/2.

(atan 'fx_arg1 'fx_arg2)

     RETURNS: the (flonum) arc tangent of fx_arg1/fx_arg2 in
              the range -J to J.



   3.4.  Bignum/Fixnum Manipulation







9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-6


(haipart bx_number x_bits)

     RETURNS: a fixnum (or bignum) which contains the x_bits
              high  bits  of  (_a_b_s _b_x__n_u_m_b_e_r)  if  x_bits is
              positive,    otherwise    it    returns    the
              (_a_b_s _x__b_i_t_s) low bits of (_a_b_s _b_x__n_u_m_b_e_r).

(haulong bx_number)

     RETURNS: the number of significant bits in bx_number.

     NOTE: the result is equal to the least integer  greater
           to or equal to the base two logarithm of one plus
           the absolute value of bx_number.

(bignum-leftshift bx_arg x_amount)

     RETURNS: bx_arg shifted left by x_amount.  If  x_amount
              is  negative,  bx_arg will be shifted right by
              the magnitude of x_amount.

     NOTE: If bx_arg is shifted right, it will be rounded to
           the nearest even number.

(sticky-bignum-leftshift 'bx_arg 'x_amount)

     RETURNS: bx_arg shifted left by x_amount.  If  x_amount
              is  negative,  bx_arg will be shifted right by
              the magnitude of x_amount and rounded.

     NOTE: sticky rounding is done this way: after shifting,
           the low order bit is changed to 1 if any 1's were
           shifted off to the right.



   3.5.  Bit Manipulation

(boole 'x_key 'x_v1 'x_v2 ...)

     RETURNS: the result of the bitwise boolean operation as
              described in the following table.

     NOTE: If there are more than 3 arguments, then  evalua-
           tion  proceeds  left  to  right with each partial
           result becoming the new value of x_v1.  That is,
                (_b_o_o_l_e '_k_e_y '_v_1 '_v_2 '_v_3) =_ (_b_o_o_l_e '_k_e_y (_b_o_o_l_e '_k_e_y '_v_1 '_v_2) '_v_3).
           In the following table, * represents bitwise and,
           + represents bitwise or, O+ represents bitwise xor
           and  _  represents  bitwise  negation  and is the
           highest precedence operator.












Arithmetic Functions                                     3-7


8____________________________________________________________________________________________
                                     (boole 'key 'x 'y)

8________________________________________________________________________________________________________________________________________________________________________________________
  key         0          1          2         3         4          5          6         7
 result       0        x * y     _ x * y      y      x * _ y       x        x O+ y     x + y

 common
 names                  and                          bitclear                xor       or

8____________________________________________________________________________________________

  key         8          9         10        11         12        13         14        15
 result   _ (x + y)   _(x O+ y)     _ x     _ x + y     _ y      x + _ y   _ x + _ y    -1
 common
 names       nor       equiv               implies                          nand
8____________________________________________________________________________________________
7|8|7|7|7|7|7|7|7|7|7|7|7|7|7|












9                                                                                           |8|7|7|7|7|7|7|7|7|7|7|7|7|7|














9
(lsh 'x_val 'x_amt)

     RETURNS: x_val shifted left by x_amt if x_amt is  posi-
              tive.   If x_amt is negative, then _l_s_h returns
              x_val shifted right by the magnitude if x_amt.

     NOTE: This always  returns  a  fixnum  even  for  those
           numbers  whose  magnitude  is  so large that they
           would normally be represented as a  bignum,  i.e.
           shifter  bits  are  lost.   For  more general bit
           shifters,  see   _b_i_g_n_u_m-_l_e_f_t_s_h_i_f_t   and   _s_t_i_c_k_y-
           _b_i_g_n_u_m-_l_e_f_t_s_h_i_f_t.

(rot 'x_val 'x_amt)

     RETURNS: x_val rotated left by x_amt if x_amt is  posi-
              tive.  If  x_amt  is  negative,  then x_val is
              rotated right by the magnitude of x_amt.



   3.6.  Other Functions

           As noted above, some of the  following  functions
      are  inherited  from  the  host math library, with all
      their virtues and vices.









9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-8


(abs 'n_arg)
(absval 'n_arg)

     RETURNS: the absolute value of n_arg.

(exp 'fx_arg)

     RETURNS: _e raised to the fx_arg power (flonum) .

(expt 'n_base 'n_power)

     RETURNS: n_base raised to the n_power power.

     NOTE: if either of the arguments are flonums, the  cal-
           culation will be done using _l_o_g and _e_x_p.

(fact 'x_arg)

     RETURNS: x_arg factorial. (fixnum or bignum)

(fix 'n_arg)

     RETURNS: a fixnum as close as we can get to n_arg.

     NOTE: _f_i_x will round down.  Currently, if  n_arg  is  a
           flonum  larger  than  the  size of a fixnum, this
           will fail.

(float 'n_arg)

     RETURNS: a flonum as close as we can get to n_arg.

     NOTE: if n_arg is a bignum larger than the maximum size
           of  a  flonum,  then  a  floating  exception will
           occur.

(log 'fx_arg)

     RETURNS: the natural logarithm of fx_arg.

(max 'n_arg1 ... )

     RETURNS: the maximum value in the list of arguments.









9

9                                   Printed: January 31, 1984







Arithmetic Functions                                     3-9


(min 'n_arg1 ... )

     RETURNS: the minimum value in the list of arguments.

(mod 'i_dividend 'i_divisor)
(remainder 'i_dividend 'i_divisor)

     RETURNS: the remainder when i_dividend  is  divided  by
              i_divisor.

     NOTE: The sign of the result will have the same sign as
           i_dividend.

(*mod 'x_dividend 'x_divisor)

     RETURNS: the  balanced  representation  of   x_dividend
              modulo x_divisor.

     NOTE: the  range  of  the  balanced  representation  is
           abs(x_divisor)/2    to    (abs(x_divisor)/2)    -
           x_divisor + 1.

(random ['x_limit])

     RETURNS: a fixnum between 0 and x_limit - 1 if  x_limit
              is  given.   If x_limit is not given, any fix-
              num, positive or negative, might be returned.

(sqrt 'fx_arg)

     RETURNS: the square root of fx_arg.





















9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch4.r  << 'EndOfFile'



























































9

9










                         CHAPTER  4


                     Special Functions




(and [g_arg1 ...])

     RETURNS: the value of the last argument  if  all  argu-
              ments  evaluate  to a non-nil value, otherwise
              _a_n_d returns nil.  It returns t if there are no
              arguments.

     NOTE: the arguments are evaluated  left  to  right  and
           evaluation  will cease with the first nil encoun-
           tered.

(apply 'u_func 'l_args)

     RETURNS: the result of applying function u_func to  the
              arguments in the list l_args.

     NOTE: If u_func is a lambda, then  the  (_l_e_n_g_t_h _l__a_r_g_s)
           should  equal the number of formal parameters for
           the u_func.  If u_func is  a  nlambda  or  macro,
           then l_args is bound to the single formal parame-
           ter.























9

9Special Functions                                        4-2







Special Functions                                        4-1



    ____________________________________________________

    ; _a_d_d_1 is a lambda of 1 argument
    -> (_a_p_p_l_y '_a_d_d_1 '(_3))
    4

    ; we will define _p_l_u_s_1 as a macro which will be equivalent to _a_d_d_1
    -> (_d_e_f _p_l_u_s_1 (_m_a_c_r_o (_a_r_g) (_l_i_s_t '_a_d_d_1 (_c_a_d_r _a_r_g))))
    plus1
    -> (_p_l_u_s_1 _3)
    4

    ; now if we _a_p_p_l_y a macro we obtain the form it changes to.
    -> (_a_p_p_l_y '_p_l_u_s_1 '(_p_l_u_s_1 _3))
    (add1 3)

    ; if we _f_u_n_c_a_l_l a macro however, the result of the macro is _e_v_a_led
    ; before it is returned.
    -> (_f_u_n_c_a_l_l '_p_l_u_s_1 '(_p_l_u_s_1 _3))
    4

    ; for this particular macro, the _c_a_r of the _a_r_g is not checked
    ; so that this too will work
    -> (_a_p_p_l_y '_p_l_u_s_1 '(_f_o_o _3))
    (add1 3)

    ____________________________________________________




(arg ['x_numb])

     RETURNS: if x_numb  is  specified  then  the  x_numb'_t_h
              argument  to  the enclosing lexpr If x_numb is
              not specified then this returns the number  of
              arguments to the enclosing lexpr.

     NOTE: it is an error to the interpreter  if  x_numb  is
           given and out of range.











9

9                                   Printed: January 31, 1984







Special Functions                                        4-2


(break [g_message ['g_pred]])

     WHERE:   if g_message is not given it is assumed to  be
              the null string, and if g_pred is not given it
              is assumed to be t.

     RETURNS: the value of (*_b_r_e_a_k '_g__p_r_e_d '_g__m_e_s_s_a_g_e)

(*break 'g_pred 'g_message)

     RETURNS: nil immediately if g_pred  is  nil,  else  the
              value  of  the next (return 'value) expression
              typed in at top level.

     SIDE EFFECT: If the  predicate,  g_pred,  evaluates  to
                  non-null, the lisp system stops and prints
                  out `Break '  followed  by  g_message.  It
                  then  enters a break loop which allows one
                  to interactively debug a program.  To con-
                  tinue  execution  from a break you can use
                  the _r_e_t_u_r_n  function.  to  return  to  top
                  level  or another break level, you can use
                  _r_e_t_b_r_k or _r_e_s_e_t.

(caseq 'g_key-form l_clause1 ...)

     WHERE:   l_clause_i is a list of the form  (g_comparator
              ['g_form_i  ...]).  The comparators may be sym-
              bols, small fixnums, a list of  small  fixnums
              or symbols.

     NOTE: The way caseq works is that it  evaluates  g_key-
           form, yielding a value we will call the selector.
           Each clause is examined  until  the  selector  is
           found consistent with the comparator.  For a sym-
           bol, or a fixnum, this means the two must be  _e_q.
           For  a list, this means that the selector must be
           _e_q to some element of the list.

           The comparator consisting of  the  symbol  t  has
           special  semantics: it matches anything, and con-
           sequently, should be the last comparator.

           In any case, having chosen a clause, _c_a_s_e_q evalu-
           ates each form within that clause and

     RETURNS: the value of the last form.  If no comparators
              are matched, _c_a_s_e_q returns nil.




9

9                                   Printed: January 31, 1984







Special Functions                                        4-3



    ____________________________________________________

    Here are two ways of defining the same function:
    ->(_d_e_f_u_n _f_a_t_e (_p_e_r_s_o_n_n_a)
            (_c_a_s_e_q _p_e_r_s_o_n_n_a
              (_c_o_w '(_j_u_m_p_e_d _o_v_e_r _t_h_e _m_o_o_n))
              (_c_a_t '(_p_l_a_y_e_d _n_e_r_o))
              ((_d_i_s_h _s_p_o_o_n) '(_r_a_n _a_w_a_y _w_i_t_h _e_a_c_h _o_t_h_e_r))
              (_t '(_l_i_v_e_d _h_a_p_p_i_l_y _e_v_e_r _a_f_t_e_r))))
    fate
    ->(_d_e_f_u_n _f_a_t_e (_p_e_r_s_o_n_n_a)
            (_c_o_n_d
                    ((_e_q _p_e_r_s_o_n_n_a '_c_o_w) '(_j_u_m_p_e_d _o_v_e_r _t_h_e _m_o_o_n))
                    ((_e_q _p_e_r_s_o_n_n_a '_c_a_t) '(_p_l_a_y_e_d _n_e_r_o))
                    ((_m_e_m_q _p_e_r_s_o_n_n_a '(_d_i_s_h _s_p_o_o_n)) '(_r_a_n _a_w_a_y _w_i_t_h _e_a_c_h _o_t_h_e_r))
                    (_t '(_l_i_v_e_d _h_a_p_p_i_l_y _e_v_e_r _a_f_t_e_r))))
    fate
    ____________________________________________________




(catch g_exp [ls_tag])

     WHERE:   if ls_tag is not given, it is  assumed  to  be
              nil.

     RETURNS: the result of (*_c_a_t_c_h '_l_s__t_a_g _g__e_x_p)

     NOTE: catch is defined as a macro.

(*catch 'ls_tag g_exp)

     WHERE:   ls_tag is either a symbol or a  list  of  sym-
              bols.

     RETURNS: the result of evaluating g_exp  or  the  value
              thrown during the evaluation of g_exp.

     SIDE EFFECT: this first sets up a `catch frame' on  the
                  lisp  runtime  stack.   Then  it begins to
                  evaluate g_exp.  If g_exp  evaluates  nor-
                  mally,  its  value  is returned.  If, how-
                  ever, a value is thrown during the evalua-
                  tion of g_exp then this *catch will return
                  with that value if one of these  cases  is
                  true:

     (1)  the tag thrown to is ls_tag

     (2)  ls_tag is a list and the tag thrown to is a member
          of this list


                                   Printed: January 31, 1984







Special Functions                                        4-4


     (3)  ls_tag is nil.

     NOTE: Errors are  implemented  as  a  special  kind  of
           throw.   A  catch  with  no tag will not catch an
           error but a catch whose tag  is  the  error  type
           will  catch  that  type of error.  See Chapter 10
           for more information.

(comment [g_arg ...])

     RETURNS: the symbol comment.

     NOTE: This does absolutely nothing.

(cond [l_clause1 ...])

     RETURNS: the last value evaluated in the  first  clause
              satisfied.   If  no clauses are satisfied then
              nil is returned.

     NOTE: This is  the  basic  conditional  `statement'  in
           lisp.   The  clauses  are  processed from left to
           right.   The  first  element  of  a   clause   is
           evaluated.   If  it evaluated to a non-null value
           then that clause is satisfied and  all  following
           elements  of that clause are evaluated.  The last
           value computed is returned as the  value  of  the
           cond.  If there is just one element in the clause
           then its value is returned.  If the first element
           of a clause evaluates to nil, then the other ele-
           ments of that clause are not  evaluated  and  the
           system moves to the next clause.

(cvttointlisp)

     SIDE EFFECT: The reader is modified to conform with the
                  Interlisp syntax.  The character % is made
                  the escape character and special  meanings
                  for  comma,  backquote  and  backslash are
                  removed. Also the reader is told  to  con-
                  vert upper case to lower case.











9

9                                   Printed: January 31, 1984







Special Functions                                        4-5


(cvttofranzlisp)

     SIDE EFFECT: FRANZ LISP's default syntax is reinstated.
                  One  would  run this function after having
                  run any of  the  other  _c_v_t_t_o-  functions.
                  Backslash  is  made  the escape character,
                  super-brackets work again, and the  reader
                  distinguishes   between  upper  and  lower
                  case.

(cvttomaclisp)

     SIDE EFFECT: The reader is  modified  to  conform  with
                  Maclisp  syntax.   The character / is made
                  the escape character and the special mean-
                  ings for backslash, left and right bracket
                  are removed.  The  reader  is  made  case-
                  insensitive.

(cvttoucilisp)

     SIDE EFFECT: The reader is modified to conform with UCI
                  Lisp  syntax.  The character / is made the
                  escape character, tilde is made  the  com-
                  ment character, exclamation point takes on
                  the  unquote  function  normally  held  by
                  comma,  and  backslash,  comma,  semicolon
                  become normal characters.  Here  too,  the
                  reader is made case-insensitive.

(debug s_msg)

     SIDE EFFECT: Enter  the  Fixit  package  described   in
                  Chapter  15.   This  package allows you to
                  examine the evaluation  stack  in  detail.
                  To  leave the Fixit package type 'ok'.

(debugging 'g_arg)

     SIDE EFFECT: If g_arg is non-null,  Franz  unlinks  the
                  transfer  tables, does a (*_r_s_e_t _t) to turn
                  on  evaluation  monitoring  and  sets  the
                  all-error  catcher  (ER%all)  to be _d_e_b_u_g-
                  _e_r_r-_h_a_n_d_l_e_r.  If g_arg is nil, all of  the
                  above changes are undone.







9

9                                   Printed: January 31, 1984







Special Functions                                        4-6


(declare [g_arg ...])

     RETURNS: nil

     NOTE: this is a no-op to the evaluator.  It has special
           meaning to the compiler (see Chapter 12).

(def s_name (s_type l_argl g_exp1 ...))

     WHERE:   s_type is one of  lambda,  nlambda,  macro  or
              lexpr.

     RETURNS: s_name

     SIDE EFFECT: This defines the function  s_name  to  the
                  lisp  system.   If  s_type  is  nlambda or
                  macro then the argument list  l_argl  must
                  contain exactly one non-nil symbol.

(defmacro s_name l_arg g_exp1 ...)
(defcmacro s_name l_arg g_exp1 ...)

     RETURNS: s_name

     SIDE EFFECT: This defines the  macro  s_name.  _d_e_f_m_a_c_r_o
                  makes  it  easy  to  write macros since it
                  makes the syntax just like _d_e_f_u_n.  Further
                  information   on  _d_e_f_m_a_c_r_o  is  in  8.3.2.
                  _d_e_f_c_m_a_c_r_o defines compiler-only macros, or
                  cmacros.  A  cmacro  is stored on the pro-
                  perty list of a symbol under the indicator
                  cmacro.  Thus a function can have a normal
                  definition and a cmacro  definition.   For
                  an  example of the use of cmacros, see the
                  definitions   of   nthcdr   and   nth   in
                  /usr/lib/lisp/common2.l

(defun s_name [s_mtype] ls_argl g_exp1 ... )

     WHERE:   s_mtype is one of fexpr, expr, args or macro.

     RETURNS: s_name

     SIDE EFFECT: This defines the function s_name.

     NOTE: this exists for Maclisp compatibility, it is just
           a  macro  which changes the defun form to the def
           form.   An  s_mtype  of  fexpr  is  converted  to
           nlambda  and of expr to lambda. Macro remains the
           same.  If ls_arg1 is a non-nil symbol,  then  the
           type  is  assumed  to be lexpr and ls_arg1 is the
           symbol which is bound to the number of args  when
           the function is entered.


                                   Printed: January 31, 1984







Special Functions                                        4-7


           For compatibility with  the  Lisp  Machine  Lisp,
           there are three types of optional parameters that
           can occur in ls_argl:   &_o_p_t_i_o_n_a_l  declares  that
           the  following  symbols  are optional, and may or
           may not appear in the argument list to the  func-
           tion, &_r_e_s_t _s_y_m_b_o_l declares that all forms in the
           function call that are not accounted for by  pre-
           vious  lambda bindings are to be assigned to _s_y_m_-
           _b_o_l, and &_a_u_x _f_o_r_m_1 ... _f_o_r_m_n declares  that  the
           _f_o_r_m_i  are either symbols, in which case they are
           lambda bound to nil, or lists, in which case  the
           first  element of the list is lambda bound to the
           second, evaluated element.


    ____________________________________________________

    ; _d_e_f and _d_e_f_u_n here are used to define identical functions
    ; you can decide for yourself which is easier to use.
    -> (_d_e_f _a_p_p_e_n_d_1 (_l_a_m_b_d_a (_l_i_s _e_x_t_r_a) (_a_p_p_e_n_d _l_i_s (_l_i_s_t _e_x_t_r_a))))
    append1

    -> (_d_e_f_u_n _a_p_p_e_n_d_1 (_l_i_s _e_x_t_r_a) (_a_p_p_e_n_d _l_i_s (_l_i_s_t _e_x_t_r_a)))
    append1

    ; Using the & forms...
    -> (_d_e_f_u_n _t_e_s_t (_a _b &_o_p_t_i_o_n_a_l _c &_a_u_x (_r_e_t_v_a_l _0) &_r_e_s_t _z)
            (_i_f _c _t_h_e_m (_m_s_g "_O_p_t_i_o_n_a_l _a_r_g _p_r_e_s_e_n_t" _N
                            "_c _i_s " _c _N))
            (_m_s_g "_r_e_s_t _i_s " _z _N
                 "_r_e_t_v_a_l _i_s " _r_e_t_v_a_l _N))
    test
    -> (_t_e_s_t _1 _2 _3 _4)
    Optional arg present
    c is 3
    rest is (4)
    retval is 0
    ____________________________________________________














9

9                                   Printed: January 31, 1984







Special Functions                                        4-8


(defvar s_variable ['g_init])

     RETURNS: s_variable.

     NOTE: This form is put at the top level in files,  like
           _d_e_f_u_n.

     SIDE EFFECT: This declares s_variable to be special. If
                  g_init   is   present  and  s_variable  is
                  unbound  when  the  file   is   read   in,
                  s_variable  will  be  set  to the value of
                  g_init.  An advantage  of  `(defvar  foo)'
                  over  `(declare (special foo))' is that if
                  a file containing defvars  is  loaded  (or
                  fasl'ed)  in during compilation, the vari-
                  ables mentioned in the  defvar's  will  be
                  declared  special.   The  only way to have
                  that effect with `(declare (special foo))'
                  is to _i_n_c_l_u_d_e the file.

(do l_vrbs l_test g_exp1 ...)

     RETURNS: the last form in the cdr of l_test  evaluated,
              or  a  value  explicitly  given  by  a  return
              evaluated within the do body.

     NOTE: This is the basic iteration form for FRANZ  LISP.
           l_vrbs  is a list of zero or more var-init-repeat
           forms.  A var-init-repeat form looks like:
                (s_name [g_init [g_repeat]])
           There  are  three  cases  depending  on  what  is
           present  in the form.  If just s_name is present,
           this means that when the do is entered, s_name is
           lambda-bound  to nil and is never modified by the
           system (though the program is certainly  free  to
           modify    its    value).     If   the   form   is
           (s_name 'g_init) then the only difference is that
           s_name  is  lambda-bound  to  the value of g_init
           instead of nil.  If g_repeat is also present then
           s_name is lambda-bound to g_init when the loop is
           entered and after each pass through the  do  body
           s_name is  bound to the value of g_repeat.
           l_test is either nil or has the form  of  a  cond
           clause.   If  it  is nil then the do body will be
           evaluated only once and the do will  return  nil.
           Otherwise,  before  the  do body is evaluated the
           car of l_test is evaluated and if the  result  is
           non-null,  this  signals  an  end to the looping.
           Then  the  rest  of  the  forms  in  l_test   are
           evaluated  and  the  value  of  the  last  one is
           returned as the value of the do.  If the  cdr  of
           l_test  is nil, then nil is returned -- thus this
           is not exactly like a cond clause.


                                   Printed: January 31, 1984







Special Functions                                        4-9


           g_exp1 and those forms  which  follow  constitute
           the  do  body.  A do body is like a prog body and
           thus may have labels and one may  use  the  func-
           tions go and return.
           The sequence of evaluations is this:

     (1)  the init forms are evaluated  left  to  right  and
          stored in temporary locations.

     (2)  Simultaneously all do variables are  lambda  bound
          to the value of their init forms or nil.

     (3)  If l_test is non-null, then the car  is  evaluated
          and  if  it  is non-null, the rest of the forms in
          l_test  are  evaluated  and  the  last  value   is
          returned as the value of the do.

     (4)  The forms in the do body  are  evaluated  left  to
          right.

     (5)  If l_test is nil the do function returns with  the
          value nil.

     (6)  The repeat forms are evaluated and saved  in  tem-
          porary locations.

     (7)  The variables with repeat forms are simultaneously
          bound to the values of those forms.

     (8)  Go to step 3.

     NOTE: there is an alternate form of  do  which  can  be
           used  when  there is only one do variable.  It is
           described next.


















9

9                                   Printed: January 31, 1984







Special Functions                                       4-10



    ____________________________________________________

    ; this is  a simple function which numbers the elements of a list.
    ; It uses a _d_o function with two local variables.
    -> (_d_e_f_u_n _p_r_i_n_t_e_m (_l_i_s)
                 (_d_o ((_x_x _l_i_s (_c_d_r _x_x))
                      (_i _1 (_1+ _i)))
                     ((_n_u_l_l _x_x) (_p_a_t_o_m "_a_l_l _d_o_n_e") (_t_e_r_p_r))
                     (_p_r_i_n_t _i)
                     (_p_a_t_o_m ": ")
                     (_p_r_i_n_t (_c_a_r _x_x))
                     (_t_e_r_p_r)))
    printem
    -> (_p_r_i_n_t_e_m '(_a _b _c _d))
    1: a
    2: b
    3: c
    4: d
    all done
    nil
    ->
    ____________________________________________________




(do s_name g_init g_repeat g_test g_exp1 ...)

     NOTE: this is another, less general,  form of  do.   It
           is evaluated by:

     (1)  evaluating g_init

     (2)  lambda binding s_name to value of g_init

     (3)  g_test is evaluated and if it is not  nil  the  do
          function returns with nil.

     (4)  the do body is evaluated beginning at g_exp1.

     (5)  the repeat form is evaluated and stored in s_name.

     (6)  go to step 3.

     RETURNS: nil






9

9                                   Printed: January 31, 1984







Special Functions                                       4-11


(environment [l_when1 l_what1 l_when2 l_what2 ...])
(environment-maclisp [l_when1 l_what1 l_when2 l_what2 ...])
(environment-lmlisp [l_when1 l_what1 l_when2 l_what2 ...])

     WHERE:   the when's  are  a  subset  of  (eval  compile
              load),  and  the symbols have the same meaning
              as they do in 'eval-when'.

              The what's may be
                      (files file1 file2 ... fileN),
              which insure that the named files are  loaded.
              To  see  if  file_i  is  loaded, it looks for a
              'version'  property  under  file_i's   property
              list.   Thus  to prevent multiple loading, you
              should put
                      (putprop 'myfile t 'version),
              at the end of myfile.l.

              Another acceptable form for a what is
              (syntax type)
              Where type is either maclisp,  intlisp,  ucil-
              isp, franzlisp.

     SIDE EFFECT: _e_n_v_i_r_o_n_m_e_n_t-_m_a_c_l_i_s_p sets  the  environment
                  to that which `liszt -m' would generate.

                  _e_n_v_i_r_o_n_m_e_n_t-_l_m_l_i_s_p   sets  up   the   lisp
                  machine  environment. This is like maclisp
                  but it has additional macros.

                  For these specialized  environments,  only
                  the     files    clauses    are    useful.
                          (environment-maclisp      (compile
                  eval) (files foo bar))

     RETURNS: the last list of files requested.

(err ['s_value [nil]])

     RETURNS: nothing (it never returns).

     SIDE EFFECT: This causes an error and if this error  is
                  caught  by an _e_r_r_s_e_t then that _e_r_r_s_e_t will
                  return s_value instead  of  nil.   If  the
                  second  arg  is given, then it must be nil
                  (MAClisp compatibility).






9

9                                   Printed: January 31, 1984







Special Functions                                       4-12


(error ['s_message1 ['s_message2]])

     RETURNS: nothing (it never returns).

     SIDE EFFECT: s_message1 and s_message2 are  _p_a_t_o_med  if
                  they  are  given  and  then  _e_r_r is called
                  (with  no  arguments),  which  causes   an
                  error.

(errset g_expr [s_flag])

     RETURNS: a list of one  element,  which  is  the  value
              resulting from evaluating g_expr.  If an error
              occurs during the evaluation of  g_expr,  then
              the locus of control will return to the _e_r_r_s_e_t
              which will then return nil (unless  the  error
              was  caused  by a call to _e_r_r, with a non-null
              argument).

     SIDE EFFECT: S_flag  is  evaluated  before  g_expr   is
                  evaluated. If s_flag is not given, then it
                  is assumed to be t.  If  an  error  occurs
                  during   the  evaluation  of  g_expr,  and
                  s_flag evaluated to a non-null value, then
                  the  error  message  associated  with  the
                  error is printed before control returns to
                  the errset.

(eval 'g_val ['x_bind-pointer])

     RETURNS: the result of evaluating g_val.

     NOTE: The evaluator evaluates g_val in this way:
           If g_val is a symbol, then the evaluator  returns
           its  value.   If  g_val had never been assigned a
           value, then this  causes  an  `Unbound  Variable'
           error.   If  x_bind-pointer  is  given,  then the
           variable  is  evaluated  with  respect  to   that
           pointer  (see  _e_v_a_l_f_r_a_m_e  for  details  on  bind-
           pointers).

           If g_val is of type  value,  then  its  value  is
           returned.   If  g_val  is  of any other type than
           list, g_val is returned.

           If g_val is a list object then g_val is either  a
           function  call  or array reference.  Let g_car be
           the  first  element  of  g_val.   We  continually
           evaluate g_car until we end up with a symbol with
           a non-null  function  binding  or  a  non-symbol.
           Call what we end up with: g_func.

           G_func must be one of three types:  list,  binary


                                   Printed: January 31, 1984







Special Functions                                       4-13


           or array.  If it is a list then the first element
           of the list, which we shall call g_functype, must
           be  either  lambda,  nlambda, macro or lexpr.  If
           g_func is a binary, then its discipline, which we
           shall call g_functype, is either lambda, nlambda,
           macro or a string.  If g_func is  an  array  then
           this  form  is evaluated specially, see Chapter 9
           on arrays.  If g_func is a list or  binary,  then
           g_functype  will  determine  how the arguments to
           this function, the cdr of g_val,  are  processed.
           If g_functype is a string, then this is a foreign
           function call (see 8.5 for more details).

           If g_functype is lambda or lexpr,  the  arguments
           are  evaluated  (by calling _e_v_a_l recursively) and
           stacked.  If g_functype is nlambda then the argu-
           ment  list  is  stacked.   If g_functype is macro
           then the entire form, g_val is stacked.

           Next, the formal variables are lambda bound.  The
           formal  variables  are  the  cadr  of g_func.  If
           g_functype is  nlambda,  lexpr  or  macro,  there
           should  only  be one formal variable.  The values
           on the stack are lambda bound to the formal vari-
           ables  except  in  the case of a lexpr, where the
           number of actual arguments is bound to the formal
           variable.

           After  the  binding  is  done,  the  function  is
           invoked,  either by jumping to the entry point in
           the case of a binary or by evaluating the list of
           forms  beginning  at  cddr g_func.  The result of
           this function invocation is returned as the value
           of the call to eval.

(evalframe 'x_pdlpointer)

     RETURNS: an evalframe  descriptor  for  the  evaluation
              frame    just    before    x_pdlpointer.    If
              x_pdlpointer is nil, it returns the evaluation
              frame  of  the  frame  just before the current
              call to _e_v_a_l_f_r_a_m_e.

     NOTE: An evalframe descriptor describes a call to _e_v_a_l,
           _a_p_p_l_y or _f_u_n_c_a_l_l.  The form of the descriptor is
           (_t_y_p_e  _p_d_l-_p_o_i_n_t_e_r  _e_x_p_r_e_s_s_i_o_n  _b_i_n_d-_p_o_i_n_t_e_r  _n_p-
           _i_n_d_e_x _l_b_o_t-_i_n_d_e_x)
           where type is `eval' if this describes a call  to
           _e_v_a_l  or  `apply'  if  this is a call to _a_p_p_l_y or
           _f_u_n_c_a_l_l.    pdl-pointer   is   a   number   which
           describes this context. It can be passed to _e_v_a_l_-
           _f_r_a_m_e to obtain the next descriptor  and  can  be
           passed  to  _f_r_e_t_u_r_n  to  cause a return from this


                                   Printed: January 31, 1984







Special Functions                                       4-14


           context.  bind-pointer is the  size  of  variable
           binding  stack  when  this  evaluation began. The
           bind-pointer can be given as a second argument to
           _e_v_a_l  to  order to evaluate variables in the same
           context as this  evaluation. If  type  is  `eval'
           then  expression  will  have  the form (_f_u_n_c_t_i_o_n-
           _n_a_m_e _a_r_g_1 ...).  If type is `apply' then  expres-
           sion    will    have    the    form    (_f_u_n_c_t_i_o_n-
           _n_a_m_e (_a_r_g_1 ...)).  np-index  and  lbot-index  are
           pointers  into  the argument stack (also known as
           the _n_a_m_e_s_t_a_c_k array) at the time of call.   lbot-
           index  points  to  the  first  argument, np-index
           points one beyond the last argument.
           In order for there to be enough  information  for
           _e_v_a_l_f_r_a_m_e to return, you must call (*_r_s_e_t _t).

     EXAMPLE: (_p_r_o_g_n (_e_v_a_l_f_r_a_m_e _n_i_l))
              returns  (_e_v_a_l  _2_1_4_7_4_7_8_6_0_0  (_p_r_o_g_n  (_e_v_a_l_f_r_a_m_e
              _n_i_l)) _1 _8 _7)

(evalhook 'g_form 'su_evalfunc ['su_funcallfunc])

     RETURNS: the result of evaluating g_form  after  lambda
              binding  `evalhook'  to su_evalfunc and, if it
              is  given,  lambda  binding  `funcallhook'  to
              su_funcallhook.

     NOTE: As explained in 14.4, the function _e_v_a_l may  pass
           the  job  of  evaluating  a form to a user `hook'
           function when  various  switches  are  set.   The
           hook  function  normally  prints  the  form to be
           evaluated on the terminal and then  evaluates  it
           by  calling  _e_v_a_l_h_o_o_k.   _E_v_a_l_h_o_o_k does the lambda
           binding mentioned above and then  calls  _e_v_a_l  to
           evaluate  the  form  after  setting  an  internal
           switch to tell _e_v_a_l not to call the  user's  hook
           function  just  this  one  time.  This allows the
           evaluation process to advance one  step  and  yet
           insure  that  further  calls  to  _e_v_a_l will cause
           traps to the hook  function  (if  su_evalfunc  is
           non-null).
           In order for  _e_v_a_l_h_o_o_k  to  work,  (*_r_s_e_t _t)  and
           (_s_s_t_a_t_u_s _e_v_a_l_h_o_o_k _t)  must  have been done previ-
           ously.








9

9                                   Printed: January 31, 1984







Special Functions                                       4-15


(exec s_arg1 ...)

     RETURNS: the result of forking and executing  the  com-
              mand   named   by   concatenating  the  s_arg_i
              together with spaces in between.

(exece 's_fname ['l_args ['l_envir]])

     RETURNS: the error code  from  the  system  if  it  was
              unable  to  execute  the  command s_fname with
              arguments l_args and with the environment  set
              up  as specified in l_envir.  If this function
              is successful, it will not return, instead the
              lisp  system  will be overlaid by the new com-
              mand.

(freturn 'x_pdl-pointer 'g_retval)

     RETURNS: g_retval from  the  context  given  by  x_pdl-
              pointer.

     NOTE: A  pdl-pointer  denotes  a   certain   expression
           currently  being evaluated. The pdl-pointer for a
           given expression can be obtained from _e_v_a_l_f_r_a_m_e.

(frexp 'f_arg)

     RETURNS: a  list  cell  (_e_x_p_o_n_e_n_t  .  _m_a_n_t_i_s_s_a)   which
              represents the given flonum

     NOTE: The exponent will be a fixnum, the mantissa a  56
           bit bignum.  If you think of the the binary point
           occurring right  after  the  high  order  bit  of
           mantissa, then f_arg = 2[exponent] * mantissa.

(funcall 'u_func ['g_arg1 ...])

     RETURNS: the value of applying function u_func  to  the
              arguments  g_arg_i  and  then  evaluating  that
              result if u_func is a macro.

     NOTE: If u_func is a macro or nlambda then there should
           be only one g_arg.  _f_u_n_c_a_l_l is the function which
           the evaluator uses to evaluate lists.  If _f_o_o  is
           a    lambda    or    lexpr    or    array,   then
           (_f_u_n_c_a_l_l '_f_o_o '_a '_b '_c)    is    equivalent    to
           (_f_o_o '_a '_b '_c).    If   _f_o_o  is  a  nlambda  then
           (_f_u_n_c_a_l_l '_f_o_o '(_a _b _c)) is equivalent to (_f_o_o _a _b
           _c).    Finally,   if   _f_o_o   is   a   macro  then
           (_f_u_n_c_a_l_l '_f_o_o '(_f_o_o _a _b _c))  is   equivalent   to
           (_f_o_o _a _b _c).

9

9                                   Printed: January 31, 1984







Special Functions                                       4-16


(funcallhook 'l_form 'su_funcallfunc ['su_evalfunc])

     RETURNS: the result of _f_u_n_c_a_l_ling the  (_c_a_r _l__f_o_r_m)  on
              the   already   evaluated   arguments  in  the
              (_c_d_r _l__f_o_r_m)  after   lambda   binding   `fun-
              callhook'  to  su_funcallfunc  and,  if  it is
              given,   lambda    binding    `evalhook'    to
              su_evalhook.

     NOTE: This function is designed to continue the evalua-
           tion  process  with  as  little  work as possible
           after a funcallhook trap has occurred. It is  for
           this  reason  that the form of l_form is unortho-
           dox: its _c_a_r is the name of the function to  call
           and  its  _c_d_r  are  a  list of arguments to stack
           (without evaluating  again)  before  calling  the
           given function.  After stacking the arguments but
           before calling _f_u_n_c_a_l_l an internal switch is  set
           to  prevent  _f_u_n_c_a_l_l from passing the job of fun-
           calling to su_funcallfunc.  If _f_u_n_c_a_l_l is  called
           recursively   in   funcalling   l_form   and   if
           su_funcallfunc is non-null, then the arguments to
           _f_u_n_c_a_l_l  will actually be given to su_funcallfunc
           (a lexpr) to be funcalled.
           In order for  _e_v_a_l_h_o_o_k  to  work,  (*_r_s_e_t _t)  and
           (_s_s_t_a_t_u_s _e_v_a_l_h_o_o_k _t)  must  have been done previ-
           ously.  A more detailed description  of  _e_v_a_l_h_o_o_k
           and _f_u_n_c_a_l_l_h_o_o_k is given in Chapter 14.

(function u_func)

     RETURNS: the function binding of u_func  if  it  is  an
              symbol   with  a  function  binding  otherwise
              u_func is returned.

(getdisc 'y_func)

     RETURNS: the discipline of the machine  coded  function
              (either lambda, nlambda or macro).

(go g_labexp)

     WHERE:   g_labexp is either a symbol or an expression.

     SIDE EFFECT: If g_labexp is an expression, that expres-
                  sion  is  evaluated and should result in a
                  symbol.  The locus  of  control  moves  to
                  just  following the symbol g_labexp in the
                  current prog or do body.

     NOTE: this is only valid in the context of a prog or do
           body.   The  interpreter  and compiler will allow
           non-local _g_o's although the compiler won't  allow


                                   Printed: January 31, 1984







Special Functions                                       4-17


           a _g_o to leave a function body.  The compiler will
           not allow g_labexp to be an expression.

(if 'g_a 'g_b)
(if 'g_a 'g_b 'g_c ...)
(if 'g_a then  'g_b [...] [elseif 'g_c then 'g_d ...]  [else
'g_e [...])
(if 'g_a then  'g_b [...] [elseif 'g_c thenret]  [else  'g_d
[...])

     NOTE: The various forms of _i_f are intended to be a more
           readable  conditional  statement,  to  be used in
           place of _c_o_n_d.  There are two  varieties  of  _i_f,
           with  keywords,  and  without.   The keyword-less
           variety is inherited from common  Maclisp  usage.
           A  keyword-less, two argument _i_f is equivalent to
           a one-clause _c_o_n_d, i.e. (_c_o_n_d (a b)).   Any other
           keyword-less  _i_f  must  have at least three argu-
           ments.  The first two  arguments  are  the  first
           clause  of the equivalent _c_o_n_d, and all remaining
           arguments are shoved into a second clause  begin-
           ning  with  t.   Thus,  the  second form of _i_f is
           equivalent to
                   (_c_o_n_d (a b) (t c ...)).

           The keyword variety has the following grouping of
           arguments:   a   predicate,  a  then-clause,  and
           optional   else-clause.    The    predicate    is
           evaluated,  and  if  the  result  is non-nil, the
           then-clause  will  be  performed,  in  the  sense
           described  below.  Otherwise, (i.e. the result of
           the predicate evaluation was precisely nil),  the
           else-clause will be performed.

           Then-clauses will either consist entirely of  the
           single  keyword  thenret,  or will start with the
           keyword then, and be followed  by  at  least  one
           general  expression.   (These general expressions
           must not be one of the keywords.)  To  actuate  a
           thenret  means to cease further evaluation of the
           _i_f, and to return the value of the predicate just
           calculated.  The performance of the longer clause
           means to  evaluate  each  general  expression  in
           turn, and then return the last value calculated.

           The else-clause may begin with the  keyword  else
           and  be  followed by at least one general expres-
           sion.  The rendition of this clause is just  like
           that  of a then-clause.  An else-clause may begin
           alternatively with the  keyword  elseif,  and  be
           followed  (recursively)  by  a  predicate,  then-
           clause, and optional else-clause.  Evaluation  of
           this  clause,  is  just evaluation of an _i_f-form,


                                   Printed: January 31, 1984







Special Functions                                       4-18


           with the same predicate, then- and else-clauses.

(I-throw-err 'l_token)

     WHERE:   l_token is the _c_d_r of the value returned  from
              a *_c_a_t_c_h with the tag ER%unwind-protect.

     RETURNS: nothing (never returns in the current context)

     SIDE EFFECT: The error or throw denoted by  l_token  is
                  continued.

     NOTE: This function is used to implement _u_n_w_i_n_d-_p_r_o_t_e_c_t
           which allows the processing of a transfer of con-
           trol though a certain context to be  interrupted,
           a  user  function  to  be  executed  and than the
           transfer of control to  continue.   The  form  of
           l_token is either
           (_t _t_a_g _v_a_l_u_e) for a throw or
           (_n_i_l _t_y_p_e _m_e_s_s_a_g_e _v_a_l_r_e_t  _c_o_n_t_u_a_b  _u_n_i_q_u_e_i_d  [_a_r_g
           ...]) for an error.
           This function is not to be used for  implementing
           throws  or errors and is only documented here for
           completeness.

(let l_args g_exp1 ... g_exprn)

     RETURNS: the result of evaluating  g_exprn  within  the
              bindings given by l_args.

     NOTE: l_args is either nil (in which case _l_e_t  is  just
           like  _p_r_o_g_n)  or it is a list of binding objects.
           A binding object is a  list  (_s_y_m_b_o_l _e_x_p_r_e_s_s_i_o_n).
           When a _l_e_t is entered, all of the expressions are
           evaluated and then simultaneously lambda-bound to
           the  corresponding  symbols.   In  effect,  a _l_e_t
           expression  is  just  like  a  lambda  expression
           except  the  symbols and their initial values are
           next to each other, making the expression  easier
           to  understand.  There are some added features to
           the _l_e_t expression: A binding object can just  be
           a   symbol,   in   which   case   the  expression
           corresponding to that  symbol  is  `nil'.   If  a
           binding object is a list and the first element of
           that list is another  list,  then  that  list  is
           assumed  to be a binding template and _l_e_t will do
           a _d_e_s_e_t_q on it.





9

9                                   Printed: January 31, 1984







Special Functions                                       4-19


(let* l_args g_exp1 ... g_expn)

     RETURNS: the result of evaluating  g_exprn  within  the
              bindings given by l_args.

     NOTE: This is identical to _l_e_t except  the  expressions
           in  the  binding  list  l_args  are evaluated and
           bound sequentially instead of in parallel.

(lexpr-funcall 'g_function ['g_arg1 ...] 'l_argn)

     NOTE: This is a cross between funcall and  apply.   The
           last  argument,  must be a list (possibly empty).
           The element of list arg are stack  and  then  the
           function is funcalled.

     EXAMPLE: (lexpr-funcall 'list 'a '(b c d)) is the  same
              as
               (funcall 'list 'a 'b 'c 'd)

(listify 'x_count)

     RETURNS: a list of x_count  of  the  arguments  to  the
              current function (which must be a lexpr).

     NOTE: normally  arguments   1   through   x_count   are
           returned.  If x_count is negative then  a list of
           last abs(x_count) arguments are returned.

(map 'u_func 'l_arg1 ...)

     RETURNS: l_arg1

     NOTE: The function u_func is applied to successive sub-
           lists  of  the  l_arg_i.  All sublists should have
           the same length.

(mapc 'u_func 'l_arg1 ...)

     RETURNS: l_arg1.

     NOTE: The function u_func is applied to successive ele-
           ments  of  the  argument lists.  All of the lists
           should have the same length.








9

9                                   Printed: January 31, 1984







Special Functions                                       4-20


(mapcan 'u_func 'l_arg1 ...)

     RETURNS: nconc applied to the results of the functional
              evaluations.

     NOTE: The function u_func is applied to successive ele-
           ments of the argument lists.  All sublists should
           have the same length.

(mapcar 'u_func 'l_arg1 ...)

     RETURNS: a list of the values returned from  the  func-
              tional application.

     NOTE: the function u_func is applied to successive ele-
           ments of the argument lists.  All sublists should
           have the same length.

(mapcon 'u_func 'l_arg1 ...)

     RETURNS: nconc applied to the results of the functional
              evaluation.

     NOTE: the function u_func is applied to successive sub-
           lists of the argument lists.  All sublists should
           have the same length.

(maplist 'u_func 'l_arg1 ...)

     RETURNS: a  list  of  the  results  of  the  functional
              evaluations.

     NOTE: the function u_func is applied to successive sub-
           lists  of  the  arguments  lists.   All  sublists
           should have the same length.

     Readers may find the following summary table useful  in
     remembering  the  differences  between  the six mapping
     functions:


8     ________________________________________________________________
                                      Value returned is

                         l_arg1   list of results   _n_c_o_n_c of results
7       Argument to
       functional is
8    ________________________________________________________________

     elements of list    mapc        mapcar             mapcan

         sublists        map         maplist            mapcon
8    ________________________________________________________________
7   |7|7|7|7|7|7|7|7|







                     |7|7|7|7|7|7|7|7|







                                                                   |7|7|7|7|7|7|7|7|












9                                   Printed: January 31, 1984







Special Functions                                       4-21


(mfunction t_entry 's_disc)

     RETURNS: a lisp  object  of  type  binary  composed  of
              t_entry and s_disc.

     NOTE: t_entry is a pointer to the machine  code  for  a
           function,  and  s_disc  is  the  discipline (e.g.
           lambda).

(oblist)

     RETURNS: a list of all symbols on the oblist.

(or [g_arg1 ... ])

     RETURNS: the value of the first non-null  argument   or
              nil if all arguments evaluate to nil.

     NOTE: Evaluation proceeds left to right  and  stops  as
           soon  as one of the arguments evaluates to a non-
           null value.

(prog l_vrbls g_exp1 ...)

     RETURNS: the value explicitly given in a return form or
              else  nil if no return is done by the time the
              last g_exp_i is evaluated.

     NOTE: the local variables are lambda-bound to nil, then
           the  g_exp_i  are  evaluated  from  left to right.
           This is a prog body (obviously)  and  this  means
           than  any symbols seen are not evaluated, but are
           treated as labels.  This also means that return's
           and go's are allowed.

(prog1 'g_exp1 ['g_exp2 ...])

     RETURNS: g_exp1

(prog2 'g_exp1 'g_exp2 ['g_exp3 ...])

     RETURNS: g_exp2

     NOTE: the forms are evaluated from left  to  right  and
           the value of g_exp2 is returned.







9

9                                   Printed: January 31, 1984







Special Functions                                       4-22


(progn 'g_exp1 ['g_exp2 ...])

     RETURNS: the last g_exp_i.

(progv 'l_locv 'l_initv g_exp1 ...)

     WHERE:   l_locv is a list of symbols and l_initv  is  a
              list of expressions.

     RETURNS: the value of the last g_exp_i evaluated.

     NOTE: The expressions in  l_initv  are  evaluated  from
           left  to  right and then lambda-bound to the sym-
           bols in l_locv.  If there are too few expressions
           in l_initv then the missing values are assumed to
           be nil.  If there are  too  many  expressions  in
           l_initv then the extra ones are ignored (although
           they  are  evaluated).   Then  the   g_exp_i   are
           evaluated  left to right.  The body of a progv is
           like the body of a progn, it is _n_o_t a prog  body.
           (C.f. _l_e_t)

(purcopy 'g_exp)

     RETURNS: a copy of g_exp with new pure cells  allocated
              wherever possible.

     NOTE: pure space is never swept up by the garbage  col-
           lector,  so  this  should only be done on expres-
           sions which are not likely to become  garbage  in
           the  future.   In  certain cases, data objects in
           pure space become read-only after a _d_u_m_p_l_i_s_p  and
           then  an attempt to modify the object will result
           in an illegal memory reference.

(purep 'g_exp)

     RETURNS: t iff the object g_exp is in pure space.

(putd 's_name 'u_func)

     RETURNS: u_func

     SIDE EFFECT: this sets the function binding  of  symbol
                  s_name to u_func.







9

9                                   Printed: January 31, 1984







Special Functions                                       4-23


(return ['g_val])

     RETURNS: g_val (or nil if g_val is  not  present)  from
              the enclosing prog or do body.

     NOTE: this form is only valid in the context of a  prog
           or do body.

(selectq 'g_key-form [l_clause1 ...])

     NOTE: This function is just  like  _c_a_s_e_q  (see  above),
           except  that  the  symbol  otherwise has the same
           semantics as the symbol t, when used  as  a  com-
           parator.

(setarg 'x_argnum 'g_val)

     WHERE:   x_argnum is greater than zero and less than or
              equal to the number of arguments to the lexpr.

     RETURNS: g_val

     SIDE EFFECT: the lexpr's x_argnum'th argument is set to
                  g-val.

     NOTE: this can only be used within the body of a lexpr.

(throw 'g_val [s_tag])

     WHERE:   if s_tag is not given, it  is  assumed  to  be
              nil.

     RETURNS: the value of (*_t_h_r_o_w '_s__t_a_g '_g__v_a_l).

(*throw 's_tag 'g_val)

     RETURNS: g_val from the first enclosing catch with  the
              tag s_tag or with no tag at all.

     NOTE: this is used in conjunction with *_c_a_t_c_h to  cause
           a clean jump to an enclosing context.











9

9                                   Printed: January 31, 1984







Special Functions                                       4-24


(unwind-protect g_protected [g_cleanup1 ...])

     RETURNS: the result of evaluating g_protected.

     NOTE: Normally g_protected is evaluated and  its  value
           remembered, then the g_cleanup_i are evaluated and
           finally  the  saved  value  of   g_protected   is
           returned.    If   something  should  happen  when
           evaluating g_protected which  causes  control  to
           pass  through  g_protected   and thus through the
           call to the unwind-protect, then  the  g_cleanup_i
           will  still  be  evaluated.   This  is  useful if
           g_protected does  something sensitive which  must
           be  cleaned  up  whether  or not g_protected com-
           pletes.





































9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch5.r  << 'EndOfFile'







                         CHAPTER  5


                        Input/Output




     The following functions are used to read from and write
to  external  devices  (e.g.  files)  and  programs (through
pipes).  All I/O goes through the lisp data type called  the
port.  A port may be open for either reading or writing, but
usually not both simultaneously (see _f_i_l_e_o_p_e_n ).  There  are
only  a  limited  number  of ports (20) and they will not be
reclaimed unless they are _c_l_o_s_ed.  All ports  are  reclaimed
by  a _r_e_s_e_t_i_o call, but this drastic step won't be necessary
if the program closes what it uses.

     If a port argument is not supplied to a function  which
requires  one,  or  if  a bad port argument (such as nil) is
given, then FRANZ LISP will use the default  port  according
to this scheme: If input is being done then the default port
is the value of the symbol piport and  if  output  is  being
done  then  the  default  port  is  the  value of the symbol
poport.  Furthermore, if the value of piport  or  poport  is
not a valid port, then the standard input or standard output
will be used, respectively.

     The standard input and standard output are usually  the
keyboard  and terminal display unless your job is running in
the background and its input or output  is  connected  to  a
pipe.   All  output  which  goes to the standard output will
also go to the port ptport if it is a  valid  port.   Output
destined for the standard output will not reach the standard
output if the symbol ^w is non nil (although it  will  still
go to ptport if ptport is a valid port).

     Some of the  functions  listed  below  reference  files
directly.   FRANZ  LISP  has borrowed a convenient shorthand
notation from /_b_i_n/_c_s_h, concerning naming files.  If a  file
name begins with ~ (tilde), and the symbol tilde-expansion

is bound to  something  other  than  nil,  then  FRANZ  LISP
expands  the  file  name.  It takes the string of characters
between the leading tilde, and the first slash  as  a  user-
name.   Then,  that  initial  segment  of  the  filename  is
replaced by the home directory of the user.  The null  user-
name is taken to be the current user.

     FRANZ LISP keeps a cache of user home directory  infor-
mation,  to  minimize  searching  the password file.  Tilde-
expansion is performed in the  following  functions:  _c_f_a_s_l,
_c_h_d_i_r, _f_a_s_l, _f_f_a_s_l, _f_i_l_e_o_p_e_n, _i_n_f_i_l_e, _l_o_a_d, _o_u_t_f_i_l_e, _p_r_o_b_e_f,


Input/Output                                             5-1







Input/Output                                             5-2


_s_y_s:_a_c_c_e_s_s, _s_y_s:_u_n_l_i_n_k.

(cfasl    'st_file    'st_entry    'st_funcname    ['st_disc
['st_library]])

     RETURNS: t

     SIDE EFFECT: This is used to load in a foreign function
                  (see  8.4).   The  object  file st_file is
                  loaded into  the  lisp  system.   St_entry
                  should  be an entry point in the file just
                  loaded.  The function binding of the  sym-
                  bol  s_funcname  will  be  set to point to
                  st_entry, so that when the  lisp  function
                  s_funcname  is  called,  st_entry  will be
                  run.  st_disc  is  the  discipline  to  be
                  given  to  s_funcname. st_disc defaults to
                  "subroutine" if it is not given or  if  it
                  is  given  as  nil.  If st_library is non-
                  null, then after st_file  is  loaded,  the
                  libraries  given  in  st_library  will  be
                  searched to resolve  external  references.
                  The form of st_library should be something
                  like "-lm".  The C library  (" -lc " )  is
                  always  searched  so  when  loading in a C
                  file you probably won't need to specify  a
                  library.   For  Fortran  files, you should
                  specify "-lF77" and if you are  doing  any
                  I/O,  the  library  entry should be "-lI77
                  -lF77".   For  Pascal  files   "-lpc"   is
                  required.

     NOTE: This function may be used to load the  output  of
           the  assembler, C compiler, Fortran compiler, and
           Pascal compiler  but NOT the lisp  compiler  (use
           _f_a_s_l  for  that).   If  a  file has more than one
           entry point, then use _g_e_t_a_d_d_r_e_s_s  to  locate  and
           setup other foreign functions.
           It is an error to load in a file which has a glo-
           bal  entry  point  of  the  same name as a global
           entry point in the running lisp.  As soon as  you
           load  in  a  file  with  _c_f_a_s_l,  its global entry
           points become part of the  lisp's  entry  points.
           Thus  you  cannot  _c_f_a_s_l  in  the same file twice
           unless you use _r_e_m_o_v_e_a_d_d_r_e_s_s  to  change  certain
           global entry points to local entry points.






9

9                                   Printed: January 31, 1984







Input/Output                                             5-3


(close 'p_port)

     RETURNS: t

     SIDE EFFECT: the specified port is drained and  closed,
                  releasing the port.

     NOTE: The standard defaults are not used in  this  case
           since  you probably never want to close the stan-
           dard output or standard input.

(cprintf 'st_format 'xfst_val ['p_port])

     RETURNS: xfst_val

     SIDE EFFECT: The UNIX formatted output function  printf
                  is  called  with  arguments  st_format and
                  xfst_val.  If xfst_val is  a  symbol  then
                  its  print  name is passed to printf.  The
                  format string may contain characters which
                  are just printed literally and it may con-
                  tain special formatting commands  preceded
                  by  a  percent  sign.  The complete set of
                  formatting characters is described in  the
                  UNIX  manual.  Some useful ones are %d for
                  printing a fixnum in decimal, %f or %e for
                  printing  a  flonum, and %s for printing a
                  character string (or print name of a  sym-
                  bol).

     EXAMPLE: (_c_p_r_i_n_t_f "_P_i _e_q_u_a_l_s %_f"  _3._1_4_1_5_9)  prints  `Pi
              equals 3.14159'

(drain ['p_port])

     RETURNS: nil

     SIDE EFFECT: If this is an output port then the charac-
                  ters  in the output buffer are all sent to
                  the device.  If this is an input port then
                  all  pending  characters are flushed.  The
                  default port  for  this  function  is  the
                  default output port.









9

9                                   Printed: January 31, 1984







Input/Output                                             5-4


(ex [s_filename])
(vi [s_filename])
(exl [s_filename])
(vil [s_filename])

     RETURNS: nil

     SIDE EFFECT: The lisp system starts up an editor on the
                  file  named  as the argument.  It will try
                  appending .l to the file if it can't  find
                  it.   The  functions _e_x_l and _v_i_l will load
                  the file  after  you  finish  editing  it.
                  These  functions  will  also  remember the
                  name of the file  so  that  on  subsequent
                  invocations, you don't need to provide the
                  argument.

     NOTE: These functions do not evaluate their argument.

(fasl 'st_name ['st_mapf ['g_warn]])

     WHERE:   st_mapf and g_warn default to nil.

     RETURNS: t if the function succeeded, nil otherwise.

     SIDE EFFECT: this function is designed to  load  in  an
                  object file generated by the lisp compiler
                  Liszt.  File names for object  files  usu-
                  ally end in `.o', so _f_a_s_l will append `.o'
                  to st_name (if it is not already present).
                  If st_mapf is non nil, then it is the name
                  of the map file to create.  _F_a_s_l writes in
                  the  map  file  the names and addresses of
                  the functions it loads and defines.   Nor-
                  mally  the map file is created (i.e. trun-
                  cated    if    it    exists),    but    if
                  (_s_s_t_a_t_u_s _a_p_p_e_n_d_m_a_p _t) is done then the map
                  file will be appended.  If g_warn  is  non
                  nil  and if a function is loaded from  the
                  file which  is  already  defined,  then  a
                  warning message will be printed.

     NOTE: _f_a_s_l only looks in the current directory for  the
           file  to  load. The function _l_o_a_d looks through a
           user-supplied search path and will call  _f_a_s_l  if
           it  finds  a  file  with the same root name and a
           `.o' extension.  In  most cases the user would be
           better  off  using  the function _l_o_a_d rather than
           calling _f_a_s_l directly.



9

9                                   Printed: January 31, 1984







Input/Output                                             5-5


(ffasl  'st_file  'st_entry   'st_funcname   ['st_discipline
['st_library]])

     RETURNS: the binary object created.

     SIDE EFFECT: the Fortran object file st_file is  loaded
                  into  the lisp system.  St_entry should be
                  an entry point in the file just loaded.  A
                  binary  object  will  be  created  and its
                  entry  field  will  be  set  to  point  to
                  st_entry.   The  discipline  field  of the
                  binary will be  set  to  st_discipline  or
                  "subroutine" by default.  If st_library is
                  present and non-null, then  after  st_file
                  is   loaded,   the   libraries   given  in
                  st_library will  be  searched  to  resolve
                  external    references.    The   form   of
                  st_library should be something  like  "-lS
                  -ltermcap".   In  any  case,  the standard
                  Fortran libraries will be searched also to
                  resolve external references.

     NOTE: in F77 on Unix, the entry point for  the  fortran
           function foo is named `_foo_'.

(filepos 'p_port ['x_pos])

     RETURNS: the current position in the file if  x_pos  is
              not given or else x_pos if x_pos is given.

     SIDE EFFECT: If x_pos is given, the  next  byte  to  be
                  read  or  written  to  the port will be at
                  position x_pos.

(filestat 'st_filename)

     RETURNS: a vector containing various numbers which  the
              UNIX  operating  system  assigns to files.  if
              the file doesn't exist, an error  is  invoked.
              Use _p_r_o_b_e_f to determine if the file exists.

     NOTE: The individual entries can be accesed by mnemonic
           functions of the form filestat:_f_i_e_l_d, where field
           may be  any  of  atime,  ctime,  dev,  gid,  ino,
           mode,mtime,  nlink,  rdev,  size, type, uid.  See
           the UNIX programmers manual for a  more  detailed
           description of these quantities.





9

9                                   Printed: January 31, 1984







Input/Output                                             5-6


(flatc 'g_form ['x_max])

     RETURNS: the number of  characters  required  to  print
              g_form  using _p_a_t_o_m.  If x_max is given and if
              _f_l_a_t_c determines that it will return  a  value
              greater  than  x_max,  then  it  gives  up and
              returns the current  value  it  has  computed.
              This  is  useful if you just want to see if an
              expression is larger than a certain size.

(flatsize 'g_form ['x_max])

     RETURNS: the number of  characters  required  to  print
              g_form  using  _p_r_i_n_t.  The meaning of x_max is
              the same as for flatc.

     NOTE: Currently this just _e_x_p_l_o_d_e's g_form  and  checks
           its length.

(fileopen 'st_filename 'st_mode)

     RETURNS: a port for reading or  writing  (depending  on
              st_mode) the file st_name.

     SIDE EFFECT: the given file is opened  (or  created  if
                  opened  for  writing  and  it  doesn't yet
                  exist).

     NOTE: this function call provides a direct interface to
           the  operating system's fopen function.  The mode
           may be more than just "r" for read, "w" for write
           or "a" for append.  The modes "r+", "w+" and "a+"
           permit both reading and writing on  a  port  pro-
           vided  that  _f_s_e_e_k  is  done  between  changes in
           direction.  See the UNIX  manual  description  of
           fopen  for  more  details.  This routine does not
           look through a search path for a given file.

(fseek 'p_port 'x_offset 'x_flag)

     RETURNS: the position in the file after the function is
              performed.

     SIDE EFFECT: this  function  positions  the  read/write
                  pointer before a certain byte in the file.
                  If x_flag is 0 then the pointer is set  to
                  x_offset  bytes  from the beginning of the
                  file.  If x_flag is 1 then the pointer  is
                  set  to  x_offset  bytes  from the current
                  location in the file.  If x_flag is 2 then
                  the  pointer is set to x_offset bytes from
                  the end of the file.
9

9                                   Printed: January 31, 1984







Input/Output                                             5-7


(infile 's_filename)

     RETURNS: a port ready to read s_filename.

     SIDE EFFECT: this tries to open s_filename  and  if  it
                  cannot  or if there are no ports available
                  it gives an error message.

     NOTE: to allow your program to continue on a  file-not-
           found error, you can use something like:
           (_c_o_n_d ((_n_u_l_l (_s_e_t_q _m_y_p_o_r_t  (_c_a_r  (_e_r_r_s_e_t  (_i_n_f_i_l_e
           _n_a_m_e) _n_i_l))))
                       (_p_a_t_o_m '"_c_o_u_l_d_n'_t _o_p_e_n _t_h_e _f_i_l_e")))
           which will set myport to the port to read from if
           the  file  exists  or  will print a message if it
           couldn't open it and also set myport to nil.   To
           simply determine if a file exists, use _p_r_o_b_e_f.

(load 's_filename ['st_map ['g_warn]])

     RETURNS: t

     NOTE: The function of _l_o_a_d has changed  since  previous
           releases of FRANZ LISP and the following descrip-
           tion should be read carefully.

     SIDE EFFECT: _l_o_a_d now serves the function of both  _f_a_s_l
                  and the old _l_o_a_d.  _L_o_a_d will search a user
                  defined search path for a lisp  source  or
                  object  file  with the filename s_filename
                  (with the extension  .l  or  .o  added  as
                  appropriate).   The search path which _l_o_a_d
                  uses is the value of  (_s_t_a_t_u_s _l_o_a_d-_s_e_a_r_c_h-
                  _p_a_t_h).  The default is (|.| /usr/lib/lisp)
                  which means look in the current  directory
                  first  and  then  /usr/lib/lisp.  The file
                  which _l_o_a_d looks for depends on  the  last
                  two    characters   of   s_filename.    If
                  s_filename ends with ".l" then  _l_o_a_d  will
                  only  look  for a file name s_filename and
                  will assume that  this  is  a  FRANZ  LISP
                  source file.  If s_filename ends with ".o"
                  then _l_o_a_d will only look for a file  named
                  s_filename  and will assume that this is a
                  FRANZ LISP object file to  be  _f_a_s_led  in.
                  Otherwise,   _l_o_a_d   will  first  look  for
                  s_filename.o,   then   s_filename.l    and
                  finally  s_filename  itself.   If it finds
                  s_filename.o it will assume that  this  is
                  an  object  file, otherwise it will assume
                  that it is a source file.  An object  file
                  is  loaded using _f_a_s_l and a source file is
                  loaded by reading and evaluating each form


                                   Printed: January 31, 1984







Input/Output                                             5-8


                  in   the  file.   The  optional  arguments
                  st_map  and  g_warn  are  passed  to  _f_a_s_l
                  should _f_a_s_l be called.

     NOTE: _l_o_a_d requires a port to open the file s_filename.
           It  then  lambda  binds the symbol piport to this
           port and reads and evaluates the forms.

(makereadtable ['s_flag])

     WHERE:   if s_flag is not present it is assumed  to  be
              nil.

     RETURNS: a readtable equal to the original readtable if
              s_flag  is  non-null,  or  else  equal  to the
              current  readtable.   See  chapter  7  for   a
              description of readtables and their uses.

(msg [l_option ...] ['g_msg ...])

     NOTE: This function is intended for printing short mes-
           sages.  Any of the arguments or options presented
           can be used any number of times,  in  any  order.
           The  messages  themselves  (g_msg) are evaluated,
           and then they are transmitted  to  _p_a_t_o_m.   Typi-
           cally,  they are strings, which evaluate to them-
           selves.  The options are interpreted specially:


    ____________________________________________________

    _m_s_g _O_p_t_i_o_n _S_u_m_m_a_r_y

    (_P _p__p_o_r_t_n_a_m_e)          causes subsequent output to go to the port p_portname
                                    (port should be opened previously)

    _B                       print a single blank.

    (_B '_n__b)                evaluate n_b and print that many blanks.

    _N                       print a single by calling _t_e_r_p_r.

    (_N '_n__n)                evaluate n_n and transmit
                                    that many newlines to the stream.

    _D                       _d_r_a_i_n the current port.
    ____________________________________________________





9

9                                   Printed: January 31, 1984







Input/Output                                             5-9


(nwritn ['p_port])

     RETURNS: the number of characters in the buffer of  the
              given port but not yet written out to the file
              or device.  The buffer  is  flushed  automati-
              cally when filled, or when _t_e_r_p_r is called.

(outfile 's_filename ['st_type])

     RETURNS: a port or nil

     SIDE EFFECT: this opens a port to write s_filename.  If
                  st_type is given and if it is  a symbol or
                  string whose name begins  with  `a',  then
                  the  file  will  be opened in append mode,
                  that is the current contents will  not  be
                  lost  and the next data will be written at
                  the end of the file.  Otherwise, the  file
                  opened  is  truncated  by  _o_u_t_f_i_l_e  if  it
                  existed beforehand.  If there are no  free
                  ports, outfile returns nil.  If one cannot
                  write on  s_filename,  an  error  is  sig-
                  nalled.

(patom 'g_exp ['p_port])

     RETURNS: g_exp

     SIDE EFFECT: g_exp is printed to the given port or  the
                  default  port.   If  g_exp  is a symbol or
                  string, the print name is printed  without
                  any escape characters around special char-
                  acters in the print name.  If g_exp  is  a
                  list  then  _p_a_t_o_m  has  the same effect as
                  _p_r_i_n_t.

(pntlen 'xfs_arg)

     RETURNS: the  number  of  characters  needed  to  print
              xfs_arg.

(portp 'g_arg)

     RETURNS: t iff g_arg is a port.








9

9                                   Printed: January 31, 1984







Input/Output                                            5-10


(pp [l_option] s_name1 ...)

     RETURNS: t

     SIDE EFFECT: If s_name_i has a function binding,  it  is
                  pretty-printed, otherwise if s_name_i has a
                  value then that is  pretty-printed.   Nor-
                  mally  the  output  of  the pretty-printer
                  goes to the standard output  port  poport.
                  The options allow you to redirect it.


    ____________________________________________________

    _P_P _O_p_t_i_o_n _S_u_m_m_a_r_y

    (_F _s__f_i_l_e_n_a_m_e)          direct future printing to s_filename

    (_P _p__p_o_r_t_n_a_m_e)          causes output to go to the port p_portname
                                    (port should be opened previously)

    (_E _g__e_x_p_r_e_s_s_i_o_n)                evaluate g_expression and don't print
    ____________________________________________________




(princ 'g_arg ['p_port])

     EQUIVALENT TO: patom.

(print 'g_arg ['p_port])

     RETURNS: nil

     SIDE EFFECT: prints g_arg on the  port  p_port  or  the
                  default port.

(probef 'st_file)

     RETURNS: t iff the file st_file exists.

     NOTE: Just because it exists doesn't mean you can  read
           it.








9

9                                   Printed: January 31, 1984







Input/Output                                            5-11


(pp-form 'g_form ['p_port])

     RETURNS: t

     SIDE EFFECT: g_form  is  pretty-printed  to  the   port
                  p_port (or poport if p_port is not given).
                  This is the  function which _p_p  uses.  _p_p-
                  _f_o_r_m  does  not  look for function defini-
                  tions or  values  of  variables,  it  just
                  prints out the form it is given.

     NOTE: This is useful as a top-level-printer, c.f.  _t_o_p-
           _l_e_v_e_l in Chapter 6.

(ratom ['p_port ['g_eof]])

     RETURNS: the next atom read from the given  or  default
              port.   On end of file, g_eof (default nil) is
              returned.

(read ['p_port ['g_eof]])

     RETURNS: the next lisp expression read from  the  given
              or  default  port.   On  end  of  file,  g_eof
              (default nil) is returned.

     NOTE: An error will occur if the reader is given an ill
           formed  expression.  The most common error is too
           many right parentheses (note  that  this  is  not
           considered an error in Maclisp).

(readc ['p_port ['g_eof]])

     RETURNS: the next character  read  from  the  given  or
              default  port.  On end of file, g_eof (default
              nil) is returned.

(readlist 'l_arg)

     RETURNS: the lisp expression  read  from  the  list  of
              characters in l_arg.











9

9                                   Printed: January 31, 1984







Input/Output                                            5-12


(removeaddress 's_name1 ['s_name2 ...])

     RETURNS: nil

     SIDE EFFECT: the entries for the s_name_i  in  the  Lisp
                  symbol  table are removed.  This is useful
                  if you wish to _c_f_a_s_l or _f_f_a_s_l  in  a  file
                  twice, since it is illegal for a symbol in
                  the file you are loading to already  exist
                  in the lisp symbol table.

(resetio)

     RETURNS: nil

     SIDE EFFECT: all ports except the standard input,  out-
                  put and error are closed.

(setsyntax 's_symbol 's_synclass ['ls_func])

     RETURNS: t

     SIDE EFFECT: this sets the code for s_symbol to sx_code
                  in  the  current readtable.  If s_synclass
                  is _m_a_c_r_o or _s_p_l_i_c_i_n_g then ls_func  is  the
                  associated  function.   See  Chapter  7 on
                  the reader for more details.

(sload 's_file)

     SIDE EFFECT: the file s_file (in the current directory)
                  is  opened  for  reading  and each form is
                  read, printed and evaluated.  If the  form
                  is  recognizable as a function definition,
                  only its name will be  printed,  otherwise
                  the whole form is printed.

     NOTE: This function is useful when a  file  refuses  to
           load because of a syntax error and you would like
           to narrow down where the error is.

(tab 'x_col ['p_port])

     SIDE EFFECT: enough spaces are printed to put the  cur-
                  sor  on  column  x_col.   If the cursor is
                  beyond x_col to start  with,  a  _t_e_r_p_r  is
                  done first.





9

9                                   Printed: January 31, 1984







Input/Output                                            5-13


(terpr ['p_port])

     RETURNS: nil

     SIDE EFFECT: a terminate line   character  sequence  is
                  sent  to  the  given  port  or the default
                  port.  This will also drain the port.

(terpri ['p_port])

     EQUIVALENT TO: terpr.

(tilde-expand 'st_filename)

     RETURNS: a symbol whose pname is the tilde-expansion of
              the  argument,  (as discussed at the beginning
              of this chapter).  If the  argument  does  not
              begin  with  a  tilde,  the argument itself is
              returned.

(tyi ['p_port])

     RETURNS: the fixnum representation of the next  charac-
              ter read.  On end of file, -1 is returned.

(tyipeek ['p_port])

     RETURNS: the fixnum representation of the next  charac-
              ter to be read.

     NOTE: This does not actually  read  the  character,  it
           just peeks at it.

(tyo 'x_char ['p_port])

     RETURNS: x_char.

     SIDE EFFECT: the character whose fixnum  representation
                  is  x_code,  is  printed as a on the given
                  output port or the default output port.

(untyi 'x_char ['p_port])

     SIDE EFFECT: x_char is put back in the input buffer  so
                  a  subsequent  _t_y_i  or  _r_e_a_d  will read it
                  first.

     NOTE: a maximum of one character may be put back.




9

9                                   Printed: January 31, 1984







Input/Output                                            5-14


(username-to-dir 'st_name)

     RETURNS: the home directory of  the  given  user.   The
              result   is  stored,  to  avoid  unnecessarily
              searching the password file.

(zapline)

     RETURNS: nil

     SIDE EFFECT: all characters up  to  and  including  the
                  line  termination  character  are read and
                  discarded from  the  last  port  used  for
                  input.

     NOTE: this is used as the macro function for the  semi-
           colon character when it acts as a comment charac-
           ter.


































9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch6.r  << 'EndOfFile'







                         CHAPTER  6


                      System Functions




     This chapter describes the functions used  to  interact
with  internal  components  of the Lisp system and operating
system.

(allocate 's_type 'x_pages)

     WHERE:   s_type is one of the  FRANZ  LISP  data  types
              described in 1.3.

     RETURNS: x_pages.

     SIDE EFFECT: FRANZ LISP attempts to allocate x_pages of
                  type  s_type.   If there aren't x_pages of
                  memory left, no space  will  be  allocated
                  and an error will occur.  The storage that
                  is allocated is not given to  the  caller,
                  instead  it  is  added to the free storage
                  list of s_type.  The functions _s_e_g_m_e_n_t and
                  _s_m_a_l_l-_s_e_g_m_e_n_t  allocate blocks  of storage
                  and return it to the caller.

(argv 'x_argnumb)

     RETURNS: a symbol whose pname is the x_argnumb_t_h  argu-
              ment (starting at 0) on the command line which
              invoked the current lisp.

     NOTE: if x_argnumb is less than zero,  a  fixnum  whose
           value  is  the number of arguments on the command
           line is returned.  (_a_r_g_v _0) returns the  name  of
           the lisp you are running.

(baktrace)

     RETURNS: nil

     SIDE EFFECT: the lisp runtime stack is examined and the
                  name  of (most) of the functions currently
                  in  execution  are  printed,  most  active
                  first.

     NOTE: this will occasionally miss the names of compiled
           lisp  functions  due to incomplete information on
           the stack.  If you  are  tracing  compiled  code,
           then  _b_a_k_t_r_a_c_e  won't  be  able  to interpret the


System Functions                                         6-1







System Functions                                         6-2


           stack unless  (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l)  was  done.
           See  the  function  _s_h_o_w_s_t_a_c_k  for another way of
           printing the lisp runtime stack.   This  misspel-
           ling is from Maclisp.

(chdir 's_path)

     RETURNS: t iff the system call succeeds.

     SIDE EFFECT: the current directory set to s_path. Among
                  other things, this will affect the default
                  location where the input/output  functions
                  look for and create files.

     NOTE: _c_h_d_i_r follows the standard UNIX  conventions,  if
           s_path  does  not begin with a slash, the default
           path is changed to the current path  with  s_path
           appended.   _C_h_d_i_r  employs  tilde-expansion (dis-
           cussed in Chapter 5).

(command-line-args)

     RETURNS: a list of the arguments typed on  the  command
              line, either to the lisp interpreter, or saved
              lisp dump, or application  compiled  with  the
              autorun option (liszt -r).

(deref 'x_addr)

     RETURNS: The contents of x_addr, when thought of  as  a
              longword memory location.

     NOTE: This may be useful in constructing arguments to C
           functions out of `dangerous' areas of memory.

(dumplisp s_name)

     RETURNS: nil

     SIDE EFFECT: the current lisp is dumped  to  the  named
                  file.   When  s_name is executed, you will
                  be in a lisp in the same state as when the
                  dumplisp was done.

     NOTE: dumplisp will fail if one tries to write over the
           current  running file. UNIX does not allow you to
           modify the file you are running.





9

9                                   Printed: January 31, 1984







System Functions                                         6-3


(eval-when l_time g_exp1 ...)

     SIDE EFFECT: l_time may contain any combination of  the
                  symbols  _l_o_a_d,  _e_v_a_l,  and  _c_o_m_p_i_l_e.   The
                  effects of load and compile  is  discussed
                  in  12.3.2.1 compiler.  If eval is present
                  however,  this  simply  means   that   the
                  expressions g_exp1 and so on are evaluated
                  from  left  to  right.   If  eval  is  not
                  present, the forms are not evaluated.

(exit ['x_code])

     RETURNS: nothing (it never returns).

     SIDE EFFECT: the lisp system dies with exit code x_code
                  or 0 if x_code is not specified.

(fake 'x_addr)

     RETURNS: the lisp object at address x_addr.

     NOTE: This is intended to be used by  people  debugging
           the lisp system.

(fork)

     RETURNS: nil to  the  child  process  and  the  process
              number of the child to the parent.

     SIDE EFFECT: A copy of the current lisp system is  made
                  in  memory and both lisp systems now begin
                  to  run.   This  function  can   be   used
                  interactively   to  temporarily  save  the
                  state of Lisp (as shown  below),  but  you
                  must  be  careful  that  only  one  of the
                  lisp's interacts with the  terminal  after
                  the fork.  The _w_a_i_t function is useful for
                  this.













9

9                                   Printed: January 31, 1984







System Functions                                         6-4



    ____________________________________________________

    -> (_s_e_t_q _f_o_o '_b_a_r)              ;; set a variable
    bar
    -> (_c_o_n_d ((_f_o_r_k)(_w_a_i_t)))        ;; duplicate the lisp system and
    nil                             ;; make the parent wait
    -> _f_o_o                          ;; check the value of the variable
    bar
    -> (_s_e_t_q _f_o_o '_b_a_z)              ;; give it a new value
    baz
    -> _f_o_o                          ;; make sure it worked
    baz
    -> (_e_x_i_t)                       ;; exit the child
    (5274 . 0)                      ;; the _w_a_i_t function returns this
    -> _f_o_o                          ;; we check to make sure parent was
    bar                             ;; not modified.
    ____________________________________________________




(gc)

     RETURNS: nil

     SIDE EFFECT: this causes a garbage collection.

     NOTE: The function _g_c_a_f_t_e_r is not called  automatically
           after  this function finishes.  Normally the user
           doesn't have to call _g_c since garbage  collection
           occurs automatically whenever internal free lists
           are exhausted.

(gcafter s_type)

     WHERE:   s_type is one of the  FRANZ  LISP  data  types
              listed in 1.3.

     NOTE: this function is called by the garbage  collector
           after  a  garbage  collection which was caused by
           running out of data type s_type.   This  function
           should  determine if more space need be allocated
           and if so should allocate it.  There is a default
           gcafter  function but users who want control over
           space allocation can define their own -- but note
           that it must be an nlambda.





9

9                                   Printed: January 31, 1984







System Functions                                         6-5


(getenv 's_name)

     RETURNS: a symbol whose pname is the value of s_name in
              the   current  UNIX  environment.   If  s_name
              doesn't exist in the  current  environment,  a
              symbol with a null pname is returned.

(hashtabstat)

     RETURNS: a list of fixnums representing the  number  of
              symbols in each bucket of the oblist.

     NOTE: the oblist is stored a  hash  table  of  buckets.
           Ideally there would be the same number of symbols
           in each bucket.

(help [sx_arg])

     SIDE EFFECT: If sx_arg is a symbol then the portion  of
                  this manual beginning with the description
                  of sx_arg is printed on the terminal.   If
                  sx_arg  is  a fixnum or the name of one of
                  the appendicies, that chapter or  appendix
                  is  printed  on the terminal.  If no argu-
                  ment is provided, _h_e_l_p prints the  options
                  that it recognizes.  The program `more' is
                  used to print the manual on the  terminal;
                  it will stop after each page and will con-
                  tinue after the space key is pressed.

(include s_filename)

     RETURNS: nil

     SIDE EFFECT: The given  filename  is  _l_o_a_ded  into  the
                  lisp.

     NOTE: this is similar to load except  the  argument  is
           not  evaluated.   Include means something special
           to the compiler.

(include-if 'g_predicate s_filename)

     RETURNS: nil

     SIDE EFFECT: This has the same effect as  include,  but
                  is  only actuated if the predicate is non-
                  nil.




9

9                                   Printed: January 31, 1984







System Functions                                         6-6


(includef 's_filename)

     RETURNS: nil

     SIDE EFFECT: this is the same  as  _i_n_c_l_u_d_e  except  the
                  argument is evaluated.

(includef-if 'g_predicate s_filename)

     RETURNS: nil

     SIDE EFFECT: This has the same effect as includef,  but
                  is  only actuated if the predicate is non-
                  nil.

(maknum 'g_arg)

     RETURNS: the address of its argument converted  into  a
              fixnum.

(monitor ['xs_maxaddr])

     RETURNS: t

     SIDE EFFECT: If xs_maxaddr is t then profiling  of  the
                  entire   lisp   system   is   begun.    If
                  xs_maxaddr is a fixnum then  profiling  is
                  done  only  up  to address xs_maxaddr.  If
                  xs_maxaddr is not given, then profiling is
                  stopped  and  the data obtained is written
                  to the file  'mon.out'  where  it  can  be
                  analyzed with the UNIX 'prof' program.

     NOTE: this function only works if the lisp  system  has
           been  compiled  in  a  special way, otherwise, an
           error is invoked.

(opval 's_arg ['g_newval])

     RETURNS: the value associated  with  s_arg  before  the
              call.

     SIDE EFFECT: If g_newval is specified, the value  asso-
                  ciated with s_arg is changed to g_newval.

     NOTE: _o_p_v_a_l keeps track of storage allocation. If s_arg
           is one of the data types then _o_p_v_a_l will return a
           list of three fixnums representing the number  of
           items  of  that  type in use, the number of pages
           allocated and the number of items  of  that  type
           per  page.  You  should  never  try to change the
           value _o_p_v_a_l associates with  a  data  type  using
           _o_p_v_a_l.


                                   Printed: January 31, 1984







System Functions                                         6-7


           If s_arg is _p_a_g_e_l_i_m_i_t then _o_p_v_a_l will return (and
           set  if  g_newval is given) the maximum amount of
           lisp data pages it  will  allocate.   This  limit
           should  remain small unless you know your program
           requires lots of space as this limit  will  catch
           programs   in  infinite  loops  which  gobble  up
           memory.

(*process 'st_command ['g_readp ['g_writep]])

     RETURNS: either a fixnum if one argument is given, or a
              list of two ports and a fixnum if two or three
              arguments are given.

     NOTE: *_p_r_o_c_e_s_s  starts  another  process   by   passing
           st_command to the shell (it first tries /bin/csh,
           then it tries /bin/sh if /bin/csh doesn't exist).
           If  only one argument is given to *_p_r_o_c_e_s_s, *_p_r_o_-
           _c_e_s_s waits for the new process to  die  and  then
           returns  the  exit  code  of the new process.  If
           more two or three arguments are  given,  *_p_r_o_c_e_s_s
           starts the process and then returns a list which,
           depending on the value of g_readp  and  g_writep,
           may  contain  i/o ports for communcating with the
           new process.  If g_writep  is  non-null,  then  a
           port  will  be created which the lisp program can
           use to send characters to the  new  process.   If
           g_readp  is non-null, then a port will be created
           which the lisp program can use to read characters
           from  the  new  process.   The  value returned by
           *_p_r_o_c_e_s_s is (readport writeport pid) where  read-
           port and writeport are either nil or a port based
           on the value of g_readp and g_writep.  Pid is the
           process  id of the new process.  Since it is hard
           to remember the order of  g_readp  and  g_writep,
           the  functions *_p_r_o_c_e_s_s-_s_e_n_d and *_p_r_o_c_e_s_s-_r_e_c_e_i_v_e
           were written to perform the common functions.

(*process-receive 'st_command)

     RETURNS: a port which can be read.

     SIDE EFFECT: The command st_command  is  given  to  the
                  shell  and  it  is  started running in the
                  background.  The output of that command is
                  available   for   reading   via  the  port
                  returned.  The input of the  command  pro-
                  cess is set to /dev/null.




9

9                                   Printed: January 31, 1984







System Functions                                         6-8


(*process-send 'st_command)

     RETURNS: a port which can be written to.

     SIDE EFFECT: The command st_command  is  given  to  the
                  shell  and  it  is  started  runing in the
                  background.  The lisp program can  provide
                  input  for that command by sending charac-
                  ters to the port returned  by  this  func-
                  tion.   The  output of the command process
                  is set to /dev/null.

(process s_pgrm [s_frompipe s_topipe])

     RETURNS: if the optional arguments are  not  present  a
              fixnum  which  is  the  exit  code when s_prgm
              dies.  If the optional arguments are  present,
              it returns a fixnum which is the process id of
              the child.

     NOTE: This command is obsolete.   New  programs  should
           use one of the *_p_r_o_c_e_s_s commands given above.

     SIDE EFFECT: If s_frompipe and s_topipe are given, they
                  are  bound  to ports which are pipes which
                  direct characters from FRANZ LISP  to  the
                  new process and to FRANZ LISP from the new
                  process  respectively.   _P_r_o_c_e_s_s  forks  a
                  process  named  s_prgm and waits for it to
                  die iff there are no pipe arguments given.

(ptime)

     RETURNS: a list of two  elements.   The  first  is  the
              amount of processor time used by the lisp sys-
              tem so far, and the second is  the  amount  of
              time used by the garbage collector so far.

     NOTE: the time is measured in those units used  by  the
           _t_i_m_e_s(2)  system call, usually 60_t_hs of a second.
           The first number includes the second number.  The
           amount  of time used by garbage collection is not
           recorded until the first call to ptime.  This  is
           done  to  prevent  overhead  when the user is not
           interested in garbage collection times.







9

9                                   Printed: January 31, 1984







System Functions                                         6-9


(reset)

     SIDE EFFECT: the lisp runtime stack is cleared and  the
                  system  restarts  at the top level by exe-
                  cuting a (_f_u_n_c_a_l_l _t_o_p-_l_e_v_e_l _n_i_l).

(restorelisp 's_name)

     SIDE EFFECT: this  reads  in  file  s_name  (which  was
                  created  by  _s_a_v_e_l_i_s_p)  and  then  does  a
                  (_r_e_s_e_t).

     NOTE: This is only used on VMS systems  where  _d_u_m_p_l_i_s_p
           cannot be used.

(retbrk ['x_level])

     WHERE:   x_level is a small integer of either sign.

     SIDE EFFECT: The default error handler keeps  a  notion
                  of  the current level of the error caught.
                  If x_level is negative, control is  thrown
                  to  this default error handler whose level
                  is that many less than the present, or  to
                  _t_o_p-_l_e_v_e_l  if  there  aren't  enough.   If
                  x_level is non-negative, control is passed
                  to  the handler at that level.  If x_level
                  is not present, the value -1 is  taken  by
                  default.

(*rset 'g_flag)

     RETURNS: g_flag

     SIDE EFFECT: If g_flag is non nil then the lisp  system
                  will   maintain  extra  information  about
                  calls to _e_v_a_l and  _f_u_n_c_a_l_l.   This  record
                  keeping slows down the evaluation but this
                  is required  for the  functions  _e_v_a_l_h_o_o_k,
                  _f_u_n_c_a_l_l_h_o_o_k,  and  _e_v_a_l_f_r_a_m_e  to  work. To
                  debug  compiled  lisp  code  the  transfer
                  tables       should      be      unlinked:
                  (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l)









9

9                                   Printed: January 31, 1984







System Functions                                        6-10


(savelisp 's_name)

     RETURNS: t

     SIDE EFFECT: the state of the Lisp system is  saved  in
                  the  file  s_name.   It  can be read in by
                  _r_e_s_t_o_r_e_l_i_s_p.

     NOTE: This is only used on VMS systems  where  _d_u_m_p_l_i_s_p
           cannot be used.

(segment 's_type 'x_size)

     WHERE:   s_type is one of the data types given in 1.3

     RETURNS: a  segment  of  contiguous  lispvals  of  type
              s_type.

     NOTE: In reality, _s_e_g_m_e_n_t returns a new  data  cell  of
           type  s_type  and  allocates space for x_size - 1
           more s_type's beyond the one  returned.   _S_e_g_m_e_n_t
           always  allocates  new  space  and does so in 512
           byte chunks.  If you ask for 2  fixnums,  segment
           will  actually  allocate 128 of them thus wasting
           126 fixnums.  The  function  _s_m_a_l_l-_s_e_g_m_e_n_t  is  a
           smarter  space allocator and should be used when-
           ever possible.

(shell)

     RETURNS: the exit code of the shell when it dies.

     SIDE EFFECT: this forks a new shell  and  returns  when
                  the shell dies.

(showstack)

     RETURNS: nil

     SIDE EFFECT: all  forms  currently  in  evaluation  are
                  printed,  beginning  with the most recent.
                  For compiled code the most that  showstack
                  will  show is the function name and it may
                  miss some functions.








9

9                                   Printed: January 31, 1984







System Functions                                        6-11


(signal 'x_signum 's_name)

     RETURNS: nil if no previous call  to  signal  has  been
              made, or the previously installed s_name.

     SIDE EFFECT: this  declares  that  the  function  named
                  s_name   will  handle  the  signal  number
                  x_signum.  If s_name is nil, the signal is
                  ignored.  Presently only four UNIX signals
                  are caught.  They and their  numbers  are:
                  Interrupt(2),    Floating    exception(8),
                  Alarm(14), and Hang-up(1).

(sizeof 'g_arg)

     RETURNS: the number of  bytes  required  to  store  one
              object of type g_arg, encoded as a fixnum.

(small-segment 's_type 'x_cells)

     WHERE:   s_type is one of fixnum, flonum and value.

     RETURNS: a segment of  x_cells  data  objects  of  type
              s_type.

     SIDE EFFECT: This may  call  _s_e_g_m_e_n_t  to  allocate  new
                  space  or  it  may  be  able  to  fill the
                  request on a page already allocated.   The
                  value returned by _s_m_a_l_l-_s_e_g_m_e_n_t is usually
                  stored in the data  subpart  of  an  array
                  object.

(sstatus g_type g_val)

     RETURNS: g_val

     SIDE EFFECT: If  g_type  is  not  one  of  the  special
                  sstatus  codes  described  in the next few
                  pages this simply sets g_val as the  value
                  of status type g_type in the system status
                  property list.











9

9                                   Printed: January 31, 1984







System Functions                                        6-12


(sstatus appendmap g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is non-null when _f_a_s_l is told  to
                  create  a  load map, it will append to the
                  file  name  given  in  the  _f_a_s_l  command,
                  rather  than creating a new map file.  The
                  initial value is nil.

(sstatus automatic-reset g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is non-null when an error  occurs
                  which no one wants to handle, a _r_e_s_e_t will
                  be done instead of  entering  a  primitive
                  internal break loop.  The initial value is
                  t.

(sstatus chainatom g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is non nil and a _c_a_r or _c_d_r of  a
                  symbol  is done, then nil will be returned
                  instead of an error being signaled.   This
                  only affects the interpreter, not the com-
                  piler.  The initial value is nil.

(sstatus dumpcore g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is nil,  FRANZ  LISP  tells  UNIX
                  that a segmentation violation or bus error
                  should cause a core dump.  If g_val is non
                  nil  then  FRANZ  LISP  will  catch  those
                  errors and print a  message  advising  the
                  user to reset.

     NOTE: The initial value for this flag is nil, and  only
           those  knowledgeable  of  the innards of the lisp
           system should ever set this flag non nil.








9

9                                   Printed: January 31, 1984







System Functions                                        6-13


(sstatus dumpmode x_val)

     RETURNS: x_val

     SIDE EFFECT: All subsequent _d_u_m_p_l_i_s_p's will be done  in
                  mode  x_val.   x_val  may be either 413 or
                  410 (decimal).

     NOTE: the advantage of mode 413 is that the dumped Lisp
           can  be demand paged in when first started, which
           will make it start faster and disrupt other users
           less.  The initial value is 413.

(sstatus evalhook g_val)

     RETURNS: g_val

     SIDE EFFECT: When g_val is non nil,  this  enables  the
                  evalhook  and  funcallhook  traps  in  the
                  evaluator.  See 14.4 for more details.

(sstatus feature g_val)

     RETURNS: g_val

     SIDE EFFECT: g_val is added  to  the  (_s_t_a_t_u_s _f_e_a_t_u_r_e_s)
                  list,

(sstatus gcstrings g_val)

     RETURNS: g_val

     SIDE EFFECT: if g_val is non-null, and if  string  gar-
                  bage  collection was enabled when the lisp
                  system was compiled, string space will  be
                  garbage collected.

     NOTE: the default value for this is nil since  in  most
           applications  garbage  collecting  strings  is  a
           waste of time.

(sstatus ignoreeof g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is non-null when an end  of  file
                  (CNTL-D  on UNIX) is typed to the standard
                  top-level interpreter, it will be  ignored
                  rather then cause the lisp system to exit.
                  If the the standard input  is  a  file  or
                  pipe  then this has no effect, an EOF will
                  always cause lisp to  exit.   The  initial
                  value is nil.


                                   Printed: January 31, 1984







System Functions                                        6-14


(sstatus nofeature g_val)

     RETURNS: g_val

     SIDE EFFECT: g_val is removed from the status  features
                  list if it was present.

(sstatus translink g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is nil then all  transfer  tables
                  are  cleared and further calls through the
                  transfer table will  not  cause  the  fast
                  links  to be set up.  If g_val is the sym-
                  bol _o_n then all  possible  transfer  table
                  entries  will  be linked and the flag will
                  be set to cause fast links to  be  set  up
                  dynamically.   Otherwise  all that is done
                  is to set the flag to cause fast links  to
                  be  set up dynamically.  The initial value
                  is nil.

     NOTE: For a discussion of transfer tables, see 12.8.

(sstatus uctolc g_val)

     RETURNS: g_val

     SIDE EFFECT: If g_val is not  nil  then  all  unescaped
                  capital  letters  in  symbols  read by the
                  reader will be converted to lower case.

     NOTE: This allows FRANZ LISP to be compatible with sin-
           gle  case  lisp  systems (e.g. Maclisp, Interlisp
           and UCILisp).

(status g_code)

     RETURNS: the value  associated  with  the  status  code
              g_code  if  g_code  is  not one of the special
              cases given below










9

9                                   Printed: January 31, 1984







System Functions                                        6-15


(status ctime)

     RETURNS: a symbol whose print name is the current  time
              and date.

     EXAMPLE: (_s_t_a_t_u_s _c_t_i_m_e) = |Sun Jun 29 16:51:26 1980|

     NOTE: This  has  been  made  obsolete  by  _t_i_m_e-_s_t_r_i_n_g,
           described below.

(status feature g_val)

     RETURNS: t iff g_val is in the status features list.

(status features)

     RETURNS: the value of the features  code,  which  is  a
              list  of  features  which  are present in this
              system.    You   add   to   this   list   with
              (_s_s_t_a_t_u_s _f_e_a_t_u_r_e '_g__v_a_l)  and  test if feature
              g_feat         is         present         with
              (_s_t_a_t_u_s _f_e_a_t_u_r_e '_g__f_e_a_t).

(status isatty)

     RETURNS: t iff the standard input is a terminal.

(status localtime)

     RETURNS: a list of  fixnums  representing  the  current
              time.

     EXAMPLE: (_s_t_a_t_u_s _l_o_c_a_l_t_i_m_e) =  (3 51 13 31 6 81  5  211
              1)
              means 3_r_d second, 51_s_t minute,  13_t_h  hour  (1
              p.m), 31_s_t day, month 6 (0 = January), year 81
              (0 = 1900), day of the  week  5  (0 = Sunday),
              211_t_h  day  of  the  year and daylight savings
              time is in effect.

(status syntax s_char)

     NOTE: This  function  should  not  be  used.   See  the
           description  of  _g_e_t_s_y_n_t_a_x  (in  Chapter 7) for a
           replacement.







9

9                                   Printed: January 31, 1984







System Functions                                        6-16


(status undeffunc)

     RETURNS: a list of all functions which  transfer  table
              entries  point to but which are not defined at
              this point.

     NOTE: Some of the undefined functions listed  could  be
           arrays which have yet to be created.

(status version)

     RETURNS: a string which is  the  current  lisp  version
              name.

     EXAMPLE: (_s_t_a_t_u_s _v_e_r_s_i_o_n) = "Franz Lisp, Opus 38.61"

(syscall 'x_index ['xst_arg1 ...])

     RETURNS: the result of issuing  the  UNIX  system  call
              number x_index with arguments xst_arg_i.

     NOTE: The UNIX system calls are described in section  2
           of the UNIX Programmer's manual. If xst_arg_i is a
           fixnum, then its value is passed as an  argument,
           if  it  is  a symbol then its pname is passed and
           finally if it is a string then the string  itself
           is  passed  as an argument.  Some useful syscalls
           are:
           (_s_y_s_c_a_l_l _2_0) returns process id.
           (_s_y_s_c_a_l_l _1_3) returns the number of seconds  since
           Jan 1, 1970.
           (_s_y_s_c_a_l_l _1_0 '_f_o_o) will unlink (delete)  the  file
           foo.

(sys:access 'st_filename 'x_mode)
(sys:chmod 'st_filename 'x_mode)
(sys:gethostname)
(sys:getpid)
(sys:getpwnam 'st_username)
(sys:link 'st_oldfilename 'st_newfilename)
(sys:time)
(sys:unlink 'st_filename)

     NOTE: We have been warned that the actual  system  call
           numbers  may  vary  among different UNIX systems.
           Users concerned about portability may wish to use
           this  group  of  functions.  Another advantage is
           that tilde-expansion is performed on all filename
           arguments.   These functions do what is described
           in the system call section of your UNIX manual.

           _s_y_s:_g_e_t_p_w_n_a_m returns a  vector  of  four  entries
           from the password file, being the user name, user


                                   Printed: January 31, 1984







System Functions                                        6-17


           id, group id, and home directory.

(time-string ['x_seconds])

     RETURNS: an ascii string giving the time and date which
              was  x_seconds  after  UNIX's idea of creation
              (Midnight, Jan 1, 1970 GMT).  If  no  argument
              is  given,  time-string  returns  the  current
              date.  This supplants (_s_t_a_t_u_s _c_t_i_m_e), and  may
              be  used  to make the results of _f_i_l_e_s_t_a_t more
              intelligible.

(top-level)

     RETURNS: nothing (it never returns)

     NOTE: This function is  the  top-level  read-eval-print
           loop.   It  never  returns  any  value.  Its main
           utility is that if you  redefine  it,  and  do  a
           (reset)  then  the  redefined (top-level) is then
           invoked.  The default top-level for Franz,  allow
           one  to  specify  his  own  printer or reader, by
           binding the symbols  top-level-printer  and  top-
           level-reader.   One can let the default top-level
           do most of the drudgery in catching _r_e_s_e_t's,  and
           reading  in  .lisprc files, by binding the symbol
           user-top-level, to a routine that concerns itself
           only with the read-eval-print loop.

(wait)

     RETURNS: a dotted pair (_p_r_o_c_e_s_s_i_d .  _s_t_a_t_u_s)  when  the
              next child process dies.



















9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch61.r  << 'EndOfFile'







                        CHAPTER  61


                           Local




     This chapter describes functions which we found  useful
at Berkeley.  Some of these functions may be useful at other
sites









































9

9Local



EndOfFile
cat >  lisplib/manual/ch7.r  << 'EndOfFile'







                         CHAPTER  7


                      The Lisp Reader






   7.1.  Introduction

           The _r_e_a_d function is responsible for converting a
      stream  of characters into a Lisp expression.  _R_e_a_d is
      table driven and the table it uses is called a  _r_e_a_d_t_-
      _a_b_l_e.  The _p_r_i_n_t function does the inverse of _r_e_a_d; it
      converts a Lisp expression into a  stream  of  charac-
      ters.   Typically the conversion is done in such a way
      that if that stream of characters were read  by  _r_e_a_d,
      the  result  would  be  an expression equal to the one
      _p_r_i_n_t was given.  _P_r_i_n_t must also refer to the  readt-
      able  in  order to determine how to format its output.
      The _e_x_p_l_o_d_e function, which returns a list of  charac-
      ters  rather  than  printing them,  must also refer to
      the readtable.

           A readtable is  created  with  the  _m_a_k_e_r_e_a_d_t_a_b_l_e
      function,  modified  with  the  _s_e_t_s_y_n_t_a_x function and
      interrogated with the _g_e_t_s_y_n_t_a_x function.  The  struc-
      ture  of  a  readtable  is  hidden  from the user  - a
      readtable should only be manipulated  with  the  three
      functions mentioned above.

           There is one distinguished readtable  called  the
      _c_u_r_r_e_n_t  _r_e_a_d_t_a_b_l_e  whose  value determines what _r_e_a_d,
      _p_r_i_n_t and _e_x_p_l_o_d_e do.  The current  readtable  is  the
      value  of  the symbol _r_e_a_d_t_a_b_l_e.  Thus it is  possible
      to rapidly change the current syntax by lambda binding
      a  different  readtable to the symbol _r_e_a_d_t_a_b_l_e.  When
      the binding is undone, the syntax reverts to  its  old
      form.



   7.2.  Syntax Classes

           The readtable describes how each of the 128 ascii
      characters   should  be  treated  by  the  reader  and
      printer.  Each character belongs  to  a  _s_y_n_t_a_x  _c_l_a_s_s
      which has three properties:

      character class -
           Tells what the reader should do when it sees this


The Lisp Reader                                          7-1







The Lisp Reader                                          7-2


           character.  There are a large number of character
           classes. They are described below.

      separator -
           Most types of tokens the  reader  constructs  are
           one  character  long.   Four  token types have an
           arbitrary length:  number  (1234),  symbol  print
           name   (franz),   escaped   symbol   print   name
           (|franz|), and string ("franz").  The reader  can
           easily  determine  when it has come to the end of
           one of the last two types: it just looks for  the
           matching  delimiter (| or ").  When the reader is
           reading a number or symbol print name,  it  stops
           reading  when  it  comes  to a character with the
           _s_e_p_a_r_a_t_o_r property.  The separator  character  is
           pushed back into the input stream and will be the
           first character read when the  reader  is  called
           again.

      escape -
           Tells the printer when to put  escapes  in  front
           of, or around, a symbol whose print name contains
           this character.  There are  three  possibilities:
           always escape a symbol with this character in it,
           only escape a symbol if this is the only  charac-
           ter  in  the  symbol, and only escape a symbol if
           this  is  the  first  character  in  the  symbol.
           [note:  The  printer  will always escape a symbol
           which, if printed out, would look  like  a  valid
           number.]

           When the Lisp system is built, Lisp code is added
      to  a  C-coded kernel and the result becomes the stan-
      dard lisp system.  The readtable  present  in  the  C-
      coded  kernel,  called the _r_a_w _r_e_a_d_t_a_b_l_e, contains the
      bare necessities for reading in Lisp code.  During the
      construction  of  the  complete Lisp system, a copy is
      made of the raw readtable and then the copy  is  modi-
      fied  by  adding macro characters.  The result is what
      is called the _s_t_a_n_d_a_r_d _r_e_a_d_t_a_b_l_e.  When a  new  readt-
      able  is created with _m_a_k_e_r_e_a_d_t_a_b_l_e, a copy is made of
      either the raw  readtable  or  the  current  readtable
      (which is likely to be the standard readtable).



   7.3.  Reader Operations

           The reader has a very simple  algorithm.   It  is
      either  _s_c_a_n_n_i_n_g  for  a token, _c_o_l_l_e_c_t_i_n_g a token, or
      _p_r_o_c_e_s_s_i_n_g a token.  Scanning involves reading charac-
      ters  and throwing away those which don't start tokens
      (such as blanks and tabs).  Collecting means gathering


                                   Printed: January 31, 1984







The Lisp Reader                                          7-3


      the  characters  which  make up a token into a buffer.
      Processing  may  involve  creating  symbols,  strings,
      lists,  fixnums,  bignums or flonums or calling a user
      written function called a character macro.

           The components of the syntax class determine when
      the  reader  switches between the scanning, collecting
      and processing states.  The reader will continue scan-
      ning  as long as the character class of the characters
      it reads is _c_s_e_p_a_r_a_t_o_r.  When  it  reads  a  character
      whose character class is not _c_s_e_p_a_r_a_t_o_r it stores that
      character in its  buffer  and  begins  the  collecting
      phase.

           If the character class of that first character is
      _c_c_h_a_r_a_c_t_e_r,  _c_n_u_m_b_e_r, _c_p_e_r_i_o_d, or _c_s_i_g_n.  then it will
      continue collecting until it  runs  into  a  character
      whose  syntax class has the _s_e_p_a_r_a_t_o_r property.  (That
      last character will be  pushed  back  into  the  input
      buffer  and  will  be  the  first  character read next
      time.) Now the reader goes into the processing  phase,
      checking  to  see  if the token it read is a number or
      symbol.  It is important to note that  after the first
      character  is  collected  the  component of the syntax
      class which tells the reader to   stop  collecting  is
      the _s_e_p_a_r_a_t_o_r property, not the character class.

           If the character class  of  the  character  which
      stopped  the  scanning  is  not  _c_c_h_a_r_a_c_t_e_r,  _c_n_u_m_b_e_r,
      _c_p_e_r_i_o_d, or _c_s_i_g_n.  then  the  reader  processes  that
      character    immediately.    The   character   classes
      _c_s_i_n_g_l_e-_m_a_c_r_o,  _c_s_i_n_g_l_e-_s_p_l_i_c_i_n_g-_m_a_c_r_o,  and  _c_s_i_n_g_l_e-
      _i_n_f_i_x-_m_a_c_r_o  will act like _c_c_h_a_r_a_c_t_e_r if the following
      token is not a _s_e_p_a_r_a_t_o_r.   The  processing  which  is
      done  for  a  given  character  class  is described in
      detail in the next section.



   7.4.  Character Classes


_c_c_h_a_r_a_c_t_e_r    raw readtable:A-Z a-z ^H !#$%&*,/:;<=>?@^_`{}~
            standard readtable:A-Z a-z ^H !$%&*/:;<=>?@^_{}~
      A normal character.


_c_n_u_m_b_e_r                                    raw readtable:0-9
                                      standard readtable:0-9
      This type is a digit. The syntax for an integer  (fix-
      num  or  bignum)  is  a  string  of _c_n_u_m_b_e_r characters
      optionally followed by a _c_p_e_r_i_o_d.  If the  digits  are
      not  followed  by a _c_p_e_r_i_o_d, then they are interpreted


                                   Printed: January 31, 1984







The Lisp Reader                                          7-4


      in base _i_b_a_s_e which must be eight or ten.  The  syntax
      for  a  floating  point  number is either zero or more
      _c_n_u_m_b_e_r's followed by a _c_p_e_r_i_o_d and then  followed  by
      one  or  more  _c_n_u_m_b_e_r's.  A floating point number may
      also be  an integer or floating point number  followed
      by 'e' or 'd', an optional '+' or '-' and then zero or
      more _c_n_u_m_b_e_r's.


_c_s_i_g_n                                       raw readtable:+-
                                       standard readtable:+-
      A leading sign  for  a  number.  No  other  characters
      should be given this class.


_c_l_e_f_t_-_p_a_r_e_n                                  raw readtable:(
                                        standard readtable:(
      A left parenthesis.  Tells the reader to begin forming
      a list.


_c_r_i_g_h_t_-_p_a_r_e_n                                 raw readtable:)
                                        standard readtable:)
      A right parenthesis.  Tells the  reader  that  it  has
      reached the end of a list.


_c_l_e_f_t_-_b_r_a_c_k_e_t                                raw readtable:[
                                        standard readtable:[
      A left bracket.  Tells the reader that it should begin
      forming a list.  See the description of _c_r_i_g_h_t-_b_r_a_c_k_e_t
      for the difference between  cleft-bracket  and  cleft-
      paren.


_c_r_i_g_h_t_-_b_r_a_c_k_e_t                               raw readtable:]
                                        standard readtable:]
      A right bracket.  A _c_r_i_g_h_t-_b_r_a_c_k_e_t finishes the forma-
      tion of the current list and all enclosing lists until
      it finds one which  begins  with  a  _c_l_e_f_t-_b_r_a_c_k_e_t  or
      until it reaches the top level list.


_c_p_e_r_i_o_d                                      raw readtable:.
                                        standard readtable:.
      The period is used to separate element of a cons  cell
      [e.g.  (a . (b . nil)) is the same as (a b)].  _c_p_e_r_i_o_d
      is also used in numbers as described above.


_c_s_e_p_a_r_a_t_o_r                     raw readtable:^I-^M esc space
                          standard readtable:^I-^M esc space
      Separates tokens.  When the reader is scanning,  these


                                   Printed: January 31, 1984







The Lisp Reader                                          7-5


      character  are  passed over.  Note: there is a differ-
      ence between the _c_s_e_p_a_r_a_t_o_r character  class  and  the
      _s_e_p_a_r_a_t_o_r property of a syntax class.


_c_s_i_n_g_l_e_-_q_u_o_t_e                                raw readtable:'
                                        standard readtable:'
      This causes _r_e_a_d to be called recursively and the list
      (quote <value read>) to be returned.


_c_s_y_m_b_o_l_-_d_e_l_i_m_i_t_e_r                            raw readtable:|
                                        standard readtable:|
      This causes the reader to begin collecting  characters
      and  to  stop  only  when  another  identical _c_s_y_m_b_o_l-
      _d_e_l_i_m_i_t_e_r is seen. The only way to escape  a  _c_s_y_m_b_o_l-
      _d_e_l_i_m_i_t_e_r within a symbol name is with a _c_e_s_c_a_p_e char-
      acter.  The collected characters are converted into  a
      string which becomes the print name of a symbol.  If a
      symbol with an identical print  name  already  exists,
      then  the  allocation is not done, rather the existing
      symbol is used.


_c_e_s_c_a_p_e                                      raw readtable:\
                                        standard readtable:\
      This causes the  next  character  to  read  in  to  be
      treated  as  a  vcharacter.   A character whose syntax
      class is vcharacter has a character  class  _c_c_h_a_r_a_c_t_e_r
      and  does  not  have the _s_e_p_a_r_a_t_o_r property so it will
      not separate symbols.


_c_s_t_r_i_n_g_-_d_e_l_i_m_i_t_e_r                            raw readtable:"
                                        standard readtable:"
      This is  the  same  as  _c_s_y_m_b_o_l-_d_e_l_i_m_i_t_e_r  except  the
      result is returned as a string instead of a symbol.


_c_s_i_n_g_l_e_-_c_h_a_r_a_c_t_e_r_-_s_y_m_b_o_l                  raw readtable:none
                                     standard readtable:none
      This returns a symbol whose print name is the the sin-
      gle character which has been collected.


_c_m_a_c_r_o                                    raw readtable:none
                                       standard readtable:`,
      The reader calls the macro  function  associated  with
      this  character  and the current readtable, passing it
      no arguments.  The result of the macro is added to the
      structure the reader is building, just as if that form
      were directly read by the  reader.   More  details  on
      macros are provided below.


                                   Printed: January 31, 1984







The Lisp Reader                                          7-6


_c_s_p_l_i_c_i_n_g_-_m_a_c_r_o                           raw readtable:none
                                       standard readtable:#;
      A _c_s_p_l_i_c_i_n_g-_m_a_c_r_o differs from a _c_m_a_c_r_o in the way the
      result  is incorporated in the structure the reader is
      building.  A _c_s_p_l_i_c_i_n_g-_m_a_c_r_o must  return  a  list  of
      forms (possibly empty).  The reader acts as if it read
      each element of the list itself without the  surround-
      ing parenthesis.


_c_s_i_n_g_l_e_-_m_a_c_r_o                             raw readtable:none
                                     standard readtable:none
      This causes to reader to check the next character.  If
      it is a _c_s_e_p_a_r_a_t_o_r then this acts like a _c_m_a_c_r_o.  Oth-
      erwise, it acts like a _c_c_h_a_r_a_c_t_e_r.


_c_s_i_n_g_l_e_-_s_p_l_i_c_i_n_g_-_m_a_c_r_o                    raw readtable:none
                                     standard readtable:none
      This is triggered like  a  _c_s_i_n_g_l_e-_m_a_c_r_o  however  the
      result is spliced in like a _c_s_p_l_i_c_i_n_g-_m_a_c_r_o.


_c_i_n_f_i_x_-_m_a_c_r_o                              raw readtable:none
                                     standard readtable:none
      This is differs from a _c_m_a_c_r_o in that the macro  func-
      tion is passed a form representing what the reader has
      read so far. The result of the macro replaces what the
      reader had read so far.


_c_s_i_n_g_l_e_-_i_n_f_i_x_-_m_a_c_r_o                       raw readtable:none
                                     standard readtable:none
      This differs from the _c_i_n_f_i_x-_m_a_c_r_o in that  the  macro
      will  only be triggered if the character following the
      _c_s_i_n_g_l_e-_i_n_f_i_x-_m_a_c_r_o character is a _c_s_e_p_a_r_a_t_o_r.


_c_i_l_l_e_g_a_l                 raw readtable:^@-^G^N-^Z^\-^_rubout
                    standard readtable:^@-^G^N-^Z^\-^_rubout
      The characters cause the reader to signal an error  if
      read.



   7.5.  Syntax Classes

           The readtable maps each character into  a  syntax
      class.   The  syntax  class  contains  three pieces of
      information: the character class, whether  this  is  a
      separator,  and  the escape properties.  The first two
      properties are used by the reader,  the  last  by  the
      printer  (and  _e_x_p_l_o_d_e).   The initial lisp system has


                                   Printed: January 31, 1984







The Lisp Reader                                          7-7


      the following syntax classes defined.   The  user  may
      add  syntax  classes  with _a_d_d-_s_y_n_t_a_x-_c_l_a_s_s.  For each
      syntax class, we list the properties of the class  and
      which  characters  have  this syntax class by default.
      More information about each syntax class can be  found
      under  the description of the syntax class's character
      class.

vcharacter    raw readtable:A-Z a-z ^H !#$%&*,/:;<=>?@^_`{}~
_c_c_h_a_r_a_c_t_e_r  standard readtable:A-Z a-z ^H !$%&*/:;<=>?@^_{}~



vnumber                                    raw readtable:0-9
_c_n_u_m_b_e_r                               standard readtable:0-9



vsign                                       raw readtable:+-
_c_s_i_g_n                                  standard readtable:+-



vleft-paren                                  raw readtable:(
_c_l_e_f_t_-_p_a_r_e_n                             standard readtable:(
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vright-paren                                 raw readtable:)
_c_r_i_g_h_t_-_p_a_r_e_n                            standard readtable:)
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vleft-bracket                                raw readtable:[
_c_l_e_f_t_-_b_r_a_c_k_e_t                           standard readtable:[
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vright-bracket                               raw readtable:]
_c_r_i_g_h_t_-_b_r_a_c_k_e_t                          standard readtable:]
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vperiod                                      raw readtable:.
_c_p_e_r_i_o_d                                 standard readtable:.
_e_s_c_a_p_e_-_w_h_e_n_-_u_n_i_q_u_e


vseparator                     raw readtable:^I-^M esc space
_c_s_e_p_a_r_a_t_o_r                standard readtable:^I-^M esc space
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r
9

9                                   Printed: January 31, 1984







The Lisp Reader                                          7-8


vsingle-quote                                raw readtable:'
_c_s_i_n_g_l_e_-_q_u_o_t_e                           standard readtable:'
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vsymbol-delimiter                            raw readtable:|
_c_s_i_n_g_l_e_-_d_e_l_i_m_i_t_e_r                       standard readtable:|
_e_s_c_a_p_e_-_a_l_w_a_y_s


vescape                                      raw readtable:\
_c_e_s_c_a_p_e                                 standard readtable:\
_e_s_c_a_p_e_-_a_l_w_a_y_s


vstring-delimiter                            raw readtable:"
_c_s_t_r_i_n_g_-_d_e_l_i_m_i_t_e_r                       standard readtable:"
_e_s_c_a_p_e_-_a_l_w_a_y_s


vsingle-character-symbol                  raw readtable:none
_c_s_i_n_g_l_e_-_c_h_a_r_a_c_t_e_r_-_s_y_m_b_o_l             standard readtable:none
_s_e_p_a_r_a_t_o_r


vmacro                                    raw readtable:none
_c_m_a_c_r_o                                 standard readtable:`,
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vsplicing-macro                           raw readtable:none
_c_s_p_l_i_c_i_n_g_-_m_a_c_r_o                        standard readtable:#;
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vsingle-macro                             raw readtable:none
_c_s_i_n_g_l_e_-_m_a_c_r_o                        standard readtable:none
_e_s_c_a_p_e_-_w_h_e_n_-_u_n_i_q_u_e


vsingle-splicing-macro                    raw readtable:none
_c_s_i_n_g_l_e_-_s_p_l_i_c_i_n_g_-_m_a_c_r_o               standard readtable:none
_e_s_c_a_p_e_-_w_h_e_n_-_u_n_i_q_u_e


vinfix-macro                              raw readtable:none
_c_i_n_f_i_x_-_m_a_c_r_o                         standard readtable:none
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r

vsingle-infix-macro                       raw readtable:none
_c_s_i_n_g_l_e_-_i_n_f_i_x_-_m_a_c_r_o                  standard readtable:none
_e_s_c_a_p_e_-_w_h_e_n_-_u_n_i_q_u_e


                                   Printed: January 31, 1984







The Lisp Reader                                          7-9




villegal                 raw readtable:^@-^G^N-^Z^\-^_rubout
_c_i_l_l_e_g_a_l            standard readtable:^@-^G^N-^Z^\-^_rubout
_e_s_c_a_p_e_-_a_l_w_a_y_s
_s_e_p_a_r_a_t_o_r



   7.6.  Character Macros

           Character macros are user written functions which
      are  executed  during  the reading process.  The value
      returned by a character macro may or may not  be  used
      by  the reader, depending on the type of macro and the
      value returned.  Character macros are always  attached
      to a single character with the _s_e_t_s_y_n_t_a_x function.



      7.6.1.  Types   There are  three  types  of  character
         macros:  normal,  splicing  and infix.  These types
         differ in the arguments they are given or  in  what
         is done with the result they return.



         7.6.1.1.  Normal

                 A normal macro is passed no arguments.  The
            value  returned by a normal macro is simply used
            by the reader  as  if  it  had  read  the  value
            itself.   Here  is  an  example of a macro which
            returns the abbreviation for a given state.


    ____________________________________________________

    ->(_d_e_f_u_n _s_t_a_t_e_a_b_b_r_e_v _n_i_l
         (_c_d_r (_a_s_s_q (_r_e_a_d) '((_c_a_l_i_f_o_r_n_i_a . _c_a) (_p_e_n_n_s_y_l_v_a_n_i_a . _p_a)))))
    stateabbrev
    -> (_s_e_t_s_y_n_t_a_x '_\! '_v_m_a_c_r_o '_s_t_a_t_e_a_b_b_r_e_v)
    t
    -> '( ! _c_a_l_i_f_o_r_n_i_a ! _w_y_o_m_i_n_g ! _p_e_n_n_s_y_l_v_a_n_i_a)
    (ca nil pa)
    ____________________________________________________



Notice what happened to
 ! _w_y_o_m_i_n_g.  Since it wasn't in the  table,  the  associated
function  returned  nil.   The creator of the macro may have
wanted to leave the list alone, in such a case, but couldn't


                                   Printed: January 31, 1984







The Lisp Reader                                         7-10


with  this  type  of  reader  macro.   The  splicing  macro,
described next, allows a character macro function to  return
a value that is ignored.



         7.6.1.2.  Splicing

                 The value returned from  a  splicing  macro
            must  be  a  list  or nil.  If the value is nil,
            then the value is ignored, otherwise the  reader
            acts  as  if  it  read  each object in the list.
            Usually the list only contains one  element.  If
            the reader is reading at the top level (i.e. not
            collecting elements of list), then it is illegal
            for  a  splicing  macro  to return more then one
            element in the list.  The major advantage  of  a
            splicing  macro over a normal macro is the abil-
            ity of the splicing macro to return nothing. The
            comment  character  (usually  ;)  is  a splicing
            macro bound to a function which reads to the end
            of the line and always returns nil.  Here is the
            previous example written as a splicing macro


    ____________________________________________________

    -> (_d_e_f_u_n _s_t_a_t_e_a_b_b_r_e_v _n_i_l
          ((_l_a_m_b_d_a (_v_a_l_u_e)
               (_c_o_n_d (_v_a_l_u_e (_l_i_s_t _v_a_l_u_e))
                     (_t _n_i_l)))
           (_c_d_r (_a_s_s_q (_r_e_a_d) '((_c_a_l_i_f_o_r_n_i_a . _c_a) (_p_e_n_n_s_y_l_v_a_n_i_a . _p_a))))))
    -> (_s_e_t_s_y_n_t_a_x '! '_v_s_p_l_i_c_i_n_g-_m_a_c_r_o '_s_t_a_t_e_a_b_b_r_e_v)
    -> '(!_p_e_n_n_s_y_l_v_a_n_i_a ! _f_o_o !_c_a_l_i_f_o_r_n_i_a)
    (pa ca)
    -> '!_f_o_o !_b_a_r !_p_e_n_n_s_y_l_v_a_n_i_a
    pa
    ->
    ____________________________________________________






         7.6.1.3.  Infix

                 Infix macros are passed  a  _c_o_n_c  structure
            representing   what   has   been  read  so  far.
            Briefly, a tconc structure is a single list cell
            whose  car points to a list and whose cdr points
            to  the  last  list  cell  in  that  list.   The
            interpretation   by  the  reader  of  the  value


                                   Printed: January 31, 1984







The Lisp Reader                                         7-11


            returned by  an infix macro depends  on  whether
            the  macro  is  called  while the reader is con-
            structing a list or whether it is called at  the
            top level of the reader.  If the macro is called
            while a list  is  being  constructed,  then  the
            value  returned  should  be   a tconc structure.
            The car of that structure replaces the  list  of
            elements  that  the  reader has been collecting.
            If the macro is called at  top  level,  then  it
            will  be  passed the value nil, and the value it
            returns should either be nil or a  tconc  struc-
            ture.   If the macro returns nil, then the value
            is ignored and the reader continues to read.  If
            the  macro returns a tconc structure of one ele-
            ment (i.e. whose car is a list of one  element),
            then  that  single  element  is  returned as the
            value of _r_e_a_d.  If the  macro  returns  a  tconc
            structure  of  more  than one element, then that
            list of elements is returned  as  the  value  of
            read.


    ____________________________________________________

    -> (_d_e_f_u_n _p_l_u_s_o_p (_x)
          (_c_o_n_d ((_n_u_l_l _x) (_t_c_o_n_c _n_i_l '_\+))
                (_t (_l_c_o_n_c _n_i_l (_l_i_s_t '_p_l_u_s (_c_a_a_r _x) (_r_e_a_d))))))

    plusop
    -> (_s_e_t_s_y_n_t_a_x '_\+ '_v_i_n_f_i_x-_m_a_c_r_o '_p_l_u_s_o_p)
    t
    -> '(_a + _b)
    (plus a b)
    -> '+
    |+|
    ->
    ____________________________________________________






      7.6.2.  Invocations

              There are  three  different  circumstances  in
         which  you  would like a macro function to be trig-
         gered.

         _A_l_w_a_y_s -
              Whenever the  macro  character  is  seen,  the
              macro should be invoked.  This is accomplished
              by  using  the   character   classes   _c_m_a_c_r_o,


                                   Printed: January 31, 1984







The Lisp Reader                                         7-12


              _c_s_p_l_i_c_i_n_g-_m_a_c_r_o, or _c_i_n_f_i_x-_m_a_c_r_o, and by using
              the _s_e_p_a_r_a_t_o_r property.   The  syntax  classes
              vmacro, vsplicing-macro, and vsingle-macro are
              defined this way.

         _W_h_e_n _f_i_r_s_t -
              The macro should only be  triggered  when  the
              macro  character  is the first character found
              after the scanning process.   A  syntax  class
              for  a _w_h_e_n _f_i_r_s_t macro would be defined using
              _c_m_a_c_r_o, _c_s_p_l_i_c_i_n_g-_m_a_c_r_o, or  _c_i_n_f_i_x-_m_a_c_r_o  and
              not including the _s_e_p_a_r_a_t_o_r property.

         _W_h_e_n _u_n_i_q_u_e -
              The macro should only be  triggered  when  the
              macro  character  is  the  only character col-
              lected in the token collection  phase  of  the
              reader,  i.e  the macro character is preceeded
              by zero or more _c_s_e_p_a_r_a_t_o_rs and followed by  a
              _s_e_p_a_r_a_t_o_r.   A  syntax class for a _w_h_e_n _u_n_i_q_u_e
              macro would be  defined  using  _c_s_i_n_g_l_e-_m_a_c_r_o,
              _c_s_i_n_g_l_e-_s_p_l_i_c_i_n_g-_m_a_c_r_o, or _c_s_i_n_g_l_e-_i_n_f_i_x-_m_a_c_r_o
              and not including the _s_e_p_a_r_a_t_o_r property.  The
              syntax  classes  so defined are vsingle-macro,
              vsingle-splicing-macro,   and   vsingle-infix-
              macro.



   7.7.  Functions

(setsyntax 's_symbol 's_synclass ['ls_func])

     WHERE:   ls_func is the name of a function or a  lambda
              body.

     RETURNS: t

     SIDE EFFECT: S_symbol should be a  symbol  whose  print
                  name  is  only  one character.  The syntax
                  class  for  that  character  is   set   to
                  s_synclass  in  the current readtable.  If
                  s_synclass is  a  class  that  requires  a
                  character macro, then ls_func must be sup-
                  plied.

     NOTE: The symbolic syntax codes are  new  to  Opus  38.
           For  compatibility,  s_synclass can be one of the
           fixnum syntax codes which appeared in older  ver-
           sions of the FRANZ LISP Manual.  This compatibil-
           ity is only temporary: existing code  which  uses
           the fixnum syntax codes should be converted.
9

9                                   Printed: January 31, 1984







The Lisp Reader                                         7-13


(getsyntax 's_symbol)

     RETURNS: the syntax class of  the  first  character  of
              s_symbol's  print name.  s_symbol's print name
              must be exactly one character long.

     NOTE: This function is new to Opus 38.   It  supercedes
           (_s_t_a_t_u_s _s_y_n_t_a_x) which no longer exists.

(add-syntax-class 's_synclass 'l_properties)

     RETURNS: s_synclass

     SIDE EFFECT: Defines the  syntax  class  s_synclass  to
                  have  properties  l_properties.   The list
                  l_properties should  contain  a  character
                  classes mentioned above.  l_properties may
                  contain  one  of  the  escape  properties:
                  _e_s_c_a_p_e-_a_l_w_a_y_s,    _e_s_c_a_p_e-_w_h_e_n-_u_n_i_q_u_e,   or
                  _e_s_c_a_p_e-_w_h_e_n-_f_i_r_s_t.  l_properties may  con-
                  tain the _s_e_p_a_r_a_t_o_r property.  After a syn-
                  tax  class  has  been  defined  with  _a_d_d-
                  _s_y_n_t_a_x-_c_l_a_s_s,  the  _s_e_t_s_y_n_t_a_x function can
                  be used to  give  characters  that  syntax
                  class.


    ____________________________________________________

    ; Define a non-separating macro character.
    ; This type of macro character is used in UCI-Lisp, and
    ; it corresponds to a  FIRST MACRO in Interlisp
    -> (_a_d_d-_s_y_n_t_a_x-_c_l_a_s_s '_v_u_c_i-_m_a_c_r_o '(_c_m_a_c_r_o _e_s_c_a_p_e-_w_h_e_n-_f_i_r_s_t))
    vuci-macro
    ->
    ____________________________________________________
















9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch8.r  << 'EndOfFile'







                         CHAPTER  8


              Functions, Fclosures, and Macros






   8.1.  valid function objects

           There are many different objects which can occupy
      the  function field of a symbol object.  Table 8.1, on
      the following page, shows all  of  the  possibilities,
      how  to recognize them, and where to look for documen-
      tation.



   8.2.  functions

           The basic Lisp function is the  lambda  function.
      When a lambda function is called, the actual arguments
      are evaluated from left to right and are  lambda-bound
      to the formal parameters of the lambda function.

           An nlambda function is usually used for functions
      which  are  invoked  by  the  user at top level.  Some
      built-in functions which evaluate their  arguments  in
      special  ways  are  also  nlambdas (e.g _c_o_n_d, _d_o, _o_r).
      When an  nlambda  function  is  called,  the  list  of
      unevaluated  arguments  is  lambda bound to the single
      formal parameter of the nlambda function.

           Some programmers will  use  an  nlambda  function
      when  they  are  not  sure  how many arguments will be
      passed.  Then, the first thing  the  nlambda  function
      does  is  map  _e_v_a_l over the list of unevaluated argu-
      ments it has been passed.  This is usually  the  wrong
      thing  to  do,  as it will not work compiled if any of
      the arguments are local variables. The solution is  to
      use  a  lexpr.   When  a lexpr function is called, the
      arguments are evaluated and a fixnum  whose  value  is
      the  number of arguments is lambda-bound to the single
      formal parameter of the lexpr function.  The lexpr can
      then access the arguments using the _a_r_g function.

           When a function is compiled, _s_p_e_c_i_a_l declarations
      may  be  needed to preserve its behavior.  An argument
      is not lambda-bound to the name of  the  corresponding
      formal parameter unless that formal parameter has been
      declared _s_p_e_c_i_a_l (see 12.3.2.2).


Functions, Fclosures, and Macros                         8-1







Functions, Fclosures, and Macros                         8-2





8_________________________________________________________________
   informal name             object type          documentation
8__________________________________________________________________________________________________________________________________
    interpreted             list with _c_a_r              8.2
  lambda function           _e_q to lambda
8_________________________________________________________________
    interpreted             list with _c_a_r              8.2
  nlambda function          _e_q to nlambda
8_________________________________________________________________
    interpreted             list with _c_a_r              8.2
   lexpr function            _e_q to lexpr
8_________________________________________________________________
    interpreted             list with _c_a_r              8.3
       macro                 _e_q to macro
8_________________________________________________________________
      fclosure            vector with _v_p_r_o_p            8.4
                           _e_q to fclosure
8_________________________________________________________________
      compiled         binary with discipline          8.2
  lambda or lexpr           _e_q to lambda
      function
8_________________________________________________________________
      compiled         binary with discipline          8.2
  nlambda function          _e_q to nlambda
8_________________________________________________________________
      compiled         binary with discipline          8.3
       macro                 _e_q to macro
8_________________________________________________________________
      foreign          binary with discipline          8.5
     subroutine          of "subroutine"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
      function            of "function"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
  integer function    of "integer-function"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
   real function        of "real-function"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
     C function          of "c-function"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
  double function     of "double-c-function"[|-]
8_________________________________________________________________
      foreign          binary with discipline          8.5
 structure function   of "vector-c-function"[|-]
8_________________________________________________________________
       array                array object                9
8_________________________________________________________________
7|8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|







































9                   |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|







































9                                               |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|







































9                                                                |8|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|7|









































9                         Table 8.1

____________________
9   [|-]Only the first character of the string is significant (i.e "s"
is ok for "subroutine")



9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-3


           Lambda and lexpr functions both  compile  into  a
      binary object with a discipline of lambda.  However, a
      compiled lexpr still acts like an interpreted lexpr.



   8.3.  macros

           An important feature of Lisp is  its  ability  to
      manipulate  programs  as  data.   As a result of this,
      most Lisp implementations  have  very  powerful  macro
      facilities.  The Lisp language's macro facility can be
      used to incorporate  popular  features  of  the  other
      languages  into  Lisp.   For  example, there are macro
      packages which allow one to create records  (ala  Pas-
      cal)  and  refer  to  elements of those records by the
      field names.  The _s_t_r_u_c_t package imported from Maclisp
      does  this.   Another  popular  use  for  macros is to
      create more readable control structures  which  expand
      into  _c_o_n_d,  _o_r  and  _a_n_d.  One such example is the If
      macro.  It allows you to write

      (_I_f (_e_q_u_a_l _n_u_m_b _0) _t_h_e_n (_p_r_i_n_t '_z_e_r_o) (_t_e_r_p_r)
       _e_l_s_e_i_f (_e_q_u_a_l _n_u_m_b _1) _t_h_e_n (_p_r_i_n_t '_o_n_e) (_t_e_r_p_r)
       _e_l_s_e (_p_r_i_n_t '|_I _g_i_v_e _u_p|))

      which expands to

      (_c_o_n_d
          ((_e_q_u_a_l _n_u_m_b _0) (_p_r_i_n_t '_z_e_r_o) (_t_e_r_p_r))
          ((_e_q_u_a_l _n_u_m_b _1) (_p_r_i_n_t '_o_n_e) (_t_e_r_p_r))
          (_t (_p_r_i_n_t '|_I _g_i_v_e _u_p|)))




      8.3.1.  macro forms

              A macro is a function  which  accepts  a  Lisp
         expression   as  input  and  returns  another  Lisp
         expression.  The action the macro takes  is  called
         macro expansion.  Here is a simple example:

         -> (_d_e_f _f_i_r_s_t (_m_a_c_r_o (_x) (_c_o_n_s '_c_a_r (_c_d_r _x))))
         first
         -> (_f_i_r_s_t '(_a _b _c))
         a
         -> (_a_p_p_l_y '_f_i_r_s_t '(_f_i_r_s_t '(_a _b _c)))
         (car '(a b c))

         The first input line defines a macro called  _f_i_r_s_t.
         Notice  that the macro has one formal parameter, _x.
         On the second input line, we ask the interpreter to


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-4


         evaluate  (_f_i_r_s_t '(_a _b _c)).   _E_v_a_l  sees that _f_i_r_s_t
         has a function definition  of  type  macro,  so  it
         evaluates  _f_i_r_s_t's definition, passing to _f_i_r_s_t, as
         an argument, the form _e_v_a_l  itself  was  trying  to
         evaluate:  (_f_i_r_s_t '(_a _b _c)).  The _f_i_r_s_t macro chops
         off the car of the argument with _c_d_r, cons'  a  _c_a_r
         at   the   beginning   of   the  list  and  returns
         (_c_a_r '(_a _b _c)), which _e_v_a_l evaluates.  The value  _a
         is returned as the value of (_f_i_r_s_t '(_a _b _c)).  Thus
         whenever _e_v_a_l tries to evaluate a  list  whose  car
         has  a macro definition it ends up doing (at least)
         two operations, the first of which is a call to the
         macro  to  let  it  macro  expand the form, and the
         other is the evaluation of the result of the macro.
         The  result of the macro may be yet another call to
         a macro, so _e_v_a_l may have to do even  more  evalua-
         tions  until it can finally determine the  value of
         an expression.  One way to see  how  a  macro  will
         expand  is to use _a_p_p_l_y as shown on the third input
         line above.



      8.3.2.  defmacro

              The macro _d_e_f_m_a_c_r_o makes it easier  to  define
         macros  because it allows you to name the arguments
         to the macro call.  For example,  suppose  we  find
         ourselves      often      writing     code     like
         (_s_e_t_q _s_t_a_c_k (_c_o_n_s _n_e_w_e_l_t _s_t_a_c_k).  We could define a
         macro  named  _p_u_s_h  to  do this for us.  One way to
         define it is:

         -> (_d_e_f _p_u_s_h
               (_m_a_c_r_o (_x) (_l_i_s_t '_s_e_t_q (_c_a_d_d_r _x) (_l_i_s_t '_c_o_n_s (_c_a_d_r _x) (_c_a_d_d_r _x)))))
         push

         then (_p_u_s_h _n_e_w_e_l_t _s_t_a_c_k) will expand  to  the  form
         mentioned above.  The same macro written using def-
         macro would be:

         -> (_d_e_f_m_a_c_r_o _p_u_s_h (_v_a_l_u_e _s_t_a_c_k)
           (_l_i_s_t '_s_e_t_q ,_s_t_a_c_k (_l_i_s_t '_c_o_n_s ,_v_a_l_u_e ,_s_t_a_c_k)))
         push

         Defmacro allows you to name the  arguments  of  the
         macro  call,  and  makes  the macro definition look
         more like a function definition.




9

9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-5


      8.3.3.  the backquote character macro

              The default syntax for  FRANZ  LISP  has  four
         characters  with  associated character macros.  One
         is semicolon for  comments.   Two  others  are  the
         backquote and comma which are used by the backquote
         character macro.  The  fourth  is  the  sharp  sign
         macro described in the next section.

              The backquote macro is used  to  create  lists
         where many of the elements are fixed (quoted). This
         makes it very useful  for  creating  macro  defini-
         tions.  In the simplest case, a backquote acts just
         like a single quote:

         ->`(_a _b _c _d _e)
         (a b c d e)

         If a comma precedes an element of a backquoted list
         then that element is evaluated and its value is put
         in the list.

         ->(_s_e_t_q _d '(_x _y _z))
         (x y z)
         ->`(_a _b _c ,_d _e)
         (a b c (x y z) e)

         If a comma followed by an at sign precedes an  ele-
         ment  in  a  backquoted  list, then that element is
         evaluated and spliced into the list with _a_p_p_e_n_d.

         ->`(_a _b _c ,@_d _e)
         (a b c x y z e)

         Once a list begins with a backquote, the commas may
         appear anywhere in the list as this example shows:

         ->`(_a _b (_c _d ,(_c_d_r _d)) (_e _f (_g _h ,@(_c_d_d_r _d) ,@_d)))
         (a b (c d (y z)) (e f (g h z x y z)))

         It is also possible and sometimes  even  useful  to
         use  the backquote macro within itself.  As a final
         demonstration of  the  backquote  macro,  we  shall
         define  the  first  and  push  macros using all the
         power at our disposal: defmacro and  the  backquote
         macro.

         ->(_d_e_f_m_a_c_r_o _f_i_r_s_t (_l_i_s_t) `(_c_a_r ,_l_i_s_t))
         first
         ->(_d_e_f_m_a_c_r_o _p_u_s_h (_v_a_l_u_e _s_t_a_c_k) `(_s_e_t_q ,_s_t_a_c_k (_c_o_n_s ,_v_a_l_u_e ,_s_t_a_c_k)))
         stack

9

9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-6


      8.3.4.  sharp sign character macro

              The sharp sign macro can perform a  number  of
         different  functions   at read time.  The character
         directly following the sharp sign determines  which
         function  will  be  done,  and  following  Lisp  s-
         expressions may serve as arguments.



         8.3.4.1.  conditional inclusion

            If you plan to run one source file in more  than
            one environment then you may want to some pieces
            of code to be included  or not included  depend-
            ing  on  the  environment.  The  C language uses
            "#ifdef" and "#ifndef"  for  this  purpose,  and
            Lisp  uses  "#+" and "#-".  The environment that
            the   sharp   sign   macro   checks    is    the
            (_s_t_a_t_u_s _f_e_a_t_u_r_e_s) list which is initialized when
            the Lisp system  is  built   and  which  may  be
            altered     by     (_s_s_t_a_t_u_s _f_e_a_t_u_r_e _f_o_o)     and
            (_s_s_t_a_t_u_s _n_o_f_e_a_t_u_r_e _b_a_r) The form  of conditional
            inclusion is
                        _#_+_w_h_e_n _w_h_a_t
            where _w_h_e_n is either a symbol or  an  expression
            involving symbols and the functions _a_n_d, _o_r, and
            _n_o_t.  The meaning is that _w_h_a_t will only be read
            in  if  _w_h_e_n  is true.  A symbol in _w_h_e_n is true
            only if  it  appears  in  the  (_s_t_a_t_u_s _f_e_a_t_u_r_e_s)
            list.


    ____________________________________________________

    ; suppose we want to write a program which references a file
    ; and which can run at ucb, ucsd and cmu where the file naming conventions
    ; are different.
    ;
    -> (_d_e_f_u_n _h_o_w_o_l_d (_n_a_m_e)
          (_t_e_r_p_r)
          (_l_o_a_d #+(_o_r _u_c_b _u_c_s_d) "/_u_s_r/_l_i_b/_l_i_s_p/_a_g_e_s._l"
                 #+_c_m_u "/_u_s_r/_l_i_s_p/_d_o_c/_a_g_e_s._l")
          (_p_a_t_o_m _n_a_m_e)
          (_p_a_t_o_m " _i_s ")
          (_p_r_i_n_t (_c_d_r (_a_s_s_o_c _n_a_m_e _a_g_e_f_i_l_e)))
          (_p_a_t_o_m "_y_e_a_r_s _o_l_d")
          (_t_e_r_p_r))
    ____________________________________________________



The form


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-7


                        _#_-_w_h_e_n _w_h_a_t
is equivalent to
                     _#_+_(_n_o_t _w_h_e_n_) _w_h_a_t



         8.3.4.2.  fixnum character equivalents

            When working with fixnum equivalents of  charac-
            ters,  it  is  often hard to remember the number
            corresponding to a character.  The form
                            _#_/_c
            is equivalent to the  fixnum  representation  of
            character c.


    ____________________________________________________

    ; a function which returns t if the user types y else it returns nil.
    ;
    -> (_d_e_f_u_n _y_e_s_o_r_n_o _n_i_l
          (_p_r_o_g_n (_a_n_s)
                 (_s_e_t_q _a_n_s (_t_y_i))
                 (_c_o_n_d ((_e_q_u_a_l _a_n_s #/_y) _t)
                       (_t _n_i_l))))
    ____________________________________________________






         8.3.4.3.  read time evaluation

            Occasionally you want to express a constant as a
            Lisp  expression,  yet you don't want to pay the
            penalty of evaluating this expression each  time
            it is referenced.  The form
                        _#_._e_x_p_r_e_s_s_i_o_n
            evaluates  the  expression  at  read  time   and
            returns its value.











9

9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-8



    ____________________________________________________

    ; a function to test if any of bits 1 3 or 12 are set in a fixnum.
    ;
    -> (_d_e_f_u_n _t_e_s_t_i_t (_n_u_m)
          (_c_o_n_d ((_z_e_r_o_p (_b_o_o_l_e _1 _n_u_m #.(+ (_l_s_h _1 _1) (_l_s_h _1 _3) (_l_s_h _1 _1_2))))
                 _n_i_l)
                (_t _t)))
    ____________________________________________________






   8.4.  fclosures

           Fclosures are a type of functional  object.   The
      purpose  is  to  remember the values of some variables
      between invocations of the functional  object  and  to
      protect this data from being inadvertently overwritten
      by other Lisp  functions.   Fortran  programs  usually
      exhibit  this behavior for their variables.  (In fact,
      some versions of Fortran would require  the  variables
      to  be  in COMMON).  Thus it is easy to write a linear
      congruent random number generator in  Fortran,  merely
      by keeping the seed as a variable in the function.  It
      is much more risky to do so in Lisp, since any special
      variable you picked, might be used by some other func-
      tion.  Fclosures are an attempt to provide most of the
      same  functionality  as closures in Lisp Machine Lisp,
      to users of FRANZ LISP.  Fclosures are related to clo-
      sures in this way:
      (fclosure '(a b) 'foo) <==>
              (let ((a a) (b b)) (closure '(a b) 'foo))



      8.4.1.  an example

____________________________________________________________

% lisp
Franz Lisp, Opus 38.60
->(defun code (me count)
  (print (list 'in x))
  (setq x (+ 1 x))
  (cond ((greaterp count 1) (funcall me me (sub1 count))))
  (print (list 'out x)))
code
->(defun tester (object count)
  (funcall object object count) (terpri))


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                         8-9


tester
->(setq x 0)
0
->(setq z (fclosure '(x) 'code))
fclosure[8]
-> (tester z 3)
(in 0)(in 1)(in 2)(out 3)(out 3)(out 3)
nil
->x
0
____________________________________________________________





              The function _f_c_l_o_s_u_r_e  creates  a  new  object
         that  we  will  call  an  fclosure, (although it is
         actually a vector).  The fclosure contains a  func-
         tional  object, and a set of symbols and values for
         the symbols.  In the above  example,  the  fclosure
         functional object is the function code.  The set of
         symbols and values just contains the symbol `x' and
         zero,  the  value  of  `x'  when  the  fclosure was
         created.

         When an fclosure is funcall'ed:

         1)   The Lisp system lambda binds  the  symbols  in
              the fclosure to their values in the fclosure.

         2)   It continues the  funcall  on  the  functional
              object of the fclosure.

         3)   Finally, it un-lambda binds the symbols in the
              fclosure  and  at  the  same  time  stores the
              current values of the symbols in the fclosure.


              Notice that the fclosure is saving  the  value
         of  the  symbol  `x'.   Each  time  a  fclosure  is
         created, new space  is  allocated  for  saving  the
         values  of the symbols. Thus if we execute fclosure
         again, over the same  function,  we  can  have  two
         independent counters:

____________________________________________________________

-> (setq zz (fclosure '(x) 'code))
fclosure[1]
-> (tester zz 2)
(in 0)(in 1)(out 2)(out 2)
-> (tester zz 2)


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-10


(in 2)(in 3)(out 4)(out 4)
-> (tester z 3)
(in 3)(in 4)(in 5)(out 6)(out 6)(out 6)
____________________________________________________________







      8.4.2.  useful functions

              Here are some quick some  summaries  of  func-
         tions  dealing  with  closures.  They are more for-
         mally defined in 2.8.4.  To  recap,  fclosures  are
         made by (_f_c_l_o_s_u_r_e '_l__v_a_r_s '_g__f_u_n_c_o_b_j).  l_vars is a
         list of symbols (not containing nil), g_funcobj  is
         any  object  that can be funcalled.  (Objects which
         can be funcalled, include compiled Lisp  functions,
         lambda  expressions,  symbols,  foreign  functions,
         etc.) In general, if you want a  compiled  function
         to  be closed over a variable, you must declare the
         variable  to  be  special  within   the   function.
         Another example would be:

                     (fclosure '(a b) #'(lambda (x) (plus x a)))

         Here, the #' construction will  make  the  compiler
         compile the lambda expression.

              There are times when you want to  share  vari-
         ables  between  fclosures.  This can be done if the
         fclosures  are  created  at  the  same  time  using
         _f_c_l_o_s_u_r_e-_l_i_s_t.  The function _f_c_l_o_s_u_r_e-_a_l_i_s_t returns
         an assoc list giving the symbols and values in  the
         fclosure.   The  predicate  _f_c_l_o_s_u_r_e_p returns t iff
         its  argument  is  a  fclosure.   Other   functions
         imported  from  Lisp  Machine  Lisp are _s_y_m_e_v_a_l-_i_n-
         _f_c_l_o_s_u_r_e,   _l_e_t-_f_c_l_o_s_e_d,    and    _s_e_t-_i_n-_f_c_l_o_s_u_r_e.
         Lastly,  the function _f_c_l_o_s_u_r_e-_f_u_n_c_t_i_o_n returns the
         function argument.



      8.4.3.  internal structure

              Currently, closures are  implemented  as  vec-
         tors, with property being the symbol fclosure.  The
         functional object is the first entry.  The  remain-
         ing  entries are structures which point to the sym-
         bols and values for the closure, (with a  reference
         count  to  determine  if  a  recursive  closure  is


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-11


         active).



   8.5.  foreign subroutines and functions

           FRANZ LISP has the ability  to  dynamically  load
      object  files  produced by other compilers and to call
      functions defined in those files.  These functions are
      called _f_o_r_e_i_g_n functions.* There are  seven  types  of
      foreign functions.  They are characterized by the type
      of result they  return,  and  by  differences  in  the
      interpretation of their arguments.  They come from two
      families: a group  suited  for  languages  which  pass
      arguments  by  reference  (e.g.  Fortran), and a group
      suited for languages which  pass  arguments  by  value
      (e.g. C).


      There are four types in the first group:

      subroutine
           This does not return anything.  The  Lisp  system
           always returns t after calling a subroutine.

      function
           This returns whatever the function returns.  This
           must  be  a valid Lisp object or it may cause the
           Lisp system to fail.

      integer-function
           This returns an integer  which  the  Lisp  system
           makes into a fixnum and returns.

      real-function
           This returns a double precision real number which
           the Lisp system makes into a flonum and returns.


      There are three types in the second group:

      c-function
           This is like an integer function, except for  its
           different interpretation of arguments.


____________________
9   *This topic is also discussed in Report  PAM-124  of  the
Center  for  Pure  and  Applied  Mathematics,  UCB, entitled
``Parlez-Vous Franz?  An Informal Introduction to  Interfac-
ing Foreign Functions to Franz LISP'', by James R. Larus



9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-12


      double-c-function
           This is like a real-function.

      vector-c-function
           This is for C functions which return a structure.
           The  first  argument  to such functions must be a
           vector (of type vectori), into which  the  result
           is  stored.  The second Lisp argument becomes the
           first argument to the C function, and so on

      A foreign function is accessed through a binary object
      just like a compiled Lisp function.  The difference is
      that the discipline field of a  binary  object  for  a
      foreign  function is a string whose first character is
      given in the following table:


8                   ____________________________
                    letter         type
8                   ________________________________________________________
                      s         subroutine
8                   ____________________________
                      f          function
8                   ____________________________
                      i      integer-function
8                   ____________________________
                      r       real-function.
8                   ____________________________
                      c         c-function
8                   ____________________________
                      v      vector-c-function
8                   ____________________________
                      d      double-c-function
8                   ____________________________
7                  |7|7|7|7|7|7|7|7|7|7|7|










                          |7|7|7|7|7|7|7|7|7|7|7|










                                              |7|7|7|7|7|7|7|7|7|7|7|












      Two functions  are  provided  for  setting-up  foreign
      functions.   _C_f_a_s_l  loads an object file into the Lisp
      system and sets up one foreign function binary object.
      If there are more than one function in an object file,
      _g_e_t_a_d_d_r_e_s_s can be used to set  up  additional  foreign
      function objects.

           Foreign  functions are  called  just  like  other
      functions,  e.g  (_f_u_n_n_a_m_e _a_r_g_1 _a_r_g_2).  When a function
      in the Fortran group  is  called,  the  arguments  are
      evaluated  and  then  examined.  List, hunk and symbol
      arguments are passed unchanged to  the  foreign  func-
      tion.   Fixnum  and flonum arguments are copied into a
      temporary location and  a  pointer  to  the  value  is
      passed (this is because Fortran uses call by reference
      and it is dangerous to modify the contents of a fixnum
      or  flonum  which  something else might point to).  If
      the argument is an array object, the data field of the
      array  object  is passed to the foreign function (This
      is the easiest way to send large amounts  of  data  to
      and receive large amounts of data from a foreign func-
      tion).  If a binary object is an argument,  the  entry


9                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-13


      field of that object is passed to the foreign function
      (the entry field is the address of a function, so this
      amounts to passing a function as an argument).

           When a function in the C group is called,  fixnum
      and flownum arguments are passed by value.  For almost
      all other arguments, the address is merely provided to
      the  C  routine.   The  only exception arises when you
      want to invoke a C routine which  expects  a  ``struc-
      ture''  argument.  Recall that a (rarely used) feature
      of the C language is the ability to pass structures by
      value.   This  copies  the  structure  onto the stack.
      Since the Franz's nearest equivalent to a C  structure
      is  a  vector, we provide an escape clause to copy the
      contents of an immediate-type vector by value.  If the
      property  field  of  a vectori argument, is the symbol
      "value-structure-argument", then the  binary  data  of
      this immediate-type vector is copied into the argument
      list of the C routine.

           The method a foreign function uses to access  the
      arguments   provided  by  Lisp  is  dependent  on  the
      language  of  the  foreign  function.   The  following
      scripts  demonstrate  how  how  Lisp can interact with
      three languages: C, Pascal and Fortran.  C and  Pascal
      have  pointer  types and the first script shows how to
      use pointers to extract information from Lisp objects.
      There  are  two  functions  defined for each language.
      The first (cfoo in C, pfoo in Pascal)  is  given  four
      arguments,  a  fixnum, a flonum-block array, a hunk of
      at least two fixnums and a list of at least  two  fix-
      nums.   To  demonstrate  that  the values were passed,
      each ?foo function prints its arguments (or  parts  of
      them).   The  ?foo  function  then modifies the second
      element of the flonum-block array and returns a  3  to
      Lisp.   The second function (cmemq in C, pmemq in Pas-
      cal) acts just like the Lisp _m_e_m_q function (except  it
      won't work for fixnums whereas the lisp _m_e_m_q will work
      for small fixnums).  In the script, typed input is  in
      bold,  computer output is in roman and comments are in
      _i_t_a_l_i_c.


____________________________________________________________

_T_h_e_s_e _a_r_e _t_h_e _C _c_o_d_e_d _f_u_n_c_t_i_o_n_s
% cat ch8auxc.c
/* demonstration of c coded foreign integer-function */

/* the following will be used to extract fixnums out of a list of fixnums */
struct listoffixnumscell
{    struct listoffixnumscell *cdr;
     int *fixnum;


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-14


};

struct listcell
{       struct listcell *cdr;
        int car;
};

cfoo(a,b,c,d)
int *a;
double b[];
int *c[];
struct listoffixnumscell *d;
{
    printf("a: %d, b[0]: %f, b[1]: %f0, *a, b[0], b[1]);
    printf(" c (first): %d   c (second): %d0,
               *c[0],*c[1]);
    printf(" ( %d %d ... ) ", *(d->fixnum), *(d->cdr->fixnum));
    b[1] = 3.1415926;
    return(3);
}

struct listcell *
cmemq(element,list)
int element;
struct listcell *list;
{
   for( ; list && element != list->car ;  list = list->cdr);
   return(list);
}


_T_h_e_s_e _a_r_e _t_h_e _P_a_s_c_a_l _c_o_d_e_d _f_u_n_c_t_i_o_n_s
% cat ch8auxp.p
type    pinteger = ^integer;
        realarray = array[0..10] of real;
        pintarray = array[0..10] of pinteger;
        listoffixnumscell = record
                                cdr  : ^listoffixnumscell;
                                fixnum : pinteger;
                            end;
        plistcell = ^listcell;
        listcell = record
                      cdr : plistcell;
                      car : integer;
                   end;

function pfoo ( var a : integer ;
                var b : realarray;
                var c : pintarray;
                var d : listoffixnumscell) : integer;
begin
   writeln(' a:',a, ' b[0]:', b[0], ' b[1]:', b[1]);
   writeln(' c (first):', c[0]^,' c (second):', c[1]^);


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-15


   writeln(' ( ', d.fixnum^, d.cdr^.fixnum^, ' ...) ');
   b[1] := 3.1415926;
   pfoo := 3
end ;

{ the function pmemq looks for the Lisp pointer given as the first argument
  in the list pointed to by the second argument.
  Note that we declare " a : integer " instead of " var a : integer " since
  we are interested in the pointer value instead of what it points to (which
  could be any Lisp object)
}
function pmemq( a : integer; list : plistcell) : plistcell;
begin
 while (list <> nil) and (list^.car <> a) do list := list^.cdr;
 pmemq := list;
end ;


_T_h_e _f_i_l_e_s _a_r_e _c_o_m_p_i_l_e_d
% cc -c ch8auxc.c
1.0u 1.2s 0:15 14% 30+39k 33+20io 147pf+0w
% pc -c ch8auxp.p
3.0u 1.7s 0:37 12% 27+32k 53+32io 143pf+0w


% lisp
Franz Lisp, Opus 38.60
_F_i_r_s_t _t_h_e _f_i_l_e_s _a_r_e _l_o_a_d_e_d _a_n_d _w_e _s_e_t _u_p _o_n_e  _f_o_r_e_i_g_n  _f_u_n_c_-
_t_i_o_n  _b_i_n_a_r_y.  _W_e _h_a_v_e _t_w_o _f_u_n_c_t_i_o_n_s _i_n _e_a_c_h _f_i_l_e _s_o _w_e _m_u_s_t
_c_h_o_o_s_e _o_n_e _t_o _t_e_l_l _c_f_a_s_l _a_b_o_u_t.  _T_h_e _c_h_o_i_c_e _i_s _a_r_b_i_t_r_a_r_y.
-> (cfasl 'ch8auxc.o '_cfoo 'cfoo "integer-function")
/usr/lib/lisp/nld -N -A /usr/local/lisp -T 63000 ch8auxc.o -e _cfoo -o /tmp/Li7055.0  -lc
#63000-"integer-function"
-> (cfasl 'ch8auxp.o '_pfoo 'pfoo "integer-function" "-lpc")
/usr/lib/lisp/nld -N -A /tmp/Li7055.0 -T 63200 ch8auxp.o -e _pfoo -o /tmp/Li7055.1 -lpc -lc
#63200-"integer-function"
_H_e_r_e _w_e _s_e_t _u_p _t_h_e _o_t_h_e_r _f_o_r_e_i_g_n _f_u_n_c_t_i_o_n _b_i_n_a_r_y _o_b_j_e_c_t_s
-> (getaddress '_cmemq 'cmemq "function" '_pmemq 'pmemq "function")
#6306c-"function"
_W_e _w_a_n_t _t_o _c_r_e_a_t_e _a_n_d _i_n_i_t_i_a_l_i_z_e _a_n _a_r_r_a_y  _t_o  _p_a_s_s  _t_o  _t_h_e
_c_f_o_o  _f_u_n_c_t_i_o_n.  _I_n _t_h_i_s _c_a_s_e _w_e _c_r_e_a_t_e _a_n _u_n_n_a_m_e_d _a_r_r_a_y _a_n_d
_s_t_o_r_e _i_t _i_n _t_h_e _v_a_l_u_e _c_e_l_l _o_f _t_e_s_t_a_r_r.  _W_h_e_n  _w_e  _c_r_e_a_t_e  _a_n
_a_r_r_a_y  _t_o  _p_a_s_s  _t_o  _t_h_e  _P_a_s_c_a_l _p_r_o_g_r_a_m _w_e _w_i_l_l _u_s_e _a _n_a_m_e_d
_a_r_r_a_y _j_u_s_t _t_o _d_e_m_o_n_s_t_r_a_t_e _t_h_e _d_i_f_f_e_r_e_n_t _w_a_y _t_h_a_t  _n_a_m_e_d  _a_n_d
_u_n_n_a_m_e_d _a_r_r_a_y_s _a_r_e _c_r_e_a_t_e_d _a_n_d _a_c_c_e_s_s_e_d.
-> (setq testarr (array nil flonum-block 2))
array[2]
-> (store (funcall testarr 0) 1.234)
1.234
-> (store (funcall testarr 1) 5.678)
5.678
-> (cfoo 385 testarr (hunk 10 11 13 14) '(15 16 17))
a: 385, b[0]: 1.234000, b[1]: 5.678000


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-16


 c (first): 10   c (second): 11
 ( 15 16 ... )
 3
_N_o_t_e _t_h_a_t _c_f_o_o _h_a_s _r_e_t_u_r_n_e_d _3 _a_s _i_t _s_h_o_u_l_d.  _I_t _a_l_s_o _h_a_d _t_h_e
_s_i_d_e  _e_f_f_e_c_t  _o_f  _c_h_a_n_g_i_n_g  _t_h_e _s_e_c_o_n_d _v_a_l_u_e _o_f _t_h_e _a_r_r_a_y _t_o
_3._1_4_1_5_9_2_6  _w_h_i_c_h _c_h_e_c_k _n_e_x_t.
-> (funcall testarr 1)
3.1415926


_I_n _p_r_e_p_a_r_a_t_i_o_n _f_o_r _c_a_l_l_i_n_g _p_f_o_o _w_e _c_r_e_a_t_e _a_n _a_r_r_a_y.
-> (array test flonum-block 2)
array[2]
-> (store (test 0) 1.234)
1.234
-> (store (test 1) 5.678)
5.678
-> (pfoo 385 (getd 'test) (hunk 10 11 13 14) '(15 16 17))
 a:       385 b[0]:  1.23400000000000E+00 b[1]:  5.67800000000000E+00
 c (first):        10 c (second):        11
 (         15        16 ...)
3
-> (test 1)
3.1415926

 _N_o_w _t_o _t_e_s_t _o_u_t _t_h_e _m_e_m_q'_s
-> (cmemq 'a '(b c a d e f))
(_a _d _e _f)
-> (pmemq 'e '(a d f g a x))
_n_i_l
____________________________________________________________





           The Fortran example will be much shorter since in
      Fortran  you can't follow pointers as you can in other
      languages.  The Fortran function ffoo is  given  three
      arguments:  a  fixnum, a fixnum-block array and a flo-
      num.  These arguments are printed out to  verify  that
      they  made it and then the first value of the array is
      modified.  The function  returns  a  double  precision
      value  which  is  converted  to  a  flonum by lisp and
      printed.  Note that the entry point  corresponding  to
      the  Fortran function ffoo is _ffoo_ as opposed to the
      C and Pascal convention of preceding the name with  an
      underscore.

____________________________________________________________


% cat ch8auxf.f


                                   Printed: January 31, 1984







Functions, Fclosures, and Macros                        8-17


        double precision function ffoo(a,b,c)
        integer a,b(10)
        double precision c
        print 2,a,b(1),b(2),c
2       format(' a=',i4,', b(1)=',i5,', b(2)=',i5,' c=',f6.4)
        b(1) = 22
        ffoo = 1.23456
        return
        end
% f77 -c ch8auxf.f
ch8auxf.f:
   ffoo:
0.9u 1.8s 0:12 22% 20+22k 54+48io 158pf+0w
% lisp
Franz Lisp, Opus 38.60
-> (cfasl 'ch8auxf.o '_ffoo_ 'ffoo "real-function" "-lF77 -lI77")
/usr/lib/lisp/nld -N -A /usr/local/lisp -T 63000 ch8auxf.o -e _ffoo_
-o /tmp/Li11066.0 -lF77 -lI77 -lc
#6307c-"real-function"

-> (array test fixnum-block 2)
array[2]
-> (store (test 0) 10)
10
-> (store (test 1) 11)
11
-> (ffoo 385 (getd 'test) 5.678)
 a= 385, b(1)=   10, b(2)=   11 c=5.6780
1.234559893608093
-> (test 0)
22

____________________________________________________________



















9

9                                   Printed: January 31, 1984



EndOfFile
cat >  lisplib/manual/ch9.r  << 'EndOfFile'







                         CHAPTER  9


                     Arrays and Vectors




     Arrays and vectors are two means of  expressing  aggre-
gate  data objects in FRANZ LISP.  Vectors may be thought of
as sequences of data.  They are intended as  a  vehicle  for
user-defined  data  types.   This  use  of  vectors is still
experimental and subject to  revision.   As  a  simple  data
structure,  they  are similar to hunks and strings.  Vectors
are used to implement closures, and are useful  to  communi-
cate with foreign functions.  Both of these topics were dis-
cussed in Chapter 8.  Later in this chapter, we describe the
current  implementation of vectors, and will advise the user
what is most likely to change.

     Arrays in FRANZ LISP provide a programmable data struc-
ture  access  mechanism.   One  possible  use for FRANZ LISP
arrays is to implement Maclisp style arrays which are simple
vectors of fixnums, flonums or general lisp values.  This is
described in more detail in 9.3 but first we  will  describe
how array references are handled by the lisp system.

     The structure of an array object is given in 1.3.10 and
reproduced here for your convenience.


8_______________________________________________________________
  Subpart name     Get value   Set value          Type

8______________________________________________________________________________________________________________________________
 access function   getaccess   putaccess      binary, list
                                                or symbol
8_______________________________________________________________
    auxiliary       getaux      putaux           lispval
8_______________________________________________________________
      data         arrayref     replace    block of contiguous
                                  set            lispval
8_______________________________________________________________
     length        getlength   putlength         fixnum
8_______________________________________________________________
      delta        getdelta    putdelta          fixnum
8_______________________________________________________________
7|7|7|7|7|7|7|7|7|7|7|7|










                |7|7|7|7|7|7|7|7|7|7|7|










                            |7|7|7|7|7|7|7|7|7|7|7|










                                        |7|7|7|7|7|7|7|7|7|7|7|










                                                              |7|7|7|7|7|7|7|7|7|7|7|















   9.1.  general arrays   Suppose the evaluator is  told  to
      evaluate (_f_o_o _a _b) and the function cell of the symbol
      foo contains an  array  object  (which  we  will  call
      foo_arr_obj).   First  the evaluator will evaluate and
      stack the values of _a and _b.  Next it will  stack  the


9Arrays and Vectors                                       9-1







Arrays and Vectors                                       9-2


      array  object  foo_arr_obj.   Finally it will call the
      access function of foo_arr_obj.  The  access  function
      should  be  a  lexpr[] or a symbol whose function cell
      contains a lexpr.  The access function is  responsible
      for  locating  and  returning  a value from the array.
      The array access function is  free  to  interpret  the
      arguments  as it wishes.  The Maclisp compatible array
      access function which  is  provided  in  the  standard
      FRANZ  LISP  system  interprets  the arguments as sub-
      scripts in the same way as languages like Fortran  and
      Pascal.

           The array access function  will  also  be  called
      upon  to  store  elements  in the array.  For example,
      (_s_t_o_r_e (_f_o_o _a _b) _c) will automatically expand to  (foo
      c  a  b)  and when the evaluator is called to evaluate
      this, it will evaluate the arguments _c, _b and _a.  Then
      it will stack the array object (which is stored in the
      function cell of foo) and call the array access  func-
      tion  with  (now)  four  arguments.   The array access
      function must be able to tell this is a  store  opera-
      tion,  which it can do by checking the number of argu-
      ments it has been given (a  lexpr  can  do  this  very
      easily).



   9.2.  subparts of an array object   An array  is  created
      by allocating an array object with _m_a_r_r_a_y and  filling
      in the fields.  Certain lisp functions  interpret  the
      values  of the subparts of the array object in special
      ways as described  in  the  following  text.   Placing
      illegal  values  in  these subparts may cause the lisp
      system to fail.



      9.2.1.  access function   The purpose  of  the  access
         function has been described above.  The contents of
         the access function should be  a  lexpr,  either  a
         binary  (compiled  function) or a list (interpreted
         function).  It may also be a symbol whose  function
         cell  contains a function definition.  This subpart
         is used by _e_v_a_l, _f_u_n_c_a_l_l, and _a_p_p_l_y when evaluating
         array references.



____________________
9   []A lexpr is a function which accepts any number of argu-
ments which are evaluated before the function is called.



9                                      Printed: July 21, 1983







Arrays and Vectors                                       9-3


      9.2.2.  auxiliary   This can be used for any  purpose.
         If  it is a list and the first element of that list
         is the symbol unmarked_array then the data  subpart
         will  not  be marked by the garbage collector (this
         is used in the Maclisp compatible array package and
         has  the  potential  for  causing strange errors if
         used incorrectly).



      9.2.3.  data   This is either nil or points to a block
         of  data  space  allocated  by  _s_e_g_m_e_n_t  or  _s_m_a_l_l-
         _s_e_g_m_e_n_t.



      9.2.4.  length   This is a fixnum whose value  is  the
         number of elements in the data block.  This is used
         by the garbage collector and by _a_r_r_a_y_r_e_f to  deter-
         mine if your index is in bounds.



      9.2.5.  delta   This is a fixnum whose  value  is  the
         number  of bytes in each element of the data block.
         This will be four for an array of fixnums or  value
         cells,  and eight for an array of flonums.  This is
         used by the garbage collector and _a_r_r_a_y_r_e_f as well.



   9.3.  The Maclisp compatible array package

           A Maclisp style array is similar to what is known
      as  arrays  in other languages: a block of homogeneous
      data elements which is indexed by one or more integers
      called  subscripts.  The data elements can be all fix-
      nums, flonums or general lisp objects.   An  array  is
      created  by  a  call  to the function _a_r_r_a_y or *_a_r_r_a_y.
      The only difference is that *_a_r_r_a_y evaluates its argu-
      ments.   This call: (_a_r_r_a_y _f_o_o _t _3 _5) sets up an array
      called foo of dimensions 3 by 5.  The  subscripts  are
      zero  based.  The first element is (_f_o_o _0 _0), the next
      is (_f_o_o _0 _1) and so on up to (_f_o_o _2 _4).  The  t  indi-
      cates  a  general  lisp  object array which means each
      element of foo can be any type.  Each element  can  be
      any  type  since  all that is stored in the array is a
      pointer to a  lisp  object,  not  the  object  itself.
      _A_r_r_a_y  does  this  by  allocating an array object with
      _m_a_r_r_a_y and then allocating a segment of 15 consecutive
      value  cells  with _s_m_a_l_l-_s_e_g_m_e_n_t and storing a pointer
      to that segment in  the  data  subpart  of  the  array
      object.   The  length  and  delta subpart of the array


                                      Printed: July 21, 1983







Arrays and Vectors                                       9-4


      object are filled in (with 15 and 4 respectively)  and
      the  access  function  subpart  is set to point to the
      appropriate  array  access  function.   In  this  case
      there is a special access function for two dimensional
      value cell arrays called arrac-twoD, and  this  access
      function  is  used.   The  auxiliary subpart is set to
      (t 3 5) which describes the  type  of  array  and  the
      bounds of the subscripts. Finally this array object is
      placed in the function cell of the  symbol  foo.   Now
      when (_f_o_o _1 _3) is evaluated, the array access function
      is invoked with three arguments: 1, 3  and  the  array
      object.   From the auxiliary field of the array object
      it gets a description of  the  particular  array.   It
      then determines which element (_f_o_o _1 _3) refers to  and
      uses arrayref to extract that element.  Since this  is
      an  array  of  value cells, what arrayref returns is a
      value cell whose value is what we want, so we evaluate
      the   value  cell  and  return  it  as  the  value  of
      (_f_o_o _1 _3).

           In Maclisp the call (_a_r_r_a_y _f_o_o _f_i_x_n_u_m _2_5) returns
      an  array  whose  data  object is a block of 25 memory
      words.  When fixnums are stored  in  this  array,  the
      actual  numbers  are stored instead of pointers to the
      numbers as is done  in  general  lisp  object  arrays.
      This  is  efficient  under  Maclisp but inefficient in
      FRANZ LISP since every time  a  value  was  referenced
      from an array it had to be copied and a pointer to the
      copy returned to prevent aliasing[].  Thus  t,  fixnum
      and  flonum  arrays  are  all  implemented in the same
      manner.  This should not affect the  compatibility  of
      Maclisp  and  FRANZ  LISP.  If there is an application
      where a block of fixnums or flonums is required,  then
      the  exact  same effect of fixnum and flonum arrays in
      Maclisp can be  achieved  by  using  fixnum-block  and
      flonum-block  arrays.  Such arrays are required if you
      want to pass a large number of arguments to a  Fortran
      or C coded function and then get answers back.

           The Maclisp compatible array package is just  one
      example  of  how  a general array scheme can be imple-
      mented.  Another type of  array  you  could  implement
      would  be  hashed  arrays.   The  subscript  could  be
____________________
9   []Aliasing is when  two  variables  are  share  the  same
storage  location.   For  example  if  the copying mentioned
weren't done then after (_s_e_t_q _x (_f_o_o _2)) was done, the value
of x and (foo 2) would share the same location.  Then should
the value of (foo 2) change, x's value would change as well.
This  is  considered  dangerous and as a result pointers are
never returned into the data space of arrays.



9                                      Printed: July 21, 1983







Arrays and Vectors                                       9-5


      anything, not just  a  number.   The  access  function
      would  hash the subscript and use the result to select
      an array element.  With the generality of arrays  also
      comes  extra cost; if you just want a simple aggregate
      of (less than 128) general lisp objects you  would  be
      wise to look into using hunks.



   9.4.   vectors    Vectors  were  invented  to   fix   two
      shortcommings with hunks.  They can be longer than 128
      elements.  They also have a tag associated with  them,
      which is intended to say, for example, "Think of me as
      an _B_l_o_b_i_t."  Thus a vector is an arbitrary sized  hunk
      with a property list.

           Continuing the example, the lisp kernel  may  not
      know how to print out or evaluate _b_l_o_b_i_t_s, but this is
      information which will be common to all  _b_l_o_b_i_t_s.   On
      the  other hand, for each individual blobits there are
      particulars  which  are  likely  to  change,  (height,
      weight,  eye-color).  This is the part that would pre-
      viously have been stored in the individual entries  in
      the hunk, and are stored in the data slots of the vec-
      tor.  Once again we summarize the structure of a  vec-
      tor in tabular form:


8         ________________________________________________
          Subpart name   Get value   Set value    Type

8         ________________________________________________________________________________________________
            datum[_i]       vref        vset      lispval
8         ________________________________________________
            property       vprop     vsetprop    lispval
                                     vputprop
8         ________________________________________________
              size         vsize         -       fixnum
8         ________________________________________________
7        |7|7|7|7|7|7|7|






                      |7|7|7|7|7|7|7|






                                  |7|7|7|7|7|7|7|






                                              |7|7|7|7|7|7|7|






                                                        |7|7|7|7|7|7|7|








      Vectors are created specifying size and optional  fill
      value using the function (_n_e_w-_v_e_c_t_o_r  'x_size ['g_fill
      ['g_prop]]), or by  initial  values:  (_v_e_c_t_o_r  ['g_val
      ...]).



   9.5.  anatomy  of  vectors    There  are  some  technical
      details about vectors, that the user should know:








9                                      Printed: July 21, 1983







Arrays and Vectors                                       9-6


      9.5.1.  size   The user is not free to alter this.  It
         is noted when the vector is created, and is used by
         the garbage collector.  The garbage collector  will
         coallesce  two free vectors, which are neighbors in
         the heap.  Internally, this is kept as  the  number
         of  bytes of data.  Thus, a vector created by (_v_e_c_-
         _t_o_r 'foo), has a size of 4.



      9.5.2.  property   Currently, we expect  the  property
         to  be either a symbol, or a list whose first entry
         is a symbol.  The symbols fclosure  and  structure-
         value-argument  are  magic,  and  their  effect  is
         described in Chapter  8.   If  the  property  is  a
         (non-null)  symbol,  the vector will be printed out
         as <symbol>[<size>]. Another case is  if  the  pro-
         perty  is  actually  a (disembodied) property-list,
         which contains a value  for  the  indicator  print.
         The value is taken to be a Lisp function, which the
         printer will invoke with two arguments:  the vector
         and the current output port.  Otherwise, the vector
         will be printed as vector[<size>].  We  have  vague
         (as  yet unimplemented) ideas about similar mechan-
         isms for evaluation  properties.   Users  are  cau-
         tioned  against  putting anything other than nil in
         the property entry of a vector.



      9.5.3.  internal order   In memory, vectors start with
         a  longword containing the size (which is immediate
         data within the vector).  The next cell contains  a
         pointer  to  the property.  Any remaining cells (if
         any) are for data.  Vectors are handled differently
         from  any  other  object  in  FRANZ LISP, in that a
         pointer to a vector is pointer to  the  first  data
         cell,  i.e.  a pointer to the _t_h_i_r_d longword of the
         structure.  This was done for  efficiency  in  com-
         piled   code  and  for  uniformity  in  referencing
         immediate-vectors  (described  below).   The   user
         should  never return a pointer to any other part of
         a vector, as this may cause the  garbage  collector
         to follow an invalid pointer.



   9.6.  immediate-vectors   Immediate-vectors  are  similar
      to  vectors.   They  differ,  in  that binary data are
      stored in space directly within the vector.  Thus  the
      garbage  collector will preserve the vector itself (if
      used), and will only traverse the property cell.   The
      data  may  be  referenced as longwords, shortwords, or


                                      Printed: July 21, 1983







Arrays and Vectors                                       9-7


      even bytes.   Shorts  and  bytes  are  returned  sign-
      extended.   The  compiler  open-codes such references,
      and will avoid  boxing  the  resulting  integer  data,
      where  possible.   Thus, immediate vectors may be used
      for efficiently processing character data.   They  are
      also  useful in storing results from functions written
      in other languages.


8        __________________________________________________
         Subpart name   Get value    Set value     Type

8        ____________________________________________________________________________________________________
           datum[_i]     vrefi-byte   vseti-byte   fixnum
                        vrefi-word   vseti-word   fixnum
                        vrefi-long   vseti-long   fixnum
8        __________________________________________________
           property       vprop       vsetprop    lispval
                                      vputprop
8        __________________________________________________
             size         vsize          -        fixnum
                        vsize-byte                fixnum
                        vsize-word                fixnum
8        __________________________________________________
7       |7|7|7|7|7|7|7|7|7|7|7|










                     |7|7|7|7|7|7|7|7|7|7|7|










                                  |7|7|7|7|7|7|7|7|7|7|7|










                                               |7|7|7|7|7|7|7|7|7|7|7|










                                                         |7|7|7|7|7|7|7|7|7|7|7|












      To create immediate vectors specifying size  and  fill
      data,  you  can  use  the  functions _n_e_w-_v_e_c_t_o_r_i-_b_y_t_e,
      _n_e_w-_v_e_c_t_o_r_i-_w_o_r_d, or _n_e_w-_v_e_c_t_o_r_i-_l_o_n_g.  You  can  also
      use   the  functions  _v_e_c_t_o_r_i-_b_y_t_e,  _v_e_c_t_o_r_i-_w_o_r_d,  or
      _v_e_c_t_o_r_i-_l_o_n_g.  All of these functions are described in
      chapter 2.


























9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch10.r  << 'EndOfFile'







                        CHAPTER  10


                     Exception Handling






   10.1.  Errset and Error Handler Functions

           FRANZ LISP allows the user to handle in a  number
      of  ways  the  errors  which arise during computation.
      One way is through the use of the _e_r_r_s_e_t function.  If
      an  error occurs during the evaluation of the _e_r_r_s_e_t's
      first argument, then the locus of control will  return
      to the errset which will return nil (except in special
      cases, such as _e_r_r).  The other method of  error  han-
      dling  is  through an error handler function.  When an
      error occurs, the error handler is called and is given
      as  an argument a description  of the error which just
      occurred.  The error handler may take one of the  fol-
      lowing actions:

      (1)  it could take some drastic action like a _r_e_s_e_t or
           a _t_h_r_o_w.

      (2)  it could, assuming that the error is continuable,
           return  to  the function which noticed the error.
           The error handler  indicates  that  it  wants  to
           return a value from the error by returning a list
           whose _c_a_r is the value it wants to return.

      (3)  it could decide  not  to  handle  the  error  and
           return a non-list to indicate this fact.



   10.2.  The Anatomy of an error

           Each error is described by a list of these items:

      (1)  error type - This is a symbol which indicates the
           general  classification of the error.  This clas-
           sification may determine which  function  handles
           this error.

      (2)  unique id - This  is  a  fixnum  unique  to  this
           error.

      (3)  continuable - If this is non-nil then this  error
           is  continuable.   There  are  some who feel that


Exception Handling                                      10-1







Exception Handling                                      10-2


           every error should be continuable and the  reason
           that some (in fact most) errors in FRANZ LISP are
           not continuable is due to  the  laziness  of  the
           programmers.

      (4)  message string - This is  a  symbol  whose  print
           name is  a message describing the error.

      (5)  data - There may  be  from  zero  to  three  lisp
           values   which   help  describe  this  particular
           error.  For example, the unbound  variable  error
           contains  one datum value, the symbol whose value
           is unbound.  The list describing that error might
           look like:
               (ER%misc 0 t |Unbound Variable:| foobar)



   10.3.  Error handling algorithm

           This is the sequence of operations which is  done
      when an error occurs:

      (1)  If the symbol ER%all has a  non  nil  value  then
           this  value is the name of an error handler func-
           tion.  That function is called with a description
           of  the  error.  If that function returns (and of
           course it may choose not to) and the value  is  a
           list  and  this  error  is  continuable,  then we
           return the _c_a_r of the list to the function  which
           called  the error.  Presumably the function  will
           use this value to retry the  operation.   On  the
           other  hand,  if  the error handler returns a non
           list, then it  has  chosen  not  to  handle  this
           error,  so  we go on to step (2).  Something spe-
           cial happens before  we  call  the  ER%all  error
           handler which does not happen in any of the other
           cases we will describe  below.   To  help  insure
           that we don't get infinitely recursive errors  if
           ER%all is set to a bad value, the value of ER%all
           is set to nil before the handler is called.  Thus
           it is the responsibility of the ER%all handler to
           `reenable' itself by storing its name in ER%all.

      (2)  Next the specific error handler for the  type  of
           error  which  just  occurred  is  called  (if one
           exists) to see if it wants to handle  the  error.
           The  names of the handlers for the specific types
           of errors are stored as the values of the symbols
           whose  names  are  the  types.   For  example the
           handler for miscellaneous errors is stored as the
           value  of  ER%misc.   Of course, if ER%misc has a
           value of nil, then there is no error handler  for


                                      Printed: July 21, 1983







Exception Handling                                      10-3


           this  type of error.  Appendix B contains list of
           all error types.  The process of classifying  the
           errors  is  not complete and thus most errors are
           lumped into the ER%misc  category.   Just  as  in
           step  (1),  the error handler function may choose
           not to handle the error by returning a  non-list,
           and then we go to step (3).

      (3)  Next a check is made to see if there is an _e_r_r_s_e_t
           surrounding  this  error.  If so the second argu-
           ment to the  _e_r_r_s_e_t  call  is  examined.  If  the
           second  argument was not given or is non nil then
           the error message associated with this  error  is
           printed.   Finally   the  stack  is popped to the
           context of the _e_r_r_s_e_t and then the _e_r_r_s_e_t returns
           nil.  If there was no _e_r_r_s_e_t we go to step (4).

      (4)  If the symbol ER%tpl has a value then it  is  the
           name  of  an  error  handler which is called in a
           manner similar to that discussed  above.   If  it
           chooses  not  to  handle the error, we go to step
           (5).

      (5)  At this point it has  been  determined  that  the
           user doesn't want to handle this error.  Thus the
           error message is printed out and a _r_e_s_e_t is  done
           to send the flow of control to the top-level.

           To summarize the error handling system:  When  an
      error occurs, you have two chances to handle it before
      the search for an _e_r_r_s_e_t is done.  Then, if  there  is
      no  _e_r_r_s_e_t,  you  have  one  more chance to handle the
      error before control jumps to the  top  level.   Every
      error  handler  works  in  the same way: It is given a
      description of the error (as described in the previous
      section).   It  may or may not return.  If it returns,
      then it returns either a list or a  non-list.   If  it
      returns  a list and the error is continuable, then the
      _c_a_r of the list is  returned  to  the  function  which
      noticed  the  error.   Otherwise the error handler has
      decided not to handle the error and we go on to  some-
      thing else.



   10.4.  Default aids

           There are two standard error handlers  which will
      probably handle the needs of most users.  One of these
      is the lisp coded function _b_r_e_a_k-_e_r_r-_h_a_n_d_l_e_r which  is
      the  default  value  of  ER%tpl.   Thus when all other
      handlers have ignored an error, _b_r_e_a_k-_e_r_r-_h_a_n_d_l_e_r will
      take over.  It will print out the error message and go


                                      Printed: July 21, 1983







Exception Handling                                      10-4


      into a read-eval-print loop.  The other standard error
      handler   is   _d_e_b_u_g-_e_r_r-_h_a_n_d_l_e_r.    This  handler  is
      designed to be connected to  ER%alland  is  useful  if
      your  program  uses _e_r_r_s_e_t and you want to look at the
      error  before it is thrown up to the _e_r_r_s_e_t.



   10.5.  Autoloading

           When _e_v_a_l, _a_p_p_l_y or _f_u_n_c_a_l_l are told to  call  an
      undefined  function,  an  ER%undef  error is signaled.
      The default handler  for  this  error  is  _u_n_d_e_f-_f_u_n_c-
      _h_a_n_d_l_e_r.   This  function  checks the property list of
      the undefined function for the indicator autoload.  If
      present,  the  value  of  that indicator should be the
      name of the file which contains the definition of  the
      undefined  function.  _U_n_d_e_f-_f_u_n_c-_h_a_n_d_l_e_r will load the
      file and check if it has defined  the  function  which
      caused  the  error.  If it has, the error handler will
      return and the computation will  continue  as  if  the
      error did not occur.  This provides a way for the user
      to tell the lisp system about the location of commonly
      used functions.  The trace package sets up an autoload
      property to point to /usr/lib/lisp/trace.



   10.6.  Interrupt processing

           The  UNIX  operating  system  provides  one  user
      interrupt character which defaults to ^C.[]  The  user
      may  select  a  lisp function to run when an interrupt
      occurs.  Since this interrupt could occur at any time,
      and  in  particular  could  occur  at  a time when the
      internal stack pointers were in an inconsistent state,
      the processing of the interrupt may be delayed until a
      safe time.  When the first ^C is typed, the lisp  sys-
      tem  sets a flag that an interrupt has been requested.
      This flag is  checked at safe places within the inter-
      preter  and in the _q_l_i_n_k_e_r function.  If the lisp sys-
      tem doesn't respond to the first ^C, another ^C should
      be  typed.  This will cause all of the transfer tables
      to be cleared forcing all calls from compiled code  to
      go  through  the  _q_l_i_n_k_e_r function where the interrupt
      flag will  be  checked.   If  the  lisp  system  still
      doesn't  respond,  a  third ^C will cause an immediate
      interrupt.  This interrupt will not necessarily be  in
____________________
9   []Actually there are two but the lisp system does not al-
low you to catch the QUIT interrupt.



9                                      Printed: July 21, 1983







Exception Handling                                      10-5


      a safe place so the user should _r_e_s_e_t the lisp  system
      as soon as possible.


















































9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch11.r  << 'EndOfFile'







                        CHAPTER  11


              The Joseph Lister Trace Package




     The Joseph Lister[] Trace package is an important  tool
for the interactive debugging of a Lisp program.  It  allows
you  to  examine selected  calls to a function or functions,
and optionally to stop execution  of  the  Lisp  program  to
examine the values of variables.

     The trace package is a set of Lisp programs located  in
the    Lisp   program   library   (usually   in   the   file
/usr/lib/lisp/trace.l).  Although not normally loaded in the
Lisp  system,  the  package will be loaded in when the first
call to _t_r_a_c_e is made.

(trace [ls_arg1 ...])

     WHERE:   the form of the ls_arg_i is described below.

     RETURNS: a list of the  function  sucessfully  modified
              for  tracing.   If  no  arguments are given to
              _t_r_a_c_e, a list of all functions currently being
              traced is returned.

     SIDE EFFECT: The function definitions of the  functions
                  to trace are modified.


The ls_arg_i can have one of the following forms:


  foo - when foo is entered and exited, the  trace  informa-
       tion will be printed.


  (foo break) - when foo is entered  and  exited  the  trace
       information  will  be  printed.  Also, just after the
       trace information for foo is printed upon entry,  you
       will  be put in  a special break loop.  The prompt is
       `T>' and you may type any Lisp  expression,  and  see
       its  value printed.  The _ith argument to the function
       just called can be accessed as (arg _i).  To leave the
       trace   loop,  just  type  ^D  or  (tracereturn)  and
____________________
9   []_L_i_s_t_e_r, _J_o_s_e_p_h     1st  Baron  Lister  of  Lyme  Regis,
1827-1912; English surgeon: introduced antiseptic surgery.



9The Joseph Lister Trace Package                         11-1







The Joseph Lister Trace Package                         11-2


       execution will continue.  Note that ^D will work only
       on UNIX systems.


  (foo if expression) - when foo is entered and the  expres-
       sion evaluates to non-nil, then the trace information
       will be printed for both exit and entry.  If  expres-
       sion evaluates to nil, then no trace information will
       be printed.


  (foo ifnot expression) -  when  foo  is  entered  and  the
       expression  evaluates to nil, then the trace informa-
       tion will be printed for both  entry  and  exit.   If
       both  if and ifnot are specified, then the if expres-
       sion must evaluate to non nil AND the  ifnot  expres-
       sion  must  evaluate to nil for the trace information
       to be printed out.


  (foo evalin expression) - when foo is  entered  and  after
       the  entry  trace  information is printed, expression
       will be evaluated. Exit  trace  information  will  be
       printed when foo exits.


  (foo evalout expression) -  when  foo  is  entered,  entry
       trace  information  will be printed.  When foo exits,
       and before the exit  trace  information  is  printed,
       expression will be evaluated.


  (foo evalinout expression) - this has the same  effect  as
       (trace (foo evalin expression evalout expression)).


  (foo lprint) - this tells _t_r_a_c_e to use the  level  printer
       when  printing  the arguments to and the result of  a
       call to foo.  The level printer prints only  the  top
       levels  of  list structure. Any structure below three
       levels is printed as a &.  This allows you  to  trace
       functions with massive arguments or results.



          The following trace options  permit  one  to  have
     greater control over each action which takes place when
     a function is traced.  These options are only meant  to
     be used by people who need special hooks into the trace
     package.  Most people should skip reading this section.


  (foo traceenter  tefunc)  -  this  tells  _t_r_a_c_e  that  the


                                      Printed: July 27, 1983







The Joseph Lister Trace Package                         11-3


       function  to be called when foo is entered is tefunc.
       tefunc should be a lambda of two arguments, the first
       argument  will  be  bound to the name of the function
       being traced, foo in this case.  The second  argument
       will  be  bound to the list of arguments to which foo
       should be applied.  The function tefunc should  print
       some  sort  of "entering foo" message.  It should not
       apply foo to the arguments,  however.  That  is  done
       later on.


  (foo traceexit txfunc) - this tells _t_r_a_c_e that  the  func-
       tion  to  be  called  when  foo  is exited is txfunc.
       txfunc should be a lambda of two arguments, the first
       argument  will  be  bound to the name of the function
       being traced, foo in this case.  The second  argument
       will  be bound to the result of the call to foo.  The
       function txfunc should print some  sort  of  "exiting
       foo" message.


  (foo evfcn evfunc) - this tells _t_r_a_c_e that the form evfunc
       should  be  evaluated to get the value of foo applied
       to its arguments. This option is a bit different from
       the  other  special options since evfunc will usually
       be an expression, not just the name  of  a  function,
       and  that  expression will be specific to the evalua-
       tion of  function  foo.   The  argument  list  to  be
       applied will be available as T-arglist.


  (foo printargs prfunc) - this tells _t_r_a_c_e to  used  prfunc
       to print the arguments  to be applied to the function
       foo.  prfunc should be a lambda of one argument.  You
       might  want  to use this option if you wanted a print
       function which could  handle  circular  lists.   This
       option  will work only if you do not specify your own
       traceenter function.  Specifying the option lprint is
       just  a simple way of changing the printargs function
       to the level printer.


  (foo printres prfunc) - this tells _t_r_a_c_e to use prfunc  to
       print the result of evaluating foo.  prfunc should be
       a lambda of one argument.  This option will work only
       if  you  do  not specify your own traceexit function.
       Specifying the option lprint changes printres to  the
       level printer.



          You may specify more  than  one  option  for  each
     function traced. For example:


                                      Printed: July 27, 1983







The Joseph Lister Trace Package                         11-4


     (_t_r_a_c_e (_f_o_o _i_f (_e_q _3 (_a_r_g _1)) _b_r_e_a_k _l_p_r_i_n_t) (_b_a_r _e_v_a_l_i_n
     (_p_r_i_n_t _x_y_z_z_y)))

     This tells _t_r_a_c_e to trace two more functions,  foo  and
     bar.   Should  foo be called with the first argument _e_q
     to 3, then the entering foo  message  will  be  printed
     with  the  level  printer.   Next it will enter a trace
     break loop, allowing you to evaluate any  lisp  expres-
     sions.  When you exit the trace break loop, foo will be
     applied to its arguments and the resulting  value  will
     be printed, again using the level printer.  Bar is also
     traced, and each time bar is entered, an  entering  bar
     message  will  be  printed  and then the value of xyzzy
     will be printed.  Next bar will be applied to its argu-
     ments  and  the  result  will  be printed.  If you tell
     _t_r_a_c_e to trace a function which is already  traced,  it
     will  first  _u_n_t_r_a_c_e  it.   Thus if you want to specify
     more than one trace option for a function, you must  do
     it all at once.  The following is _n_o_t equivalent to the
     preceding call to _t_r_a_c_e for foo:

     (_t_r_a_c_e (_f_o_o  _i_f  (_e_q  _3  (_a_r_g  _1)))  (_f_o_o  _b_r_e_a_k)  (_f_o_o
     _l_p_r_i_n_t))

     In this example, only the last option, lprint, will  be
     in effect.

          If the symbol $tracemute is given a non nil value,
     printing  of  the  function name and arguments on entry
     and exit will be surpressed.  This is particularly use-
     ful  if  the  function you are tracing fails after many
     calls to it.  In this case  you  would  tell  _t_r_a_c_e  to
     trace  the function, set $tracemute to t, and begin the
     computation.  When an error occurs  you  can  use  _t_r_a_-
     _c_e_d_u_m_p to print out the current trace frames.

          Generally the trace package has its  own  internal
     names  for  the the lisp functions it uses, so that you
     can feel free to trace system functions like  _c_o_n_d  and
     not worry about adverse interaction with the actions of
     the trace package.  You can trace any type of function:
     lambda,  nlambda,  lexpr  or  macro whether compiled or
     interpreted and you can  even  trace  array  references
     (however  you  should  not attempt to store in an array
     which has been traced).

          When tracing compiled code keep in mind that  many
     function  calls  are  translated  directly  to  machine
     language  or other equivalent  function calls.  A  full
     list of open coded functions is listed at the beginning
     of  the  liszt  compiler  source.   _T_r_a_c_e  will  do   a
     (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l)  to  insure that the new traced
     definitions it defines are called instead  of  the  old


                                      Printed: July 27, 1983







The Joseph Lister Trace Package                         11-5


     untraced  ones.  You may notice that compiled code will
     run slower after this is done.

(traceargs s_func [x_level])

     WHERE:   if x_level is missing it is assumed to be 1.

     RETURNS: the arguments to the x_level_t_h call to  traced
              function s_func are returned.

(tracedump)

     SIDE EFFECT: the  currently  active  trace  frames  are
                  printed  on  the terminal.  returns a list
                  of functions untraced.

(untrace [s_arg1 ...])

     RETURNS: a list of the functions which were untraced.

     NOTE: if no arguments  are  given,  all  functions  are
           untraced.

     SIDE EFFECT: the old function definitions of all traced
                  functions  are restored except in the case
                  where it appears that the current  defini-
                  tion  of  a  function  was  not created by
                  trace.
























9

9                                      Printed: July 27, 1983



EndOfFile
cat >  lisplib/manual/ch12.r  << 'EndOfFile'







                        CHAPTER  12


                 Liszt - the lisp compiler






   12.1.  General strategy of the compiler

           The purpose of the lisp compiler,  Liszt,  is  to
      create  an  object  module which when brought into the
      lisp system using _f_a_s_l will have the  same  effect  as
      bringing in the corresponding lisp coded source module
      with _l_o_a_d with one important exception, functions will
      be  defined  as sequences of machine language instruc-
      tions, instead of lisp S-expressions.  Liszt is not  a
      function compiler, it is a _f_i_l_e compiler.  Such a file
      can contain more than  function  definitions;  it  can
      contain  other  lisp S-expressions which are evaluated
      at load time.  These other S-expressions will also  be
      stored in the object module produced by Liszt and will
      be evaluated at fasl time.

           As is almost universally true of Lisp  compilers,
      the  main  pass of Liszt is written in Lisp.  A subse-
      quent pass is the assembler,  for  which  we  use  the
      standard UNIX assembler.



   12.2.  Running the compiler

           The compiler is normally run in this manner:
      % liszt foo
      will compile the file foo.l or foo (the preferred  way
      to indicate a lisp source file is to end the file name
      with `.l').  The result of  the  compilation  will  be
      placed  in  the  file  foo.o   if no fatal errors were
      detected.  All messages which Liszt  generates  go  to
      the  standard  output.  Normally each function name is
      printed  before  it  is  compiled   (the   -q   option
      suppresses this).



   12.3.  Special forms

           Liszt makes one pass over  the  source  file.  It
      processes each form in this way:
9

9Liszt - the lisp compiler                               12-1







Liszt - the lisp compiler                               12-2


      12.3.1.  macro expansion

              If the form is a macro invocation (i.e it is a
         list  whose  car is a symbol whose function binding
         is  a  macro),  then  that  macro   invocation   is
         expanded.   This  is  repeated  until the top level
         form is not a macro invocation.  When Liszt begins,
         there are already some macros defined, in fact some
         functions (such as defun) are actually macros.  The
         user  may  define  his  own  macros as well.  For a
         macro to be used it must be  defined  in  the  Lisp
         system in which Liszt runs.



      12.3.2.  classification

              After all macro expansion is done, the form is
         classified according to its _c_a_r (if the form is not
         a list, then it is classified as an _o_t_h_e_r).



         12.3.2.1.  eval-when

                 The   form   of   eval-when    is    (_e_v_a_l-
            _w_h_e_n (_t_i_m_e_1 _t_i_m_e_2 ...) _f_o_r_m_1 _f_o_r_m_2 ...)    where
            the time_i are one of  _e_v_a_l,  _c_o_m_p_i_l_e,  or  _l_o_a_d.
            The  compiler examines the form_i in sequence and
            the action taken depends on what is in the  time
            list.   If  _c_o_m_p_i_l_e is in the list then the com-
            piler will invoke _e_v_a_l on each form_i as it exam-
            ines  it.   If _l_o_a_d is in the list then the com-
            pile will recursively  call  itself  to  compile
            each form_i as it examines it.  Note that if _c_o_m_-
            _p_i_l_e and _l_o_a_d are in the  time  list,  then  the
            compiler  will  both  evaluate  and compile each
            form.  This is useful if you need a function  to
            be  defined in the compiler at both compile time
            (perhaps to aid macro expansion) and at run time
            (after the file is _f_a_s_led in).



         12.3.2.2.  declare

                 Declare  is  used  to  provide  information
            about  functions  and variables to the compiler.
            It   is   (almost)    equivalent    to    (_e_v_a_l-
            _w_h_e_n (_c_o_m_p_i_l_e) ...).   You may declare functions
            to  be  one  of  three  types:  lambda  (*expr),
            nlambda  (*fexpr), lexpr (*lexpr).  The names in
            parenthesis  are  the  Maclisp  names  and   are


                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-3


            accepted  by  the compiler as well (and not just
            when the compiler is in  Maclisp  mode).   Func-
            tions  are  assumed to be lambdas until they are
            declared otherwise or are  defined  differently.
            The  compiler treats calls to lambdas and lexprs
            equivalently, so you needn't worry about declar-
            ing  lexprs  either.  It is important to declare
            nlambdas or define  them  before  calling  them.
            Another attribute you can declare for a function
            is localf which makes the function  `local'.   A
            local function's name is known only to the func-
            tions  defined  within  the  file  itself.   The
            advantage  of a local function is that is can be
            entered and exited very quickly and it can  have
            the  same name as a function in another file and
            there will be no name conflict.

                 Variables may be declared special or unspe-
            cial.   When  a special variable is lambda bound
            (either in a lambda, prog or do expression), its
            old  value  is  stored  away  on a stack for the
            duration of the lambda, prog or  do  expression.
            This  takes  time  and  is  often not necessary.
            Therefore the default classification  for  vari-
            ables  is  unspecial.  Space for unspecial vari-
            ables is dynamically allocated on a  stack.   An
            unspecial  variable  can  only  be accessed from
            within the function where it is created  by  its
            presence  in  a  lambda,  prog  or do expression
            variable list.  It is possible to  declare  that
            all  variables  are  special  as  will  be shown
            below.

                 You may declare any  number  of  things  in
            each declare statement.  A sample declaration is
            (_d_e_c_l_a_r_e
                 (_l_a_m_b_d_a _f_u_n_c_1 _f_u_n_c_2)
                 (*_f_e_x_p_r _f_u_n_c_3)
                 (*_l_e_x_p_r _f_u_n_c_4)
                 (_l_o_c_a_l_f _f_u_n_c_5)
                 (_s_p_e_c_i_a_l _v_a_r_1 _v_a_r_2 _v_a_r_3)
                 (_u_n_s_p_e_c_i_a_l _v_a_r_4))

                 You may also declare all  variables  to  be
            special  with  (_d_e_c_l_a_r_e (_s_p_e_c_i_a_l_s _t)).   You may
            declare that macro definitions  should  be  com-
            piled  as  well  as evaluated at compile time by
            (_d_e_c_l_a_r_e (_m_a_c_r_o_s _t)).  In fact, as was mentioned
            above,    declare    is    much    like   (_e_v_a_l-
            _w_h_e_n (_c_o_m_p_i_l_e) ...).  Thus if the compiler  sees
            (_d_e_c_l_a_r_e (_f_o_o _b_a_r))  and foo is defined, then it
            will evaluate (_f_o_o _b_a_r).  If foo is not  defined
            then an undefined declare attribute warning will


                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-4


            be issued.



         12.3.2.3.  (progn 'compile form1 form2 ... formn)

                 When the compiler sees this it simply  com-
            piles  form1  through  formn as if they too were
            seen at top level.  One use for this is to allow
            a  macro  at  top-level to expand into more than
            one function definition for the compiler to com-
            pile.



         12.3.2.4.  include/includef

                 _I_n_c_l_u_d_e and _i_n_c_l_u_d_e_f cause another file  to
            be  read  and  compiled  by  the  compiler.  The
            result is the same as if the included file  were
            textually  inserted into the original file.  The
            only difference between _i_n_c_l_u_d_e and _i_n_c_l_u_d_e_f  is
            that  include  doesn't evaluate its argument and
            includef does.  Nested includes are allowed.



         12.3.2.5.  def

                 A def form is used to  define  a  function.
            The  macros  _d_e_f_u_n  and _d_e_f_m_a_c_r_o expand to a def
            form.   If  the  function  being  defined  is  a
            lambda,  nlambda or lexpr then the compiler con-
            verts the  lisp  definition  to  a  sequence  of
            machine  language instructions.  If the function
            being defined is a macro, then the compiler will
            evaluate the definition, thus defining the macro
            withing the running Lisp compiler.  Furthermore,
            if  the  variable  _m_a_c_r_o_s  is  set  to a non nil
            value, then the macro definition  will  also  be
            translated  to machine language and thus will be
            defined when the object file is fasled in.   The
            variable    _m_a_c_r_o_s    is    set    to    t    by
            (_d_e_c_l_a_r_e (_m_a_c_r_o_s _t)).

                 When a function or macro definition is com-
            piled,  macro  expansion is done whenever possi-
            ble.  If the compiler can determine that a  form
            would  be evaluated if this function were inter-
            preted then it will macro expand  it.   It  will
            not  macro  expand arguments to a nlambda unless
            the characteristics of the nlambda is known  (as
            is  the  case  with  _c_o_n_d).  The map functions (


                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-5


            _m_a_p, _m_a_p_c, _m_a_p_c_a_r, and so on) are expanded to  a
            _d_o statement.  This allows the first argument to
            the map function to be a lambda expression which
            references local variables of the function being
            defined.



         12.3.2.6.  other forms

                 All other forms are simply  stored  in  the
            object  file  and are evaluated when the file is
            _f_a_s_led in.



   12.4.  Using the compiler

           The previous section describes exactly  what  the
      compiler  does  with  its  input.  Generally you won't
      have to worry about all that  detail  as  files  which
      work  interpreted  will work compiled.  Following is a
      list of steps you should follow to insure that a  file
      will compile correctly.

      [1]  Make sure all macro definitions precede their use
           in  functions or other macro definitions.  If you
           want the macros to be around when you _f_a_s_l in the
           object  file you should include this statement at
           the beginning of the file: (_d_e_c_l_a_r_e (_m_a_c_r_o_s _t))

      [2]  Make sure all nlambdas are  defined  or  declared
           before  they  are  used.   If  the compiler comes
           across a call to a function which  has  not  been
           defined  in  the  current  file,  which  does not
           currently have a function binding, and whose type
           has  not  been  declared then it will assume that
           the function needs  its arguments evaluated (i.e.
           it  is  a lambda or lexpr) and will generate code
           accordingly.  This means that you do not have  to
           declare  nlambda functions like _s_t_a_t_u_s since they
           have an nlambda function binding.

      [3]  Locate all variables which are used for  communi-
           cating values between functions.  These variables
           must be declared special at the  beginning  of  a
           file.   In most cases there won't be many special
           declarations but if you fail to declare  a  vari-
           able  special  that  should be, the compiled code
           could fail in mysterious ways.  Let's look  at  a
           common  problem, assume that a file contains just
           these three lines:
9

9                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-6


           (_d_e_f _a_a_a (_l_a_m_b_d_a (_g_l_o_b _l_o_c) (_b_b_b _l_o_c)))
           (_d_e_f _b_b_b (_l_a_m_b_d_a (_m_y_l_o_c) (_a_d_d _g_l_o_b _m_y_l_o_c)))
           (_d_e_f _c_c_c (_l_a_m_b_d_a (_g_l_o_b _l_o_c) (_b_b_b _l_o_c)))


           We can see that if we load in these  two  defini-
           tions then (aaa 3 4) is the same as (add 3 4) and
           will give us 7.  Suppose we compile the file con-
           taining  these  definitions.  When Liszt compiles
           aaa, it will assume that both glob  and  loc  are
           local  variables  and  will allocate space on the
           temporary stack for  their  values  when  aaa  is
           called.   Thus  the values of the local variables
           glob and loc will not affect the  values  of  the
           symbols  glob  and  loc  in the Lisp system.  Now
           Liszt moves on to function bbb.  Myloc is assumed
           to  be local.  When it sees the add statement, it
           find a reference to a variable called glob.  This
           variable is not a local variable to this function
           and therefore glob must refer to the value of the
           symbol  glob.   Liszt  will automatically declare
           glob to be special and it will print a warning to
           that  effect.   Thus subsequent uses of glob will
           always refer to the symbol glob.  Next Liszt com-
           piles ccc and treats glob as a special and loc as
           a local.  When the object file is _f_a_s_l'ed in, and
           (ccc  3  4) is evaluated, the symbol glob will be
           lambda bound to 3 bbb will  be  called  and  will
           return 7.  However (aaa 3 4) will fail since when
           bbb is called, glob will be unbound.  What should
           be done here is to put (_d_e_c_l_a_r_e (_s_p_e_c_i_a_l _g_l_o_b) at
           the beginning of the file.

      [4]  Make sure that all calls to _a_r_g  are  within  the
           lexpr  whose arguments they reference.  If _f_o_o is
           a compiled lexpr and it calls _b_a_r then _b_a_r cannot
           use  _a_r_g  to get at _f_o_o's arguments.  If both _f_o_o
           and _b_a_r are interpreted this will  work  however.
           The  macro _l_i_s_t_i_f_y can be used to put all of some
           of a lexprs arguments in a list which then can be
           passed to other functions.



   12.5.  Compiler options

           The compiler recognizes a number of options which
      are  described  below.  The options are typed anywhere
      on the command line preceded by  a  minus  sign.   The
      entire   command  line  is  scanned  and  all  options
      recorded before any action is taken.  Thus
      % liszt -mx foo
      % liszt -m -x foo


                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-7


      % liszt foo -mx
      are all equivalent. Before scanning the  command  line
      for  options,  liszt  looks for in the environment for
      the variable LISZT, and if found scans its value as if
      it  was  a  string  of  options.   The  meaning of the
      options are:

      C    The assembler language output of the compiler  is
           commented.   This  is  useful  when debugging the
           compiler and is not normally done since it  slows
           down compilation.

      I    The next command line  argument  is  taken  as  a
           filename, and loaded prior to compilation.

      e    Evaluate the next argument on  the  command  line
           before starting compilation.  For example
           % liszt -e '(setq foobar "foo string")' foo
           will evaluate the above s-expression.  Note  that
           the  shell  requires  that  the arguments be sur-
           rounded by single quotes.

      i    Compile this program in  interlisp  compatibility
           mode. This is not implemented yet.

      m    Compile this program in Maclisp mode.  The reader
           syntax  will be changed to the Maclisp syntax and
           a file of macro definitions  will  be  loaded  in
           (usually   named  /usr/lib/lisp/machacks).   This
           switch brings us sufficiently close to Maclisp to
           allow us to compile Macsyma, a large Maclisp pro-
           gram.  However Maclisp is a moving target and  we
           can't  guarantee  that this switch will allow you
           to compile any given program.

      o    Select a different object or  assembler  language
           file name.  For example
           % liszt foo -o xxx.o
           will compile foo and into xxx.o  instead  of  the
           default foo.o, and
           % liszt bar -S -o xxx.s
           will compile to  assembler  language  into  xxx.s
           instead of bar.s.

      p    place profiling code at  the  beginning  of  each
           non-local  function.   If the lisp system is also
           created with profiling in it, this  allows  func-
           tion  calling  frequency  to  be  determined (see
           _p_r_o_f(_1))

      q    Run in quiet mode. The names of  functions  being
           compiled and various "Note"'s are not printed.
9

9                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-8


      Q    print compilation statistics and warn of  strange
           constructs.  This  is the inverse of the q switch
           and is the default.

      r    place bootstrap code  at  the  beginning  of  the
           object  file,  which when the object file is exe-
           cuted will cause a lisp system to be invoked  and
           the  object  file  _f_a_s_led  in.  This  is known as
           `autorun' and is described below.

      S    Create an assembler language file only.
           % liszt -S foo
           will create  the  file  assembler  language  file
           foo.s  and  will  not attempt to assemble it.  If
           this  option  is  not  specified,  the  assembler
           language  file  will be put in the temporary disk
           area under a automatically generated  name  based
           on the lisp compiler's process id.  Then if there
           are no compilation errors, the assembler will  be
           invoked to assemble the file.

      T    Print the assembler language output on the  stan-
           dard  output file.  This is useful when debugging
           the compiler.

      u    Run in UCI-Lisp mode.  The  character  syntax  is
           changed to that of UCI-Lisp and a UCI-Lisp compa-
           tibility package of macros is read in.

      w    Suppress warning messages.

      x    Create an cross reference file.
           % liszt -x foo
           not only compiles foo into foo.o  but  also  gen-
           erates  the file foo.x .  The file foo.x  is lisp
           readable and lists for each  function  all  func-
           tions  which  that function could call.  The pro-
           gram lxref reads one or more of these ".x"  files
           and  produces  a  human  readable cross reference
           listing.



   12.6.  autorun

           The object  file which liszt writes does not con-
      tain  all the functions necessary to run the lisp pro-
      gram which was compiled.  In order to use  the  object
      file,  a  lisp  system  must be started and the object
      file _f_a_s_led in.  When the -r switch is given to liszt,
      the  object file created will contain a small piece of
      bootstrap code at the beginning, and the  object  file
      will  be  made  executable.  Now, when the name of the


                                     Printed: August 5, 1983







Liszt - the lisp compiler                               12-9


      object file is given to the UNIX  command  interpreter
      (shell) to run, the bootstrap code at the beginning of
      the object file will cause a lisp system to be started
      and  the first action the lisp system will  take is to
      _f_a_s_l in the object file which started it.   In  effect
      the object file has created an environment in which it
      can run.

           Autorun  is  an  alternative  to  _d_u_m_p_l_i_s_p.   The
      advantage  of  autorun  is  that the object file which
      starts the whole process is typically  small,  whereas
      the  minimum  _d_u_m_p_l_i_s_ped  file is very large (one half
      megabyte).  The disadvantage of autorun  is  that  the
      file  must  be _f_a_s_led into a lisp each time it is used
      whereas the file which _d_u_m_p_l_i_s_p creates can be run  as
      is.   liszt  itself  is  a _d_u_m_p_l_i_s_ped file since it is
      used so often and is large enough that too  much  time
      would  be  wasted _f_a_s_ling it in each time it was used.
      The lisp cross reference program, lxref, uses  _a_u_t_o_r_u_n
      since it is a small and rarely used program.

           In order to have the program _f_a_s_led in begin exe-
      cution  (rather  than  starting a lisp top level), the
      value of the symbol user-top-level should  be  set  to
      the  name  of the function to get control.  An example
      of this is shown next.


























9

9                                     Printed: August 5, 1983







Liszt - the lisp compiler                              12-10



    ____________________________________________________

    _w_e _w_a_n_t _t_o _r_e_p_l_a_c_e _t_h_e _u_n_i_x _d_a_t_e _p_r_o_g_r_a_m _w_i_t_h _o_n_e _w_r_i_t_t_e_n _i_n _l_i_s_p.

    % cat lispdate.l
    (defun mydate nil
       (patom "The date is ")
       (patom (status ctime))
       (terpr)
       (exit 0))
    (setq user-top-level 'mydate)

    % liszt -r lispdate
    Compilation begins with Lisp Compiler 5.2
    source: lispdate.l, result: lispdate.o
    mydate
    %Note: lispdate.l: Compilation complete
    %Note: lispdate.l:  Time: Real: 0:3, CPU: 0:0.28, GC: 0:0.00 for 0 gcs
    %Note: lispdate.l: Assembly begins
    %Note: lispdate.l: Assembly completed successfully
    3.0u 2.0s 0:17 29%

     _W_e _c_h_a_n_g_e _t_h_e _n_a_m_e _t_o _r_e_m_o_v_e _t_h_e "._o", (_t_h_i_s _i_s_n'_t _n_e_c_e_s_s_a_r_y)
    % mv lispdate.o lispdate

     _N_o_w _w_e _t_e_s_t _i_t _o_u_t
    % lispdate
    The date is Sat Aug  1 16:58:33 1981
    %
    ____________________________________________________






   12.7.  pure literals

           Normally the quoted lisp objects (literals) which
      appear in functions are treated as constants. Consider
      this function:

      (_d_e_f _f_o_o
         (_l_a_m_b_d_a _n_i_l (_c_o_n_d ((_n_o_t (_e_q '_a  (_c_a_r  (_s_e_t_q  _x  '(_a
      _b)))))
                            (_p_r_i_n_t '_i_m_p_o_s_s_i_b_l_e!!))
                           (_t (_r_p_l_a_c_a _x '_d)))))

      At first glance it seems that the  first  cond  clause
      will  never  be  true,  since  the _c_a_r of (_a _b) should
      always be _a.  However if you run this function  twice,
      it will print 'impossible!!' the second time.  This is


                                     Printed: August 5, 1983







Liszt - the lisp compiler                              12-11


      because the following clause modifies  the  'constant'
      list  (_a _b)  with the _r_p_l_a_c_a function.  Such modifica-
      tion of literal lisp objects  can  cause  programs  to
      behave  strangely as the above example shows, but more
      importantly it can cause garbage  collection  problems
      if  done  to compiled code.  When a file is _f_a_s_led in,
      if the symbol $purcopylits is  non  nil,  the  literal
      lisp  data  is  put in 'pure' space, that is it put in
      space which needn't be looked at by the garabage  col-
      lector.   This  reduces the work the garbage collector
      must do but it is dangerous since if the literals  are
      modified  to point to non pure objects, the marker may
      not mark the non pure objects.  If  the  symbol  $pur-
      copylits  is  nil then the literal lisp data is put in
      impure space and the compiled code will act  like  the
      interpreted  code  when literal data is modified.  The
      default value for $purcopylits is t.



   12.8.  transfer tables

           A transfer table is setup by _f_a_s_l when the object
      file is loaded in.  There is one entry in the transfer
      table for each function which is called in that object
      file.   The  entry  for a call to the function _f_o_o has
      two parts whose contents are:

      [1]  function address - This will initially  point  to
           the internal  function _q_l_i_n_k_e_r.  It may some time
           in the future point to the function _f_o_o  if  cer-
           tain  conditions  are  satisfied  (more  on  this
           below).

      [2]  function name - This is a pointer to  the  symbol
           _f_o_o.  This will be used by _q_l_i_n_k_e_r.



      When a call is made to the function _f_o_o the call  will
      actually  be made to the address in the transfer table
      entry  and  will  end  up  in  the  _q_l_i_n_k_e_r  function.
      _Q_l_i_n_k_e_r will determine that _f_o_o was the function being
      called by locating the  function  name  entry  in  the
      transfer table[].  If the function being called is not
      compiled  then  _q_l_i_n_k_e_r  just calls _f_u_n_c_a_l_l to perform
____________________
9   []_Q_l_i_n_k_e_r does this by tracing back the call stack  until
it finds the _c_a_l_l_s machine instruction which called it.  The
address field of the  _c_a_l_l_s  contains  the  address  of  the
transfer table entry.



9                                     Printed: August 5, 1983







Liszt - the lisp compiler                              12-12


      the  function  call.   If  _f_o_o  is  compiled  and   if
      (_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k)  is  non  nil,  then  _q_l_i_n_k_e_r  will
      modify the function address part of the transfer table
      to  point  directly  to  the  function  _f_o_o.   Finally
      _q_l_i_n_k_e_r will call _f_o_o directly .  The next time a call
      is  made  to  _f_o_o the call will go directly to _f_o_o and
      not through _q_l_i_n_k_e_r.  This will result in  a  substan-
      tial   speedup  in  compiled  code  to  compiled  code
      transfers.  A disadvantage is that no debugging infor-
      mation is left on the stack, so _s_h_o_w_s_t_a_c_k and _b_a_k_t_r_a_c_e
      are useless.  Another  disadvantage  is  that  if  you
      redefine a compiled function either through loading in
      a new version or interactively defining it,  then  the
      old  version may still be called from compiled code if
      the fast linking  described  above  has  already  been
      done.   The  solution  to  these  problems  is  to use
      (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _v_a_l_u_e).  If value is

      _n_i_l  All transfer tables will  be  cleared,  i.e.  all
           function  addresses  will  be  set  to  point  to
           _q_l_i_n_k_e_r.  This means that the next time  a  func-
           tion  is  called  _q_l_i_n_k_e_r will be called and will
           look at the current definition.   Also,  no  fast
           links  will  be  set  up since (_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k)
           will be nil.  The end result  is  that  _s_h_o_w_s_t_a_c_k
           and  _b_a_k_t_r_a_c_e  will work and the function defini-
           tion at the time of call will always be used.

      _o_n   This causes the lisp system  to  go  through  all
           transfer  tables  and  set up fast links wherever
           possible.  This is normally used after  you  have
           _f_a_s_led  in  all  of your files. Furthermore since
           (_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k) is not nil, _q_l_i_n_k_e_r will  make
           new  fast  links  if  the situation arises (which
           isn't likely unless you _f_a_s_l in another file).

      _t    This or any other value not previously  mentioned
           will just make (_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k) be non nil, and
           as a result fast links will be made   by  _q_l_i_n_k_e_r
           if the called function is compiled.



   12.9.  Fixnum functions

           The compiler will generate inline arithmetic code
      for  fixnum only functions.  Such functions include +,
      -, *,  /, \, 1+ and 1-.  The code  generated  will  be
      much  faster than using _a_d_d, _d_i_f_f_e_r_e_n_c_e, etc.  However
      it will only work if the arguments to and  results  of
      the functions are fixnums.  No type checking is done.

9

9                                     Printed: August 5, 1983



EndOfFile
cat >  lisplib/manual/ch13.r  << 'EndOfFile'







                        CHAPTER  13


         The CMU User Toplevel and the File Package



This documentation was written by Don Cohen, and  the  func-
tions described below were imported from PDP-10 CMULisp.

_N_o_n _C_M_U _u_s_e_r_s _n_o_t_e: this is not the default  top  level  for
your  Lisp system.  In order to start up this top level, you
should type (_l_o_a_d '_c_m_u_e_n_v).




   13.1.  User Command Input Top Level

      The top-level is the  function  that  reads  what  you
      type, evaluates it and prints the result.  The _n_e_w_l_i_s_p
      top-level was inspired by the CMULisp top-level (which
      was  inspired  by interlisp) but is much simpler.  The
      top-level is a function (of zero arguments)  that  can
      be  called  by  your  program.   If you prefer another
      top-level, just redefine the  top-level  function  and
      type  "(reset)" to start running it.  The current top-
      level simply calls the functions  tlread,  tleval  and
      tlprint  to  read, evaluate and print.  These are sup-
      posed to be replaceable by the  user.   The  only  one
      that  would  make  sense  to replace is tlprint, which
      currently uses a function that refuses to go  below  a
      certain  level  and prints "...]" when it finds itself
      printing a circular list.  One might want  to  pretty-
      print  the  results  instead.   The  current top-level
      numbers the lines that you type to it,  and  remembers
      the  last  n  "events"  (where  n  can  be  set but is
      defaulted to 25).  One can refer to  these  events  in
      the following "top-level commands":













9

9The CMU User Toplevel and the File Package              13-1







The CMU User Toplevel and the File Package              13-2



    ____________________________________________________

    _T_O_P_L_E_V_E_L _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

    ??      prints events - both the input and the result.  If you just type
            "??" you will see all of the recorded events.  "?? 3" will show
            only event 3, and "?? 3 6" will show events 3 through 6.

    redo    pretends that you typed the same thing that was typed before.  If
            you type "redo 3" event number 3 is redone.  "redo -3" redoes the
            thing 3 events ago.  "redo" is the same as "redo -1".

    ed      calls the editor and then does whatever the editor returns.  Thus
            if you want to do event 5 again except for some small change, you
            can type "ed 5", make the change and leave the editor.  "ed -3"
            and "ed" are analogous to redo.
    ____________________________________________________



Finally, you can get the value of event 7 with the  function
(valueof 7).  The other interesting feature of the top-level
is that it makes outermost parentheses superfluous  for  the
most  part.   This  works the same way as in CMULisp, so you
can use the help for an explanation.  If you're not sure and
don't  want  to  risk  it  you  can  always just include the
parentheses.


(top-level)

     SIDE EFFECT: _t_o_p-_l_e_v_e_l is the  LISP top level function.
                  As well as  being the  top level  function
                  with  which  the user interacts, it can be
                  called  recursively  by  the   user or any
                  function.  Thus, the   top  level  can  be
                  invoked  from  inside  the  editor,  break
                  package, or a user  function to  make  its
                  commands available to the user.

     NOTE: The  CMU FRANZ  LISP  top-level    uses  _l_i_n_e_r_e_a_d
           rather   than _r_e_a_d.  The difference will not usu-
           ally be noticeable.  The principal  thing  to  be
           careful   about is that input  to the function or
           system being called cannot appear   on  the  same
           line as the  top-level call.  For example, typing
           (_e_d_i_t_f _f_o_o)_f_P _o_n _o_n_e   _l_i_n_e  _w_i_l_l  _e_d_i_t  _f_o_o  _a_n_d
           _e_v_a_l_u_a_t_e  _P, _n_o_t _e_d_i_t _f_o_o _a_n_d _e_x_e_c_u_t_e _t_h_e  _p _c_o_m_-
           _m_a_n_d _i_n _t_h_e _e_d_i_t_o_r.  _t_o_p-_l_e_v_e_l  _s_p_e_c_i_a_l_l_y  _r_e_c_o_g_-
           _n_i_z_e_s _t_h_e _f_o_l_l_o_w_i_n_g _c_o_m_m_a_n_d_s:

9

9                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-3


(valueof '_g__e_v_e_n_t_s_p_e_c)

     RETURNS: the value(s)  of  the  event(s)  specified  by
              g_eventspec.   If a single event is specified,
              its value will be returned.  If more than  one
              event  is specified, or an event has more than
              one subevent (as for _r_e_d_o,  etc),  a  list  of
              vlaues will be returned.




   13.2.  The File Package

      Users typically define functions in lisp and then want
      to  save  them  for  the  next  session.   If  you  do
      (_c_h_a_n_g_e_s), a list of  the  functions  that  are  newly
      defined  or  changed  will  be printed.  When you type
      (_d_s_k_o_u_t_s), the functions associated with files will be
      saved in the new versions of those files.  In order to
      associate functions with files you can either add them
      to  the  _f_i_l_e_f_n_s  list of an existing file or create a
      new file to hold them.  This is  done  with  the  _f_i_l_e
      function.   If  you  type  (_f_i_l_e  _n_e_w) the system will
      create a variable called  _n_e_w_f_n_s.   You  may  add  the
      names of the functions to go into that file to _n_e_w_f_n_s.
      After you do (_c_h_a_n_g_e_s), the functions which are in  no
      other  file  are  stored  in  the  value  of  the atom
      _c_h_a_n_g_e_s.  To put these all  in  the  new  file,  (_s_e_t_q
      _n_e_w_f_n_s  (_a_p_p_e_n_d  _n_e_w_f_n_s  _c_h_a_n_g_e_s)).   Now  if  you  do
      (_c_h_a_n_g_e_s), all of  the  changed  functions  should  be
      associated  with  files.  In order to save the changes
      on the files, do (_d_s_k_o_u_t_s).  All of the changed  files
      (such  as  NEW)  will  be written.  To recover the new
      functions the next time you run FRANZ LISP, do  (_d_s_k_i_n
      _n_e_w).
















9

9                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-4



    ____________________________________________________

    Script started on Sat Mar 14 11:50:32 1981
    $ newlisp
    Welcome to newlisp...
    1.(defun square (x) (* x x))            ; define a new function
    square
    2.(changes)                             ; See, this function is associated
                                            ; with no file.
    <no-file>      (square)nil
    3.(file 'new)                           ; So let's declare file NEW.
    new
    4.newfns                                ; It doesn't have anything on it yet.
    nil
    5.(setq newfns '(square))               ; Add the function associated
    (square)                                ; with no file to file NEW.
    6.(changes)                             ; CHANGES magically notices this fact.

    new            (square)nil
    7.(dskouts)                             ; We write the file.
    creating new
    (new)
    8.(dskin new)                           ; We read it in!
    (new)
    14.Bye
    $
    script done on Sat Mar 14 11:51:48 1981

    ____________________________________________________





(changes s_flag)

     RETURNS: Changes computes a list  containing  an  entry
              for  each  file  which defines atoms that have
              been marked changed.  The entry  contains  the
              file   name  and  the  changed  atoms  defined
              therein.  There is also a  special  entry  for
              changes  to atoms which are not defined in any
              known file.  The global variable _f_i_l_e_l_s_t  con-
              tains  the  list of "known" files.  If no flag
              is passed this  result  is  printed  in  human
              readable  form  and the value returned is t if
              there were any changes and nil if not.  Other-
              wise  nothing is printed and the computer list
              is returned.  The global variable _c_h_a_n_g_e_s con-
              tains  the  atoms which are marked changed but
              not yet associated with any file.  The _c_h_a_n_g_e_s
              function  attempts  to  associate  these names


                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-5


              with files, and any that  are  not  found  are
              considered  to belong to no file.  The _c_h_a_n_g_e_s
              property is the means by which  changed  func-
              tions  are associated with files.  When a file
              is read in or written out its _c_h_a_n_g_e_s property
              is removed.

(dc s_word s_id [ g_descriptor1  ... ] <text> <esc>)

     RETURNS: _d_c defines comments.   It  is  exceptional  in
              that  its  behavior is very context dependent.
              When _d_c  is  executed  from  _d_s_k_i_n  it  simply
              records  the fact that the comment exists.  It
              is expected that in interactive mode  comments
              will  be  found via _g_e_t_d_e_f - this allows large
              comments which do not take up  space  in  your
              core image.  When _d_c is executed from the ter-
              minal it expects you to type a comment. _d_s_k_o_u_t
              will  write  out  the comments that you define
              and also copy the comments on the old  version
              of the file, so that the new version will keep
              the old comments even though they  were  never
              actually  brought  into core.  The optional id
              is  a  mechanism  for   distinguishing   among
              several  comments  associated  with  the  same
              word.  It defaults to  nil.   However  if  you
              define  two  comments  with  the  same id, the
              second is considered to be a  replacement  for
              the first. The behavior of _d_c is determined by
              the value of the global variable  _d_e_f-_c_o_m_m_e_n_t.
              _d_e_f-_c_o_m_m_e_n_t  contains  the  name of a function
              that is run.  Its arguments are the  word,  id
              and  attribute  list. _d_e_f-_c_o_m_m_e_n_t is initially
              _d_c-_d_e_f_i_n_e.  Other functions rebind it  to  _d_c-
              _h_e_l_p,  _d_c-_u_s_e_r_h_e_l_p,  and  the  value of _d_s_k_i_n-
              _c_o_m_m_e_n_t.  The comment property of an atom is a
              list  of  entries,  each representing one com-
              ment.  Atomic entries are assumed to be  iden-
              tifiers of comments on a file but not in core.
              In-core comments are represented by a list  of
              the  id,  the  attribute  list and the comment
              text.  The comment text is an uninterned atom.
              Comments  may be deleted or reordered by edit-
              ing the comment property.








9

9                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-6


(dskin l_filenames)

     SIDE EFFECT: READ-EVAL-PRINTs  the  contents  of    the
                  given  files.  This is the function to use
                  to read files created  by  _d_s_k_o_u_t.   _d_s_k_i_n
                  also  declares the files that it reads (if
                  a _f_i_l_e-_f_n_s list is defined and the file is
                  otherwise  declarable  by  _f_i_l_e ), so that
                  changes to it can be recorded.


(dskout s_file1 ...)

     SIDE EFFECT: For each file  specified,  _d_s_k_o_u_t  assumes
                  the   list  named  filenameFNS (i.e.,  the
                  file  name,   excluding  extension,   con-
                  catenated   with  _f_n_s )  contains  a  list
                  of function names, etc., to be loaded  Any
                  previous  version  of  the  file  will  be
                  renamed  to have extension ".back".

(dskouts s_file1 ...)

     SIDE EFFECT: applies _d_s_k_o_u_t to and  prints the name  of
                  each  s_filei    (with    no    additional
                  arguments,   assuming filenameFNS to be  a
                  list  to  be loaded) for  which s_file_i is
                  either not in _f_i_l_e_l_s_t  (meaning  it  is  a
                  new   file not previously declared by _f_i_l_e
                  or  given  as  an   argument   to   _d_s_k_i_n,
                  _d_s_k_o_u_t_s,  or _d_s_k_o_u_t_s) or is in _f_i_l_e_l_s_t and
                  has some recorded changes  to  definitions
                  of  atoms  in  filenameFNS, as recorded by
                  _m_a_r_k!_c_h_a_n_g_e_d and  noted  by  changes.   If
                  _f_i_l_ei  is not  specified, _f_i_l_e_l_s_t  will be
                  used.  This  is the  most common   way  of
                  using  dskouts.   Typing   (_d_s_k_o_u_t_s)  will
                  save  every  file  reported  by  (_c_h_a_n_g_e_s)
                  to have changed definitions.


(dv s_atom g_value)

     EQUIVALENT TO: (_s_e_t_q   _a_t_o_m    '_v_a_l_u_e).     _d_v    calls
                    _m_a_r_k!_c_h_a_n_g_e_d.







9

9                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-7


(file 's_file)

     SIDE EFFECT: declares its argument to be a file  to  be
                  used  for  reporting and saving changes to
                  functions by adding the  file  name  to  a
                  list  of  files,  _f_i_l_e_l_s_t.  _f_i_l_e is called
                  for each file argument of  _d_s_k_i_n,  _d_s_k_o_u_t,
                  and _d_s_k_o_u_t_s.

(file-fns 's_file)

     RETURNS: the name of the  fileFNS  list  for  its  file
              argument s_file.

(getdef 's_file ['s_i1 ...])

     SIDE EFFECT: selectively executes definitions for atoms
                  s_i1  ... from the specified file.  Any of
                  the words to be defined which end with "@"
                  will be treated as patterns in which the @
                  matchs any suffix (just like the  editor).
                  _g_e_t_d_e_f  is driven by _g_e_t_d_e_f_t_a_b_l_e (and thus
                  may be programmed).  It looks for lines in
                  the  file  that  start  with a word in the
                  table.  The first character must be a  "("
                  or "[" followed by the word, followed by a
                  space, return or something else that  will
                  not  be considered as part of the identif-
                  ier by _r_e_a_d, e.g.,  "("  is  unacceptable.
                  When  one  is found the next word is read.
                  If it matches one of  the  identifiers  in
                  the call to _g_e_t_d_e_f then the table entry is
                  executed.  The table entry is  a  function
                  of  the  expression starting in this line.
                  Output from _d_s_k_o_u_t is in acceptable format
                  for _g_e_t_d_e_f.  _g_e_t_d_e_f

     RETURNS: a list of the words which match  the  ones  it
              looked for, for which it found (but, depending
              on the table, perhaps did not execute) in  the
              file.

     NOTE: _g_e_t_d_e_f_t_a_b_l_e is the table that drives _g_e_t_d_e_f.   It
           is in the form of an association list.  Each ele-
           ment is a dotted pair consisting of the name of a
           function for which _g_e_t_d_e_f searches and a function
           of one argument to be executed when it is found.





9

9                                      Printed: July 21, 1983







The CMU User Toplevel and the File Package              13-8


(mark!changed 's_f)

     SIDE EFFECT: records the fact that  the  definition  of
                  s_f has been changed.  It is automatically
                  called by _d_e_f, _d_e_f_u_n, _d_e, _d_f, _d_e_f_p_r_o_p, _d_m,
                  _d_v,  and  the  editor when a definition is
                  altered.













































9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch14.r  << 'EndOfFile'







                        CHAPTER  14


                      The LISP Stepper






   14.1.  Simple Use Of Stepping

(step s_arg1...)

     NOTE: The LISP "stepping" package is intended  to  give
           the  LISP  programmer a facility analogous to the
           Instruction  Step  mode  of  running  a   machine
           language  program.  The user interface is through
           the function (fexpr) step, which sets switches to
           put the LISP interpreter in and out of "stepping"
           mode.  The most common _s_t_e_p  invocations  follow.
           These  invocations  are usually typed at the top-
           level, and will take effect immediately (i.e. the
           next  S-expression  typed in will be evaluated in
           stepping mode).


    ____________________________________________________

    (_s_t_e_p _t)                                ; Turn on stepping mode.
    (_s_t_e_p _n_i_l)                      ; Turn off stepping mode.
    ____________________________________________________




     SIDE EFFECT: In stepping mode, the LISP evaluator  will
                  print  out  each  S-exp  to  be  evaluated
                  before evaluation, and the returned  value
                  after  evaluation,  calling  itself recur-
                  sively to display the  stepped  evaluation
                  of  each argument, if the S-exp is a func-
                  tion call.  In stepping mode, the  evalua-
                  tor  will wait after displaying each S-exp
                  before evaluation for a command  character
                  from the console.






9

9The LISP Stepper                                        14-1







The LISP Stepper                                        14-2



    ____________________________________________________

    _S_T_E_P _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

    <return>                        Continue stepping recursively.

    c                               Show returned value from this level
                                    only, and continue stepping upward.

    e                               Only step interpreted code.

    g                               Turn off stepping mode. (but continue
                                    evaluation without stepping).

    n <number>                      Step through <number> evaluations without
                                    stopping

    p                               Redisplay current form in full
                                    (i.e. rebind prinlevel and prinlength to nil)

    b                               Get breakpoint

    q                               Quit

    d                               Call debug
    ____________________________________________________






   14.2.  Advanced Features



      14.2.1.  Selectively Turning On Stepping.

         If
                (_s_t_e_p _f_o_o_1 _f_o_o_2 ...)

         is typed at top level, stepping will  not  commence
         immediately,  but  rather  when the evaluator first
         encounters an S-expression  whose  car  is  one  of
         _f_o_o_1,  _f_o_o_2,  etc.   This form will then display at
         the console, and the evaluator will be in  stepping
         mode waiting for a command character.

              Normally the stepper intercepts calls to  _f_u_n_-
         _c_a_l_l  and  _e_v_a_l.   When _f_u_n_c_a_l_l is intercepted, the
         arguments  to  the  function  have   already   been
         evaluated   but   when  _e_v_a_l  is  intercepted,  the


                                      Printed: July 21, 1983







The LISP Stepper                                        14-3


         arguments have not been  evaluated.   To  differen-
         tiate  the  two  cases,  when  printing the form in
         evaluation, the stepper preceded intercepted  calls
         to  _f_u_n_c_a_l_l  with  "f:".  Calls to _f_u_n_c_a_l_l are nor-
         mally caused by compiled lisp  code  calling  other
         functions, whereas calls to _e_v_a_l usually occur when
         lisp code is interpreted.  To step  only  calls  to
         eval use:         (_s_t_e_p _e)




      14.2.2.  Stepping With Breakpoints.

              For the moment, step is turned off  inside  of
         error  breaks, but not by the break function.  Upon
         exiting the error,  step  is  reenabled.   However,
         executing  (_s_t_e_p _n_i_l) inside a error loop will turn
         off stepping globally, i.e. within the error  loop,
         and after return has be made from the loop.



   14.3.  Overhead of Stepping.

           If stepping mode has been  turned  off  by  (_s_t_e_p
      _n_i_l),  the  execution  overhead of having the stepping
      packing in your LISP is identically nil.  If one stops
      stepping  by  typing  "g", every call to eval incurs a
      small    overhead--several    machine    instructions,
      corresponding  to  the compiled code for a simple cond
      and one function pushdown.  Running  with  (_s_t_e_p  _f_o_o_1
      _f_o_o_2 ...) can be more expensive, since a member of the
      car of the current form into the list (_f_o_o_1 _f_o_o_2  ...)
      is required at each call to eval.



   14.4.  Evalhook and Funcallhook

           There are hooks in the FRANZ LISP interpreter  to
      permit  a user written function to gain control of the
      evaluation process.  These hooks are used by the  Step
      package  just described.  There are two hooks and they
      have been strategically placed in the  two  key  func-
      tions  in the interpreter: _e_v_a_l (which all interpreted
      code goes through) and  _f_u_n_c_a_l_l  (which  all  compiled
      code  goes through if (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l) has been
      done).  The hook in _e_v_a_l is compatible  with  Maclisp,
      but there is no Maclisp equivalent of the hook in _f_u_n_-
      _c_a_l_l.

9

9                                      Printed: July 21, 1983







The LISP Stepper                                        14-4


           To arm the hooks two  forms  must  be  evaluated:
      (*_r_s_e_t _t)  and  (_s_s_t_a_t_u_s _e_v_a_l_h_o_o_k _t).   Once  that  is
      done, _e_v_a_l and _f_u_n_c_a_l_l do a special  check  when  they
      enter.

           If  _e_v_a_l  is  given  a  form  to  evaluate,   say
      (_f_o_o _b_a_r),  and  the symbol `evalhook' is non nil, say
      its value is `ehook', then _e_v_a_l will lambda  bind  the
      symbols  `evalhook'  and `funcallhook' to nil and will
      call ehook passing (_f_o_o _b_a_r) as the argument.   It  is
      ehook's   responsibility  to  evaluate  (_f_o_o _b_a_r)  and
      return its value.  Typically ehook will call the func-
      tion  `evalhook'  to  evaluate  (_f_o_o _b_a_r).   Note that
      `evalhook' is a symbol whose  function  binding  is  a
      system  function  described  in  Chapter  4, and whose
      value binding, if non nil, is the name of a user writ-
      ten  function  (or  a  lambda  expression, or a binary
      object) which  will  gain  control  whenever  eval  is
      called.  `evalhook' is also the name of the _s_t_a_t_u_s tag
      which must be set for all of this to work.

           If _f_u_n_c_a_l_l is given a function, say  foo,  and  a
      set of already evaluated arguments, say barv and bazv,
      and if the symbol `funcallhook' has a non  nil  value,
      say  `fhook', then _f_u_n_c_a_l_l will lambda bind `evalhook'
      and `funcallhook' to nil  and  will  call  fhook  with
      arguments  barv,  bazv  and foo.  Thus fhook must be a
      lexpr since it may be given any number  of  arguments.
      The  function  to  call, foo in this case, will be the
      _l_a_s_t of the arguments given to fhook.   It  is  fhooks
      responsibility  to do the function call and return the
      value.  Typically fhook will call  the  function  _f_u_n_-
      _c_a_l_l_h_o_o_k  to  do the funcall.  This is an example of a
      funcallhook function which  just prints the  arguments
      on each entry to funcall and the return value.

















9

9                                      Printed: July 21, 1983







The LISP Stepper                                        14-5



    ____________________________________________________

    -> (_d_e_f_u_n _f_h_o_o_k _n (_l_e_t ((_f_o_r_m (_c_o_n_s (_a_r_g _n) (_l_i_s_t_i_f_y (_1- _n))))
                            (_r_e_t_v_a_l))
                           (_p_a_t_o_m "_c_a_l_l_i_n_g ")(_p_r_i_n_t _f_o_r_m)(_t_e_r_p_r)
                           (_s_e_t_q _r_e_t_v_a_l (_f_u_n_c_a_l_l_h_o_o_k _f_o_r_m '_f_h_o_o_k))
                           (_p_a_t_o_m "_r_e_t_u_r_n_s ")(_p_r_i_n_t _r_e_t_v_a_l)(_t_e_r_p_r)
                           _r_e_t_v_a_l))
    fhook
    -> (*_r_s_e_t _t) (_s_s_t_a_t_u_s _e_v_a_l_h_o_o_k _t) (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l)
    -> (_s_e_t_q _f_u_n_c_a_l_l_h_o_o_k '_f_h_o_o_k)
    calling (print fhook)           ;; now all compiled code is traced
    fhookreturns nil
    calling (terpr)

    returns nil
    calling (patom "-> ")
    -> returns "-> "
    calling (read nil Q00000)
    (_a_r_r_a_y _f_o_o _t _1_0)                ;; to test it, we see what happens when
    returns (array foo t 10)        ;; we make an array
    calling (eval (array foo t 10))
    calling (append (10) nil)
    returns (10)
    calling (lessp 1 1)
    returns nil
    calling (apply times (10))
    returns 10
    calling (small-segment value 10)
    calling (boole 4 137 127)
    returns 128
     ... there is plenty more ...
    ____________________________________________________


















9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch15.r  << 'EndOfFile'







                        CHAPTER  15


                     The FIXIT Debugger






   15.1.  Introduction   FIXIT is  a  debugging  environment
      for  FRANZ LISP users doing program development.  This
      documentation and  FIXIT  were  written  by  David  S.
      Touretzky  of  Carnegie-Mellon University for MACLisp,
      and adapted to FRANZ LISP  by  Mitch  Marcus  of  Bell
      Labs.  One of FIXIT's goals is to get the program run-
      ning again  as  quickly  as  possible.   The  user  is
      assisted  in  making  changes to his functions "on the
      fly", i.e. in the midst of execution, and then  compu-
      tation is resumed.

           To enter the debugger type (_d_e_b_u_g).  The debugger
      goes  into  its  own  read-eval-print  loop.  Like the
      top-level, the debugger  understands  certain  special
      commands.   One  of these is help, which prints a list
      of the available commands.  The basic idea is that you
      are  somewhere  in a stack of calls to eval.  The com-
      mand "bka" is probably the most appropriate for  look-
      ing  at  the stack.  There are commands to move up and
      down.  If you want to know the value of "x" as of some
      place  in  the  stack, move to that place and type "x"
      (or (cdr x) or anything else that you  might  want  to
      evaluate).   All  evaluation is done as of the current
      stack position.  You can fix the problem  by  changing
      the  values of variables, editing functions or expres-
      sions in the stack etc.  Then you  can  continue  from
      the current stack position (or anywhere else) with the
      "redo" command.  Or you can simply  return  the  right
      answer with the "return" command.

           When it is not immediately obvious why  an  error
      has  occurred  or  how the program got itself into its
      current state, FIXIT comes to the rescue by  providing
      a powerful debugging loop in which the user can:

      -  examine the stack

      -  evaluate expressions in context

      -  enter stepping mode

      -  restart the computation at any point
9

9The FIXIT Debugger                                      15-1







The FIXIT Debugger                                      15-2


      The result is that program errors can be  located  and
      fixed  extremely  rapidly, and with a minimum of frus-
      tration.

           The debugger can only work effectively when extra
      information  is  kept about forms in evaluation by the
      lisp system.  Evaluating (*_r_s_e_t _t) tells the lisp sys-
      tem to maintain this information. If you are debugging
      compiled code you should also be sure  that  the  com-
      piled   code  to  compiled  code  linkage  tables  are
      unlinked, i.e do (_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l).


(debug [ s_msg ])

     NOTE: Within a program, you  may  enter  a  debug  loop
           directly  by putting in a call to _d_e_b_u_g where you
           would normally put a call to _b_r_e_a_k.  Also, within
           a break loop you may enter FIXIT by typing _d_e_b_u_g.
           If an argument is given to DEBUG, it  is  treated
           as  a message to be printed before the debug loop
           is entered.  Thus you can put (_d_e_b_u_g |_j_u_s_t _b_e_f_o_r_e
           _l_o_o_p|)  into  a  program to indicate what part of
           the program is being debugged.




























9

9                                      Printed: July 21, 1983







The FIXIT Debugger                                      15-3



    ____________________________________________________

    _F_I_X_I_T _C_o_m_m_a_n_d _S_u_m_m_a_r_y

    TOP     go to top of stack (latest expression)
    BOT     go to bottom of stack (first expression)
    P       show current expression (with ellipsis)
    PP      show current expression in full
    WHERE   give current stack position
    HELP    types the abbreviated command summary found
            in /usr/lisp/doc/fixit.help.  H and ? work too.
    U       go up one stack frame
    U n     go up n stack frames
    U f     go up to the next occurrence of function f
    U n f   go up n occurrences of function f
    UP      go up to the next user-written function
    UP n    go up n user-written functions
     ...the DN and DNFN commands are similar, but go down
     ...instead of up.
    OK      resume processing; continue after an error or debug loop
    REDO    restart the computation with the current stack frame.
            The OK command is equivalent to TOP followed by REDO.
    REDO f  restart the computation with the last call to function f.
            (The stack is searched downward from the current position.)
    STEP    restart the computation at the current stack frame,
            but first turn on stepping mode.  (Assumes Rich stepper is loaded.)
    RETURN e   return from the current position in the computation
               with the value of expression e.
    BK..    print a backtrace.  There are many backtrace commands,
            formed by adding suffixes to the BK command.  "BK" gives
            a backtrace showing only user-written functions, and uses
            ellipsis.  The BK command may be suffixed by one or more
            of the following modifiers:
     ..F..   show function names instead of expressions
     ..A..   show all functions/expressions, not just user-written ones
     ..V..   show variable bindings as well as functions/expressions
     ..E..   show everything in the expression, i.e. don't use ellipsis
     ..C..   go no further than the current position on the stack
            Some of the more useful combinations are BKFV, BKFA,
            and BKFAV.
    BK.. n    show only n levels of the stack (starting at the top).
              (BK n counts only user functions; BKA n counts all functions.)
    BK.. f    show stack down to first call of function f
    BK.. n f  show stack down to nth call of function f
    ____________________________________________________






9

9                                      Printed: July 21, 1983







The FIXIT Debugger                                      15-4


   15.2.  Interaction with _t_r_a_c_e    FIXIT  knows  about  the
      standard  Franz trace package, and tries to make trac-
      ing invisible  while  in  the  debug  loop.   However,
      because  of  the  way _t_r_a_c_e works, it may sometimes be
      the case that the functions on the  stack  are  really
      un_i_n_t_e_r_ned  atoms  that have the same name as a traced
      function.  (This  only  happens  when  a  function  is
      traced  WHEREIN  another one.)  FIXIT will call atten-
      tion to _t_r_a_c_e'_s hackery by printing an appropriate tag
      next to these stack entries.




   15.3.  Interaction with _s_t_e_p   The _s_t_e_p function  may  be
      invoked from within FIXIT via the STEP command.  FIXIT
      initially turns off stepping when the  debug  loop  is
      entered.   If  you  step through a function and get an
      error, FIXIT will still be invoked normally.   At  any
      time  during  stepping, you may explicitly enter FIXIT
      via the "D" (debug) command.




   15.4.  Multiple error levels   FIXIT will evaluate  arbi-
      trary LISP expressions in its debug loop.  The evalua-
      tion is not done within an _e_r_r_s_e_t,  so,  if  an  error
      occurs,  another  invocation  of  the  debugger can be
      made.  When there are multiple errors  on  the  stack,
      FIXIT  displays  a  barrier  symbol between each level
      that looks something  like  <------------UDF-->.   The
      UDF in this case stands for UnDefined Function.  Thus,
      the upper level debug loop was invoked by an undefined
      function error that occurred while in the lower loop.

















9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch16.r  << 'EndOfFile'







                        CHAPTER  16


                      The LISP Editor







   16.1.  The Editors

      It is quite possible to use VI, Emacs or  other  stan-
      dard editors to edit your lisp programs, and many peo-
      ple do just that.  However there is a  lisp  structure
      editor  which  is particularly good for the editing of
      lisp programs, and  operates  in  a  rather  different
      fashion,  namely  within a lisp environment.  applica-
      tion.  It is handy to know how to use  it  for  fixing
      problems  without  exiting  from the lisp system (e.g.
      from the debugger  so  you  can  continue  to  execute
      rather  than having to start over.)  The editor is not
      quite like the top-level  and  debugger,  in  that  it
      expects  you  to  type editor commands to it.  It will
      not evaluate whatever you happen to type.   (There  is
      an editor command to evaluate things, though.)

      The editor is available (assuming your system  is  set
      up  correctly  with  a  lisp  library) by typing (load
      'cmufncs) and (load 'cmuedit).

      The  most  frequent  use of the editor  is  to  change
      function  definitions  by starting the editor with one
      of the  commands  described  in  section  16.14.  (see
      _e_d_i_t_f),   values   (_e_d_i_t_v),  properties  (_e_d_i_t_p),  and
      expressions  (_e_d_i_t_e).  The  beginner   is  advised  to
      start  with  the  following (very basic) commands: _o_k,
      _u_n_d_o, _p, #, under which are  explained  two  different
      basic commands which  start with numbers, and f.

      This documentation, and the editor, were imported from
      PDP-10  CMULisp by Don Cohen.  PDP-10 CMULisp is based
      on UCILisp, and the editor itself was derived from  an
      early  version of Interlisp.  Lars Ericson, the author
      of this section, has provided this very  concise  sum-
      mary.   Tutorial  examples  and implementation details
      may be found in the Interlisp Reference Manual,  where
      a similar editor is described.



9

9The LISP Editor                                         16-1







The LISP Editor                                         16-2


   16.2.  Scope of Attention

      Attention-changing commands allow you  to  look  at  a
      different  part  of a Lisp expression you are editing.
      The sub-structure upon which the editor's attention is
      centered  is called "the current expression".   Chang-
      ing the current expression  means  shifting  attention
      and not actually modifying any structure.

____________________________________________________________

_S_C_O_P_E _O_F _A_T_T_E_N_T_I_O_N _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_n (_n>_0) . Makes the nth element of the current expression be
the new current expression.

-_n (_n>_0). Makes the nth element from the end of the  current
expression be the new current expression.

_0. Makes the  next  higher expression  be  the  new  correct
expression.   If  the  intention  is  to go back to the next
higher left parenthesis, use the command !0.

_u_p .  If a p command would cause  the  editor  to  type  ...
before  typing  the current expression, (the current expres-
sion is a tail of the next higher expression)  then  has  no
effect;  else, up makes the old current expression the first
element in the new current expression.

!_0 . Goes back to the next higher left parenthesis.

^ .  Makes the top level expression be the  current  expres-
sion.

_n_x .  Makes the current expression be the next expression.

(_n_x _n) equivalent to n nx commands.

!_n_x .  Makes current expression be the next expression at  a
higher  level.  Goes through any number of right parentheses
to get to the next expression.

 _b_k .  Makes the current expression be the previous  expres-
sion in the next higher expression.

(_n_t_h _n) _n>_0 .  Makes the list starting with the nth  element
of the current expression be the current expression.

(_n_t_h $) - _g_e_n_e_r_a_l_i_z_e_d _n_t_h _c_o_m_m_a_n_d. nth locates $,  and  then
backs up to the current level, where the new current expres-
sion is the tail whose first element contains, however  dee-
ply,  the  expression  that was the terminus of the location
operation.


                                      Printed: July 21, 1983







The LISP Editor                                         16-3


:: .  (pattern ::  .  $)  e.g., (cond :: return).   finds  a
cond that contains a return, at any depth.

(_b_e_l_o_w _c_o_m _x) .  The below command is useful for locating  a
substructure  by  specifying something  it contains.  (below
cond) will cause the cond  clause  containing   the  current
expression  to  become  the new current expression.  Suppose
you are editing a list of lists, and want to find a  sublist
that  contains a foo (at any depth).  Then simply executes f
foo (below ).

(_n_e_x _x) .  same as (_b_e_l_o_w _x) followed by nx.   For  example,
if  you are deep inside of a selectq clause, you can advance
to the next clause with (_n_e_x _s_e_l_e_c_t_q).

_n_e_x.  The  atomic  form  of  _n_e_x is useful if  you  will  be
performing  repeated   executions   of  (_n_e_x  _x).  By simply
marking  the  chain corresponding to x,  you can use _n_e_x  to
step through the sublists.
____________________________________________________________





   16.3.  Pattern Matching Commands

      Many editor commands that  search  take  patterns.   A
      pattern _p_a_t matches with x if:

____________________________________________________________

_P_A_T_T_E_R_N _S_P_E_C_I_F_I_C_A_T_I_O_N _S_U_M_M_A_R_Y

- _p_a_t is _e_q to x.

- _p_a_t is &.

- _p_a_t is a number and equal to x.

- if (car _p_a_t) is the atom *any*, (cdr _p_a_t)  is  a  list  of
patterns,  and  _p_a_t matches x if and only if one of the pat-
terns on (cdr _p_a_t) matches x.

- if _p_a_t is a literal atom or string, and (nthchar  _p_a_t  -1)
is @, then _p_a_t matches with any literal atom or string which
has the same initial characters as _p_a_t, e.g.   ver@  matches
with verylongatom, as well as "verylongstring".

- if (car _p_a_t) is the atom --, _p_a_t matches  x  if  (a)  (cdr
_p_a_t)=nil,  i.e.   _p_a_t=(--), e.g., (a --) matches (a) (a b c)
and (a .  b) in other words, -- can  match  any  tail  of  a
list.   (b)  (cdr _p_a_t) matches with some tail of x, e.g.  (a


                                      Printed: July 21, 1983







The LISP Editor                                         16-4


-- (&)) will match with (a b c (d)), but not (a b c  d),  or
(a  b c (d) e).  however, note that (a -- (&) --) will match
with (a b c (d) e).  in other words, -- will match any inte-
rior segment of a list.

- if (car _p_a_t) is the atom ==, _p_a_t matches x if and only  if
(cdr  _p_a_t) is _e_q to x.  (this pattern is for use by programs
that call the editor as a subroutine, since  any  non-atomic
expression  in a command typed in by the user obviously can-
not be _e_q to existing structure.) -  otherwise  if  x  is  a
list,  _p_a_t  matches x if (car _p_a_t) matches (car x), and (cdr
_p_a_t) matches (cdr x).

- when searching, the pattern  matching  routine  is  called
only  to  match  with  elements in the structure, unless the
pattern begins with :::, in which case cdr of the pattern is
matched  against tails in the structure.  (in this case, the
tail does not have to be a proper tail, e.g.   (:::   a  --)
will  match  with the element (a b c) as well as with cdr of
(x a b c), since (a b c) is a tail of (a b c).)
____________________________________________________________





      16.3.1.  Commands That Search

____________________________________________________________

_S_E_A_R_C_H _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_f _p_a_t_t_e_r_n .  f informs the editor that the next  command  is
to  be  interpreted as a pattern.  If no pattern is given on
the same line as the f then the last  pattern  is  used.   f
pattern means find the next instance of pattern.

(_f _p_a_t_t_e_r_n _n).  Finds the next instance of pattern.

(_f _p_a_t_t_e_r_n _t).  similar to f pattern, except,  for  example,
if the current expression is (cond ..), f cond will look for
the next cond, but (f cond t) will 'stay here'.

(_f _p_a_t_t_e_r_n  _n)  _n>_0.   Finds  the  nth  place  that  pattern
matches.   If the current expression is (foo1 foo2 foo3), (f
f00@ 3) will find foo3.

(_f _p_a_t_t_e_r_n) _o_r (_f _p_a_t_t_e_r_n _n_i_l).  only matches with  elements
at  the top level of the current expression.  If the current
expression is (_p_r_o_g _n_i_l (_s_e_t_q _x (_c_o_n_d & &)) (_c_o_n_d &) ...)  f
(cond  --)  will  find  the cond inside the setq, whereas (f
(cond --)) will find the top level cond,  i.e.,  the  second
one.


                                      Printed: July 21, 1983







The LISP Editor                                         16-5


(_s_e_c_o_n_d . $) .  same as (lc .  $) followed by another (lc  .
$)  except  that  if the first succeeds and second fails, no
change is made to the edit chain.

(_t_h_i_r_d . $) .  Similar to second.

(_f_s _p_a_t_t_e_r_n_1 ... _p_a_t_t_e_r_n_n) .  equivalent to f pattern1  fol-
lowed by f pattern2 ...  followed by f pattern n, so that if
f pattern m fails, edit chain is left at place  pattern  m-1
matched.

(_f= _e_x_p_r_e_s_s_i_o_n _x) .  Searches for a structure eq to  expres-
sion.

(_o_r_f _p_a_t_t_e_r_n_1 ... _p_a_t_t_e_r_n_n) .  Searches  for  an  expression
that is matched by either pattern1 or ...  patternn.

_b_f _p_a_t_t_e_r_n .  backwards find.   If the current expression is
(_p_r_o_g _n_i_l (_s_e_t_q _x (_s_e_t_q _y (_l_i_s_t _z))) (_c_o_n_d ((_s_e_t_q _w --) --))
--) f list followed  by  bf  setq  will  leave  the  current
expression  as (setq y (list z)), as will f cond followed by
bf setq

(_b_f _p_a_t_t_e_r_n _t).  backwards  find.   Search  always  includes
current  expression,  i.e., starts at end of current expres-
sion and works backward, then ascends and backs up, etc.
____________________________________________________________





         16.3.1.1.   Location Specifications    Many  editor
            commands  use  a  method  of specifying position
            called  a  location  specification.   The  meta-
            symbol $ is used to denote a location specifica-
            tion.   $ is a list of commands  interpreted  as
            described above.  $ can also be atomic, in which
            case it is interpreted as (list $).  a  location
            specification  is  a  list of edit commands that
            are executed in  the  normal  fashion  with  two
            exceptions.   first, all commands not recognized
            by the editor are interpreted as though they had
            been  preceded  by f. The location specification
            (cond 2 3) specifies  the  3rd  element  in  the
            first clause of the next cond.

            the if command and the ## function provide a way
            of  using  in  location specifications arbitrary
            predicates applied to elements  in  the  current
            expression.

            In insert, delete, replace and change, if  $  is


                                      Printed: July 21, 1983







The LISP Editor                                         16-6


            nil (empty), the corresponding operation is per-
            formed on the current edit chain, i.e.  (replace
            with  (car x)) is equivalent to (:(car x)).  for
            added readability, here is also permitted, e.g.,
            (insert  (print  x)  before  here)  will  insert
            (print x) before the current expression (but not
            change  the  edit chain).  It is perfectly legal
            to ascend to insert, replace,  or  delete.   for
            example  (insert  (_r_e_t_u_r_n) after ^ prog -1) will
            go to the top, find the first prog, and insert a
            (_r_e_t_u_r_n)  at its end, and not change the current
            edit chain.

            The a, b,  and  :   commands  all  make  special
            checks in e1 thru em for expressions of the form
            (## . coms).  In this case, the expression  used
            for  inserting  or  replacing  is  a copy of the
            current expression after executing coms, a  list
            of  edit  commands.    (insert (## f cond -1 -1)
            after3)  will make a copy of the  last  form  in
            the  last clause of the next cond, and insert it
            after the third element of the  current  expres-
            sion.

            $.  In descriptions of  the  editor,  the  meta-
            symbol $ is used to denote a location specifica-
            tion.   $ is a list of commands  interpreted  as
            described above.  $ can also be atomic.

____________________________________________________________

_L_O_C_A_T_I_O_N _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

(_l_c . $) .  Provides a way of explicitly invoking the  loca-
tion operation.  (lc cond 2 3) will perform search.

(_l_c_l . $) .  Same as lc except search is confined to current
expression.   To  find a cond containing a _r_e_t_u_r_n, one might
use the location specification (cond (lcl  _r_e_t_u_r_n)  )  where
the   would reverse the effects of the lcl command, and make
the final current expression be the cond.
____________________________________________________________





      16.3.2.  The Edit Chain   The edit-chain is a list  of
         which  the first element is the the one you are now
         editing ("current expression"), the next element is
         what  would  become  the  current expression if you
         were to do a 0, etc., until the last element  which
         is the expression that was passed to the editor.


                                      Printed: July 21, 1983







The LISP Editor                                         16-7


____________________________________________________________

_E_D_I_T _C_H_A_I_N _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_m_a_r_k .  Adds the current edit chain to the front of the list
marklst.

_ .  Makes the new edit chain be (car marklst).

(_ _p_a_t_t_e_r_n) .  Ascends the edit chain  looking  for  a  link
which matches pattern.  for example:

__ .  Similar to _ but also erases the mark.

\ . Makes the edit chain be the value of unfind.  unfind  is
set  to  the current edit chain by each command that makes a
"big jump", i.e., a command that usually performs more  than
a  single  ascent or descent, namely ^, _, __, !nx, all com-
mands that involve a search, e.g., f, lc, ::, below,  et  al
and                      and                     themselves.
if the user types f cond, and then f car,   would  take  him
back  to the cond.  another  would take him back to the car,
etc.

\_p .  Restores the edit chain to its state as  of  the  last
print  operation.   If  the edit chain has not changed since
the last printing, \p restores it to its  state  as  of  the
printing before that one.  If the user types p followed by 3
2 1 p, \p will  return  to  the  first  p,  i.e.,  would  be
equivalent to 0 0 0.  Another \p would then take him back to
the second p.
____________________________________________________________





   16.4.  Printing Commands

____________________________________________________________

_P_R_I_N_T_I_N_G _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_p  Prints current expression in  abbreviated  form.   (p  m)
prints  mth  element  of  current  expression in abbreviated
form.  (p m n) prints mth element of current  expression  as
though  printlev  were  given  a depth of n.  (p 0 n) prints
current expression as though printlev were given a depth  of
n.  (p cond 3) will work.

?  .  prints the current expression as though printlev  were
given a depth of 100.
9

9                                      Printed: July 21, 1983







The LISP Editor                                         16-8


_p_p .  pretty-prints the current expression.

_p_p*.  is like pp, but forces comments to be shown.
____________________________________________________________





   16.5.  Structure Modification Commands

      All structure modification commands are undoable.  See
      _u_n_d_o.


____________________________________________________________

_S_T_R_U_C_T_U_R_E _M_O_D_I_F_I_C_A_T_I_O_N _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

# [_e_d_i_t_o_r _c_o_m_m_a_n_d_s] (n)  n>1 deletes the corresponding  ele-
ment from the current expression.

(_n _e_1 ...  _e_m) _n,_m>_1 replaces the nth element in the current
expression with e1 ...  em.

(-_n _e_1 ...  _e_m) _n,_m>_1 inserts e1 ...  em before the  n  ele-
ment in the current expression.

(_n _e_1 ...  _e_m) (the letter "n" for "next" or "nconc", not  a
number)  m>1  attaches  e1 ...  em at the end of the current
expression.

(_a _e_1 ... _e_m) .   inserts  e1  ...   em  after  the  current
expression (or after its first element if it is a tail).

(_b _e_1 ... _e_m) .  inserts  e1  ...   em  before  the  current
expression.   to  insert  foo before the last element in the
current expression, perform -1 and then (b foo).

(: _e_1 ... _e_m) .  replaces the current expression by  e1  ...
em.     If the current expression is a tail then replace its
first element.

_d_e_l_e_t_e _o_r (:)  .  deletes the current expression, or if  the
current expression is a tail, deletes its first element.

(_d_e_l_e_t_e . $).  does a (lc .  $) followed by delete.  current
edit chain is not changed.

(_i_n_s_e_r_t _e_1 ... _e_m _b_e_f_o_r_e . $) .  similar to  (lc.   $)  fol-
lowed by (b e1 ... em).

(_i_n_s_e_r_t _e_1 ...  _e_m _a_f_t_e_r .  $).  similar  to  insert  before


                                      Printed: July 21, 1983







The LISP Editor                                         16-9


except uses a instead of b.

(_i_n_s_e_r_t _e_1 ...  _e_m _f_o_r .   $).   similar  to  insert  before
except uses :  for b.

(_r_e_p_l_a_c_e $ _w_i_t_h _e_1 ... _e_m) .  here $ is the segment  of  the
command between replace and with.

(_c_h_a_n_g_e $ _t_o _e_1 ... _e_m) .  same as replace with.
____________________________________________________________





   16.6.  Extraction and Embedding Commands

____________________________________________________________

_E_X_T_R_A_C_T_I_O_N _A_N_D _E_M_B_E_D_D_I_N_G _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

(_x_t_r . $) .  replaces the original current  expression  with
the expression that is current after performing (lcl . $).

(_m_b_d _x) .  x is a list, substitutes the  current  expression
for  all  instances  of  the  atom  * in x, and replaces the
current expression with the  result  of  that  substitution.
(mbd x) :  x atomic, same as (mbd (x *)).

(_e_x_t_r_a_c_t $_1 _f_r_o_m $_2) .  extract is an editor  command  which
replaces  the  current expression with one of its subexpres-
sions (from any depth).  ($1 is the segment between  extract
and  from.)    example:  if the current expression is (print
(cond ((null x) y) (t z))) then following  (extract  y  from
cond), the current expression will be (print y).  (extract 2
-1 from cond), (extract y from 2), (extract  2  -1  from  2)
will all produce the same result.

(_e_m_b_e_d $ _i_n . _x) .  embed replaces  the  current  expression
with  a new expression which contains it as a subexpression.
($ is the segment between embed and in.)   example:   (embed
print  in setq x), (embed 3 2 in _r_e_t_u_r_n), (embed cond 3 1 in
(or * (null x))).
____________________________________________________________





   16.7.  Move and Copy Commands


9

9                                      Printed: July 21, 1983







The LISP Editor                                        16-10


____________________________________________________________

_M_O_V_E _A_N_D _C_O_P_Y _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

(_m_o_v_e $_1 _t_o _c_o_m . $_2) .  ($1 is the segment between move and
to.)  where com is before, after, or the name of a list com-
mand, e.g., :, n, etc.  If $2 is nil, or (here), the current
position specifies where the operation is to take place.  If
$1 is nil, the move command allows the user to specify  some
place  the  current  expression  is to be moved to.   if the
current expression is (a b d c), (move 2 to  after  4)  will
make the new current expression be (a c d b).

(_m_v _c_o_m . $) .  is the same as (move here to com . $).

(_c_o_p_y $_1 _t_o _c_o_m . $_2)  is like move except that  the  source
expression is not deleted.

(_c_p _c_o_m . $).  is like mv except that the source  expression
is not deleted.
____________________________________________________________





   16.8.    Parentheses Moving Commands      The    commands
      presented  in  this section permit modification of the
      list structure itself, as opposed  to  modifying  com-
      ponents  thereof.   their  effect  can be described as
      inserting  or  removing  a  single   left   or   right
      parenthesis, or pair of left and right parentheses.

____________________________________________________________

_P_A_R_E_N_T_H_E_S_E_S _M_O_V_I_N_G _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

(_b_i _n _m) .  both in.  inserts  parentheses  before  the  nth
element and after the mth element in the current expression.
example:  if the current expression is (a b (c d  e)  f  g),
then (bi 2 4) will modify it to be (a (b (c d e) f) g).  (bi
n) :  same as (bi n n).  example:  if the current expression
is (a b (c d e) f g), then (bi -2) will modify it to be (a b
(c d e) (f) g).

(_b_o _n) .  both out.  removes both parentheses from  the  nth
element.   example:   if the current expression is (a b (c d
e) f g), then (bo d) will modify it to be (a b c d e f g).

(_l_i _n) .  left in.  inserts a left  parenthesis  before  the
nth  element (and a matching right parenthesis at the end of
the current expression).  example:  if the  current  expres-
sion  is (a b (c d e) f g), then (li 2) will modify it to be


                                      Printed: July 21, 1983







The LISP Editor                                        16-11


(a (b (c d e) f g)).

(_l_o _n) .  left  out.  removes  a  left parenthesis  from the
nth  element.  all  elements  following  the nth element are
deleted.  example: if the current expression is (a b (c d e)
f g), then  (lo  3) will modify it to be (a b c d e).

(_r_i _n _m) .  right  in.  move  the  right parenthesis at  the
end of the nth element in to after the mth element.  inserts
a  right parenthesis  after  the mth element of the nth ele-
ment.   The  rest  of  the  nth element is brought up to the
level of the  current expression.   example: if the  current
expression  is (a (b c d e) f g), (ri 2 2) will modify it to
be (a (b c) d e f g).

(_r_o _n) .  right  out.  move the right parenthesis at the end
of  the  nth  element out to the  end of the current expres-
sion.  removes the right parenthesis from the  nth  element,
moving it to the end of the current expression. all elements
following the nth  element  are moved  inside of   the   nth
element.  example: if the current expression is (a b (c d e)
f  g),  (ro  3) will modify  it to be (a b (c d e f g)).

(_r _x _y)  replaces  all  instances  of x by y in the  current
expression,  e.g.,  (r  caadr  cadar).   x  can  be  the  s-
expression (or atom) to be substituted for, or can be a pat-
tern which specifies that s-expression (or atom).

(_s_w _n _m)  switches the nth and mth elements of  the  current
expression.  for example, if the current expression is (list
(cons (car x) (car y)) (cons (cdr y))),   (sw   2  3)   will
modify  it  to be (list (cons (cdr x) (cdr y)) (cons (car x)
(car y))).   (sw car  cdr) would produce the same result.
____________________________________________________________





      16.8.1.  Using to and thru

         to, thru, extract, embed, delete, replace, and move
         can  be  made to operate on several contiguous ele-
         ments, i.e., a segment of a list, by using  the  to
         or   thru  command  in  their  respective  location
         specifications.  thru and to  are  intended  to  be
         used   in  conjunction with extract, embed, delete,
         replace, and move.    to and thru can also be  used
         directly  with  xtr  (which  takes after a location
         specification), as in (xtr (2 thru  4))  (from  the
         current expression).

9

9                                      Printed: July 21, 1983







The LISP Editor                                        16-12


____________________________________________________________

_T_O _A_N_D _T_H_R_U _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

($_1 _t_o $_2)    .   same  as  thru  except  last  element  not
included.

($_1 _t_o).  same as ($1 thru -1)

($_1 _t_h_r_u $_2)  .  If the current expression is (a  (b  (c  d)
(e)  (f  g  h)  i)  j  k), following (c thru g), the current
expression will be ((c d) (e) (f g h)).  If both $1  and  $2
are  numbers, and $2 is greater than $1, then $2 counts from
the beginning of the current expression, the same as $1.  in
other  words,  if the current expression is (a b c d e f g),
(3 thru 4) means (c thru d), not (c thru f).  in this  case,
the corresponding bi command is (bi 1 $2-$1+1).

($_1 _t_h_r_u). same as ($_1 _t_h_r_u -_1).
____________________________________________________________





   16.9.  Undoing Commands   each command that causes struc-
      ture  modification  automatically adds an entry to the
      front of undolst containing the  information  required
      to  restore all pointers that were changed by the com-
      mand.  The undo command undoes the  last,  i.e.,  most
      recent such command.

____________________________________________________________

_U_N_D_O _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_u_n_d_o .  the  undo  command  undoes  most  recent,  structure
modification  command  that  has  not  yet  been undone, and
prints the name of that command, e.g., mbd undone.  The edit
chain  is  then exactly what it was before the 'undone' com-
mand had been performed.

!_u_n_d_o .  undoes  all  modifications  performed  during  this
editing session, i.e., this call to the editor.

_u_n_b_l_o_c_k .  removes  an  undo-block. If executed  at  a  non-
blocked  state,  i.e., if undo or !undo could operate, types
not blocked.

_t_e_s_t .  adds an undo-block at the front  of  undolst.   note
that  test   together   with  !undo  provide  a  'tentative'
mode  for editing, i.e., the user can perform  a  number  of
changes,  and  then  undo  all  of  them with a single !undo


                                      Printed: July 21, 1983







The LISP Editor                                        16-13


command.

_u_n_d_o_l_s_t [_v_a_l_u_e].  each editor command that causes  structure
modification  automatically  adds  an  entry to the front of
undolst containing the information required to  restore  all
pointers that were changed by the command.

??   prints the entries on undolst.  The entries are  listed
most recent entry first.
____________________________________________________________





   16.10.  Commands that Evaluate

____________________________________________________________

_E_V_A_L_U_A_T_I_O_N _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_e .  only when typed in, (i.e., (insert  d  before  e)  will
treat  e  as  a  pattern) causes  the  editor  to  call  the
lisp interpreter giving it the next input as argument.

(_e  _x)  evaluates  x, and prints the result.  (e x  t)  same
as (e x) but does not print.

(_i _c _x_1 ... _x_n)  same as (c y1 ...  yn) where yi=(eval  xi).
example:   (i  3  (cdr foo)) will replace the 3rd element of
the current expression with the cdr of the value of foo.  (i
n foo (car fie)) will attach the value of foo and car of the
value of fie to the end of the current  expression.   (i  f=
foo t) will search for an expression eq to the value of foo.
If c is not an atom, it is evaluated as well.

(_c_o_m_s _x_1 ... _x_n) .  each  xi  is  evaluated  and  its  value
executed as a command.  The i command is not very convenient
for computing an entire edit command for  execution,   since
it  computes  the command name and its arguments separately.
also, the i command cannot be used  to  compute  an   atomic
command.   The  coms  and comsq  commands provide more  gen-
eral ways of computing commands.  (coms  (cond  (x  (list  1
x))))  will replace the first element of the current expres-
sion with the value of x if non-nil, otherwise  do  nothing.
(nil as a command is a nop.)

(_c_o_m_s_q _c_o_m_1 ... _c_o_m_n) .  executes com1 ... comn.   comsq  is
mainly  useful in conjunction with the  coms command.    for
example,  suppose the user wishes to compute an entire  list
of  commands  for  evaluation,  as opposed to computing each
command one at a time  as does  the coms command.  he  would
then  write  (coms  (cons (quote comsq) x)) where x computed


                                      Printed: July 21, 1983







The LISP Editor                                        16-14


the list of commands, e.g.,   (coms   (cons   (quote  comsq)
(get  foo (quote commands))))
____________________________________________________________





   16.11.  Commands that Test

____________________________________________________________

_T_E_S_T_I_N_G _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

(_i_f _x)  generates an error unless the value of (eval  x)  is
non-nil,  i.e., if (eval x) causes an error or (eval x)=nil,
if will cause an error.  (if x coms1 coms2) if (eval  x)  is
non-nil,  execute  coms1;  if (eval x) causes an error or is
equal to nil, execute coms2.  (if x coms1)   if   (eval   x)
is  non-nil,  execute  coms1; otherwise generate  an  error.

(_l_p . _c_o_m_s) .  repeatedly executes coms, a list of commands,
until  an   error   occurs.      (lp  f  print (n  t))  will
attach  a t  at the end of every  print  expression.  (lp  f
print  (if  (##  3) nil ((n t)))) will attach a t at the end
of each print expression  which  does  not  already  have  a
second  argument.   (i.e.   the  form   (## 3) will cause an
error if the edit command 3 causes an error, thereby select-
ing  ((n t)) as the list of commands to be executed.  The if
could also  be written  as  (if  (cddr (##)) nil ((n t))).).

(_l_p_q . _c_o_m_s)  same as lp but does not print n occurrences.

(_o_r_r _c_o_m_s_1 ... _c_o_m_s_n) .  orr begins by  executing  coms1,  a
list  of  commands.   If  no  error occurs, orr is finished.
otherwise, orr restores the edit  chain  to   its   original
value,   and  continues by executing coms2, etc.  If none of
the command lists execute without  errors,   i.e.,  the  orr
"drops off the end", orr generates an error.  otherwise, the
edit chain is left as of the completion of the first command
list  which executes  without error.
____________________________________________________________





   16.12.  Editor Macros

      Many of the more sophisticated branching  commands  in
      the  editor, such as orr, if,  etc.,  are  most  often
      used  in  conjunction with  edit  macros.   The  macro
      feature  permits  the  user to define new commands and


                                      Printed: July 21, 1983







The LISP Editor                                        16-15


      thereby  expand  the  editor's  repertoire.  (however,
      built in commands always  take  precedence  over  mac-
      ros, i.e.,  the  editor's repertoire can be  expanded,
      but  not  modified.) macros are defined by using the m
      command.

      (_m _c . _c_o_m_s)  for c an atom, m defines c as an  atomic
      command.   (if a macro  is  redefined, its new defini-
      tion replaces its old.) executing c is then  the  same
      as  executing  the  list of  commands  coms.    macros
      can  also define list commands,  i.e.,  commands  that
      take  arguments.  (m (c) (arg[1] ... arg[n]) . coms) c
      an atom.  m defines c as a list command.  executing (c
      e1  ...   en)  is then  performed  by substituting  e1
      for  arg[1],  ...    en  for arg[n]  throughout  coms,
      and  then  executing  coms.   a  list  command  can be
      defined via a macro  so  as  to   take   a  fixed   or
      indefinite   number  of  'arguments'.   The form given
      above specified a macro with a fixed number  of  argu-
      ments,  as indicated by its argument list.   if the of
      arguments.  (m (c) args . coms) c,  args  both  atoms,
      defines  c as  a  list command.  executing  (c  e1 ...
      en) is performed by substituting (e1 ...   en),  i.e.,
      cdr of the command, for args throughout coms, and then
      executing coms.

      (m bp bk up p) will define bp as  an  atomic   command
      which   does three things,  a bk, an up, and a p. note
      that macros can use commands defined by macros as well
      as  built  in  commands  in  their definitions.    for
      example, suppose  z  is  defined by (m z -1 (if  (null
      (##))  nil  (p))),  i.e.  z does a -1, and then if the
      current expression is not nil, a p. now we can  define
      zz  by  (m zz  -1 z), and zzz by (m zzz -1 -1 z) or (m
      zzz -1 zz).  we could define a more general bp  by  (m
      (bp)  (n) (bk n) up p).    (bp 3)  would  perform  (bk
      3), followed  by  an  up,  followed  by a p.  The com-
      mand  second  can  be defined as a macro by (m (2nd) x
      (orr ((lc .  x) (lc .  x)))).

      Note  that  for  all editor commands, 'built in'  com-
      mands  as  well  as commands defined by macros, atomic
      definitions  and  list  definitions   are   completely
      independent.   in  other  words,  the  existence of an
      atomic definition for c in no way  affects  the treat-
      ment  of  c  when it appears as car of a list command,
      and the existence of a list definition for c in no way
      affects  the  treatment  of   c  when it appears as an
      atom.  in particular, c can be used  as  the  name  of
      either  an atomic command, or a list command, or both.
      in the latter case, two  entirely  different   defini-
      tions   can   be   used.    note  also  that once c is
      defined as an atomic command via a  macro  definition,


                                      Printed: July 21, 1983







The LISP Editor                                        16-16


      it  will  not  be searched for when used in a location
      specification, unless c is preceded by an f.   (insert
      --   before  bp)  would not search for bp, but instead
      perform a bk, an up, and a p, and then do  the  inser-
      tion.  The corresponding also holds true for list com-
      mands.

      (_b_i_n_d . _c_o_m_s)  bind  is  an  edit   command  which  is
      useful  mainly  in macros.  it binds three dummy vari-
      ables #1, #2, #3, (initialized to nil), and then  exe-
      cutes   the   edit  commands   coms.   note that these
      bindings are only in effect  while  the  commands  are
      being executed, and that bind can be used recursively;
      it will  rebind #1, #2,   and   #3  each  time  it  is
      invoked.

      _u_s_e_r_m_a_c_r_o_s  [_v_a_l_u_e].   this   variable   contains  the
      users editing macros .   if you want to save your mac-
      ros then you  should  save  usermacros.   you   should
      probably  also  save editcomsl.

      _e_d_i_t_c_o_m_s_l [_v_a_l_u_e].  editcomsl  is  the  list of  "list
      commands"  recognized  by  the editor.  (these are the
      ones of the form (command arg1 arg2 ...).)




   16.13.  Miscellaneous Editor Commands

____________________________________________________________

_M_I_S_C_E_L_L_A_N_E_O_U_S _E_D_I_T_O_R _C_O_M_M_A_N_D _S_U_M_M_A_R_Y

_o_k .  Exits from the editor.

_n_i_l .  Unless preceded by f or bf, is always a  null  opera-
tion.

_t_t_y:  .  Calls  the  editor  recursively.  The user can then
type in commands, and have them executed.  The tty:  command
is completed when  the  user exits  from  the lower   editor
(with   ok   or  stop).  the tty:  command is extremely use-
ful. it enables the user to  set  up a  complex   operation,
and   perform   interactive attention-changing commands part
way through it. for example the command  (move  3  to  after
cond  3  p  tty:)  allows  the user to interact, in  effect,
within  the move  command.      he can  verify  for  himself
that  the  correct  location has been found, or complete the
specification "by hand". in effect, tty: says "I'll tell you
what you should do when you get there."

_s_t_o_p .  exits from the editor with an error.  mainly for use


                                      Printed: July 21, 1983







The LISP Editor                                        16-17


in  conjunction  with  tty:  commands that the user wants to
abort.  since all of the commands in the editor are   errset
protected, the user must exit from the editor via a command.
stop provides a way of distinguishing between  a  successful
and unsuccessful  (from the user's  standpoint) editing ses-
sion.

_t_l .  tl  calls (top-level).  to return to the  editor  just
use the _r_e_t_u_r_n top-level command.

_r_e_p_a_c_k .  permits the 'editing' of an atom or string.

(_r_e_p_a_c_k $) does (lc . $) followed by  repack,  e.g.  (repack
this@).

(_m_a_k_e_f_n _f_o_r_m _a_r_g_s _n _m) .  makes (car form) an expr with  the
nth  through mth  elements  of  the  current expression with
each occurrence  of  an element of (cdr  form)  replaced  by
the  corresponding  element  of  args.   The nth through mth
elements  are replaced  by form.

(_m_a_k_e_f_n _f_o_r_m _a_r_g_s _n).  same as (makefn form args n n).

(_s _v_a_r . $) .  sets var (using setq) to the current  expres-
sion  after  performing  (lc .    $).    (s  foo)  will  set
foo to the current expression, (s foo -1 1) will set foo  to
the first element in the last element of the current expres-
sion.
____________________________________________________________





   16.14.  Editor Functions


(editf s_x1 ...)

     SIDE EFFECT: edits a function. s_x1 is the name of  the
                  function,  any additional arguments are an
                  optional list of commands.

     RETURNS: s_x1.

     NOTE: if s_x1 is not an editable function,  editf  gen-
           erates an fn not editable error.





9

9                                      Printed: July 21, 1983







The LISP Editor                                        16-18


(edite l_expr l_coms s_atm))
edits an expression.  its  value  is  the  last  element  of
(editl (list l_expr) l_coms s_atm nil nil).


(editracefn s_com)
is available to help the user debug complex edit macros,  or
subroutine  calls  to   the   editor.  editracefn  is  to be
defined by the user.  whenever the value of  editracefn   is
non-nil,   the   editor   calls  the   function   editracefn
before executing  each command (at  any  level),  giving  it
that command as its argument.  editracefn is initially equal
to nil, and undefined.


(editv s_var [ g_com1 ... ])

     SIDE EFFECT: similar  to  editf,  for  editing  values.
                  editv  sets  the  variable  to  the  value
                  returned.

     RETURNS: the name  of  the  variable  whose  value  was
              edited.


(editp s_x)

     SIDE EFFECT: similar  to  editf  for  editing  property
                  lists. used if x is nil.

     RETURNS: the atom whose property list was edited.


(editl coms atm marklst mess)

     SIDE EFFECT: editl is the editor.  its  first  argument
                  is  the  edit  chain,  and its value is an
                  edit chain, namely the value of l  at  the
                  time  editl  is  exited.   (l is a special
                  variable, and so can be examined or set by
                  edit  commands.    ^  is  equivalent to (e
                  (setq l(last l)) t).)  coms is an optional
                  list  of  commands.  for interactive edit-
                  ing, coms is nil.   in  this  case,  editl
                  types  edit  and then waits for input from
                  the teletype.  (if mess is not  nil  editl
                  types  it  instead  of edit.  for example,
                  the tty:  command is essentially  (setq  l
                  (editl  l  nil  nil  nil  (quote tty:))).)
                  exit occurs only via an ok, stop, or  save
                  command.   If  coms is not nil, no message
                  is typed,  and  each  member  of  coms  is
                  treated  as a command and executed.  If an


                                      Printed: July 21, 1983







The LISP Editor                                        16-19


                  error occurs in the execution  of  one  of
                  the  commands, no error message is printed
                  , the rest of the  commands  are  ignored,
                  and  editl  exits with an error, i.e., the
                  effect is the same as though a  stop  com-
                  mand  had  been executed.  If all commands
                  execute successfully,  editl  returns  the
                  current  value  of l.  marklst is the list
                  of marks.  on calls from editf, atm is the
                  name  of  the  function  being  edited; on
                  calls from editv, the name  of  the  vari-
                  able,  and  calls  from editp, the atom of
                  which some property of its  property  list
                  is being edited.  The property list of atm
                  is used by the save command for saving the
                  state  of  the  edit.   save will not save
                  anything if  atm=nil  i.e.,  when  editing
                  arbitrary  expressions  via edite or editl
                  directly.


(editfns s_x [ g_coms1 ... ])
fsubr function, used to perform the same editing  operations
on  several  functions.  editfns maps down the list of func-
tions, prints the name of each function, and calls the  edi-
tor (via editf) on that function.

     EXAMPLE: editfns foofns (r fie fum)) will change  every
              fie   to   fum   in  each  of the functions on
              foofns.

     NOTE: the  call  to  the  editor is  errset  protected,
           so  that if the editing of one function causes an
           error, editfns will proceed to  the  next   func-
           tion.     in  the  above  example,  if one of the
           functions did not contain a fie,  the  r  command
           would   cause   an  error, but editing would con-
           tinue with  the  next  function.   The  value  of
           editfns is nil.


(edit4e pat y)

     SIDE EFFECT: is the pattern match routine.

     RETURNS: t if pat matches y. see edit-match for defini-
              tion of 'match'.

     NOTE: before  each  search  operation  in  the   editor
           begins,  the   entire   pattern  is  scanned  for
           atoms  or strings that end  in  at-signs.   These
           are  replaced  by  patterns  of  the  form  (cons
           (quote  /@)  (explodec   atom)).       from   the


                                      Printed: July 21, 1983







The LISP Editor                                        16-20


           standpoint   of  edit4e, pattern type 5, atoms or
           strings  ending  in  at-signs,  is   really   "if
           car[pat]  is the atom @ (at-sign), pat will match
           with  any  literal atom  or  string  whose   ini-
           tial   character codes (up to the @) are the same
           as those in cdr[pat]." if  the  user  wishes   to
           call  edit4e  directly, he must therefore convert
           any patterns which contain   atoms   or   strings
           ending  in  at-signs  to  the  form recognized by
           edit4e.   this  can  be  done  via  the  function
           editfpat.

(editfpat pat flg)
makes a copy of pat with all patterns of type 5  (see  edit-
match)  converted to the form expected by edit4e. flg should
be passed as nil (flg=t is for internal use by the editor).


(editfindp x pat flg)

     NOTE: Allows a program to use the edit find command  as
           a  pure  predicate from outside the editor.  x is
           an expression, pat a pattern.  The value of edit-
           findp  is  t  if the command f pat would succeed,
           nil otherwise.  editfindp calls editfpat to  con-
           vert  pat  to the form expected by edit4e, unless
           flg=t.    if the program is applying editfindp to
           several different expressions using the same pat-
           tern, it will be more efficient to call  editfpat
           once,  and then call editfindp with the converted
           pattern and flg=t.


(## g_com1 ...)

     RETURNS: what the current  expression  would  be  after
              executing the edit commands com1 ...  starting
              from the present  edit  chain.   generates  an
              error  if  any  of  comi  cause  errors.   The
              current edit chain is never changed.  example:
              (i  r  (quote x) (## (cons ..z))) replaces all
              x's in the current  expression  by  the  first
              cons containing a z.









9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/ch17.r  << 'EndOfFile'







                        CHAPTER  17


                        Hash Tables






   1.1.  Overview

           A hash table is an object  that  can  efficiently
      map  a  given object to another.  Each hash table is a
      collection of entries,  each  of  which  associates  a
      unique  _k_e_y  with  a _v_a_l_u_e.  There are elemental func-
      tions to add, delete, and find entries based on a par-
      ticular key.  Finding a value in a hash table is rela-
      tively fast compared to  looking  up  values  in,  for
      example, an assoc list or property list.

           Adding a key to a hash table  modifies  the  hash
      table, and so it is a descructive operation.

           There are two different  kinds  of  hash  tables:
      those that use the function _e_q_u_a_l for the comparing of
      keys, and those that use _e_q, the default.  If a key is
      "eq"  to  another  object,  then  a  match is assumed.
      Likewise with "equal".



   1.2.  Functions

(makeht 'x_size ['s_test])

     RETURNS: A hash  table  of  x_size  hash  buckets.   If
              present, s_test is used as the test to compare
              keys in the hash table, the default being  eq.
              _E_q_u_a_l  might  be  used  to create a hash table
              where the keys are to be lists  (or  any  lisp
              object).

     NOTE: At this time, hash tables are implemented on  top
           of vectors.







9

9Hash Tables                                             17-1







Hash Tables                                             17-2


(hash-table-p 'H_arg)

     RETURNS: t if H_arg is a hash table.

     NOTE: Since hash tables are really  vectors,  the  lisp
           type of a hash table is a vector, so that given a
           vector, this function will return t.

(gethash 'g_key 'H_htable ['g_default])

     RETURNS: the value associated the  key  g_key  in  hash
              table  H_htable.   If  there  is  not an entry
              given by the key and g_default  is  specified,
              then  g_default is returned, otherwise, a sym-
              bol that is unbound is returned.  This  is  so
              that nil can be a associated with a key.

     NOTE: _s_e_t_f may be used to set the value assocaited with
           a key.

(remhash 'g_key 'H_htable)

     RETURNS: t if there was an entry for g_key in the  hash
              table H_htable, nil otherwise.  In the case of
              a match, the entry and associated  object  are
              removed from the hash table.

(maphash 'u_func 'H_htable)

     RETURNS: nil.

     NOTE: The function u_func is applied to  every  element
           in  the  hash  table  H_htable.   The function is
           called with two arguments: the key and  value  of
           an  element.   The mapped function should not add
           or delete  object  from  the  table  because  the
           results would be unpredicable.

(clrhash 'H_htable)

     RETURNS: the hash table cleared of all entries.











9

9                                       Printed: May 22, 1985







Hash Tables                                             17-3


(hash-table-count 'H_htable)

     RETURNS: the number of entries in  H_htable.   Given  a
              new  hash table with no entries, this function
              returns zero.















































9

9                                       Printed: May 22, 1985







Hash Tables                                             17-4



    ____________________________________________________

    ; make a vanilla hash table using "eq" to compare items...
    -> (setq black-box (makeht 20))
    hash-table[26]
    -> (hash-table-p black-box)
    t
    -> (hash-table-count black-box)
    0
    -> (setf (gethash 'key black-box) '(the value associated with the key))
    key
    -> (gethash 'key black-box)
    (the value associated with the key)
    -> (hash-table-count black-box)
    1
    -> (addhash 'composer black-box 'franz)
    composer
    -> (gethash 'composer black-box)
    franz
    -> (maphash '(lambda (key val) (msg "key " key " value " val N)) black-box)
    key composer value franz
    key key value (the value associated with the key)
    nil
    -> (clrhash black-box)
    hash-table[26]
    -> (hash-table-count black-box)
    0
    -> (maphash '(lambda (key val) (msg "key " key " value " val N)) black-box)
    nil

    ; here is an example using "equal" as the comparator
    -> (setq ht (makeht 10 'equal))
    hash-table[16]
    -> (setf (gethash '(this is a key) ht) '(and this is the value))
    (this is a key)
    -> (gethash '(this is a key) ht)
    (and this is the value)
    ; the reader makes a new list each time you type it...
    -> (setq x '(this is a key))
    (this is a key)
    -> (setq y '(this is a key))
    (this is a key)
    ; so these two lists are really different lists that compare "equal"
    ; not "eq"
    -> (eq x y)
    nil
    ; but since we are using "equal" to compare keys, we are OK...
    -> (gethash x ht)
    (and this is the value)
    -> (gethash y ht)
    (and this is the value)
    ____________________________________________________


                                       Printed: May 22, 1985







Hash Tables                                             17-5






















































9

9                                       Printed: May 22, 1985



EndOfFile
cat >  lisplib/manual/chb.r  << 'EndOfFile'







                        APPENDIX  B


                      Special Symbols




     The values of these symbols  have a predefined meaning.
Some values are counters while others are simply flags whose
value the user can change to affect the  operation  of  lisp
system.   In all cases, only the value cell of the symbol is
important, the function cell is not.  The value of  some  of
the  symbols  (like ER%misc) are functions - what this means
is that the value cell of those symbols  either  contains  a
lambda  expression,  a binary object, or symbol with a func-
tion binding.

     The values of the special symbols are:

$gccount$ - The number of  garbage  collections  which  have
     occurred.

$gcprint - If bound to  a non nil  value,  then  after  each
     garbage  collection and subsequent storage allocation a
     summary of storage allocation will be printed.

$ldprint - If bound to a non nil  value,  then  during  each
     _f_a_s_l or _c_f_a_s_l a diagnostic message will be printed.

ER%all - The function which is the  error  handler  for  all
     errors (see 10)

ER%brk - The function which is the  handler  for  the  error
     signal  generated  by the evaluation of the _b_r_e_a_k func-
     tion (see 10).

ER%err - The function which is the  handler  for  the  error
     signal  generated by the evaluation of the _e_r_r function
     (see 10).

ER%misc - The function which is the  handler  of  the  error
     signal generated by one of the unclassified errors (see
     10).  Most errors are unclassified at this point.

ER%tpl - The function which is the handler to be called when
     an  error  has occurred which has not been handled (see
     10).

ER%undef - The function which is the handler for  the  error
     signal  generated  when a call to an undefined function
     is made.
9

9                                                         B-1







                                                         B-2


^w - When bound to a non nil value this will prevent  output
     to  the standard output port (poport) from reaching the
     standard output (usually a terminal).  Note that ^w  is
     a  two character symbol and should not be confused with
     ^W which is how we would denote control-w.   The  value
     of  ^w  is  checked  when the standard output buffer is
     flushed which occurs after a _t_e_r_p_r, _d_r_a_i_n or  when  the
     buffer  overflows.   This is most useful in conjunction
     with ptport described  below.   System  error  handlers
     rebind  ^w  to nil when they are invoked to assure that
     error messages are not lost.  (This was introduced  for
     Maclisp compatibility).

defmacro-for-compiling - The has an effect  during  compila-
     tion.  If  non-nil it causes macros defined by defmacro
     to be compiled and included in the object file.

environment - The UNIX environment in assoc list form.

errlist - When a _r_e_s_e_t is done,  the  value  of  errlist  is
     saved  away  and  control  is  thrown to the top level.
     _E_v_a_l is then mapped over the saved away value  of  this
     list.

errport - This port is initially bound to the standard error
     file.

evalhook - The value of this symbol, if bound, is  the  name
     of a function to handle evalhook traps (see 14.4)

float-format - The value of this symbol is a string which is
     the  format  to be used by print to print flonums.  See
     the documentation on the UNIX  function  printf  for  a
     list of allowable formats.

funcallhook - The value of this symbol,  if  bound,  is  the
     name  of  a  function  to handle funcallhook traps (see
     14.4).

gcdisable - If non nil, then garbage collections will not be
     done  automatically  when  a collectable data type runs
     out.

ibase - This is the input radix used by the lisp reader.  It
     may  be  either  eight  or  ten.  Numbers followed by a
     decimal point are assumed to be decimal  regardless  of
     what ibase is.

linel - The line length used  by  the  pretty  printer,  pp.
     This  should  be  used  by  _p_r_i_n_t but it is not at this
     time.

nil - This symbol represents the null list and thus  can  be


                                      Printed: July 21, 1983







                                                         B-3


     written  ().   Its value is always nil.  Any attempt to
     change the value will result in an error.

piport - Initially bound to the standard input (usually  the
     keyboard).  A read with no arguments reads from piport.

poport - Initially bound to the standard output (usually the
     terminal  console).   A  print  with no second argument
     writes to poport.  See also: ^w and ptport.

prinlength - If this is a positive fixnum,  then  the  _p_r_i_n_t
     function will print no more than prinlength elements of
     a list or hunk  and  further  elements  abbreviated  as
     `...'.  The initial value of prinlength is nil.

prinlevel - If this is a positive  fixnum,  then  the  _p_r_i_n_t
     function  will  print  only  prinlevel levels of nested
     lists or hunks.  Lists below this level will be  abbre-
     viated by `&' and hunks below this level will be abbre-
     viated by a `%'.  The initial  value  of  prinlevel  is
     nil.

ptport - Initially bound to nil.  If bound to a  port,  then
     all  output  sent  to  the standard output will also be
     sent to this port as long as this port is not also  the
     standard  output  (as  this  would cause a loop).  Note
     that ptport will not get a copy of whatever is sent  to
     poport if poport is not bound to the standard output.

readtable - The value of this is the current readtable.   It
     is  an array but you should NOT try to change the value
     of the elements of the array using the array functions.
     This  is because the readtable is an array of bytes and
     the smallest unit the array functions work  with  is  a
     full  word  (4 bytes).  You can use _s_e_t_s_y_n_t_a_x to change
     the values and (_s_t_a_t_u_s _s_y_n_t_a_x ...) to read the values.

t - This symbol always has the value t.  It is  possible  to
     change  the  value  of this symbol for short periods of
     time but you are strongly advised against it.

top-level - In       a       lisp       system       without
     /usr/lib/lisp/toplevel.l loaded, after a _r_e_s_e_t is done,
     the lisp system will _f_u_n_c_a_l_l the value of top-level  if
     it  is  non  nil.   This provides a way for the user to
     introduce  his  own  top   level   interpreter.    When
     /usr/lib/lisp/toplevel.l  is  loaded, it sets top-level
     to franz-top-level and changes the  _r_e_s_e_t  function  so
     that once franz-top-level starts, it cannot be replaced
     by changing top-level.  Franz-top-level  does provide a
     way  of  changing  the  top  level however, and that is
     through user-top-level.
9

9                                      Printed: July 21, 1983







                                                         B-4


user-top-level - If this is bound then after  a  _r_e_s_e_t,  the
     top  level function will _f_u_n_c_a_l_l the value of this sym-
     bol rather than go through a read eval print loop.

















































9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/chc.r  << 'EndOfFile'







                        APPENDIX  C


                      Short Subjects.





                   The Garbage Collector

     The garbage collector is invoked automatically whenever
a  collectable  data type runs out.  All data types are col-
lectable except strings and atoms are not.  After a  garbage
collection  finishes,  the  collector will call the function
_g_c_a_f_t_e_r which should be a lambda of one argument.  The argu-
ment  passed  to  _g_c_a_f_t_e_r is the name of the data type which
ran out and caused the garbage collection.  It is  _g_c_a_f_t_e_r's
responsibility  to  allocate  more pages of free space.  The
default _g_c_a_f_t_e_r makes its decision based on  the  percentage
of  space  still  in  use  after the garbage collection.  If
there is a large percentage of space still in  use,  _g_c_a_f_t_e_r
allocates a larger amount of free space than if only a small
percentage of space is still in use.   The  default  _g_c_a_f_t_e_r
will  also  print a summary of the space in use if the vari-
able $_g_c_p_r_i_n_t is non nil.  The summary always  includes  the
state  of the list and fixnum space and will include another
type if it caused the garbage collection.   The  type  which
caused the garbage collection is preceded by an asterisk.




                         Debugging

     There are two simple functions to help you  debug  your
programs:  _b_a_k_t_r_a_c_e and _s_h_o_w_s_t_a_c_k.  When an error occurs (or
when you type the interrupt character), you will be left  at
a  break  level  with the state of the computation frozen in
the stack.  At this point, calling  the  function  _s_h_o_w_s_t_a_c_k
will  cause  the contents of the lisp evaluation stack to be
printed in reverse chronological order (most recent  first).
When the programs you are running are interpreted or traced,
the output of _s_h_o_w_s_t_a_c_k can be very verbose.   The  function
_b_a_k_t_r_a_c_e  prints  a  summary of what _s_h_o_w_s_t_a_c_k prints.  That
is, if showstack would print a  list,  _b_a_k_t_r_a_c_e  would  only
print  the  first  element  of the list.  If you are running
compiled code with the (_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k) non nil, then fast
links  are  being  made.   In this case, there is not enough
information on the stack for _s_h_o_w_s_t_a_c_k and _b_a_k_t_r_a_c_e.   Thus,
if  you  are  debugging compiled code you should probably do
(_s_s_t_a_t_u_s _t_r_a_n_s_l_i_n_k _n_i_l).
9

9                                                         C-1







                                                         C-2


     If the contents of the  stack  don't  tell  you  enough
about your problem, the next thing you may want to try is to
run your program with certain  functions  traced.   You  can
direct  the  trace package to stop program execution when it
enters a function, allowing you to examine the  contents  of
variables  or  call  other  functions.  The trace package is
documented in Chapter 11.

     It is also possible to single step the evaluator and to
look  at  stack frames within lisp.  The programs which per-
form these actions are described in Chapters 14 and 15.









































9

9                                      Printed: July 21, 1983







                                                         C-3


                The Interpreter's Top Level

     The default top  level  interpreter  for  Franz,  named
_f_r_a_n_z-_t_o_p-_l_e_v_e_l is defined in /usr/lib/lisp/toplevel.l It is
given control when the lisp system  starts  up  because  the
variable  top-level  is bound to the symbol _f_r_a_n_z-_t_o_p-_l_e_v_e_l.
The first action _f_r_a_n_z-_t_o_p-_l_e_v_e_l takes is to print  out  the
name  of  the  current  version of the lisp system.  Then it
loads the file .lisprc from the HOME directory of the person
invoking  the  lisp system if that file exists.  The .lisprc
file allows you to set up your own defaults, read in  files,
set up autoloading  or anything else you might want to do to
personalize the lisp system.  Next, the top level goes  into
a  prompt-read-eval-print  loop.  Each time around the loop,
before printing the prompt it checks if the  variable  user-
top-level is bound.  If so, then the value of user-top-level
will be _f_u_n_c_a_l_led.  This provides a  convenient  way  for  a
user  to  introduce  his own top level (Liszt, the lisp com-
piler, is an example of a program which uses this).  If  the
user  types  a  ^D (which is the end of file character), and
the standard input is not from a keyboard, the  lisp  system
will  exit.   If the standard input is a keyboard and if the
value of (_s_t_a_t_u_s _i_g_n_o_r_e_e_o_f) is nil,  the  lisp  system  will
also exit.  Otherwise the end of file will be ignored.  When
a _r_e_s_e_t is done the current value of _e_r_r_l_i_s_t is  saved  away
and control is thrown back up to the top level where _e_v_a_l is
mapped over the saved value of _e_r_r_l_i_s_t.

























9

9                                      Printed: July 21, 1983



EndOfFile
cat >  lisplib/manual/helpindex  << 'EndOfFile'
(cons ch2.r)
(xcons ch2.r)
(ncons ch2.r)
(list ch2.r)
(append ch2.r)
(append1 ch2.r)
(quote! ch2.r)
(bignum-to-list ch2.r)
(list-to-bignum ch2.r)
(dtpr ch2.r)
(listp ch2.r)
(tailp ch2.r)
(length ch2.r)
(car ch2.r)
(cdr ch2.r)
(c..r ch2.r)
(nth ch2.r)
(nthcdr ch2.r)
(nthelem ch2.r)
(last ch2.r)
(ldiff ch2.r)
(rplaca ch2.r)
(rplacd ch2.r)
(attach ch2.r)
(delete ch2.r)
(delq ch2.r)
(dremove ch2.r)
(remq ch2.r)
(remove ch2.r)
(insert ch2.r)
(merge ch2.r)
(subst ch2.r)
(dsubst ch2.r)
(lsubst ch2.r)
(subpair ch2.r)
(nconc ch2.r)
(reverse ch2.r)
(nreverse ch2.r)
(nreconc ch2.r)
(arrayp ch2.r)
(atom ch2.r)
(bcdp ch2.r)
(bigp ch2.r)
(dtpr ch2.r)
(hunkp ch2.r)
(listp ch2.r)
(stringp ch2.r)
(symbolp ch2.r)
(valuep ch2.r)
(vectorp ch2.r)
(vectorip ch2.r)
(type ch2.r)
(typep ch2.r)
(signp ch2.r)
(eq ch2.r)
(neq ch2.r)
(equal ch2.r)
(eqstr ch2.r)
(not ch2.r)
(null ch2.r)
(member ch2.r)
(memq ch2.r)
(concat ch2.r)
(uconcat ch2.r)
(concatl ch2.r)
(implode ch2.r)
(maknam ch2.r)
(gensym ch2.r)
(copysymbol ch2.r)
(ascii ch2.r)
(intern ch2.r)
(remob ch2.r)
(rematom ch2.r)
(boundp ch2.r)
(alphalessp ch2.r)
(symeval ch2.r)
(get_pname ch2.r)
(plist ch2.r)
(getd ch2.r)
(getchar ch2.r)
(nthchar ch2.r)
(getcharn ch2.r)
(substring ch2.r)
(substringn ch2.r)
(set ch2.r)
(setq ch2.r)
(desetq ch2.r)
(setplist ch2.r)
(makunbound ch2.r)
(aexplode ch2.r)
(explode ch2.r)
(aexplodec ch2.r)
(explodec ch2.r)
(aexploden ch2.r)
(exploden ch2.r)
(new-vector ch2.r)
(new-vectori-byte ch2.r)
(new-vectori-word ch2.r)
(new-vectori-long ch2.r)
(vector ch2.r)
(vectori-byte ch2.r)
(vectori-word ch2.r)
(vectori-long ch2.r)
(vref ch2.r)
(vrefi-byte ch2.r)
(vrefi-word ch2.r)
(vrefi-long ch2.r)
(vprop ch2.r)
(vget ch2.r)
(vsize ch2.r)
(vsize-byte ch2.r)
(vsize-word ch2.r)
(vset ch2.r)
(vseti-byte ch2.r)
(vseti-word ch2.r)
(vseti-long ch2.r)
(vsetprop ch2.r)
(vputprop ch2.r)
(marray ch2.r)
(*array ch2.r)
(array ch2.r)
(arrayp ch2.r)
(getaccess ch2.r)
(getaux ch2.r)
(getdelta ch2.r)
(getdata ch2.r)
(getlength ch2.r)
(arrayref ch2.r)
(arraycall ch2.r)
(arraydims ch2.r)
(listarray ch2.r)
(putaccess ch2.r)
(putaux ch2.r)
(putdata ch2.r)
(putdelta ch2.r)
(putlength ch2.r)
(store ch2.r)
(fillarray ch2.r)
(hunk ch2.r)
(makhunk ch2.r)
(*makhunk ch2.r)
(cxr ch2.r)
(hunk-to-list ch2.r)
(rplacx ch2.r)
(*rplacx ch2.r)
(hunksize ch2.r)
(getdisc ch2.r)
(getentry ch2.r)
(putdisc ch2.r)
(assoc ch2.r)
(assq ch2.r)
(sassoc ch2.r)
(sassq ch2.r)
(sublis ch2.r)
(plist ch2.r)
(setplist ch2.r)
(get ch2.r)
(getl ch2.r)
(putprop ch2.r)
(defprop ch2.r)
(remprop ch2.r)
(tconc ch2.r)
(lconc ch2.r)
(fclosure ch2.r)
(fclosure-alist ch2.r)
(fclosure-function ch2.r)
(fclosurep ch2.r)
(symeval-in-fclosure ch2.r)
(set-in-fclosure ch2.r)
(bcdad ch2.r)
(copy ch2.r)
(copyint* ch2.r)
(cpy1 ch2.r)
(getaddress ch2.r)
(macroexpand ch2.r)
(ptr ch2.r)
(quote ch2.r)
(kwote ch2.r)
(replace ch2.r)
(scons ch2.r)
(setf ch2.r)
(sort ch2.r)
(sortcar ch2.r)
(add ch3.r)
(plus ch3.r)
(sum ch3.r)
(\(pl ch3.r)
(add1 ch3.r)
(1+ ch3.r)
(diff ch3.r)
(difference ch3.r)
(\(mi ch3.r)
(sub1 ch3.r)
(1\(mi ch3.r)
(minus ch3.r)
(product ch3.r)
(times ch3.r)
(\(** ch3.r)
(quotient ch3.r)
(/ ch3.r)
(*quo ch3.r)
(Divide ch3.r)
(Emuldiv ch3.r)
(numberp ch3.r)
(numbp ch3.r)
(fixp ch3.r)
(floatp ch3.r)
(evenp ch3.r)
(oddp ch3.r)
(zerop ch3.r)
(onep ch3.r)
(plusp ch3.r)
(minusp ch3.r)
(greaterp ch3.r)
(> ch3.r)
(>& ch3.r)
(lessp ch3.r)
(< ch3.r)
(<& ch3.r)
(\(eq ch3.r)
(\(eq& ch3.r)
(cos ch3.r)
(sin ch3.r)
(acos ch3.r)
(asin ch3.r)
(atan ch3.r)
(haipart ch3.r)
(haulong ch3.r)
(bignum-leftshift ch3.r)
(sticky-bignum-leftshift ch3.r)
(boole ch3.r)
(lsh ch3.r)
(rot ch3.r)
(abs ch3.r)
(absval ch3.r)
(exp ch3.r)
(expt ch3.r)
(fact ch3.r)
(fix ch3.r)
(float ch3.r)
(log ch3.r)
(max ch3.r)
(min ch3.r)
(mod ch3.r)
(remainder ch3.r)
(*mod ch3.r)
(random ch3.r)
(sqrt ch3.r)
(and ch4.r)
(apply ch4.r)
(arg ch4.r)
(break ch4.r)
(*break ch4.r)
(caseq ch4.r)
(catch ch4.r)
(*catch ch4.r)
(comment ch4.r)
(cond ch4.r)
(cvttointlisp ch4.r)
(cvttofranzlisp ch4.r)
(cvttomaclisp ch4.r)
(cvttoucilisp ch4.r)
(debug ch4.r)
(debugging ch4.r)
(declare ch4.r)
(def ch4.r)
(defmacro ch4.r)
(defcmacro ch4.r)
(defun ch4.r)
(defvar ch4.r)
(do ch4.r)
(do ch4.r)
(environment ch4.r)
(environment-maclisp ch4.r)
(environment-lmlisp ch4.r)
(err ch4.r)
(error ch4.r)
(errset ch4.r)
(eval ch4.r)
(evalframe ch4.r)
(evalhook ch4.r)
(exec ch4.r)
(exece ch4.r)
(freturn ch4.r)
(frexp ch4.r)
(funcall ch4.r)
(funcallhook ch4.r)
(function ch4.r)
(getdisc ch4.r)
(go ch4.r)
(if ch4.r)
(if ch4.r)
(if ch4.r)
(if ch4.r)
(I-throw-err ch4.r)
(let ch4.r)
(let* ch4.r)
(lexpr-funcall ch4.r)
(listify ch4.r)
(map ch4.r)
(mapc ch4.r)
(mapcan ch4.r)
(mapcar ch4.r)
(mapcon ch4.r)
(maplist ch4.r)
(mfunction ch4.r)
(oblist ch4.r)
(or ch4.r)
(prog ch4.r)
(prog1 ch4.r)
(prog2 ch4.r)
(progn ch4.r)
(progv ch4.r)
(purcopy ch4.r)
(purep ch4.r)
(putd ch4.r)
(return ch4.r)
(selectq ch4.r)
(setarg ch4.r)
(throw ch4.r)
(*throw ch4.r)
(unwind-protect ch4.r)
(cfasl ch5.r)
(close ch5.r)
(cprintf ch5.r)
(drain ch5.r)
(ex ch5.r)
(vi ch5.r)
(exl ch5.r)
(vil ch5.r)
(fasl ch5.r)
(ffasl ch5.r)
(filepos ch5.r)
(filestat ch5.r)
(flatc ch5.r)
(flatsize ch5.r)
(fileopen ch5.r)
(fseek ch5.r)
(infile ch5.r)
(load ch5.r)
(makereadtable ch5.r)
(msg ch5.r)
(nwritn ch5.r)
(outfile ch5.r)
(patom ch5.r)
(pntlen ch5.r)
(portp ch5.r)
(pp ch5.r)
(princ ch5.r)
(print ch5.r)
(probef ch5.r)
(pp-form ch5.r)
(ratom ch5.r)
(read ch5.r)
(readc ch5.r)
(readlist ch5.r)
(removeaddress ch5.r)
(resetio ch5.r)
(setsyntax ch5.r)
(sload ch5.r)
(tab ch5.r)
(terpr ch5.r)
(terpri ch5.r)
(tilde-expand ch5.r)
(tyi ch5.r)
(tyipeek ch5.r)
(tyo ch5.r)
(untyi ch5.r)
(username-to-dir ch5.r)
(zapline ch5.r)
(allocate ch6.r)
(argv ch6.r)
(baktrace ch6.r)
(chdir ch6.r)
(command-line-args ch6.r)
(deref ch6.r)
(dumplisp ch6.r)
(eval-when ch6.r)
(exit ch6.r)
(fake ch6.r)
(fork ch6.r)
(gc ch6.r)
(gcafter ch6.r)
(getenv ch6.r)
(hashtabstat ch6.r)
(help ch6.r)
(include ch6.r)
(include-if ch6.r)
(includef ch6.r)
(includef-if ch6.r)
(maknum ch6.r)
(monitor ch6.r)
(opval ch6.r)
(*process ch6.r)
(*process-receive ch6.r)
(*process-send ch6.r)
(process ch6.r)
(ptime ch6.r)
(reset ch6.r)
(restorelisp ch6.r)
(retbrk ch6.r)
(*rset ch6.r)
(savelisp ch6.r)
(segment ch6.r)
(shell ch6.r)
(showstack ch6.r)
(signal ch6.r)
(sizeof ch6.r)
(small-segment ch6.r)
(sstatus ch6.r)
(sstatus appendmap ch6.r)
(sstatus automatic-reset ch6.r)
(sstatus chainatom ch6.r)
(sstatus dumpcore ch6.r)
(sstatus dumpmode ch6.r)
(sstatus evalhook ch6.r)
(sstatus feature ch6.r)
(sstatus gcstrings ch6.r)
(sstatus ignoreeof ch6.r)
(sstatus nofeature ch6.r)
(sstatus translink ch6.r)
(sstatus uctolc ch6.r)
(status ch6.r)
(status ctime ch6.r)
(status feature ch6.r)
(status features ch6.r)
(status isatty ch6.r)
(status localtime ch6.r)
(status syntax ch6.r)
(status undeffunc ch6.r)
(status version ch6.r)
(syscall ch6.r)
(sys:access ch6.r)
(sys:chmod ch6.r)
(sys:gethostname ch6.r)
(sys:getpid ch6.r)
(sys:getpwnam ch6.r)
(sys:link ch6.r)
(sys:time ch6.r)
(sys:unlink ch6.r)
(time-string ch6.r)
(top-level ch6.r)
(wait ch6.r)
(setsyntax ch7.r)
(getsyntax ch7.r)
(add-syntax-class ch7.r)
(trace ch11.r)
(traceargs ch11.r)
(tracedump ch11.r)
(untrace ch11.r)
(top-level ch13.r)
(valueof ch13.r)
(changes ch13.r)
(dc ch13.r)
(dskin ch13.r)
(dskout ch13.r)
(dskouts ch13.r)
(dv ch13.r)
(file ch13.r)
(file-fns ch13.r)
(getdef ch13.r)
(mark!changed ch13.r)
(step ch14.r)
(debug ch15.r)
(editf ch16.r)
(edite ch16.r)
(editracefn ch16.r)
(editv ch16.r)
(editp ch16.r)
(editl ch16.r)
(editfns ch16.r)
(edit4e ch16.r)
(editfpat ch16.r)
(editfindp ch16.r)
(## ch16.r)
(makeht ch17.r)
(hash-table-p ch17.r)
(gethash ch17.r)
(remhash ch17.r)
(maphash ch17.r)
(clrhash ch17.r)
(hash-table-count ch17.r)
EndOfFile
cat >  utils/Makefile  << 'EndOfFile'
# $Header: Makefile,v 1.1 83/04/20 10:29:24 sklower Exp $
# $Locker: jkf $

LibDir = /usr/lib/lisp
AllSrc = Makefile append.c tackon.c

AllObj = ${LibDir}/append ${LibDir}/tackon

all: ${LibDir}/append ${LibDir}/tackon

${LibDir}/append: append.c
	cc -O -o ${LibDir}/append  -I../franz/h append.c

${LibDir}/tackon: tackon.c
	cc -O -o ${LibDir}/tackon -I../franz/h tackon.c

copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))


scriptcatall: ${AllSrc}
	@../scriptcat . utils ${AllSrc}


clean:
	rm ${AllObj}
EndOfFile
cat >  utils/append.c  << 'EndOfFile'
static char *rcsid =
  "$Header: append.c,v 1.2 84/01/22 04:07:25 sklower Exp $";
  
/*
 * append:  append a tail to a list of roots or prepend a head to a list
 *	    of tails. 
 * use:
 *	append tail root1 root2 ... rootn
 * result:
 *	root1tail root2tail ... rootntail
 * or
 * 	append -p root tail1 tail2 ... tailn
 *  result:
 *    	roottail1 roottail2 ... roottailn
 *
 * or
 *	append -s xtail root1xoldt root2xoldt ...
 *  result:
 *	root1xtail  root2xtail ...
 *   that is, each root is tested for the presence of 'x', the first character
 *   in the tail.  If it is present, then all characters beyond it are thrown
 *   away before merging.  This is useful for things like
 *	append -s .c foo.o bar.o baz.o =>> foo.c bar.c baz.c
 *
 * Useful in Makefiles due to the lack of such facilities in make.
 * 
*/
#include <stdio.h>
#include "lconf.h"
#include "config.h"
#if os_unix_ts || os_masscomp
#define rindex strrchr
#endif

char buffer[2000];	/* nice and big */
char *rindex();

 main(argc,argv)
 char **argv;
 {
     int i, base;
     int prepend = 0,
         append = 0,
	 strip = 0;
     char stripchar;
     char *chp;
     
     if(argc <= 2)
     {
	 fprintf(stderr,"use: append tail root1 root2 ... rootn\n");
	 exit(1);
     }
     if(argv[1][0] == '-')
     {
	 switch(argv[1][1])
	 {
	     case 'p' : prepend = 1;
	     		break;
	     case 's' : strip = 1;
	     		append = 1;
			stripchar = argv[2][0];	/* first char of tail */
			break;
	     default:  fprintf(stderr,"append: illegal switch %s\n",argv[1]);
	     		exit(1);
	 }
	 base = 2;
     }
     else {
	 append = 1;
	 base = 1;
     }
     
     for(i = base +1; i < argc ; i++)
     {
	 if(append)
	 {
	    strcpy(buffer,argv[i]);
	    if(strip && (chp = rindex(buffer,stripchar)))
	    {
		*chp = '\0';
	    }
	    strcat(buffer,argv[base]);
	 }
	 else {
	     strcpy(buffer,argv[base]);
	     strcat(buffer,argv[i]);
	 }
	 printf("%s ",buffer);
     }
     printf("\n");
     exit(0);
 }
 
EndOfFile
cat >  utils/tackon.c  << 'EndOfFile'
#include <stdio.h>
#include "lconf.h"
#include "config.h"
#if ! os_unisoft
#include <sys/types.h>
#include <a.out.h>
/*
 * $Header: /na/franz/utils/RCS/tackon.c,v 1.4 83/08/22 19:01:17 sklower Exp $
 *
 * $Locker:  $
 *
 * This program tacks on extra symbols into the symbol table.
 * someone should write one for system 5.
 *
 */

FILE *map;
int aout;
#define NEWSIZ 100000
char newstrb[NEWSIZ];

#endif
main(argc, argv)
int argc;
char *argv[];
{
#if ! os_unisoft
	char sym[50], svalue[50];
	char *strb,*newstr,*malloc();
	char *curstr;
	int value;
	int cnt;
	int strsiz;
	int strcnt;
	int size;
	int header_location;
	struct nlist a;
	struct exec e;

	argc--, argv++;
	if (argc == 0 || argc > 2) {
usage:
		fprintf(stderr, "usage: tackon map [ a.out ]\n");
		exit(1);
	}
	map = fopen(argv[0], "r");
	if (map == NULL) {
		perror(argv[0]);
		exit(1);
	}
	aout = open(argc == 2 ? argv[1] : "a.out", 2);
	if ((aout < 0) && (argc == 2)) {
		char Name[256];

		strcpy(Name,argv[1]);
		strcat(Name,".exe");
		aout = open(Name,2);
	}
	if (aout < 0) {
		printf(" No object file to tackon or text busy\n");
		exit(1);
	}
	header_location = 0;
	read(aout,&e, sizeof(e));
	if (N_BADMAG(e)) {
		header_location = 512;
		lseek(aout,512,0);
		read(aout,&e,sizeof(e));
		if (N_BADMAG(e)) {
			printf("tackon: bad magic number\n");
			exit(0);
		}
	}
	/* read current string table into buffer */
	lseek(aout, N_STROFF(e), 0);	/* seek to string table beginning */
	read(aout,&strsiz,4);		/* read in string table size	  */
	strb = malloc(strsiz);
	read(aout,strb,strsiz);		/* read in string table */
	lseek(aout, N_STROFF(e), 0);	/* now write at end of symbols	  */
	cnt = 0;
	strcnt = 4 + strsiz;
	curstr = newstrb;		/* point to new string buffer */
	for (;;) {
		if (fgets(sym, 50, map) == NULL)
			break;
		sym[size=strlen(sym)-1] = 0;
		if (fgets(svalue, 50, map) == NULL) {
			fprintf(stderr, "missing value\n");
			break;
		}
		strcpy(curstr,sym);
		sscanf(svalue, "%x", &a.n_value);
		a.n_un.n_strx = strcnt;
		a.n_type = N_EXT|N_TEXT;
		write(aout, &a, sizeof (a));
		curstr += size+1;
		strcnt += size+1;
		cnt++;
		if( curstr >= &newstrb[NEWSIZ])
		{
			printf(" Tackon; string buffer overflow \n");
			exit(1);
		}
	}
	write(aout, &strcnt, 4);	/* new character count */
	write(aout, strb, strsiz);	/* write out old string table */
	write(aout, newstrb, strcnt - ( 4 + strsiz));
	lseek(aout, header_location, 0);
	e.a_syms += cnt*sizeof(struct nlist);
	lseek(aout, header_location, 0);
	write(aout, &e, sizeof (e));
	exit(0);
#endif
}
EndOfFile
cat >  pearl/Makefile  << 'EndOfFile'

#	Makefile for pearl 

# Read the ReadMe file for more info.
# This makefile creates these things:
#   pearl - the executable PEARL, loaded into a lisp.
#   pearl.o - the object version of PEARL's functions for fasl'ing
#             into another lisp file at compile time.
#   tags - tags file for PEARL source.
#

# If LibDir is changed, you must also change the pathnames in pearllib.l
LibDir = /usr/lib/lisp
CopyTo = /dev/null
ManDir = /usr/man/man1
ObjDir = /usr/ucb
Liszt = ${ObjDir}/liszt
CdTo = ..

Src =	alias.l create.l db.l fix.l franz.l hash.l history.l hook.l \
	inits.l lowlevel.l match.l path.l pearl.l \
	pearlbase.l pearlbulk.l pearllib.l pearlsmall.l \
	print.l scopy.l symord.l \
	toplevel.l ucisubset.l vars.l

AllSrc =  Makefile ChangeLog ReadMe implement.ms ltags \
	manual.ms pearl.1 ptags template update.ms ${Src}

.l.o:
	${Liszt} $<

# Make "pearl.o" and "pearl" from scratch.
# NOTE: At installations where memory is less than 2.5Mb,
#    "make pearl" normally makes "small" which builds PEARL in two steps.
#    If your installation has more memory, "pearl" can be changed to
#    make "big" instead.  In this case, "install" below should also be
#    changed to make "biginstall" instead of "smallinstall".
pearl:	small
	echo "(savepearl)" | pearl.o
	@echo pearl done

pearlbase.o:	pearlbase.l

pearlbulk.o:	pearlbase.o pearlbulk.l

small:	pearlbase.o pearlbulk.o
	${Liszt} -r pearlsmall.l -o pearl.o

big:
	${Liszt} -r pearl.l

# Install the executable pearl in ObjDir and the
#   fasl'able pearl.o for compiling code using PEARL in LibDir.
#   NOTE: "install" can be changed to use "biginstall" on big enough machines.
install: smallinstall

smallinstall: small
	echo "(savepearl)" | pearl.o
	mv pearlbase.o ${LibDir}/pearlbase.o
	mv pearlbulk.o ${LibDir}/pearlbulk.o
	${Liszt} -r pearllib.l -o pearl.o
	mv pearl.o ${LibDir}/pearl.o
	mv pearl ${ObjDir}/pearl
	cp pearl.1 ${ManDir}/pearl.1
	@echo pearl done

biginstall: big
	echo "(savepearl)" | pearl.o
	mv pearl.o ${LibDir}/pearl.o
	mv pearl ${ObjDir}/pearl
	cp pearl.1 ${ManDir}/pearl.1
	@echo pearl done

tags:	/dev/tty  ${Src}
	-rm -f tags
	awk -f ltags ${Src} | sort > tags

# For distribution purposes.
copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@(cd ${CdTo} ; scriptcat pearl pearl ${AllSrc})

clean:
	-rm -f pearl pearl.o

EndOfFile
cat >  pearl/ChangeLog  << 'EndOfFile'
    Changes to PEARL since the User's Manual.

6/26/83 -- Version 3.9: Misc. bug fixes -- distributed with 4.2.
-- Fixed a(n embarassingly) large number of bugs in the functions
relating to blocks and freezing and thawing variables.  User visible
changes are that freezeblock and thawblock are now fexprs expecting
the name of the block to be frozen.  Blocks without names cannot be
frozen or thawed individually.  A prominent bug was also found in
freezebindings which did not work correctly when the structure being
frozen had no non-frozen variables of its own.

6/21/83
-- Changed the name of the "selectq" in ucisubset.l to "selectq*" to
avoid the new Franz function "selectq" which requires the default case
to be labeled with "t" or "otherwise".  Changed all PEARL code to use
the new Franz selectq.

5/14/83 -- Version 3.8: Unification added.
-- Added unification pattern matching as an option, using code written
by Dave Chin.  To turn on unification, call the function "useunification".
There is currently no way to turn it off since the code as written
cannot handle old unification results if it doesn't think unification
is taking place (controlled by special variable *unifyunbounds*).
It is not as expensive as expected so this may be changed.
-- Also fixed serious bugs in "setv".

5/12/83
-- Fixed bug in create which caused the mechanism of changing the type
of create being done in nested structures to fail.

5/6/83
-- Fixed bug in printing of global adjunct variables.

5/1/83
-- Fixed various major bugs in varreplace.

4/26/83 -- Version 3.7: Two part compilation and minor bug fixes
	    in scopy and hooks.
-- Created a way to do a "make" which compiles in two pieces for small
machines.  Simply define "make pearl" as either "big" or "small"
depending on memory size (Less than about 2.5 Mb of memory requires
"small").
-- Changed "scopy" and related functions so that the abbreviation on the
copy is just gensym'ed from the old abbreviation, without adding ":copy".
-- Fixed a bug in the hook functions which caused all slots after the ones
with hooks to execute the result (*done*, etc) of the first one.

3/28/83 -- Version 3.6: Inherit all slot hooks and predicates and unbind
	    incorrectly bound global variables after failed match.
--- Slot hooks are now always inherited and added to, rather than
replaced.  If the hooks and predicates of a slot are preceded by "instead"
then inheriting doesn't happen and hooks and predicates are replaced.
--- Fixed match so that if an unbound global variable is set during a match
that later fails, the value is restored to *pearlunbound*.  The names of
variables that are set are saved in the special variable *globalsavestack*.

3/18/83 -- Version 3.5: New print functions.
--- Rewrote all the print functions.  Externally, the three old
pairs of functions: "valprint"/"valform", "fullprint"/"fullform",
and "abbrevprint"/"abbrevform" behave the same.  However, there is now
a function called "allform" which all of these use which adjusts its
treatment of a structure based on several special atoms:
    1. *abbrevprint* -- non-nil value causes abbreviations to be used
whenever possible.  "abbrevform" (and thus "abbrevprint") lambda-binds
this to t and calls "allform".  "fullform" binds this to nil.
    2. *fullprint* -- non-nil value causes complete information
including hooks and predicates to be given when present.  "fullform"
(and thus "fullprint") lambda-binds this to t and calls "allform".
"abbrevform" binds this to nil.
    3. *uniqueprint* -- described below.
    4. *quiet* -- described below.
"valform" lambda-binds both to nil which is their default values.
Thus, the default action of "allform" used by itself will be like "valform".
--- All the default print functions which used to use "valprint"
automatically now use "allprint" so that they can all be changed by
changes to the default values of *abbrevprint* and *fullprint*.
--- The third atom which affects the behavior of all the print functions
is *uniqueprint*.  If it is given a non-nil value then if a structure
is encountered more than once during the same top-level call to a
print function, it will be translated into exactly the same cons-cells.
This saves on cons-cells and also makes it possible for the "*form"
functions to handle circular structures, although "sprint" and thus
the "*print" functions can't handle the result.  Since most people
seldom have duplications within a structure, the default is OFF (nil).
The assoc list is stored in the special atom *uniqueprintlist*.
--- "form" and "print" functions were added to handle structures,
streams and symbols specially.  They are called
"structureform", "structureprint" "symbolform", "symbolprint",
"streamform" and "streamprint" and do not ensure that you give them
the right type of value.
--- The fourth atom which affects the behavior of all the print
functions is *quiet* which, if non-nil, keeps them from running
either sprint or the *form function.   This is helpful for when you
wish to turn off ALL printing in one fell swoop.  A function called
"quiet" was also added which behaves like progn, except that it
lambda-binds *quiet* to t during the evaluation of its arguments,
provided a local island of "quiet".

3/8/83 -- Version 3.4: Type tags added.
--- Added a field to definitions, structures, symbols, and databases to
indicate what they were to speed up type checking.  All relevant
functions related to structures and databases were changed.
--- Fixed some bugs in releasedb.
--- Many lowlevel functions in PEARL were changed, but none in ways that would
affect most people (because they shouldn't be using the changed functions).

3/4/83 -- Version 3.3: New faster hashing.
--- Changed internal code to do the hashing so that it only gets the value
out of a slot once instead of as many as 4 times as before.  Resulted
in about a 5% speedup for structures only hashed a couple of ways.
Should be more for multiply hashed items.  Should also make new
hashing methods easier to add.

2/25/83 -- Version 3.2: Slot encoding applied to speeded-up match.
--- Rewrote match functions to use the new slot encoding.  Provided
about a 10% speedup.
--- There are now two different kinds of match function: "standardmatch"
and "basicmatch" will only match two structures of the same type.
"standardexpandedmatch" and "basicexpandedmatch" will match two
structures which are related hierarchically (one above the other)
on the slots they have in common.  "standardfetch" uses the regular
versions and "expandedfetch" uses the expanded versions.

2/21/83
--- Changed all special variables in PEARL to be defined with defvar so
that fasl'ing in pearl.o at compile time will automatically declare them
special again.

2/17/83 -- Version 3.1: Slot encoding for speed.
--- Added major and minor version numbers to PEARL, stored in
"pearlmajorversion" and "pearlminorversion" respectively.
Started at 3.1 for this version.
--- Added new method of storing in slots to speed up some things.
--- Putpath, delsetpath, addsetpath and clearpath now will work on a
slot with any kind of value or variable in it but result in a constant
value.  This may cause problems, and if it does it will be "fixed" to
worry about what was there and decide what to do to it.
--- Scopy no longer throws away bound adjunct variables.
--- Many functions listed in the manual as being "proprietary" to PEARL
(i.e., not safe to use) have gone away.  There are too many to list here.

1/23/83
--- Fixed a bug which made slots inherit hashing when redescribed in an
expanded structure unless new hashing was specifically included.
--- Added a new "hashing mark" "+", for redescribed slots of expanded
structures only, which says copy the old info and add the following
new hashing too.  It must come first to be effective.
    Thus, the following should work:
	(cb x (* a int))
	(ce x y (a ^))
	(ce x z (+ : a ^))
	(ce x w (: + a ^)) ;; anomalous use of +
resulting in:
	* hashing in x,
	no hashing in y,
	both * and : hashing in z,
    and only * hashing in w (because of misplacement of +).

1/19/83
--- Merged the file sprint.l into ucisubset.l.

1/18/83
--- Miscellaneous changes to functions length and others in ucisubset.l
to improve efficiency.

1/7/83
--- Changed ,@ to ., in most cases (i.e., whenever equivalent) to
avoid an unneeded append generated by the backquote macro.

12/24/82
--- Made change in the definitions of de, df, dm, drm and dsm so that
if the special variable *savedefs* is nil then old definitions of functions
are not saved.  This is especially useful in compiling (and hence assembly
and loading) since it will speed it up quite a bit.  The saving of the file
the definition was in is also disabled.  The variable *savedefs* is
normally t which causes these macros to act as before, saving the
definition, etc.  If *savedefs* is nil, then they simply expand into the
appropriate defun or setsyntax.  The following lines should be
included in the file to have this effect only at compile time:
    (eval-when (compile)
	       (declare (special *savedefs*))
	       (setq *savedefs* nil))
If you want to permanently disable the saving in your lisp,
simply put a
    (setq *savedefs* nil)
in your .lisprc file AFTER the loading of ucisubset.l.

11/12/82
--- Removed association of "remove" with Franz's "delete" so that
Franz's remove could be used and fixed all references to "remove" and
"dremove", changing many to "delq"s.
--- Deleted "powercopy" and redefinition of "copy" now that Franz has
correct meaning (doesn't attempt to copy hunks) for copy.

10/30/82
--- All the exprs whose names were of the form XXXX1 where XXXX was the
name of a lexpr which was a principle function of PEARL were eliminated
(i.e., absorbed by the other form).
--- Many small changes to speed up PEARL, including:
    1. Changed many progs to lets.
    2. Inserted progn's around (or (non-error)
				   (not (msg t .....))
				   (pearlbreak))
    thus eliminating the not and clarifying the meaning.
    3. Changed many pops to (setq x (cdr x)) (where popped item not wanted).
    4. Changed plus, difference, times and remainder to +&, -&, * and \\.
    5. Changed greaterp and lessp to >& and <&.
    6. Changed minusp to (<& ..  0)
    7. Changed (neq 0 ..) to (not (=& 0 ..)).
    8. Eliminated the intermediate exprs insertdb1, fetch1, etc.
    by converting the basic functions insertdb, fetch to use the
    &optional syntax.
PRELIMINARY RESULTS:
    25-33% speedup of various test programs.

10/20/82
--- Added abbreviation "pdb" for "printdb".
--- Changed usage of nth, push and pop to use Franz Opus 38.32's new
definitions of them, removing them from ucisubset.l.

9/17/82
--- Changed scopy, patternize and varreplace to exprs from macros
so that they will compile without complaints of special variables.

9/16/82
--- Added new hashing mechanism using label && and called "hash
focusing".  If this is found when inserting into the database
then the item is hashed as if it were the item in the slot so
labelled.  This is designed for people using a data base all of
whose entries are of the same type (not required, just common
for this application) and enables the contents of a slot to be
more usefully used to discriminate them (e.g., planfors, inference
rules, or almost any such extremely-common binary predicates.)
At fetching time, && is considered less useful than *** or ** and more
useful than * or nothing (subject to debate and change).  (This
necessitated the addition of an additional entry in the header of
structure definitions, moving everything else down a slot in the hunk.)
This differs from & (hash aliasing) in that && hash focussing affects
how a structure itself is inserted and fetched, while & simply
affects how structures containing this type of structure are
treated.  For example, suppose the unique numbers of A, B, and C
respectively are 1, 2, and 3.  C is a symbol.  A has one slot X with
* and && hashing.  B has one slot Y of type symbol with * hashing.
Then a structure like (A (X (B (Y C)))) will be indexed the
following ways and fetcheverywhere will find it in the following
order:
    && which uses the 2 and 3 from B and its C, (ignoring the 1 of A),
	    and also simply 2 from B.
    * on A uses type of B thus using 1 and 2.
    also put under 1 of A without using 2 or 3.
If B had an & in its slot then the
    * on A is affected by & on B thus using 1 and 3 (ignoring the 2 of B).

Thus, if you consider A, B, and C to be three levels of information
in the structure, an item can be hashed under any combination of two
of those levels.  The normal * method uses levels 1 and 2, the
aliasing & method ignores level 2 and uses levels 1 and 3, and the
new focussing && method ignores level 1 and uses levels 2 and 3.
In addition, the item can be put under 1, 2 or 3 individually by
various combinations of marks (1 = none, 2 = :, 3 = :+&).  The only
unavailable combination of the 3 is all three.

(Added internal-use-only functions are insertbyfocus, removebyfocus,
puthashfocus, gethashfocus, recursetoinsidestandardfetch.

9/15/82
--- Added two functions "memmatch" and "memstrequal" which are like
"memq" except that they use "match" and "strequal" respectively
instead of "eq".
--- Added fixes to "scopy" and "patternize" from Dave Chin which allow
them to handle circularly linked structures AND to use the same copy
of the same structure wherever it appears.  This required the addition
of a special variable *scopieditems*.  This also included a bug fix
which added code to store pointers to the new copies in the
abbreviation atoms stored in them.
--- Added a function called "varreplace" similar to "patternize" which
replaces all bound variables in an item with their values, in effect
permanently freezing them.
--- Added a function called "(intscopy item outeritem)" where intscopy
stands for "internal scopy" exactly the same as "(scopy item)" except
it does the copying as if the item were internal to outeritem, thus
sharing its local and block variables.
--- Split create.l into create.l and scopy.l.

9/14/82
--- Moved much of the initialization stuff out of pearl-top-level-init
to be done at load time instead.  This cut the minimum startup cost
for PEARL from 4 seconds to 0.8 seconds CPU.
--- Changed setdbsize to remove all current databases before changing
the size, warn if *warn* is set and recreate *maindb* with *db*
pointing to it.  Also fixed a bug when removing the last database.
--- Changed the init-files processing to parallel the new Franz method,
looking in the current directory, and then the home directory, and
looking for .init.prl followed by .o, .l or nothing, and then init.prl
followed by .o, .l or nothing.  Similarly for start.prl.
--- Fixed cleardb so that it doesn't make new cons-cells for the buckets
and so that it uses connectdb if the database has a parent.  Thus,
cleardb is a local database clearer and its effects do not extend up
the DB hierarchy.

6/6/82
Added new hashing method.  If slots are labelled with *** and all
slots so marked are filled with useful values, then the item is hashed
under the type of structure plus the values of all these slots.
New functions are gethashmulti and puthashmulti.  *multiproducts* is a
new special atom containing the numbers to multiply the various values
with to produce the index (currently powers of 16).

6/3/82
Fixed a bug in fetcheverywhere which caused it to only find the
bucket for the first *-ed slot, instead of all of them.  (Added
to npearl also).

5/28/82
Tried replacing the sequential search method of finding slot numbers
for particular slot names with evaluating a concat'ed atom made out
of <typename ":" slotname> but timings found it slower so it was
removed.

5/27/82
Fixed a problem with storage of variables.  Instead of two spots in
the hunk, one for the alist (unfrozen variables) and one for the
alistcp (frozen variables), there is a special cons cell with these
in its car and cdr.  This cons cell is pointed to by all substructures
so that they can be used in fetches and matches and will be able to
unbind or freeze or thaw their variables.  Additional special variable
is *toplevelalists* (or some such).

5/6/82
--- When an individual (including default instance) structure is created,
an abbreviation atom is stored in it.  This abbreviation is chosen as
follows:
    1.  If the option of having a structure stored in an atom is used,
    then that atom is the one used as an abbreviation.  Thus
	(create individual x Pete)
    will have Pete as a abbreviation.
    2.  If that option isn't used, then default instances will be
    given the abbreviation i:x (where x is the structure type name)
    and individuals at the top level will be given a name newsym-ed
    from the name of their type.  Thus
	(create base x)  will make a default instance abbreviated i:x and
	(create individual x) will be abbreviated x0 or x1 or whatever.
--- New printing and "form-type" functions were added called "abbrevprint"
and "abbrevform" which print the abbreviation (if there is one) for
any structure below the top level.
--- The base name of the type of a slot (i.e., the last word, after
setof's are stripped off) is stored for each slot (a more general
application of the "ppset" information always stored for integer slots
with ordinal types before).  This is in preparation for two things:
    1. Enforcing such type descriptions.
    2. Generating knowledge about the slots of a structure so that the
    user need not know whether to use fetch or path.

5/5/82
The name of an old slot in a new expanded may be changed by following
the new name by the old slotname preceded with an equal sign.  Thus
for example:
pearl> (create base X
	       (A struct))
(X (A (nilstruct)))
pearl> (create expanded X Y
	       (B =A)
	       (C .....))
(Y (B (nilstruct)) (C .....)))

NOTE that there MAY NOT be a space between the equal sign and the A
since = is the read macro which expands =A into (*slot* A) but leaves
a single space-surrounded = alone.

4/28/82
--- Adapted PEARL to fit Franz Opus 38.13 so that the atoms
showstack-printer and trace-printer are bound to the functions
pearlshowstackprintfn and pearltraceprintfn. (Note the addition of
"pearl" to the beginning of these).  Also changed the name of
breakprintfn to pearlbreakprintfn but it is not currently
lambda-bindable.
--- Adapted the reading of .init.prl and .start.prl files to disable
the printing of "[load .init.prl]" by lambda-binding $ldprint to nil
first (Franz Opus 38.14).

2/22/82
--- Fixed a bug in the hook disablers.   The atoms for path hooks
were misnamed in such a way that you couldn't use hidden and
visible.   Instead of *rungethooks*, and other *run...hooks*
forms, they are now *rungetpathhooks* and other *run...pathhooks*.
Note that they must be called as (XXXpath ...) and not (path XXX ...)
when used with hidden and visible.

2/21/82
--- Added ability to evaluate an atom when expecting a value of a
different type (besides integers which already worked this way).
For symbols, this is done if the atom isn't a symbol name.
For structures, it must evaluate to a structure.
For Lisp slots, it may not evaluate to an atom.
For setof slots, its value is checked for being of the appropriate
type, including depth of nesting.
--- Added the fetching function "fetcheverywhere" which gathers
ALL the buckets the object could have been hashed into and builds
a stream out of all of them (potentially five buckets).  Will wait
to build an "expandedfetcheverywhere" with its potential of
returning 5 times the-depth-of-the-hierarchy buckets.

vi: set lisp:
EndOfFile
cat >  pearl/ReadMe  << 'EndOfFile'
ReadMe file for the distribution of the Franz implementation of PEARL.
						 8/9/83 by Joe Faletti

PEARL is an AI programming language implemented on top of Franz Lisp
by Joseph Faletti and Michael Deering under the direction of Robert
Wilensky at the Berkeley AI Research Project (BAIR).

DOCUMENTATION
    For more information on PEARL's capabilities, see the following:

[1] Deering, M., Faletti, J., and Wilensky, R.  1981.  PEARL:  An Efficient
Language for Artificial Intelligence Programming.  In the Proceedings
of the Seventh International Joint Conference on Artificial Intelligence.  
Vancouver, British Columbia.  August, 1981.

[2] Deering, M., Faletti, J., and Wilensky, R.  1982.  The PEARL Users Manual.
Berkeley Electronic Research Laboratory Memorandum No.
UCB/ERL/M82/19.  March, 1982.

[3] Faletti, J., and Wilensky, R.  1982.  The Implementation of PEARL.
Unpublished memo. 

The last two are included in vtroff source form in this distribution
but the page numbers of [2] may be off by a bit (sorry! -- if someone
bothers to convert the manual for automatic table of contents and
index generation, we'd be happy to use it!).  (More below).

The manual [2] may be printed and distributed to users with no fear
of copyright infringement.  However, for those without suitable printing
facilities, a single photocopy of the manual suitable for auto-feed copying
for local distribution of the manual may be acquired from:
    Berkeley AI Research Project
    Robert Wilensky, Director
    Computer Science Division
    553 Evans Hall
    University of California, Berkeley
    Berkeley, CA  94720
This version will include an addendum summarizing the changes
described in the file ChangeLog.

BUG REPORTS:
    Bug reports should be mailed to Pearl-Bugs@Berkeley by ARPANET or
ucbvax!pearl-bugs by USENET.  PEARL is being provided as is for the
cost of distribution with Franz and as such carries no warranty or
guarantee.

CONTENTS OF THIS DIRECTORY:
    The files in this directory fall into two categories: A) the source and
make file for building a version of PEARL in Franz and B) documentation.

    A) Source and make file for building a version of PEARL in Franz.
These files are described briefly after the following description of
how to make a version of PEARL.

To Make PEARL:
    A version of PEARL may be made by changing to this directory and
executing a "make pearl".  As delivered, this makes "small" which compiles
PEARL in two pieces, and builds "pearl.o" (which loads the two pieces
into a lisp) and then executes the "savepearl" function which dumps a
lisp called "pearl" in the current directory containing all of PEARL
with the PEARL top level installed and ready to start up from scratch.
This form is necessary on machines with less than about 2.5Mb of memory.
If your installation is larger, you can change "pearl" to make "big"
instead of "small" and change "install" to make "biginstall" instead
of "smallinstall".  This will compile PEARL in one piece, creating
"pearl.o" simply by compiling the file "pearl.l" which "includes" all
the other source files described below.
    Making PEARL from scratch takes about 13 minutes of CPU time, or about
15 minutes of real time (times the load average) on a VAX 780.
    To install the executable pearl in the usual object directory,
/usr/ucb, and the load module pearl.o in the Franz library /usr/lib/lisp,
execute a "make install".  If you change where the library is you must
also change the absolute path names in the file "pearllib.l" (which is used
in a "make small" to make it easy to load the two halves of PEARL with a
single file).

The Source for PEARL:
    The source for PEARL is described below in the order that it is
included in "pearl.l".

ucisubset.l --- PEARL was originally implemented in UCILisp.  This file
    defines those functions from UCILisp still used in PEARL.
franz.l --- Franz version of functions that are likely to need
    to be redefined for a particular lisp.
lowlevel.l --- Lowest level functions (mostly macros) in PEARL
    used to access the various data structures.
db.l --- Functions for creating databases.
vars.l --- Functions to handle pattern-matching variables.
symord.l --- Functions for creating symbols and ordinals.
hook.l --- Functions used by everything else to handle hooks (demons).
create.l --- Functions to create PEARL structures.
scopy.l --- Functions to copy PEARL structures.
path.l --- The PATH function.
print.l --- Functions to print PEARL objects.
hash.l --- Functions using hashing info in structures to insert and
    fetch from data bases.
match.l --- Functions to match and/or compare structures.
history.l --- Functions used to implement the history mechanism in the
    toplevel loop.
toplevel.l --- Variation on the Franz toplevel loop for PEARL,
    including functions for dumping various versions of a running PEARL.
fix.l --- Variation on the "fixit" debugger adapted for PEARL.
alias.l --- Code to save various functions under alternative names.
inits.l --- Code which must run at load time to initialize a PEARL
    environment.

Documentation included in this directory:

manual.ms --- The -ms source of the PEARL manual as published in the
    reference [2] above.  This should be vtroffable to produce a copy
    of the PEARL manual, although the page numbers were done by hand
    and thus may be off by a bit if anything is changed.  It may also
    be nroffed, although the page numbers will most certainly be off.
update.ms --- The -ms source for an update to the manual covering PEARL
    up through Version 3.9 paginated for appending to the manual.
ChangeLog --- A listing in reverse date order of things changed in
    PEARL since the manual was published.
template --- Visual representation of the allocation of information in
    the hunks used by PEARL for various internal data structures.
implement.ms --- An unfinished memo on the implementation of PEARL.
    Includes a simple example of how to implement forward and backward
    chaining in PEARL and a bit more detail on the hashing mechanism.
ltags --- A tags file for the various function and macro definition
    mechanisms used in PEARL (more than standard Franz).
ptags --- A tags file for files which contain mixed Lisp functions and
    PEARL structure definitions.

EndOfFile
cat >  pearl/implement.ms  << 'EndOfFile'
.so /usr/lib/vlpmacs
.ND
.ds CH
.ds CF - % -
.po 1.00i
.nr LL 6.25i
.RP
.TL
.LG
The Implementation of PEARL
.SM
.sp 1
A Package for Efficient Access to
Representations in Lisp*
.FS
* This research was sponsored in part by the Office of Naval Research
under contract N00014-80-C-0732 and the National Science Foundation
under grant MCS79-06543.
.FE
.AU
Joseph Faletti
Robert Wilensky
.AI
Computer Science Division
Department of EECS
University of California, Berkeley
Berkeley, California 94720
.sp 1
March 1982
.AB
PEARL is an AI language developed with space and
time efficiencies in mind.
In addition to providing the usual facilities such as
slot-filler objects, demons and associative data bases,
PEARL introduces stronger typing on slots,
user-assisted hashing mechanisms, and a forest of data bases.
The resulting product is a simple but powerful and efficient
tool for AI research.
.AE
.NH
Introduction
.sp 3
.PP
We have developed an AI language called PEARL (Package for Efficient
Access to Representations in Lisp).
Unlike the recent tendency toward
elaborate representation languages such as KRL [1]
or language generators such as RRL [5], PEARL is
a more modest system that combines a number of useful
AI techniques into a very efficient package.
PEARL provides the user with a set of operators for defining, creating,
and manipulating slot-filler objects, as well as placing them into
associative data bases, upon which further operations may be performed.
Besides the usual goal of providing the user with a more meaningful
interface than is available via Lisp, PEARL has the following salient 
characteristics:
.IP 1)
PEARL combines some features of predicate calculus-like data bases with
those of frame-based systems like FRL [9].
.IP 2)
PEARL introduces typing to user-defined knowledge structures.
.IP 3)
PEARL allows the user to manipulate a forest of associative
data bases implemented as hash tables.
.IP 4)
Fetches from the data base return streams of answers.
Retrieval is based on pattern matching.
.IP 5)
PEARL is very efficient.
PEARL uses its own internal representation
for knowledge structures for both economy of storage and speed.
A great deal of effort has gone into exploiting type information
not available in most AI languages to eliminate searching inefficiencies.
In addition, the user may easily specify, as part of a knowledge
structure definition, a great deal of information about how
objects should be indexed for efficient retrieval.
Thus PEARL provides much of the power
of expression of other AI languages without the usual overhead.
.LP
Perhaps most significantly, PEARL is actually being used in the
construction of several AI systems.
In particular, the latest version of PAM [12],
a story understanding program, has been re-programmed in PEARL.
PANDORA [13], a planning program now under development at Berkeley,
is also written in PEARL.
Our experience has led us to conclude that PEARL
is an effective AI tool for the creation of efficient AI programs.
.sp 3
.PP
The following is a quick overview of the paper:
First we present an overview of PEARL by discussing a sample session
which demonstrates the primary functions provided.
Next we present some measurements as evidence that PEARL is
indeed efficient.
The bulk of the paper then describes the details of each of PEARL's
main functions -- creating structures, the form of the data bases,
indicating indexing methods, fetching from the data bases, predicates
and matching, matching variables, and demons.
This is followed by descriptions of the various implementations of
PEARL and their relative speeds plus evidence that PEARL's hashing
mechanism does in fact speed up fetching.
Finally, we compare PEARL to its nearest cousins, FRL and KRL.
.NH
An Overview and Sample Application Of PEARL
.sp 3
.PP
In the section we give an overview of PEARL by presenting an
extended example of PEARL's use.
The example we will use to demonstrate the various features of
PEARL before going into each in more detail is a \fIvery simple\fR
inference mechanism based on forward and backward inferences rules.
In order to explain and motivate the various pieces of PEARL (and
Lisp) code, we present them in the order that one would most likely
design them, rather than the order that they must be entered
into PEARL.  Afterwards, they would have to be moved around so
that things are defined before being referenced.
.sp 3
.PP
To implement the inference mechanism, we will want to ensure that
we perform forward inferences whenever we insert a concept into
the data base and backward inference whenever we fetch a concept
from the data base.  The easiest way to accomplish this is to
create two demons, one for forward inference and one for backward
inference which will be run when insert and fetching respectively
happens.  These will need to be attached to all concepts which we
want to make inferences from, so we need a \fIstructure\fR (PEARL's
name for a slot/filler object) which we will call \fIConcept\fR.
It will have no slots but will be used as the root of our
conceptual hierarchy so that all concepts can inherit the
inference demons from it.
(We will add these later when we know what their names are).
We do this in PEARL by declaring a \fIbase\fR structure called \fIConcept\fR:
.DS
(create base  Concept)
.DE
.sp 3
.PP
We will then want to describe some of the concepts that we
wish to make inferences about.
For the purposes of this example, we will present only enough
information to use backward inference to determine that Samuel is
probably poor from the fact that he is a professor.
So we will want structures which describe a person, a professor,
a salary level, and being poor.
\fIPerson\fR is an expanded \fIConcept\fR;
that is, it should inherit everything not otherwise specified from
the structure \fIConcept\fR.
It will have one slot (for our current purposes) containing the
person's name which we will represent as a \fIsymbol\fR which is
used in PEARL for creating literals (that it, something with no
conceptual content):
.DS
.Ls
(create \kAexpanded  Concept  Person
        \h'|\nAu'(*  Name  symbol))
.Le
.DE
.LP
Included in our definition is a special hashing mark (*) on the
Name slot which says that the value in this slot should be
helpful in indexing \fIPerson\fR structures.
This is true because we are likely to be asking questions of the
data base like "Is Samuel the name of a person?".
For example, suppose we have declared the symbol Samuel:
.DS
(symbol  Samuel)
.DE
.LP
and asserted into the data base the fact that there is a person named
\fISamuel\fR by creating an individual instance of a \fIPerson\fR
with the \fIName\fR slot filled with the symbol \fISamuel\fR and
inserting it into the data base:
.DS
.Ls
(insertdb  (create \kAindividual  Person  Sam
                   \h'|\nAu'(Name  Samuel)))
.Le
.DE
.LP
(As a side effect of the above, the individual structure instance
\fI(Person (Name Samuel))\fR is stored in the Lisp atom \fISam\fR
for future use.)
The function \fIinsertdb\fR uses the hashing information we gave
for \fIPerson\fR to insert this structure in the data base in
two places: under the fact that it is a \fIPerson\fR which is
automatic for all structures and under the combination of
\fIPerson\fR and \fISamuel\fR because we bothered to provide
the extra information in our definition of \fIPerson\fR.
.sp 3
.PP
Now we can "phrase" the question "Is Samuel the name
of a person?" as:
.DS
.Ls
(setq  Stream  (fetch  (create \kAindividual  Person
                               \h'|\nAu'(Name  Samuel)))
.Le
.DE
.LP
that is, by creating an individual \fIPerson\fR with name \fISamuel\fR,
and fetching it from the data base.
This returns a hash bucket from the data base which is chosen
based on two parts of our pattern: the fact that it is a
\fIPerson\fR structure (because this is always available)
plus the value in the Name slot (because we labelled this slot
in our definition of \fIPerson\fR.
Given this stream (virtual list) of possible matches, we ask
whether there is in fact something there which matches our pattern:
.DS
(setq Result (nextitem Stream))
.DE
.LP
If Result is \fInil\fR then the fact that Sam is a Person is not
in the data base.
If it is, then Result will contain the structure in the data base.
.sp 3
.PP
Similarly, we declare the structure \fIProfessor\fR,
a predicate about a (structure of type) \fIPerson\fR and
assert that Sam is a \fIProfessor\fR using the structure
value we stored in \fISam\fR before:
.DS
.Ls
(create \kAexpanded  Concept  Professor
        \h'|\nAu'(* > Person  Person))
(insertdb  (create \kAindividual  Professor
                   \h'|\nAu'(Person  Sam)))
.Le
.DE
.sp 3
.PP
In choosing a way to index this structure, we consider the fact
that Person slot of \fIProfessor\fR will always contain a
\fIPerson\fR structure and thus the combination of \fIProfessor\fR
and \fIPerson\fR will not help to spread these out in our data base. 
However, the value of the first marked slot \fIName\fR of Person will
contain widely varying information so the combination of
\fIProfessor\fR and this value will work well.
The hashing mark ">" instructs PEARL to do precisely this.
We also define \fISalary\fR, a relation between an \fIEmployee\fR
and a salary level:
.DS
.Ls
(create \kBexpanded  Concept  Salary
        \h'|\nBu'\kA(* > Employee  Person)
        \h'|\nAu'(      Level  symbol))
.Le
.DE
.LP
Here the first slot is starred because we are likely to ask for
the salary of Sam.
If we were also likely to ask for all people with Low salaries,
then we would star the second slot also.
Finally, we define \fIPoor\fR, a predicate about a \fIPerson\fR:
.DS
.Ls
(create \kAexpanded  Concept  Poor
        \h'|\nAu'(* > Person  Person))
.Le
.DE
.LP
Having defined the types of objects we know about and the few
actual facts we know, we are ready to describe the inference
rules.
Forward rules say that if the value in the Fact slot is true then
the value in the Implies slot is true also.
We are likely to fetch them using Fact as a key, so we mark that
slot as useful in hashing:
.DS
.Ls
(create \kBbase  ForwardRule
        \h'|\nBu'\kA(* Fact  Concept)
        \h'|\nAu'(   Implies  Concept))
.Le
.DE
.LP
Backward rules say that if you want to know if the value in the Need
slot is true then check to see if the value in the LookFor slot is true:
.DS
.Ls
(create \kBbase  BackwardRule
        \h'|\nBu'\kA(* Need  Concept)
        \h'|\nAu'(   LookFor  Concept))
.Le
.DE
.LP
Finally, we need to add some rules to our data base.
Since we are likely to know a lot of inference rules and to want
to access them often, it would help to keep them in a different
data base separate from other facts to speed up access.
So we build a special data base just for inference rules:
.DS
(builddb *Rules*)
.DE
.LP
Then we insert some rules into it:
.DS
(symbol  Low)
.DE
.DS
.Ls
\fI; If you want to know if someone is poor, check for a low pay level.\fP
(insertdb  \kA(create \kBindividual  BackwardRule
                   \h'|\nBu'\kC(Need  (Poor  (Person  ?Person)))
                   \h'|\nCu'(LookFor  (Salary  \kB(Employee  ?Person)
                                      \h'|\nBu'(Level  Low))))
           \h'|\nAu'*Rules*)
.Le
.DE
.DS
.Ls
\fI; If you want to know if someone's pay level is low, check to\fP
\fI;    see if they are a professor.\fP
(insertdb  \kA(create \kDindividual  BackwardRule
                   \h'|\nDu'\kB(Need  (Salary  \kC(Employee  ?Person)
                                   \h'|\nCu'(Level  Low)))
                   \h'|\nBu'(LookFor  (Professor  (Person  ?Person))))
           \h'|\nAu'*Rules*)
.Le
.DE
.LP
Note in our rules that we use the pattern matching variable \fI?Person\fR.
In the first rule this ties together the person who is poor with the
person whose is paid at a low level.
In the second rule it ties together the person with low pay
to the professor.
Although these two rules have variables with the same name, no
naming conflict arises because most variables in PEARL are local
to the structure they are used in.
.sp 3
.PP
Next we are in a position to say how to make forward inferences:
.DS
.Ls
\fI; MakeForwardInference is a demon, triggered by insertions into the\fP
\fI;    data base, which fetches forward inference rules predicated upon\fP
\fI;    the Fact being inserted and inserts the implications from the\fP
\fI;    rule into the data base.\fP
(de \kDMakeForwardInference (Fact)
    \h'|\nDu'(prog \kC(Rules Rule)
          \h'|\nCu'\kB(setq \kDRules
                \h'|\nDu'(fetch \kA(create \kCpattern ForwardRule
                               \h'|\nCu'(Fact Fact))
                       \h'|\nAu'*Rules*))
          \h'|\nBu'(while \kA(setq Rule (nextitem Rules))
                 \h'|\nAu'(insertdb (path get Rule 'Implies)))))
.Le
.DE
.LP
This says to fetch all forward inference rules with the new fact
in the Fact slot and assert each of their associated Implies slots.
.sp 3
.PP
Making backward inferences is similar but a bit more complex
because we want it to stop right away if it succeeds:
.DS
.Ls
\fI; MakeBackwardInference is a demon, triggered by fetches from the\fP
\fI;    data base which fetches backward inference rules whose Need\fP
\fI;    slot contains the Fact being inserted and fetches the value\fP
\fI;    of the rule's LookFor slot from the data base until one succeeds.\fP
(de \kBMakeBackwardInference (Fact)
    \h'|\nBu'(prog \kA(Rules Rule Found Try)
          \h'|\nAu'\kC(setq Rules (fetch \kD(create \kBpattern BackwardRule
                                     \h'|\nBu'(Need Fact))
                             \h'|\nDu'*Rules*))
          \h'|\nCu'\kD(setq Found nil)
          \h'|\nDu'\kA(while \kB(and \kC(not Found)
                      \h'|\nCu'(setq Rule (nextitem Rules)))
                 \h'|\nBu'\kC\fI; Get the LookFor slot's value.\fP
                 \h'|\nCu'\kB(setq Try (path get Rule 'LookFor))
                 \h'|\nBu'(cond (\kC(nextitem (fetch Try))
                        \h'|\nCu'\kB(insertdb Fact)
                        \h'|\nBu'(setq Found t))))
          \h'|\nAu'(return Found)))
.Le
.DE
.LP
Finally, we can finish our description of \fIConcept\fR by saying
that all concepts inserted into the data base should run the demon
MakeForwardInference after the insertion has been performed (">insertdb").
All concepts fetched from the data base should run MakeBackwardInference
\fIbefore\fR the fetch has been performed ("<fetch"):
.DS
.Ls
(create \kBbase  Concept
        \h'|\nBu'(if  \kA>insertdb  MakeForwardInference
             \h'|\nAu'<fetch  MakeBackwardInference))
.Le
.DE
.LP
Now we "phrase" our question "Is Sam poor?" as a pattern:
.DS
.Ls
(create \kApattern  Poor  NeededFact
        \h'|\nAu'(Person  Sam))
.Le
.DE
.LP
This fact is not in the data base.
However, upon fetching it:
.DS
(nextitem  (fetch  NeededFact))
.DE
.LP
Our two backward inference rules will be used by our backward
inference demon and the desired fact will have been inserted into
the data base before the fetch does its job.
.sp 3
.PP
This example demonstrates a good deal of what PEARL can do and
gives the flavor of its use.
After presenting some measurements of its speed, we will discuss
each of its features in more detail and describe their
implementations.
.sp 3
.PP
The above example was described as a user would design and enter
code into a file to be read into PEARL.
This is the normal mode for experienced users of PEARL, just as it
is for Lisp programmers.
PEARL can also be used interactively since it is
built on top of Lisp.
However, PEARL constructs objects which Lisp does not know how
to print intelligibly.
To remedy this, the read-eval-print loop of Lisp has been modified
to deal with PEARL objects and uses PEARL's print function to
print a readable representation of them.
To help demonstrate what it is like to use PEARL interactively,
the examples in later sections use italics to indicate those things
typed by PEARL during an interactive session and bold face to
indicate those things typed by the user.
To remind the users that they are using PEARL
rather than Lisp, the prompt has been changed to \fIpearl>\fR.
.NH
How Fast Is PEARL?
.sp 3
.PP
PEARL achieves its space efficiency and some of its time efficiency
by requesting a block of memory from Lisp for each structure
instance or definition.
The contents or defining information are then packed within
this block.
Since much of the defining information is Boolean, 
this provides substantial savings in space for definitions.
Data bases are managed similarly.
.sp 3
.PP
As a rough measure of PEARL's execution speed on the PDP-10,
we created a test data base of 4000 structures, in which the
average unsuccessful query took 0.0042 CPU seconds (237 per
second) and the average successful query took 0.0073 CPU seconds
(136 per second).
Note that PEARL's hashing mechanism results in particularly fast
determination of failure.
As another measure of PEARL's execution speed, we
compared the original implementation of PAM [12] written purely in Lisp
(with no special consideration for efficiency)
with the current implementation which uses PEARL.
The average time required by the original to process a single
sentence in a 5-sentence story was 5.6 CPU seconds.
The new version, which builds a more complete representation of
the overall structure of the story and uses a significantly
larger collection of knowledge, requires an average of only
0.56 CPU seconds per sentence in a 23-sentence story.
.sp 3
.PP
For measurements demonstrating the effectiveness of the hashing,
and comparisons between various implementations, see the section
below on performance.
.NH
Objects and Structures
.sp 3
.PP
PEARL has four basic types: \fIinteger\fR, \fIsymbol\fR, \fIstructure\fR,
and \fIlisp\fR.
Objects of type \fBinteger\fR are the usual numeric type, and objects
of type \fBlisp\fR can be any non-atomic Lisp object.
\fBSymbols\fR (objects of type \fIsymbol\fR) correspond to atoms in Lisp,
and are simply primitive objects with predeclared unique labels.
There is a special built-in symbol \fBnilsym\fR
(corresponding to \fInil\fR when considered as an atom)
which denotes a value of type symbol carrying no special conceptual
information, that is, devoid of meaning.
\fBStructures\fR are collections of slots.
Each slot of a structure
may be filled with an object of one of the four types.
There is also a meta-type for slots, \fBsetof\fR,
which can be applied (recursively) to any basic type to generate a new type,
which will consist of a list of the specified type of objects.
There is a special built-in structure \fBnilstruct\fR respresenting
the standard empty structure (similar to \fInil\fR when considered
as the empty list).
.sp 3
.PP
Types of structures must be predefined, with the number of slots, and
their names and types specified via a user declaration.
When an instance
of a structure is created and its slots filled, only objects with the
same type as the slot may fill it.
In addition, new structures may
build upon old ones in a hierarchical fashion by specifying new slots
to add to the old ones.
This hierarchy may be used in operations upon the data base.
.sp 3
.PP
Since the data bases are hash tables (to be described in
more detail later), each symbol and type of structure is assigned
a unique integer at definition time to be used by the hash function
to compute a location in the hash table.
This contributes significantly to the speed of data base operations
in PEARL since it allows the hash function
to be a simple computation based on these numbers rather than
depending on the spelling of the names.
It also helps to prevent
structures with similar names from being hashed in similar ways.
In particular, the unique numbers 0 and 1 are automatically
assigned to \fInilsym\fR and \fInilstruct\fR.
.sp 3
.PP
For example, symbols are declared as follows:
.DS 
\fIpearl>\fB(symbol  John  Home  Here)
    \fI(John  Home  Here)\fR
.DE
.LP
This call to \fIsymbol\fR sets up three unique objects whose print
names are "John", "Home", and "Here" and associates with
them the next three unique integers (2, 3, and 4).
Note that the value returned is a \fIlist of the symbols created\fR,
not a list of Lisp atoms and PEARL's print function prints this
value out as \fI(John Home Here)\fR.
.sp 3
.PP
The internal structure built by \fIsymbol\fR is a hunk of memory
big enough for two pointers pointing to the name and unique number.
.DS
    Internal representat\kaion of the symbol John:

    s:John --->	      \h'|\nau'Unique Number     \kb---|---> 2
		      \h'|\nau'Print Name        \h'|\nbu'---|---> John

.DE
.LP
Although we generally chose to use hunks of memory where possible
to save space (as demonstrated below), this representation
saves no space since it is equivalent to a cons-cell.
However, we chose to build it as a hunk and not a cons-cell since
in this way, PEARL can more easily distinguish it as a symbol
rather than a list cell.
The atom \fIs:John\fR is created with its value
set to the symbol John so that this unique symbol can be
generated at a later time, leaving the atom \fIJohn\fR available for
use by the user.
.sp 3
.PP
New types of structures and instances of previously defined
types of structures are all created with the function \fBcreate\fR.
The statement
.DS
\fIpearl>\fB(create  base  Act
                     (Actor  symbol) )
    \fI(Act (Actor nilsym))\fR
.DE
.LP
will define the primitive type \fIAct\fR with one slot named
\fIActor\fR and containing any single object of type symbol.
At the same time, \fIcreate\fR produces and returns an individual
instance known as the \fBdefault-instance\fR which contains the
standard default values for each slot.
PEARL also provides a
mechanism for changing these default values at definition time.
In this case, the slot Actor contains the default symbol \fInilsym\fR.
The other defaults are \fInilstruct\fR for structures, zero for integers
and \fInil\fR for slots of type \fIlisp\fR or \fIsetof\fR.
Again, the object returned by \fIcreate\fR is an internally represented
structure, not a list.
The representation of the definition and default-instance structures
internally as hunks of memory is as follows:
.DS
\klStructure definition for\km Act                  Default-instance for Act

                        \h'|\nmu'       <--------\kn|
\h'|\nlu'Unique Number	\h'|\nmu'---|---> 5      \h'|\nnu'|----|---\koDefinition
\h'|\nlu'Length		\h'|\nmu'---|---> 1	\h'|\nou'Var-List                      \kp---|---> nil
\h'|\nlu'Default Instance\h'|\nmu'---|---------->\h'|\nou'Var-List Copy	\h'|\npu'---|---> nil
\h'|\nlu'Isa		\h'|\nmu'---|---> nil
\h'|\nlu'Print Name	\h'|\nmu'---|---> Act	\h'|\nou'Value or Var Name	\h'|\npu'---|---> nilsym
\h'|\nlu'Hash Alias	\h'|\nmu'---|---> 0	\h'|\nou'Var-Value Pair	\h'|\npu'---|---> nil
\h'|\nlu'Expansion List	\h'|\nmu'---|---> nil	\h'|\nou'Predicate List	\h'|\npu'---|---> nil
\h'|\nlu'Base Ifs	\h'|\nmu'---|---> nil	\h'|\nou'Slot If List	\h'|\npu'---|---> nil

\h'|\nlu'Hash Information\h'|\nmu'---|---> 0 		\h'|\nou'  ^
\h'|\nlu'Type Number	\h'|\nmu'---|---> 0 		\h'|\nou'   |
\h'|\nlu'Slot Print Name\h'|\nmu'---|---> Actor		\h'|\nou'i:Act
\h'|\nlu'PP Set Info	\h'|\nmu'---|---> nil
			\h'|\nmu'  ^
			\h'|\nmu'   |
			\h'|\nmu'd:Act
.DE
.LP
There are many values in the above structure which are not yet
important to our discussion and which will be explained later.
The key values so far in the definition information are the unique
number, length of the structure (number of slots), the default
instance, and the print names of the structure itself and of its slot(s).
In the default instance note that a pointer to the definition is
kept in each instance to allow quick access to the unique number,
and other information during hashing and matching.
This means that the only time that a definition must be
accessed through its special atom (\fId:Act\fR in this case)
is when a new instance is created.
.sp 3
.PP
The most important feature of this representation however, is the
speed gained by the use of hunks.
In order to represent this
information as an S-expression, we would need one cons-cell (space
for two pointers) per piece of information with half of this space
wasted on the pointer to the next cons-cell.
Accessing a particular piece of information would require
\fIcdr\fRing down the list an appropriate number of times
which is potentially quite slow with a larger number of slots.
Also, since this definition information is pointed to by all
instances, the uniqueness of at least its header
cell must be maintained requiring some extra effort on the
part of the programmer in Lisp.
However, given the cost of a cons-cell in terms of garbage
collection time, it would be best to maintain the uniqueness
of all of its parts.
.sp 3
.PP
By using a hunk, we can 
.IP 1)
easily guarantee the uniqueness of a definition or instance,
.IP 2)
save the space used by list pointers, thus using half the space,
.IP 3)
use no new cons-cells after a structure is created,
.IP 4)
access any piece of a structure in constant time
(essentially two adds and a multiply at the worst), and
.IP 5)
compile all access operations relatively efficiently.
.LP
Thus, the use of hunks rather than lists contributes significantly
to the speed of PEARL.
.sp 3
.PP
Once we have defined the \fIbase\fR structure Act,
we can define more specific forms of Acts in terms of
it, using the \fBexpanded\fR argument to \fIcreate\fR in
place of \fIbase\fR:
.DS
\fIpearl>\fB(create  expanded  Act  Trans
                    (From  symbol)
                    (To  symbol))
    \fI(Trans  (Actor  nilsym)
	       (From  nilsym)
	       (To  nilsym))\fR
.DE
.LP
Here, we are declaring that Transes (transfers) are Acts with
two additional slots for the initial location From and the final
location To which are both symbols.
In addition to the information
diagrammed above, the structure definitions for Act and Trans are now
connected via their Isa and Expansion List fields (that is, the Isa
field of Trans points to Act and Trans is an element of the
Expansion List field of Act.
In this way, a complete tree of the
concept hierarchy rooted at a base structure is accessible from any
element in that hierarchy.
.sp 3
.PP
This hierarchy can be expanded to any depth.
Thus, we can now further
differentiate between various kinds of transfers, defining mental
transfers (MTrans) and physical transfers (PTrans).
In MTrans, the
mental object MObject slot will contain another concept and is thus
of type structure:
.DS
\fIpearl>\fB(create  expanded  Trans  MTrans
                    (MObject  struct))
    \fI(MTrans  (Actor  nilsym)
		(From  nilsym)
		(To  nilsym)
		(MObject  (nilstruct)))\fR
.DE
.DS
\fIpearl>\fB(create  expanded  Trans  PTrans
                     (From  Here)
                     (Object  symbol))
    \fI(PTrans  (Actor  nilsym)
		(From  Here)
		(To  nilsym)
		(Object  nilsym))\fR
.DE
.LP
Slots which are not filled by the user when creating
an individual are filled in automatically with the default value
from the default instance.
Note in the definition of PTrans that we give the
default value of \fIHere\fR for the previously defined slot
\fIFrom\fR by simply including the slot and its new value.
This means that whenever we create an \fIindividual\fR instance
of PTrans but do not specify a value for the From slot, it will
be filled in with the value Here:
.DS
\fIpearl>\fB(create  individual  PTrans
                    (Actor  John)
                    (Object  John)
                    (To  Home))
\fI(PTrans  (Actor  John)
	    (From  Here)
	    (To  Home)
	    (Object  John))\fR
.DE
.LP
This last structure denotes "John went home (from here)" in Schank's
Conceptual Dependency [11] theory of representation.
These representations are used in the rest of the paper simply
as an example of PEARL's use.
However, PEARL makes no commitment to any
particular set of predicates or primitives and can be used equally
well with any type of slot-filler structure.
.sp 3
.PP
Slots within a structure may also be filled with a
pattern-matching variable, in which case the structure may
be viewed as a pattern.
The simplest form of pattern is one in which any unspecified
slots are filled with the \fImatch-anything\fR variable \fI?*any*\fR.
For example, a pattern matching any PTranses performed by John
could be defined as follows:
.DS
\fIpearl>\fB(create pattern  PTrans
                    (Actor  John))
\fI(PTrans  (Actor  John)
	    (From  ?*any*)
	    (To  ?*any*)
	    (Object  ?*any*))\fR
.DE
.LP
However, \fBany\fR individual PEARL structure, including one with
all of its slots filled with actual values, can be used as a
pattern.
Thus, the first individual PTrans created above is
a pattern which matches only instances of John Ptransing home
from Here.
The sole purpose of using the \fIpattern\fR option to
\fIcreate\fR rather than \fIindividual\fR is
to change the default value for all types of slots to \fI?*any*\fR.
Variables are indicated by preceding them with a question mark
as in ?X for the variable X and, other than \fI?*any*\fR, they are
bound as part of the matching process (usually during a
fetch from the data base) which is discussed further below.
PEARL also provides functions for accessing and changing the
values of slots within individual structures
and for automatically naming the structure created.
.sp 3
.PP
Variables come in two other flavors in PEARL and are discussed in more
detail in the sections on matching and variables.
.NH
Data Base Facilities
.sp 3
.PP
PEARL allows for a forest of associative data bases
into which structures may be placed, and later fetched
via structure patterns.
Since many AI programs spend a significant part of their time
searching for knowledge in growing data bases, this needs to
be as efficient as possible.
.sp 3
.PP
Hashing is the usual programming solution to accessing a particular
element from within a large set.
However, traditionally, hashing has two prerequisites that are seldom
easy for an AI programmer to meet:
.IP 1)
The hash function must be carefully chosen in
advance to do a good job of spreading out the items to be inserted
with a minimum of computation.
In traditional applications of hash tables, this meant finding
a function which converts a (set of) string(s) into an index.
.IP 2)
Only completely specified items can be searched for.
That is, one may
not ask of a hash table "Find the closest one to X".
.LP
Unfortunately, since the knowledge structures used in AI are
much more complex than simple strings, finding a good hash
function is very difficult.
Also, in AI programming, normal hashing would only handle fetching
a particular fact from the data base, which would make the fetching
mean "Is this (completely specified) fact true?"
But it is much more likely that what is wanted is the (set of) thing(s)
which match a much more general pattern.
.sp 3
.PP
For these reasons, hashing in the normal sense is
inappropriate for AI data bases.
As a result, the traditional solution to the need for efficient
indexing into an AI data base is the discrimination net.
Or, in some cases, the data base is reduced to a linear list with
its inefficiency ignored (or tolerated).
With a discrimination net, the user often must carefully determine
the structure of the net and the nature of the tests to be made at
each level.
This is necessary to reduce the breadth of the net at each level,
since a discrimination net usually implies a linear search through
the possible values at each branch point.
As the knowledge changes, the representation hierarchy must change
to avoid this breadth problem, drawing the programmer away from the
problem at hand into worrying about indexing every step of the way
and forcing the representation into unnatural distinctions.
Generalized pattern matching is also difficult, making questions
like "What in the data base is close to X?" hard to ask.
.sp 3
.PP
Thus, a common problem with most AI data base implementations
is the system's lack of knowledge about how best to automatically
organize information for efficient and flexible retrieval.
The user usually has such knowledge, but needs to be able to provide
it in an easy way.
Moreover, if possible, this knowledge should be used to build a
hash table with its attendant speed, rather than a discrimination net.
The system must then provide a hash function which is
flexible enough to handle a large range of objects.
Such a hash table must also be organized in such a way that items may
be found which match a general pattern.
.sp 3
.PP
PEARL provides such a hash table and hash function, designed in such a
way that the user gets a significant speed up with only the effort
required to define objects as already been described above.
In addition, PEARL encourages the user to provide as much extra
knowledge as possible when a structure type is defined.
The choice of a particular structure hierarchy does not affect the
efficiency of the hashing so the representations are not twisted
to achieve efficiency.
Since the purpose of a hash function is to scatter
similar items, the required information consists of
indicating those slots whose values are most likely
to distinguish two similar structures.
.sp 3
.PP
This information is provided in the form of labels on
these slots in the definition of the structure.
Since only symbols and structures are assigned a unique integer at
definition time, slots of type \fIsymbol\fR, \fIstructure\fR
and \fIinteger\fR may contain such hashing information but slots
of type \fIlisp\fR may not.
These labels specify ways in which the unique number of the item being
hashed may be combined with the unique numbers associated with the
values of the labelled slots to provide a set of one, two, or three 
numbers to be combined into an index into the hash table.
The particular ways of specifying these slots and the
ways of grouping them is described below,
but first we describe the form of a single data base and
the organization of a forest of data bases.
.sp 3
.PP
Each data base is implemented as a pair of hash tables in which
each bucket is a list of the objects hashing to that spot.
The possible sizes of the data bases are chosen from the set of primes
which are just barely smaller than the powers of two,
(that is, 1, 3, 7, 13, 29, 61, 127, ...).
The two hash tables are chosen to be off by a factor of four,
(that is, 1+7, 3+13, ... 29+127, ...).
The two data bases are chosen to be of different sizes because 
it was hard to find a hash function to provide a good spread
in a large table for single small integers like the unique numbers
associated with structures.
The currently-used hash functions can be described as follows:
.DS
Let Size1 and Size2 be the sizes of the two hash tables.
Then the hash functions are:

    For indexes based on one number X:
	X mod Size1
    For indexes based on two numbers X and Y:
	(4096 * Y + X ) mod Size2
    For indexes based on three numbers X, Y and Z:
	( (4096 * 4096 * Z) + (4096 * Y) + X ) mod Size2
.DE
.LP
Thus the smaller of the two hash tables is used to enter
items indexed under only one unique number.
The larger is used for items indexed under combinations of
two or three numbers.
The sizes for hash tables can be chosen by the user to match the
number and variety of objects, the number of data bases being used
and the size of their machine's memory.
.sp 3
.PP
In order to allow flexible fetching using a pattern which is only
partly specified, and since the place we look must be determined based
upon the information that \fIis\fR provided in the pattern,
an item must be placed everywhere we are likely to be able to
look for it.
Thus, PEARL will index all individual instances of a structure type
which are inserted into the data base
under as many different hashing strategies as it can,
using the information provided by the user in the
definition of that type of structure.
Then to fetch with a particular pattern, PEARL need only use one of
the hashing strategies which uses slots from the pattern whose
values are considered hashable.
.sp 3
.PP
Whether there is hashing information or not, all individuals are
indexed in the smaller data base under (the unique integer
assigned to) their structure type.
Thus, with no effort, the user automatically gets one level
of distinction which provides a significant improvement
in efficiency over the often-used linked list.
This minimal use of hashing in PEARL is also an
improvement over discrimination nets since nets usually
imply a linear search through the possible values at each
branch point of the net instead of random access.
Of course, if the number of types of structures is
larger than the size of the data base, then after this random access,
there is still potentially a list of items to be searched linearly.
.sp 3
.PP
At this point, the speed with which the matching process
eliminates structures of the wrong type becomes important.
But the easily available unique number in each item provides a quick
test to eliminate items of the wrong type.
(For a complete description of the matching process, see the section on
predicates and matching.)
.sp 3
.PP
However, no amount of speed-up of the matching process can help as
much as a greater degree of discrimination by the hash function.
So to improve upon this automatic type of hashing, PEARL
needs to know which slots or collections of slots of a structure
are likely to help split up objects of the same type.
We will now describe each of the available hashing methods and the
circumstances in which you would want to use them.
.sp 3
.PP
The simplest case of adding hashing information is to label slots
whose values, in combination with the type of structure, would provide
a good distinction.
To indicate that a particular slot is useful in this way,
the user puts an asterisk (*) in that slot in the declaration.
Thus
.DS
\fIpearl>\fB(create base  PlanFor
                    (* Goal  struct)
                    (   Plan  struct))
\fI(PlanFor  (Goal  (nilstruct))
	     (Plan  (nilstruct)))\fR
.DE
.LP
defines a type PlanFor with slots for a goal and a plan, and indicates that
PlanFors should be indexed to be retrieved by the content of
their Goal slot plus the fact that they are PlanFors.
PEARL then uses the unique integers associated with the PlanFor
type and with whatever type of value is in the Goal slot.
.sp 3
.PP
Since the object filling the Goal slot of a PlanFor will always be
a structure of type Goal, using an asterisk in the Goal slot will not
actually distinguish PlanFors from one another.
In this case, we may
also wish to specify that the value that fills the Goal slot is to be
used to in a slightly different way to create the index.
For example, if the Objective of the Goal
is deemed more significant for such purposes than the fact that it
is a Goal, we can indicate this as follows:
.DS
\fIpearl>\fB(create  base  Goal
                    (   Planner  symbol)
                    (& Objective  struct))
\fI(Goal  (Planner  nilsym)
	  (Objective  (nilstruct)))\fR
.DE
.LP
This will inform PEARL that structures that indexing on slots
in other structures which are filled with Goal-type structures
should instead use the Objective slot for further discriminations.
Thus, Goals change the way in which other structures use them to
index but the way in which Goals themselves are indexed
will not be affected.
This hash labelling of Goal is called \fBhash aliasing\fR and
will cause all PlanFors to be indexed
under the number for the PlanFor type plus the number for the type of value in
the Objective slot of the Goal, and thus all PlanFor's for Goals for a
particular type of Objective will be indexed in the same bucket.
As a short hand, the phrase "indexed under the number for the PlanFor
type plus the number for the type of value in the Objective slot of
Goal" is abbreviated as "PlanFor + Objective(Goal)"
.sp 3
.PP
It might be the case that PlanFor was the only structure
indexed based on Goals which would benefit from this and that
some structures would actually be hurt by this because they
expected Goals to be only one of many types of values.
In this case, putting the control of how Goals get used by
other structures into the definition of Goal is a bad idea.
Instead, the control can be moved up into only the
problematic structures.
These structures can simply add the ">" hash label to
a starred slot, causing PEARL to use the first starred slot of
the slot-filling structure instead of its type.
.DS
\fIpearl>\fB(create base  Goal
                    (Planner  symbol)
                    (* Objective  struct))
\fI(Goal  (Planner  nilsym)
	  (Objective  (nilstruct)))\fR
.DE
.DS
\fIpearl>\fB(create base  PlanFor
                    (* > Goal  struct)
                    (Plan  struct))
\fI(PlanFor  (Goal  (nilstruct))
	     (Plan  (nilstruct)))\fR
.DE
.LP
If the user wanted to also star the Planner slot of Goal,
but wanted the Objective slot to be used in cases where the
containing structure had a ">",
then the use of an "^" on the Objective slot will allow that:
.DS
\fIpearl>\fB(create  base  Goal
                     (*    Planner  symbol)
                     (* ^ Objective  struct))
\fI(Goal  (Planner  nilsym)
	  (Objective  (nilstruct)))\fR
.DE
.LP
thus allowing Goals inserted directly into the data base to be
indexed by the combinations (Goal + Planner(Goal)) and
(Goal + Objective(Goal)) while objects containing Goals would
use the Objective slot rather than Goal (Object + Objective(Goal)).
If most structures containing Goals would benefit from the use of
the hash aliasing label & in Goal, but only one or two are hurt by it,
the use of "&" in Goal can be overridden by the structures
which will contain Goals by adding the "<" hash label to the starred
slot, thus giving the controlling structure the last word over how
it is hashed.
.DS
\fIpearl>\fB(create base  Goal
                    (   Planner  symbol)
                    (& Objective  struct))
\fI(Goal  (Planner  nilsym)
	  (Objective  (nilstruct)))\fR
.DE
.DS
\fIpearl>\fB(create base  OffendedStructure
      		    (* < Slot  struct))
\fI(OffendedStructure  (Slot  nilstruct)))\fR
.DE
.sp 3
.PP
The above methods are all designed to allow the indexing of a
structure to be based upon the type of structure and the type of the
value of one slot.
There are sometimes cases where one slot is not
enough to distinguish items sufficiently but two slots would do a much
better job.
For example, a program which dealt with a large number of
Goals of several planners might want to be able to ask whether a
particular planner had a particular objective.
Putting an asterisk in each of the slots of Goal would allow
hashing by one or the other, but it would be even faster to use the
fact it was a Goal, plus the values of both the Planner and Objective
slots.
Labelling this pair of slots with "**" causes their values
plus the structure type to be combined into an index.
.DS
\fIpearl>\fB(create base  Goal
      		    (* ** Planner  symbol)
      		    (* ** Objective struct) )
\fI(Goal  (Planner  nilsym)
	  (Objective  (nilstruct) ) )\fR
.DE
.LP
This is also useful whenever the range of types of values in
each slot is limited but the combinations of the two
have a wider range.
.sp 3
.PP
On the other hand, it may sometimes be useful to know all
structures containing a particular type of value in any prominent
slots.
Thus for example, if a program has many kinds of structures all
containing references to individual planners, it might be useful
to be able to efficiently ask the question "What do I know about
John?".
In this case, the use of a ":" hash label on those slots of relevant
structures which contain Planners causes all those
structure to be indexed by that slot's value only, without
regard to the structure type.
This would result in some bucket in the smaller data base to contain
all structures which refer to John in such a labelled slot,
because they would all be indexed under that single value.
Note that this is similar to the "&" type of hashing,
but affects the structure itself instead of containing structures.
.sp 3
.PP
Finally, there is a hash labelling which is the combination
of these last two ideas.
It may sometimes be useful to know all structures containing a two
particular types of values in prominent slots.
Thus for example, if a program has many kinds of acts and states
all containing references to individual person/object and the time
of occurrence, it might be useful to be able to efficiently ask
the question "What did John do at 8 o'clock?".
Thus, the use of a single pair of slots (in each structure) labelled
with "::" causes the value of those two slots to be combined
into an index.
.DS
\fIpearl>\fB(create base  Act
      		    (:: Actor  struct)
      		    (:: Time  int) )
\fI(Act  (Actor  (nilstruct))
	 (Time  0) )\fR
\fIpearl>\fB(create base  State
      		    (:: Object  struct)
      		    (:: Time  int) )
\fI(State  (Object  (nilstruct))
	   (Time  0) )\fR
.DE
In this case, all states of John or acts by John would be indexed
under John plus the time, thus ending up in the same hash bucket.
.sp 3
.PP
The hashing mechanism was designed to give the user benefit in
proportion to the effort expended in determining hash labels.
With no effort, the structure type provides some help.
With the addition of each label or pair of labels,
an item to be inserted into the data base is indexed into
another location in the hash table.
Thus the cost of extra labels is simply the time to find
another hash bucket (a few adds and multiplies), and add
the item to the front of the list implying the time and
space incurred by one cons-cell.
The benefit at fetching time is the ability to use this
extra information to narrow in on a small subset of
the items in the data base which are most likely to
be what is desired.
.sp 3
.PP
It is often the case that a program needs to build several
data bases where one or more are extensions of another.
For example, consider a planner which is trying to choose
between two alternative plans.
One way to do this is to simulate carrying each one out to
determine its likely effects (good or bad) to help in the
decision.
Thus the program might want to build a data base for each
into which it could assert the various facts determined by
the simulation.
Both of these new data bases would be considered extensions of the
usual data base with the added feature that anything stored in
them was simply expected to be true in the future.
Thus, after the simulation, it might be desireable to delete the
data base of the plan not chosen and the program would certainly
not want to assert the effects of the simulation into its regular
data base since they are not in fact true.
.PP
PEARL provides both these abilities by providing facilities for
building a forest of data bases.
The regular data base which is built automatically is called
\fI*maindb*\fR.
To build two extensions from this, one uses the function
\fIbuilddb\fR: to build a tree of data bases:
.DS
\fIpearl>\fB(builddb Test1 *maindb*)
\fI(database: Test1)\fR
\fIpearl>\fB(builddb Test2 *maindb*)
\fI(database: Test2)\fR
.DE
.LP
We can then assert various facts from the simulation into each of
these new data bases.
If we subsequently fetch from Test1, we will get back all facts
which were asserted into either \fITest1 \fBor \fI*maindb*\fR.
When we have decided which to use, we can then free up the one
that is no longer needed.
.NH
Fetching
.sp 3
.PP
To fetch an object from a data base, the user invokes the
fetcher with a structure to be used as a pattern.
For efficiency,
PEARL tries to narrow down the possible choices without
actually matching this pattern against any knowledge in the 
data base.
Thus, narrowing down the possibilities and avoiding
matching as long has possible are the two driving goals of the
fetching algorithm.
In order to narrow down the choices,
information in the pattern is examined to determine
which of the hashing indices is most likely to narrow
down the choices.
This determination is made based on the ways in which PEARL has been
instructed to hash structures of the same type as the pattern and also
based on which slots of the pattern actually have a useful value for
hashing.
\fINilsym\fR, \fInilstruct\fR, \fInil\fR and \fIunbound\fR values
are not considered useful.
Given the values which are considered useful and the hashing
information for the type of structure, the hierarchy of buckets to be
chosen is as follows:
.DS
** hashing
:: hashing
*  hashing
:  hashing
.DE
.LP
All the other hashing labels are modifiers on these four
methods and affect what values are used to compute the index.
.sp 3
.PP
The resulting hash index is used to choose a bucket from the hash
table which is returned to the user as a result stream.
No matching between the pattern and objects
in the data base occurs at this point and the
stream simply contains pointers to all data base items
in the same hash bucket, regardless of whether they actually 
match the pattern.
PEARL appends the pattern to the front of this
stream for subsequent use.
For example, to fetch all PlanFors involving Goals whose Objective
is a PTrans, we create a pattern for this type of object:
.DS
\fIpearl>\fB(setq  PTransGoals  (create  pattern  PlanFor
                                         (Goal  (Goal  (Objective  (PTrans))))
                                         (Plan  ?Plan)))
\fI(PlanFor (Goal (Goal (Planner ?*any*)
			(Objective (PTrans (Actor ?*any*)
					   (Object ?*any*)
					   (From ?*any*)
					   (To ?*any*)))))
	    (Plan ?Plan))\fR
.DE
.LP
and then call the function \fBfetch\fR with this pattern as an
argument:
.DS
(setq  PTransGoalStream  (fetch  PTransGoals))
.DE
.sp 3
.PP
The user may then extract items from
the stream one at a time by successive requests to \fBnextitem\fR:
.DS
(setq  Result  (nextitem  PTransGoalStream))
.DE
.LP
At each request, the pattern is matched against successive
items from the hash bucket until one matches,
in which case it is returned,
or until the potential items run out,
in which case \fInil\fR is returned.
.NH
Predicates and Matching
.sp 3
.PP
Predicates may also be attached to a slot specifying constraints on
the values of pattern-matching variables.
Each time a match is made between the slots of two structures
(described in detail below), the predicates of each slot are run to
determine whether the match should succeed or fail.
Two types of predicates are provided by PEARL.
The first type are Lisp functions or expressions to be evaluated.
If a predicate is simply the name of a function, that function is
applied to the slot value from the opposing structure.
If it is an S-expression, it is processed for special forms
which indicate where to get the arguments and then evaluated.
For example, the following pattern will require that the variable in
its first slot be bound to a positive integer value with the predicate
\fIplusp\fR.
It also requires that the variable in its third slot be bound
to a value which is a member of its second slot (\fB"*"\fR refers
to the value in the current slot of the opposing structure and
\fI"=Two"\fR refers to the value in the slot named Two of the
opposing structure):
.DS
\fIpearl>\fB(create individual  Example
		    (One  ?One  plusp)
		    (Two  ?*any*)
		    (Three  ?Three  (member  *  =Two) ) )
\fI(Example (One  ?One)
	    (Two  ?*any*)
	    (Three  ?Three) )\fR
.DE
.sp 3
.PP
The second type of predicate is called a \fBstructure predicate\fR and
consists of the name of a structure type.
Its effect is to restrict the value in a structure slot to being a
structure of the specified type.
Thus another way to restrict the value of the Objective of the Goal in
the Goal slot of the PlanFor which was fetched above, is to put a variable
in the slot and add a PTrans predicate:
.DS
\fIpearl>\fB(setq PTransGoals (create pattern PlanFor
                                      (Goal (Goal (Objective ?O PTrans)))
                                      (Plan ?Plan)))
\fI(PlanFor (Goal (Goal (Planner ?*any*)
			(Objective ?O)))
	    (Plan ?Plan))\fR
.DE
.LP
The effect is the same but testing the type of the value is much more
efficient than doing the matching process on the two PTranses slot by
slot.
.sp 3
.PP
For efficiency, the semantics of the matching have been
constrained to avoid the usual variable naming problems.
Two structures match if they can be unified.
However, no attempt is made to detect circularities,
nor are variables ever bound to other variables.
Circularities have never actually occurred in our experience and
most variables are local to the pattern they appear in,
so naming conflicts do not arise.
Of course it would be straightforward to add checks for
these problems if one was willing to incur the expense.
.sp 3
.PP
The variables in a structure are implemented as an assoc-list attached
to the structure so that a list of the variables of a structure can be
located quickly.
However, \fIassoc\fR is only used for external lookup of a variable.
Once the structure has been created, each slot containing a variable
has a pointer to the special cons-cell associated with it in the
assoc-list so that it has immediate access to its value.
In particular, the name of the variable is not even accessed during
the matching process, since its value is all that is needed.
.sp 3
.PP
In general, the matching procedure takes two structures
which each may contain variables.
If the structures are not definitionally the same type
then the match fails automatically.
This quickly eliminates items which happen to hash to the same slot.
Otherwise, each structure is viewed as a sequence of slots
which are successively matched between the two structures.
Two structures of the same type match if and only if each of their
slots matches the corresponding slot of the other structure.
Each slot is filled in one of three ways:
.IP 1)
The slot may contain an actual value of its type (for example,
a slot of type \fIstructure\fR may contain a PTrans).
.IP 2)
The slot may contain a user-defined variable.
.IP 3)
The slot may contain the special match-anything variable \fI?*any*\fR.
.LP
If the slot contains a variable (other than \fI?*any*\fR) which has not
been bound then it may become bound as a side effect of the
matching process.
Once a variable is bound to a real value during the
matching process, for the purposes of matching, it will
be treated as if the slot were filled with that value.
.sp 3
.PP
We now examine each of the pairings of slot values which may
occur and how they are matched.
If either of the two slots being matched contains the special
variable \fI?*any*\fR, then the slots match by definition,
regardless of the contents of the other slot.
If both slots contain variables that are unbound, the slots do not
match.
(This is true even if the two variables are textually
the same name, since they are each considered local to their
particular structures.)
If one slot contains an unbound variable (and the other
a bound variable or a value), then any predicates on the
slot with the unbound variable are tested to see if the
unbound variable should be bound to the bound value.
If so, then the unbound variable is bound to the value
of the other slot, and the two slots match.
If any of the predicates return \fInil\fR, the two slots do not
match, the variable is not bound, and the entire match fails.
.sp 3
.PP
If both slots contain either bound variables or values,
then the values of the two slots are compared.
If the slot is of type \fIstructure\fR, then the entire matching
algorithm is recursively applied.
If the slot is of types \fIinteger\fR or \fIlisp\fR, then \fIequal\fR is used.
If the type is \fIsymbol\fR, than the two values must be the same symbol.
Regardless of the type, any predicates associated with the
slot are run and all must succeed.
.sp 3
.PP
For example, if we create two structures, one representing Sam
and one with a variable in the \fIName\fR slot:
.DS
\fIpearl>\fB(create individual  Person Sam
		    (Name  Samuel))
\fI(Person (Name Samuel))\fR
\fIpearl>\fB(create individual  Person PersonPattern
		    (Name  ?FirstName))
\fI(Person (Name ?FirstName))\fR
.DE
.LP
then match them and look at the result in \fIPersonPattern\fR:
.DS
\fIpearl>\fB(match Sam PersonPattern)
\fIt\fR
\fIpearl>\fBPersonPattern
\fI(Person (Name ?FirstName = Samuel))\fR
.DE
.LP
we find that they do match and the variable \fI?FirstName\fR in
\fIPersonPattern\fR has been bound to the symbol \fISamuel\fR.
.PP
We now take a slightly more complicated example.
In PEARL's matching algorithm there is no sense that one of its
arguments is the pattern and one the thing to be matched to, so
both may have variables.
As long as the variables are in different slots so that \fImatch\fR
will never try to match two unbound variables to each other, the
matching will work fine.
Thus, if we want our backward inference mechanism from the extended
example in section 2 to not only tell us \fIthat\fR Sam has a low
salary but in fact \fIwhat level\fR of salary he had, we could
fetch the following structure:
.DS
.Ls
(create \kBindividual Salary SamsSalary
        \h'|\nBu'\kA(Employee Sam)
        \h'|\nAu'(Level ?Level))
.Le
.DE
.LP
This would result in the backward inference demon using the
following pattern to fetch rules that might tell it about
finding a person's salary:
.DS
\fIpearl> \fB(create pattern BackwardRule Wanted
		     (Need (Salary (Employee Sam)
				   (Level ?Level))))
\fI(BackwardRule (Need (Salary (Employee (Person (Name Sam)))
			       (Level ?Level)))
		 (LookFor ?*any*))\fR
.DE
.LP
In processing the resulting stream, the matcher would be called
upon to match the above pattern \fIWanted\fR to the following
rule (which is in the data base but which we recreate for
this example):
.DS
\fIpearl> \fB(create individual BackwardRule Known
		     (Need  (Salary  (Employee  ?Person)
				     (Level  Low)))
		     (LookFor  (Professor  (Person  ?Person))))
\fI(BackwardRule (Need (Salary (Employee ?Person)
			       (Level Low)))
		 (LookFor (Professor (Person ?Person))))\fR
.DE
Matching these will succeed and in the process the variables 
\fI?Level\fR in \fIWanted\fR and \fI?Person\fR in \fIKnown\fR
will be bound:
.DS
\fIpearl> \fB(match Wanted Known)
   \fIt\fR
\fIpearl> \fBWanted
\fI(BackwardRule (Need (Salary (Employee (Person (Name Sam)))
			       (Level ?Level = Low)))
		 (LookFor ?*any*))\fR
\fIpearl> \fBKnown
\fI(BackwardRule (Need (Salary (Employee ?Person = (Person (Name Sam)))
			       (Level Low)))
		 (LookFor (Professor (Person ?Person
					     = (Person (Name Sam))))))\fR
.DE
.NH
Variables
.sp 3
.PP
There are three types of pattern matching variables in PEARL.
Global variables (which are just Lisp variables) must be declared
and are never unbound by PEARL.
All undeclared variables are local to the individual structure in
which they are mentioned.
Local variables are dummy variables, local to a particular
structure and any of its components which were created
in the same instant.
They are all unbound by PEARL before every match on that structure.
The examples given of variables in the previous section were of local
variables which require no declaration.
The third, intermediate, type of variable provides lexical
scoping within groups of structures.
Lexically scoped variables are like local variables in that they
are unbound by PEARL before a match is made, but have their
scope extended across several structures as indicated by the user.
.sp 3
.PP
Consider the following examples of the three types of variables.
For our first example, suppose that in a data base representing the
planning knowledge of a particular person is an Ego structure which
records the identity of that person.
The program wishes to determine this and to remember it in a variable
called Planner.
Planner is declared to be global and then used to fetch the
appropriate knowledge structure from the data base:
.DS
.Ls
(global  Planner)
(nextitem  (fetch  (create \kAindividual  Ego
                           \h'|\nAu'(Identity ?Planner))))
.Le
.DE
.LP
At this point, the Lisp atom Planner is bound to the
identity of the planner.
We can now ask for all PTranses in the data base involving the planner
as the Actor and Object:
.DS
.Ls
(setq  Pat  (create \kBindividual  Ptrans
                    \h'|\nBu'\kA(Actor  ?Planner)
                    \h'|\nAu'\kB(Object  ?Planner)
                    \h'|\nBu'\kA(From  ?Start)
                    \h'|\nAu'(To  ?Dest)))
(setq  Stream  (fetch  Pat))
.Le
.DE
.LP
At this point the pattern in Pat has two local variables,
\fI?Start\fR and \fI?Dest\fR which will be unbound before each match and
may be bound to a new value during each match.
\fI?Planner\fR on the other hand is global and will continue to have the
value it received during the original fetch it was used in.
.sp 3
.PP
With a global variable, a group of structures are allowed to share a
variable whose value is constant once it is set the first time.
Furthermore, all structures are thereafter required to share this same
variable and are precluded from having their own variable with the
same name.
However, it is sometimes useful to group a set of structures together
via a set of variables which we wish to behave like local variables in
every other way.
Furthermore we might wish to have several such groups which can each
have a variable with this same name.
For example, a body of PEARL structures conceptually composing a
single frame should be made to share the same variables but it should
be possible to have several instances of such a frame with the same
variable names tying each group together without interfering with the
others.
Each instance of this group of variables is then local to that frame.
However, the results of matching any particular component
of the frame will be detectable in the variables associated
with the other components.
This is done in PEARL by dynamically declaring a scope with local
variables which are imposed upon all structures created until that
scope is closed.
For example, consider the following sequence:
.DS
.Ls
(block  Plan1  (Planner  Goal))
(create \kBindividual  PlanFor
        \h'|\nBu'\kA(Goal  ?Goal)
        \h'|\nAu'(Plan  ?Plan))
(create \kBindividual  Goal
        \h'|\nBu'\kA(Planner  ?Planner)
        \h'|\nAu'(Objective  ?Objective))
(create \kAindividual  Plan
        \h'|\nAu'\kB(Planner  ?Planner)
        \h'|\nBu'\kA(Goal  ?Goal)
        \h'|\nAu'(Steps  ?Steps))
(endblock  Plan1)
.Le
.DE
.LP
This sequence creates three structures which are intimately tied
together via the variables \fI?Planner\fR and \fI?Goal\fR which
are declared in the enclosing block.
After this code executes, if any of the structures is fetched from
the data base, any binding of these two variables would have an
immediate effect in all of them.
In addition, the values of these variables are available simply by
knowing the name of the block, so that one can ask for the value of
the Planner variable in Plan1 directly.
However, now that the block has been closed, other structures are
free to have variables with the same names.
.NH
Demons
.sp 3
.PP
A common AI mechanism provided by AI languages is one of
"if-added" functions or demons.
PEARL has a general ability to attach functions called \fIhooks\fR
to base structures (\fIbase hooks\fR) or to slots of individual
structures (\fIslot hooks\fR).
Base hooks are run whenever the particular PEARL function that the
hook is labelled with accesses an individual of that type.
Slot hooks are put into individual and are run whenever the particular
PEARL function that the hook is labelled with accesses that slot
of the individual.
In order to allow these hooks to tailor the operation of the
various PEARL functions on particular structures or types of
structures, these demons may be invoked either before or after
the PEARL function they are labelled with does its work.
If they run before, they are allowed to short-circuit the function's
action or perform it themselves and specify a value to return.
If they run after, they may also modify the value to be returned.
.sp 3
.PP
For example, in the extended example at the beginning of this
paper, we presented a simple inference package which would run
automatically whenever an object was fetched or inserted.
To implement this, we wrote two functions MakeForwardInference
and MakeBackwardInference.
MakeForwardInference was designed to use rules which said if
you learn X then infer Y.
MakeBackwardInference was designed to use rules which said if
you want to know X then check to see if you know Y.
Learning something while using PEARL usually means inserting
something into the data base, so we wish to have
MakeForwardInference run whenever we insert some concept
into the data base, after the insertion.
Wanting to know something while using PEARL means fetching
it from the data base, so we wish to have MakeBackwardInference
run whenever we fetch some concept from the data base, before the
actual fetch takes place.
This was accomplished by attaching these two functions as demons
to the base structure Concept as follows:
.DS
.Ls
(create \kBbase  Concept
        \h'|\nBu'(if  \kA<insertdb  MakeForwardInference
             \h'|\nAu'>fetch  MakeBackwardInference))
.Le
.DE
.LP
A similar mechanism is available for attaching demons to individual
slots of structures.
Other than through matching, the principle way that slots of
already created structures get changed is through the PEARL
function \fIputpath\fR.
For example, if Sam got a raise, making his salary level
\fIMedium\fR, we might want to change the \fILevel\fR slot of
his Salary structure:
.DS
(putpath SamsSalary 'Level (getsymbol 'Medium))
.DE
If there were facts in the data base (like the fact that Sam is
poor) which depended on this fact, we would be interested in
monitoring Sam's salary level so that we could fix this up.
Of course, a general data dependency mechanism would be much
better but if you did not have one, one possible way of
accompishing this would be to attach a demon to the Level slot of
\fISamsSalary\fR at the time of creation:
.DS
.Ls
(create \kBindividual Salary SamsSalary
        \h'|\nBu'\kA(Employee Sam)
        \h'|\nAu'(Level  ^  if  >putpath  (AdjustPoorness  =Employee  *)))
.Le
.DE
This assumes that \fIAdjustPoorness\fR is a function expecting the
name of the person and the new level.
.PP
Like predicates, a PEARL demon may be either the name of a function
to be run with the structure or slot as its argument
or it may be a general S-expression which contains any of the
special forms which refer to the current structure or slot.
Besides the built-in PEARL functions which automatically check for
demons with their names on them attached to slots that they touch,
there is a facility for user-defined functions to explicitly
request that demons on structures or slots that they touch be run.
However, this action is not automatic;
the involved functions must explicitly run the demons.
.NH
Implementations
.sp 3
.PP
The main emphasis of efficiency considerations within PEARL was
to allow the user to avoid inefficient algorithms.
We also tried to make the code itself as efficient as possible.
To make the user interface as friendly as possible,
error checking is done whenever it can be done efficiently.
As a result of these two principles, PEARL is fast and
friendly enough for use as a serious programming language.
.sp 3
.PP
PEARL was also intended to be portable.
It was originally developed on a DEC 20 and moved with no
modification to a DEC PDP-10 under UCI Lisp.
It was then moved to a VAX-11/780 under Franz Lisp [3] [4]
which at that time did not provide a facility for allocating
hunks of memory and thus required the lowest level of the
implementation to be rewritten using arrays.
Since the lowest level of the UCI Lisp version was written in
Lisp assembler (LAP) operating on blocks of memory, this new
Franz Lisp version was somewhat less efficient.
When "hunks" were added to Franz Lisp, we attempted to modify
the VAX version to use them.
However, since Franz Lisp hunks behave significantly differently
in several ways from blocks of memory in UCI Lisp, this was
abandoned temporarily.
Instead, we used what we learned to redesign the lowest level of
the UCI Lisp version of PEARL so that it could be easily moved
between UCI Lisp and Franz Lisp and then moved it back to the VAX.
.PP
We now believe that PEARL could be moved to another Lisp by
rewriting about a dozen functions and adding the macros
needed to convert from UCI Lisp to the target Lisp.
(Only one of these is now machine coded on the PDP-10,
a routine for doing address arithmetic.
The Franz Lisp version is completely in Lisp.)
The primary functions which must be rewritten pertain to creating
and accessing hunks of memory and modifying the top level
read-eval-print loop.
We are currently verifying PEARL's portability by moving it to
both MACLisp and Lisp Machine Lisp.
.NH
Performance
.sp 3
.PP
As mentioned, PEARL gains much of its speed during fetches from the
data base by using a user-assisted hashing mechanism.
Here we present some evidence that this mechanism does in
fact speed up access to the data base.
To test this, we timed the running of a recent version of PAM,
a story understanding program [12], which was written using PEARL.
For these timings, we used the Franz Lisp version of PEARL.
Since the size of PEARL data bases is user-settable, we compared
two runs of PAM on a large (23 sentence) story, one using the
largest available hash table (see below for details of sizes)
and one using the smallest available hash table which is logically
equivalent to a linear list.
.sp 3
.PP
For each run we read in the initial knowledge and program
once and then processed the story three times to test the effects
of the data base getting fuller.
The results are as follows:
.DS
\h'|\nau'
		\kaSmall Table		\kbLarge Table

Load		\h'|\nau'68 + 13	\h'|\nbu'30 + 5

Run 1		\h'|\nau'96 + 10	\h'|\nbu'65 + 10

Run 2		\h'|\nau'113 + 11	\h'|\nbu'66 + 9

Run 3		\h'|\nau'129 + 9	\h'|\nbu'65 + 10
.DE
.LP
Note that while the large hash table was quite stable as the
amount of information in it approximately tripled, the small
hash table causes the execution times to increase substantially 
as the data base fills up.
.sp 3
.PP
In similar comparisons with UCI Lisp on the PDP 10, the results
were even more dramatic.
Times for the large data base were flat but using a small data base,
each run's time was bigger than the previous run by 50% of the first
run's time and each run's garbage collection time was bigger
than the previous by 100% of the first run's garbage collection time.
.DS
		\kaSmall Table		\kbLarge Table

Load		\h'|\nau'17 + 2		\h'|\nbu'16 + 2

Run 1		\h'|\nau'64 + 13	\h'|\nbu'24 + 2

Run 2		\h'|\nau'92 + 22	\h'|\nbu'24 + 1

Run 3		\h'|\nau'125 + 33	\h'|\nbu'26 + 2
.DE
.LP
This indicates that PEARL could make large programs running on
the PDP10 must faster.
It also indicates that although the VAX is a slower machine, 
with its virtual memory it behaves quite well under what a load
that taxes the PDP 10.
.sp 3
.PP
Another piece of timing we performed is also interesting to those
considering moving to VAXes from PDP 10s.
All of the above timings were of compiled versions of PEARL on
both machines.
(The PAM code was not compiled.)
Thus, Franz Lisp on the VAX seems to run the same program
with 2-2.5 times the CPU time of UCI Lisp on the PDP 10.
Since the ratio between the speeds of the processors is estimated
at 2.5, compiled Franz Lisp code competes favorably (modulo the
processor speed) with compiled UCI Lisp code.  
However, we also tried running PAM with uncompiled versions
of PEARL on both machines.
In this case, we found that the Franz Lisp version ran 10 times
slower, while the UCI Lisp version ran only 3 times slower.
This would seem to imply that either the Franz Lisp interpreter
is abnormally slow or that the UCI Lisp interpreter is
unusually fast.
When the MAC Lisp and Lisp Machine Lisp versions are running, we
will explore this further.
.sp 3
.PP
Although we have not done any extensive profiling of PAM to
determine where all the time is spent, we have tried disabling the
printing functions while running PAM.
Doing this, we discovered that PAM spends about 55% of its time
doing input and output.
This breaks down to 5% for input, 10% for conversion to list
structure from internal PEARL structures and 40% for actual
(pretty-)printing by Lisp.
.NH
Comparison to FRL
.sp 3
.PP
Of the existing AI languages, PEARL has the most in common with FRL.
This is true partly because both languages use several good ideas
which have been around in AI for some time.
It is also partly true because some of PEARL's features were added
in imitation of the example representation language XRL presented
in Charniak[2] (which the authors admit is partly in imitation of
FRL and KRL).
In this section, we discuss some of the ways that PEARL differs
from FRL.
.sp 3
.PP
Like PEARL, FRL is designed for representing slot-filler objects.
However, in FRL these objects are modelled more after frames as
described by Minsky [7] whereas PEARL's structures lean more
toward logical predicates.
In particular, frames become \fIactivated\fR or
\fItriggered\fR by being instantiated and the data base
is simply all the activated frames;
there seems to be no distinction between instantiating a
frame and adding it to the data base.
In contrast to PEARL, frames are not encoded internally but
represented as multiple depth association lists and the FRL
data base is not hash coded.
The FRL manual [10] seems to imply that it is in fact a linked list
subject to a sequential search.
The idea of separating frames into groups like PEARL's multiple
data bases has been recently added as "domains" [6].
.sp 3
.PP
Whereas PEARL requires type information on its slots and uses this
information to advantage, FRL requires no information on the type
or even number of values which will be allowed.
This of course allows the user more flexibility but makes it more
difficult for FRL to deal efficiently with each slot.
.sp 3
.PP
In addition to the slot/filler features, FRL uses 6 primary
representation techniques to improve the flexibility of frames.
These are comments on slots, abstraction through slot inheritance,
inherited default values for slots, constraints on slot values,
indirection through values in other frames and attached procedures.
We look briefly now at each of these.
.IP 1)
Comments in FRL are attached to slots and are generally used to
remember where the value in a slot came from although they could
be used for anything.
This is a useful feature which in PEARL must be
implemented as a separate set of predicates inserted into the data
base or as dynamically-added attached procedures.
We have not added them to PEARL because we are unsure whether such
information should rightly be distinguished from predications
about where other pieces of knowledge came from.
.IP 2)
The notion of inheritance of slots from more abstract objects is
quite similar in FRL and PEARL, since this is one of the features
PEARL inherited through XRL.
The principle difference is that while in PEARL all slots must be
predeclared (because of the internal mode of storage), FRL allows
the addition of slots at a later time.
.IP 3)
The notion of default values was similarly inheritted from FRL by PEARL.
However, in designing PEARL we wished to more clearly separate the
idea of a general piece of knowledge represented by the definition
of a type of structure along with its set of defaults from an instance
of such a structure.
As a result PEARL stores the default values for slots in the special
instance of each type of structure called the \fIdefault instance\fR.
In contrast, FRL does not make this distinction clear and provides
for both a default and a value in a slot of a frame.
Apparently a frame may be both an instance and a generalization
at the same time.
.IP 4)
FRL's notion of constraints is significantly stronger and more
complex than PEARL's.
PEARL provides for predicates on slots but these are only enforced
during matching on slots containing variables.
FRL on the other hand provides three flavors of constraint with
different degrees of restriction.
A \fIrequirement\fR is a strong predicate on a slot which must be
true of the value in that slot.
A \fIpreference\fR is a weaker predicate which may be relaxed.
A weaker special case of a preference is a default which simply
suggests a specific value which can be easily overridden.
.IP 5)
A feature of FRL which goes hand-in-hand with the idea of triggered
frames (and is thus lacking in PEARL) is that of indirection.
This allows a frame to specify constraints on slots of other
frames that are currently active when it is triggered.
Thus indirection provides what might be considered a "horizontal"
version of the vertical notion of default inheritance.
.IP 6)
Demons and attached procedures are old ideas in AI but FRL
introduced a new twist on them which PEARL then took one step
further.
FRL provides for if-added, if-needed, and if-removed procedures which
are attached to slots and rather than being triggered by arbitrary
conditions are instead run only in the case of adding, requesting
or removing the value of a slot.
These attached procedures are enforced by the functions that
perform these types of access, thus providing for idiosyncratic
forms of inheritance or finding a slot value.
In PEARL we extend this idea so that there are a large variety of
access functions which may trigger attached procedures (hooks).
In addition, these procedures are allowed to affect the actions
of the access functions, thus allowing a particular class of
objects to tailor the behavior of most of PEARL's functions.
Similarly, procedures to tailor the performance of printing and
other functions on objects (rather than their slots) are provided
by both FRL (via the SELF slot) and by PEARL (via base hooks)
In addition, a form of detached procedures ("sentinels") have
recently been added to FRL [6] in which the triggering condition
is the activation of a group of frames.
.sp 3
.PP
In contrast to more ambitious knowledge representation languages,
FRL and PEARL are similar in their fairly restricted matching
procedures which are essentially slot-by-slot matches with no
provision for matching to a degree or forcing a match via mapping
as in MERLIN [8].
.sp 3
.PP
Finally, there are two features of hierarchical representations
which FRL provides but which are not yet provided by PEARL.
The principal one is the ability to store multiple views of an object
thus allowing a frame to inherit slots from several other frames.
The second one is the ability to move an object down the hierarchy,
thus providing the dynamic ability to further specify a previously
general frame based on new information.
Both of these are in the works since we have encountered a need for them.
.NH
Comparison to KRL
.sp 3
.PP
.bp
.NH
References
.sp 2
.IP [1]
Bobrow, D. G., and Winograd, T. "An Overview of KRL, a Knowledge
Representation Language."
\fICognitive Science\fR 1:1 (1977).
.IP [2]
Charniak, E., Riesbeck, C. K.,  and McDermott, D. V.
\fIArtificial Intelligence Programming\fR. Hilldale, New Jersey:
Lawrence Erlbaum Associates, 1980.
.IP [3]
Fateman, R., "Views on Transportability of Lisp and Lisp-based Systems",
in \fIProc. of the 1981 ACM Symposium on Symbolic and Algebraic
Computation\fR p 137-141, (ACM order no 505810), 1981.
.IP [4]
Foderaro, J. K., and Sklower, K. L.
\fIThe Franz Lisp Manual\fR in \fIBerkeley UNIX Reference Manual\fR,
Vol. 2c., Computer Systems Research Group, Computer Science Div.
EECS Dept., University of California, September, 1981
.IP [5]
Greiner, R., and Lenat, D. "A Representation Language Language."
In \fIProc. First NCAI\fR. Stanford, CA, August, 1980,
165-169.
.IP [6]
?????, ?. "Extended Features of FRL" ?????, reproduced in forthcoming
edition of [4], 1982.
.IP [7]
Minsky, M. "A Framework for Representing Knowledge" in P. H.
WInston (Ed.) \fIThe Psychology of Computer Vision\fR,
New York: McGraw-Hill, 1975.
.IP [8]
Moore, J., and Newell, A. "How Can MERLIN Understand?" in L. Gregg
(Ed.), \fIKnowledge and Cognition\fR, Lawrence Erlbaum Associates, 1973.
.IP [9]
Roberts, R. B., and Goldstein, I. P.
"NUDGE, A Knowledge-Based Scheduling Program."
In \fIProc. IJCAI-77\fR. Cambridge, MA, August, 1977, 257-263.
.IP [10]
Roberts R. B., and Goldstein, I. P.
\fIThe FRL Manual\fR,  MIT AI Memo, September, 1977, reproduced in
forthcoming edition of [4], 1982.
.IP [11]
Schank, R. \fIConceptual Information Processing\fR. Amsterdam: North Holland,
1975.
.IP [12]
Wilensky, R. "Understanding Goal-Based Stories",
Technical Report 140, Computer Science Department,
Yale University, New Haven, CT, September 1978.
.IP [13]
Wilensky, R.
"Meta-Planning: Representing and Using Knowledge about Planning in Problem
Solving and Natural Language Understanding."
\fICognitive Science\fR 5:3 (1981). 
.rm CF
.bp 0
.sp 14
.B
.LG
.ce
Table Of Contents
.SM
.sp 2
.DS
  1.  Introduction                                                        \ka 1
  2.  An Overview and Sample Application Of PEARL	\h'|\nau' 2
  3.  How Fast Is PEARL?		\h'|\nau' 6
  4.  Objects and Structures		\h'|\nau' 7
  5.  Data Base Facilities		\h'|\nau'11
  6.  Fetching				\h'|\nau'17
  7.  Predicates and Matching		\h'|\nau'18
  8.  Variables				\h'|\nau'21
  9.  Demons				\h'|\nau'23
10.  Implementations			\h'|\nau'24
11.  Performance			\h'|\nau'25
12.  Comparison to FRL			\h'|\nau'26
13.  Comparison to KRL			\h'|\nau'29
14.  References				\h'|\nau'31
.DE
.bp 0
.sp 14
.SH
Acknowledgements
.PP
PEARL was originally a joint project of Joe Faletti and Mike
Deering (now at the Fairchild AI Lab in Palo Alto) aimed at
redesigning, extending and completely rewriting an earlier
package designed and written by Mike.
PEARL owes many ideas and much of its success to Mike who
has been involved in all design decisions.
In particular, the hashing scheme which is responsible for
much of PEARL's efficiency was originally his idea.
.PP
The initial move of PEARL to the VAX from which we learned enough
to make the second one easier was accomplished by Mike Deering
and Doug Lanam (now at the Hewlett Packard AI Lab in Palo Alto).
The move was made significantly easier by Doug's UCI Lisp
compatibility package for Franz Lisp.
.PP
The authors wish to thank Mike and Doug for their contributions.
We also wish to thank the members of the Berkeley AI Research
group (BAIR) who have used PEARL during its development and made
many valuable suggestions based on active experience in its use.
EndOfFile
cat >  pearl/ltags  << 'EndOfFile'
/^\(de /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(df /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(dm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(drm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(dsm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(def/	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(putd /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(setsyntax /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(setq /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(aliasdef /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
EndOfFile
cat >  pearl/manual.ms  << 'EndOfFile'
.ND
.nr LL 75n
.nr LT 80n
.rm CF
.ds LH PEARL Documentation
.rm CH
.ds RH Page %
.po 1.00i
.ls 1
.hy 14
.RP
.TL
.LG
.LG
Using the PEARL AI Package
.sp 1
.SM
\fR(\fIP\fRackage for \fIE\fRfficient \fIA\fRccess to \fIR\fRepresentations in \fIL\fRisp)*
.NL
.FS
* This research was sponsored in part by the Office of Naval Research
under contract N00014-80-C-0732 and the National Science Foundation
under grant MCS79-06543.
.FE
.AU
Michael Deering
Joseph Faletti
Robert Wilensky
.AI
Computer Science Division
Department of EECS
University of California, Berkeley
Berkeley, California 94720
.sp 1
February 1982
.AB
This document is a tutorial and manual for PEARL
(Package for Efficient Access to Representations in Lisp),
an AI language developed with space and time efficiencies in mind.
PEARL provides a set of functions for creating hierarchically-defined
slot-filler representations and for efficiently and flexibly inserting
and fetching them from a forest of associative data bases.
In addition to providing the usual facilities such as demons and matching,
PEARL introduces stronger typing on slots and user-assisted hashing
mechanisms.
.AE
.NH 0
Introduction
.PP
PEARL (Package for Efficient Access to Representations in Lisp) is
a set of functions for creating hierarchically-defined slot-filler
representations and for efficiently and flexibly inserting and fetching
them from a forest of data bases.
Its intended use is in AI programming and it has been used at Berkeley
in the development of several AI programs including PAM [7] and
PANDORA [8].
.PP
PEARL has the expressive power found in other AI knowledge
representation languages, but is extremely time-space efficient.
For example, using a data base of 4000 entries, PEARL takes only
about 4.2 CPU milliseconds for an average unsuccessful query and
7.3 CPU milliseconds of an average successful query on a PDP-10.
.PP
This document describes PEARL's use and is intended for the
beginning user.
(A description of the implementation of PEARL will be available
shortly.)
The best way to approach PEARL is to read this document up through
section 11 and then to take it to a terminal and reread it, typing
in the examples and observing their effects.
.PP
PEARL was implemented by Michael Deering and Joseph Faletti.
It was originally developed on a DEC PDP-10 under UCI Lisp
and was subsequently moved to a DEC VAX 11/780 under Franz Lisp
with help from Douglas Lanam and Margaret Butler.
Both PEARL and its documentation are still
being developed, improved, and debugged.
Any comments or suggestions will be appreciated.
Send them to Joe Faletti via Arpanet or Unix mail
(Kim\fB.\fRFaletti\fB@\fRBerkeley or ucbvax\fB!\fRkim\fB.\fRfaletti).
.bp
.DS
.sp 5
.DE
.NH
Running PEARL
.PP
PEARL is implemented as a set of functions compiled and
loaded into Lisp.
Thus the full power of Lisp is available in addition to the added
power of PEARL.
.PP
Since PEARL runs under two different Lisps on two different machines,
there are a few differences between versions.
Most of these differences are in the method of starting PEARL up
and in the names of external files accessed by PEARL.
The two parts of this section describe how to start up PEARL either
under Franz Lisp or under UCI Lisp.
You need only read the section which is applicable to your Lisp.
.NH 2
Under Franz Lisp
.PP
To access PEARL, simply run the core version of Lisp
containing PEARL. On Berkeley Unix, this is available by typing
the command:
.DS
  %  ~bair/bin/pearl
.DE
or, if ~bair/bin is in your search path, simply:
.DS
  %  pearl
.DE
During the startup process, PEARL will read in two
files, \fB.init.prl\fR and \fB.start.prl\fR, if they exist.
These files are designed for purposes similar to those
of \fI.lisprc\fR.
However, they split these functions into two groups.
In your \fI.init.prl\fR file you should include any
expressions which change the user-settable parameters to PEARL.
(For example, methods for setting the size of data bases,
the print function, and the prompt are described below.)
.PP
When you wish to have other files read in at startup time,
this usually needs to be done after PEARL's parameters are set.
PEARL is set up so that after the reading of \fI.init.prl\fR, it sets
any necessary parameters which you have not set in your .init.prl
and then reads in the file \fI.start.prl\fR if you have one.
This is where any processing which requires the
attention of PEARL (such as the existence of its data bases)
should be placed.
Thus \fI.init.prl\fR is primarily for initializing PEARL
and \fI.start.prl\fR is for starting up your use of PEARL.
\fBNote:\fR unlike most Unix programs which look for startup files
only in your home directory, thereby limitting you to only one
environment for each program, PEARL looks for each file first in
the current directory and if there is none, then it looks in your
home directory.
This allows you to tailor invocations of PEARL to the kind of work
you do in a particular directory.
.bp
.PP
After reading in these two files, PEARL will then place you in a
modified prompt-read-eval-print loop, with a default prompt of "PEARL>  ".
This can be changed by setting the special variable
\fB*pearlprompt*\fR to the desired value.
If you want the standard Lisp prompt "->  " to be used by PEARL,
you must set \fI*pearlprompt*\fR to \fInil\fR in your \fI.init.prl\fR
and PEARL will do the right thing.
.PP
The primary feature of the PEARL prompt-read-eval-print loop is that
it uses a different print function.
The default function is
.DS
(lambda (*printval*)
        (valprint  *printval*  4) )
.DE
but this can be changed to whatever you desire by giving 
a new function definition to \fBpearlprintfn\fR.
The PEARL prompt-read-eval-print loop also contains a number of
features to improve upon the standard Lisp top level.
These include a history mechanism and are described in chapter 25.
.PP
There are quite a few functions from UCI Lisp which have been added
to PEARL to make it easier to move programs to Franz Lisp.
A list of these with brief documentation of differences is
included in an appendix.
.NH 2
Under UCI Lisp
.PP
To access PEARL, simply run the core version of Lisp containing PEARL. 
On the Berkeley KL-10 system, this is available by typing the system call
.DS
RU  PEARL[5500,504,PEARL]
.DE
During the startup process, PEARL will read in two files,
INIT.PRL and START.PRL, if they exist.
The file INIT.PRL is designed for purposes similar to those
of INIT.LSP.
In this file you should include any expressions which
change the user-settable parameters to PEARL.
(For example, methods for setting the size of data bases,
the print function, and the prompt are described below.)
If you wish to use the REALLOC function to
enlarge your memory space, this call should be the
last call in your INIT.PRL file.
.PP
When you wish to have other files read in at startup
time, this usually needs to be done after the REALLOC.
The common kludge with UCI Lisp to solve this is to define
an INITFN (initialization function) which does this and then
to reset the INITFN to \fInil\fR which returns you to the
standard Lisp prompt-read-eval-print loop.
However, PEARL sets the INITFN for its own purposes so
that this common "solution" will not work.
Instead, PEARL is set up so that after the reading of INIT.PRL,
it sets any necessary parameters which you have not set in your
INIT.PRL and then reads in the file START.PRL if you have one.
This is where any processing which requires the
attention of PEARL should be placed.
Thus INIT.PRL is primarily for initializing PEARL and
START.PRL is for starting up your use of PEARL.
.PP
After reading in these two files, PEARL will then place you in a
modified prompt-read-eval-print loop, with a default prompt of "PEARL>  ".
The ">" portion is the (modified) Lisp prompt which is printed
whenever \fIread\fR is invoked and can be changed
with the UCI Lisp function INITPROMPT.
The "PEARL" is PEARL's addition and can be set by
setting the special variable \fB*pearlprompt*\fR
to the desired value.
If you do not want any prompt added by PEARL other than the Lisp
prompt you must set \fI*pearlprompt*\fR to \fInil\fR in your
INIT.PRL and PEARL will do the right thing.
.PP
The main feature of the PEARL prompt-read-eval-print loop is
that it uses a different print function.
The default function is
.DS
(lambda (*printval*)
        (valprint  *printval*  4) )
.DE
but this can be changed to whatever you desire by giving the
function \fBpearlprintfn\fR a new definition.
Note that \fIdskin\fR and the break package have been
changed slightly to also use of this print function.
Also, although the functions names and examples below are in
lower case, PEARL in UCI Lisp expects them all in upper
case, just as the rest of the UCI Lisp functions.
.NH
Creating Simple Objects.
.PP
PEARL allows four basic types of objects.
The first two are integers and arbitrary Lisp objects
and are created in the usual Lisp fashion.
The second two are structured types provided by PEARL,
and are stored in an internal form as blocks of memory.
These latter types are called \fBsymbols\fR and \fBstructures\fR.
.NH 2
Defining Symbols
.PP
\fBSymbol\fRs are PEARL's internal atomic symbols.
Semantically they are like Lisp atoms, but are represented
and used differently to make PEARL more efficient.
Before they are used, symbols must
be declared (and thus defined to PEARL) by a call to the function
\fBsymbol\fR, which takes as arguments any number of atoms
whose names will be used to create symbols.
For example,
.DS
(symbol  John)
.DE
creates one symbol called John and
.DS
(symbol  Bob  Carol  Ted  Alice  Home
         Office  School  Healthy  NewYork)
.DE
creates several symbols at one time.
\fISymbol\fR is an nlambda (fexpr) and returns
a list containing the names of the symbols it created.
A one-argument lambda (expr) version is available as \fBsymbole\fR.
.PP
There are two ways to get at the actual (unique) symbol:
you can use the function \fBgetsymbol\fR or you can evaluate the
atom whose name is built out of the symbol name with the characters
\fBs:\fR on the front.
The function \fBsymatom\fR will build this atom for you when
given a symbol name.
For example, to set B to the symbol Bob use any of:
.DS
(setq  B  (getsymbol  'Bob) )
(setq  B  s:Bob)
(setq  B  (eval (symatom 'Bob))
.DE
.LP
Given an internal symbol, you can find out its print name by passing
it to the function \fBpname\fR (which also will return the print name
of other types of PEARL objects).
.NH 2
Defining Structures
.PP
\fBStructure\fRs in PEARL provide the ability to define and manipulate
logical groupings of heterogeneous data and are essentially objects
with slots and slot fillers.
As such, they act more like "records"
in Pascal or "structures" in C than Lisp lists.
In reality they are more than both, but for the moment the reader
should keep records in mind.
.PP
Just as you must define the form
of a record in Pascal before defining the value of a variable whose
type is that kind of record, it is necessary to define each particular
form of structure you wish to use in PEARL before creating an
object with that form.
PEARL provides one function called \fBcreate\fR which
is used both to define kinds of structures and to
create individual instances of these structures.
(One function is provided for both because a special individual
is created as a side effect of each definition.
More on this is provided in section 7 on defaults.)
The first argument to \fIcreate\fR distinguishes
between a call which defines and one which creates an individual.
There are three kinds of defining calls (\fIbase\fR, \fIexpanded\fR
and \fIfunction\fR) and two kinds of instance-creating calls
(\fIindividual\fR, \fIpattern\fR) to \fIcreate\fR.
Only one of each (\fIbase\fR and \fIindividual\fR) is described
in this section.
The rest are left for later.
.PP
To start off with an example, let us suppose that you wish to represent
the conceptual act "PTrans" from the Conceptual Dependency (CD) notation
of Schank.
(The examples in this documentation assume a passing
familiarity with CD but lack of this should not hurt you too badly
and PEARL itself does not restrict you in any way to CD.
PTrans stands for Physical Transfer which has four "cases": actor doing
the transfer, object being transferred, original location and final
location.)
First we must define the form which PTrans structures will take.
In C this would be a type definition for the type PTrans as
follows (assuming a system-provided definition of the type \fIsymbol\fR):
.DS
struct  PTrans {
        symbol  Actor;
        symbol  Object;
        symbol  From;
        symbol  To;
};
.DE
In Pascal this would be
.DS
type  PTrans  =  record
                     Actor  :  symbol;
		     Object  :  symbol;
	             From  :  symbol;
		     To  :  symbol
                 end;
.DE
.LP
In PEARL,
.DS
(create base  PTrans
	(Actor  symbol)
	(Object  symbol)
	(From  symbol)
	(To  symbol) )
.DE
does the job.
Note first of all that in order to define a new form
of structure, the first argument to \fIcreate\fR must be \fBbase\fR.
Note also that the second argument to \fIcreate\fR is the name of the
structure form to be created.
Following this is a list of (<slotname> <type>) pairs.
Structures are currently allowed to have up to 32 slots
in Franz PEARL or 18 in UCI Lisp PEARL as long as all slots
within a particular structure have mutually distinct names.
Different structures may have slots of the same name.
Thus in applications of PEARL to CD twenty different structure
types might all have an Actor slot.
.PP
Five types are allowed for slots: \fBsymbol\fR, \fBstruct\fR,
\fBint\fR, \fBlisp\fR, and \fBsetof <type>\fR.
\fISymbol\fR and \fIstruct\fR are the types just described.
\fIInt\fR is a normal Lisp integer value.
The type \fIlisp\fR allows arbitrary \fBnon-atomic\fR Lisp values.
Finally, \fIsetof <type>\fR allows you to define sets consisting
of all symbols (\fIsetof symbol\fR) or all structures (\fIsetof struct\fR)
and can be done recursively (\fIsetof setof struct\fR).
.NH
Creating Individual Instances of Defined Structures
.PP
Once you have defined a specific form of structure like PTrans, you
can create an individual PTrans using \fBindividual\fR as the first
argument to \fIcreate\fR and the name of the base structure you want
an individual instance of as the second argument.
The rest of the arguments are (<slotname> <value>) pairs in which
the <value> must be of the type that the slot was declared to be.
The slots may be listed in any order and need not be in the same
order as defined.
For example, to create an instance of John going home
from the office (i.e., John PTransing himself from the office to
home) you would use this call to \fIcreate\fR:
.DS
(create individual  PTrans
	(Actor  John)
	(Object  John)
	(From  Office)
	(To  Home) )
.DE
\fICreate\fR will return an object of type PTrans, with the slots filled
in as indicated.
The object returned has been created and stored as
a \fIhunk\fR of memory in Franz Lisp or a block of memory in Binary
Program Space in the UCI Lisp (rather than Free Storage where most
Lisp objects are stored).
Since you are using the PEARL prompt-read-eval-print loop,
the object returned by \fIcreate\fR will be printed in an external list
form, something like the above.
However, if you print a structure using the standard Lisp print
functions (as for example some break packages will do), it will
be printed by Franz Lisp in the normal way it prints hunks.
(Warning: Since the structure actually contains a circular
reference to another hunk, this will cause problems with programs
which do not set \fIprinlevel\fR in Franz Lisp so general packages which
you wish to add to PEARL should be modified to use some PEARL
print function.)
With UCI Lisp's normal print function, it will show up as an
address in Binary Program Space, looking something like "#31534".
.PP
As with any Lisp function that returns an object,
we must store (a pointer to) the result of \fIcreate\fR somewhere
(for example, in the atom Trip)
if we wish to reference it in the future.
Otherwise, the created object will be inaccessible.
(This point is clearer if you consider
that Pascal would insist that you do something with the result
of the function call, although PEARL and many languages like Lisp
and C in which every subprogram is a value-returning function allow
you to construct a value and then blithely go on your way without
using it.)
.PP
To store (a pointer to) the instance returned by \fIcreate\fR in
the atom Trip, you could do the following:
.DS
(setq  Trip  (create individual  PTrans
		     (Actor  John)
		     (Object  John)
		     (From  Office)
		     (To  Home) ) )
.DE
Since this is a common operation, \fIcreate\fR provides the option of
having (a pointer to) the newly created instance automatically
assigned to a Lisp atom.
This is accomplished by including the
name of the atom as the third argument to \fIcreate\fR.
If the third argument to \fIcreate\fR is an atom rather than a
(<slotname> <value>) pair, \fIcreate\fR stores the new
object in this atom.
Thus the effect of the previous example can be achieved by:
.DS
(create individual  PTrans  Trip
	(Actor  John)
	(Object  John)
	(From  Office)
	(To  Home) )
.DE
(In addition, when \fIcreate base PTrans\fR is used, an assignment is
automatically made to the atom PTrans, thus making the defaultinstance
of a structure easily available.
To preserve this, calls to create of the form
\fI(create individual PTrans PTrans ...)\fR are disallowed (that
is, ignored).
In case you should actually wish to use the atom PTrans for other
purposes, evaluating the atom built by prepending \fBi:\fR onto
the structure name will give you the default instance of a base
structure and evaluating the atom built by prepending \fBd:\fR
will give you the actual definition.
Changing the value of these atoms is \fBvery dangerous\fR.
Given the name of a structure, the functions \fBinstatom\fR and
\fBdefatom\fR will construct these atoms for you.
For more information about the item assigned to \fIPTrans\fR
and \fIi:PTrans\fR, see the section 7 on defaults.)
.PP
PTrans is an example of a structure whose slots are all
of the type \fIsymbol\fR.
A more complex example is that of MTrans (Mental Transfer:
an actor transfering a concept (Mental Object) from one place
to another (usually from himself to someone else).
The MObject slot is some other act and so would be of
type \fIstruct\fR resulting in the following definition:
.DS
(create base  MTrans
	(Actor  symbol)
	(MObject  struct)
	(From  symbol)
	(To  symbol) )
.DE
A sample instance of MTrans is \fIJohn told Carol that he
was going home from the office\fR and would be created with
.DS
(create individual  MTrans  InformLeaving
	(Actor  John)
	(MObject  (PTrans  Leaving
		           (Actor  John)
		           (Object  John)
		           (From  Office)
		           (To  Home) ) )
	(From  John)
	(To  Carol) )
.DE
.LP
Note that to fill a slot of type \fIstruct\fR (or \fIsetof struct\fR)
with a structure value within a
\fIcreate\fR one just embeds the appropriate arguments for a recursive
call to \fIcreate\fR, \fIexcept\fR that you \fBmay\fR leave out
\fIindividual\fR since it would just be repetitive.
If you should want to create an object of another type within
an individual or base structure, you must include the alternative
argument (\fIindividual\fR, \fIbase\fR, \fIpattern\fR, \fIexpanded\fR,
or \fIfunction\fR) before the type name.
This is particularly useful when you wish to create a pattern
with an individual instance in one of its slots.
.PP
The optional third argument of an atom name for storing
in may be included at each level if you wish.
In the example above, \fIcreate\fR actually will create two
new instances, an MTrans which will be stored in InformLeaving,
and a PTrans which is pointed to by the MObject slot of the
MTrans and is also pointed to by Leaving.
In this case, neither InformLeaving nor Leaving is required.
If Leaving were left out, then one would still have a way
to get at the PTrans via the MObject slot of the MTrans that 
InformLeaving points to.
However, if InformLeaving were left out and the
result of the call to \fIcreate\fR were not stored any other way,
there is one more way that the MTrans would be accessible.
The value of the most recently created object is always
stored in the special variable \fB*lastcreated*\fR by
\fIcreate\fR so the value of the MTrans would remain
accessible until the next call to \fIcreate\fR.
Note that if there are recursive calls to \fIcreate\fR during this
time in order to process structure values in slots, the value of
\fI*lastcreated*\fR is continually changing to the most recent
one and the setting of \fI*lastcreated*\fR is the last thing
\fIcreate\fR does.
There is also a special variable called \fB*currenttopcreated*\fR
which is set by \fIcreate\fR at the top level call as soon as
the space for an individual or default instance is allocated.
Since it is sometimes handy for a piece of user code which
runs during \fIcreate\fR (see the sections on !, $, predicates and
demons) to be able to access the topmost object,
\fI*currenttopcreated*\fR is sometimes quite useful.
.PP
As in C and Pascal, one can embed to any level.
\fICreate\fR does not have facilities
for more complex networks of structures, as there are other
functions in PEARL which allow their construction.
\fICreate\fR is mainly used to create objects for other
functions to manipulate.
.NH
Accessing Slots of Structures
.PP
In C and Pascal one can access the slots of a record or structure by
using dot notation.
For example, in Pascal the To slot of the MObject slot of
the MTrans pointed to by InformLeaving would be accessed
with the expression InformLeaving.MObject.To (or perhaps
more accurately InformLeaving\fB^\fR.MObject\fB^\fR.To
since slots really contain pointers to objects).
In Pascal and C, there are essentially only two things that
one can do to a slot of a record or structure: access it
(get its value) and assign to it (give it a new value).
In PEARL the macro \fBpath\fR provides
a large number of ways to access and/or change the values
in slots of individual structures.
(In the UCI Lisp version this is called \fIppath\fR
to distinguish it from the system function \fIpath\fR.)
A call to \fIpath\fR is of the following general form:
.DS
(path  <Selector>  <Structure>  <Slot-Name-or-List>  <Value>)
.DE
<Selector> determines the action to be performed
and is not evaluated.
<Structure> should evaluate to the object in which the slot
occurs (or in whose depths the object occurs).
<Slot-Name-or-List> should evaluate either to the atom name of the
slot desired in <Structure> or a list of the slot names
which one must follow to get down to the slot.
<Value> (which is only needed when it makes sense) 
should evaluate to the value to be put into the slot
(or otherwise used in performing the function).
At this point, we will only describe the two <Selector>s
corresponding to accessing and assigning.
These are \fBget\fR and \fBput\fR respectively.
Thus to access the value of a slot, you would use
.DS
(path  get  <Structure>  <Slot-Name-or-List>)
.DE
(No value is needed;
the purpose of this call is to get the value.)
To assign a value to a slot, you would use
.DS
(path  put  <Structure>  <Slot-Name-or-List>  <Value>)
.DE
For example, to access the Actor slot of the PTrans in Trip, either of
the following is appropriate:
.DS
(path  get  Trip  'Actor)
(path  get  Trip  '(Actor) )
.DE
This is essentially equivalent to a reference to
\fITrip\fB^\fI.Actor\fR in Pascal.
.PP
To access a slot within a structure in a slot of type \fIstruct\fR, 
add the slot names to the <Slot-Name-or-List>, just as we access
embedded fields within fields in Pascal by adding more slots
to the accessing expression.
For example, to access the place
John told Carol he was going in our MTrans example above, we
want the To slot of the MObject slot of the MTrans stored in
InformLeaving:
.DS
(path  get  InformLeaving  '(MObject To) )
.DE
This is essentially equivalent to a reference to
\fIInformLeaving\fB^\fI.MObject\fB^\fI.To\fR in Pascal.
PEARL will check each slot reference, and will indicate if
a slot name is not found (perhaps due to a misspelling or an
unbound slot).
.PP
Similarly, to change the Actor of our PTrans in Trip to be Bob:
.DS
(path  put  Trip  '(Actor)   (getsymbol  'Bob) )
.DE
and to change the To slot within the MObject of the MTrans:
.DS
(path  put  InformLeaving  '(MObject  To)   (getsymbol  'School) )
.DE
which is essentially equivalent to assigning a value to
\fIInformLeaving\fB^\fI.MObject\fB^\fI.To\fR in Pascal.
Note that the order of the arguments to these functions is in
\fBnot like\fR the argument ordering of \fIputprop\fR.
.PP
\fBCAUTION\fR:
\fIPath\fR does not check values to ensure that they are of the
correct type before putting them in a slot.
Also, a change in a structure with \fIpath\fR
does not cause it to be reinserted in the data base
(see the next section).
Thus, before changing a structure, one should remove it from
the data base and then reinsert it after the change.
.PP
These functions were gathered under the macro \fIpath\fR because of
their similarity.
However, if you prefer to have the action being performed lead off the
function name in keeping with \fIputprop\fR, \fIget\fR, \fIputd\fR,
\fIgetd\fR, etc., these two functions are also available as
\fBputpath\fR and \fBgetpath\fR with similar names also provided for
all the other forms of path described below.
Thus the name "path" may be tacked onto the end of one of the action
selectors to \fIpath\fR but the rest of the arguments to these
functions remain the same.
.PP
There are quite a few other operations which are allowed through
\fIpath\fR which you will not need or understand until you have read
the rest of this documentation.
We describe them here for completeness but suggest you skip
to the next section during your first reading.
If you feel there is one missing, feel free to suggest it since
they are easy to add.
.IP
\fIpath \fBclear\fR or \fBclearpath\fR -- sets the selected path to
the standard default value for its type (\fInilsym\fR,
\fInilstruct\fR, zero or \fInil\fR).
Note that this is only the standard default and does
not inherit a default from above.
See section 7 for more on default values.
.IP
\fIpath \fBaddset\fR or \fBaddsetpath\fR -- add the specified value to
a slot of type \fIsetof\fR.
.IP
\fIpath \fBdelset\fR or \fBdelsetpath\fR -- delete the specified value
from a slot of type \fIsetof\fR.
.IP
\fIpath \fBgetpred\fR or \fBgetpredpath\fR -- get the list of
predicates on the slot.
.IP
\fIpath \fBaddpred\fR or \fBaddpredpath\fR -- add the specified
predicate to the predicates on the slot.
.IP
\fIpath \fBdelpred\fR or \fBdelpredpath\fR -- delete the specified
predicate from the predicates on the slot.
.IP
\fIpath \fBgethook\fR or \fBgethookpath\fR -- get the assoc-list of 
hooks (demons) on the slot.
.IP
\fIpath \fBapply\fR or \fBapplypath\fR -- arguments to this function
are a <Function-or-Lambda-Body>, followed by the <Structure>, and
<Slot-Name-or-List>.
The <Function-or-Lambda-Body> is applied to the value of the slot.
(In the UCI Lisp version, \fIapply#\fR is used so that macros will work.
In the Franz Lisp version, a PEARL-supplied version of \fIapply\fR
called \fBapply*\fR is used which also handles macros "right".)
.PP
(Skip this next paragraph until you have read about hashing and
the data bases.)
The method of processing the path in \fBpath\fR functions allows a
form of indirection through the data base that is sometimes
helpful when you use symbols in slots as unique pointers to
other structures.
Suppose you had the following definitions:
.DS
(create base  Person
	(* Identity  symbol)
	(   Name  lisp) )
.DE
.DS
(dbcreate individual  Person
	  (Identity  John)
	  (Name  (John  Zappa) )
.DE
and you want to ask \fI"what is the Name of the Person in the
Actor slot of Trip (above)"\fR which you might normally write as:
.DS
(getpath  (fetch  (create pattern  Person
			  (Identity  !  (getpath  Trip  'Actor) ) ) )
	   'Name)
.DE
This is very hard to understand.
A shorthand for this is the following:
.DS
(getpath  Trip  '(Actor  Person  Name) )
.DE
which behaves like this:  when \fIpath\fR gets to the symbol in
the Actor slot of Trip, it notices that there is still more path
to follow.
It then interprets the next symbol in the path as the
name of a type and does a quick equivalent of fetch of a Person
with its first slot set to John.
It then continues to follow the path specified in this new
structure, finishing up with the value of the Name slot
of the structure.
(Note that this depends on Person structures being hashed by the
relevant slot and will fail otherwise.
Also note that the tendency of most users of PEARL has been away
from the use of symbols as indirections to larger structures and
toward actually putting the larger structure in the slot.
In this case this would imply putting the Person structure in the
Actor slot of PTrans and eliminate the need for "Person" in the
path list.)
.NH
Storing In and Retrieving From the Data Base -- The Simplest Way
.PP
So far we have shown how to create structures and have treated
them pretty much like C structures or Pascal records.
However, PEARL's most important departures from these languages
involve its data base facilities.
PEARL's data base can be thought of as one large
bag into which any structure can be placed.
The data base can hold hundreds, even thousands of separate objects.
There are two basic operations that can be performed upon
the data base, inserting with the function \fIinsertdb\fR
and retrieving with a combination of the functions
\fIfetch\fR and \fInextitem\fR.
.NH 2
Storing In the Data Base: \fIInsertdb\fR and \fIRemovedb\fR
.PP
While the simplest forms of these actions are
relatively straightforward, the power and efficiency of PEARL
derives from the nuances and controls available with these
functions which take up much of the rest of this document.
Much of the power develops from knowledge provided by the user about
how each kind of structure is likely to be retrieved (and therefore
how it should be stored).
Thus, the data base benefits from knowing as much as possible
in advance about the objects that will be placed within it.
This information is provided by using a large variety
of extra flags during definition calls to \fIcreate\fR.
It is used by \fIinsertdb\fR to hash objects into a specific
\fIhash bucket\fR in the data base, by \fIfetch\fR to retrieve the
correct hash bucket from the data base, and by \fInextitem\fR
to filter the desired objects from this bucket.
.PP
PEARL allows the construction and use of multiple data bases which are
described in detail later.
Without exerting any effort, a data base is automatically created
called \fB*maindb*\fR and pointed to by the special variable \fB*db*\fR.
In general, all PEARL functions which deal with a data base have an
optional last argument which specifies which data base to use.
If it is missing, then the default data base pointed to by
\fI*db*\fR is assumed.
Thus you can change the default data base
simply by assigning the desired data base to \fI*db*\fR.
For simplicity, this optional data base argument is not
mentioned in the following discussion.
.PP
The function \fBinsertdb\fR takes a single structure argument and
inserts it into the data base.
In its simplest form \fIinsertdb\fR requires no user flags on the
definitions of structures.
In this case, \fIinsertdb\fR simply hashes on the type of the
structure regardless of its specific contents so that each
entry ends up in a bucket with all other entries of that type.
For example, to insert into the data base the PTrans which was
saved in the Lisp variable Trip above, you simply provide it as an
argument to \fIinsertdb\fR:
.DS
(insertdb  Trip)
.DE
We could also put the PTrans (saved in Leaving whose To slot
was changed to School) which was the MObject of the MTrans above
in the data base with:
.DS
(insertdb  Leaving)
.DE
Since no information has been provided by the user about how to
efficiently distinguish PTranses in general, these two will be stored
in the same bucket (as will all PTranses).
When inserting an item into a bucket, \fIinsertdb\fR will check
to ensure that this specific item is not already in that bucket
(using \fIeq\fR) and will only insert it if
it is not already there, thus avoiding duplicates.
.PP
The function \fBremovedb\fR takes a single structure argument
and removes it from any place in the data base where it has been
put using \fIeq\fR to determine equality.
.PP
Since one often wants to create an individual and then insert it into
the data base, there is a macro \fBdbcreate\fR provided whose
arguments are precisely like \fIcreate\fR.
Thus, \fI(dbcreate individual PTrans ....)\fR expands into
\fI(insertdb (create individual PTrans ....) )\fR.
.NH 2
Retrieving Hash Buckets From the Data Base: Fetch
.PP
.hy next-item
The simplest case of fetching from the data base is
equivalent to asking if a particular, completely defined
object is in the data base.
This is performed by a combination of the functions 
fIfetch\fR and \fInextitem\fR.
The first step is to retrieve the hash bucket(s) for the object.
For example, to determine whether the object stored in Trip is in the
data base, the first step is to call the function \fBfetch\fR and
store what it returns (the form of what is returned is described
below):
.DS
(setq  PotentialTrips  (fetch  Trip) )
.DE
.PP
The function \fIfetch\fR takes a single structure argument which is
called the \fBpattern\fR.
What \fIfetch\fR returns includes this pattern and the hash bucket(s)
from the data base which contain those structures which are
most likely to "match".
The rules of "matching" are fairly complex and are described in
detail in section 20, but for the moment it is enough to know that
two structures match if their respective slots contain equal values.
Thus matching is closer to Lisp's \fIequal\fR than to \fIeq\fR.
.NH 2
Accessing the Results of a Fetch: Nextitem.
.PP
Conceptually, what \fIfetch\fR returns is a restricted type of \fBstream\fR.
A stream is a "virtual" list, whose items are computed only as needed.
When a fetch from the data base is performed, the pattern provided
is only used to construct a stream containing that pattern and the
appropriate hash bucket from the data base;
no matching (comparing)
between the pattern and objects in the data base occurs.
Thus the stream contains pointers to all data base items in the
same hash bucket, regardless of their likelihood of matching the pattern.
Therefore, the \fIstream\fR or "virtual list" returned by \fIfetch\fR is
in fact bigger than the list of actual items which match.
(For this reason, the default PEARL print function only prints how
many potential items are in the stream.)
.PP
For our purposes, you should regard the object that \fIfetch\fR
returns to be a funny sort of black box, whose only use is as
an argument to the function \fBnextitem\fR.
\fINextitem\fR will compute the next element to be removed from the stream.
When elements are extracted from the stream with the function \fInextitem\fR,
the pattern is "matched" against successive items from the hash bucket
until one matches (and is returned) or until the potential items run out
(and \fInil\fR is returned).
.PP
\fINextitem\fR is very much like the function \fIpop\fR in Lisp because it
updates the status of the stream to reflect the
extraction of the "topmost element" similar to the way \fIpop\fR replaces
its list argument with its \fIcdr\fR.
\fINextitem\fR does this by destructively modifying the stream
(but not the hash bucket);
once the top item
has come off it is no longer a part of the stream.
Like \fIpop\fR, \fInextitem\fR returns \fInil\fR if the stream is empty.
.PP
A stream, as returned by \fIfetch\fR in PotentialTrips,
will \fBnever\fR be \fInil\fR but instead will be a list.
In all cases, the first element will be the atom \fB*stream*\fR.
In most cases, the second element (\fIcadr\fR) is the pattern (object
being fetched) and the rest (\fIcddr\fR) is
the hash bucket that the object hashes to.
However, it is entirely possible for the hash bucket to either
fail to contain any instances of the object, or to contain
multiple instances of the object.
The form that is printed by PEARL's default print function is:
the atom \fB*stream:*\fR, the object being fetched,
and the number of potential items in the stream,
avoiding the prining of a lengthy result.
(If the pattern is actually a function structure, then the atom
used is \fB*function-stream:*\fR.)
.PP
Thus, to actually determine whether the object in Trip is in the data
base, it is necessary to ask for the \fInextitem\fR in the bucket of
the stream PotentialTrips (that is, in the \fIcddr\fR)
which matches the object being fetched (that is, the \fIcadr\fR
of PotentialTrips):
.DS
(setq  FirstResult  (nextitem  PotentialTrips) )
(setq  SecondResult  (nextitem  PotentialTrips) )
.DE
If nothing matching Trip occurred in the data base, FirstResult would
contain \fInil\fR;
otherwise, it would contain an object in the data base
which matches Trip.
If you have typed in all the examples we have shown you above,
then FirstResult will contain the same value as Trip.
SecondResult will be \fInil\fR.  (The only other object in the same
bucket is the value of Leaving, but that does not match because
its To slot contains School after the \fIpath put\fR above.)
If the two structures in Trip and Leaving both contained
the same slot fillers, they would both match Trip and each
would be returned by \fInextitem\fR on successive calls.
.PP
This is essentially the only type of fetching that is
useful with the information presented so far,
but more powerful types will be described shortly.
.PP
Since the functions \fIcreate\fR, \fIfetch\fR, and \fInextitem\fR
are often used in combination, several macros combining them are
provided by PEARL:
.IP
When you wish to create a pattern only long enough to use it as an
argument to \fIfetch\fR, you can use the macro \fBfetchcreate\fR
which is defined in such a way that \fI(fetchcreate blah)\fR is
equivalent to \fI(fetch (create blah) )\fR ).
.IP
If you want to do a \fIfetchcreate\fR in a function definition and
you wish the pattern to be created only once but used each time
this function is called (a potential savings in space and time),
the macro \fBinlinefetchcreate\fR will call \fIcreate\fR when it
expands and then expand to a call to fetch with this pattern.
.IP
If you want to do a \fIcreate\fR in a function definition and
you wish the object to be created only once,
the macro \fBinlinecreate\fR will call \fIcreate\fR when it
expands and effectively replace itself with the result.
.IP
When you wish to fetch but only need the resulting stream long
enough to use it as an argument to \fInextitem\fR, you can use
the macro \fBfirstfetch\fR which is defined in such a way that
\fI(firstfetch blah)\fR is equivalent to \fI(nextitem (fetch blah) )\fR ).
.IP
If your only goal in fetching some fully-specified object is to
test for its existence in the data base, the function \fBindb\fR
which expects a single structure argument will return \fInil\fR
if it is not there, and non-\fInil\fR if it is.
(Note that \fIindb\fR uses \fIstrequal\fR rather than \fImatch\fR.)
.IP
It is sometimes convenient to have a list of all the items which would be
returned by successive calls to \fInextitem\fR on a stream.
The function \fBstreamtolist\fR expects a stream argument and
returns a list of the items which the stream would produce.
.NH
The Default Values for Unspecified Slots
.PP
When creating an instance of a given type, one may not always
wish to fill in all the slots of the structure, either because
the slot value is unknown or immaterial.
PEARL has a mechanism for filling unfilled slots with default values.
The simplest form of defaulting involves two
predefined objects, \fBnilsym\fR and \fBnilstruct\fR.
\fINilsym\fR is a \fIsymbol\fR, and roughly corresponds to Lisp's
\fInil\fR when \fInil\fR is viewed as an atom.
\fINilstruct\fR is a structure without any slots,
and corresponds to a null structure.
In the absence of a specified value, PEARL will fill in slots
of an individual instance of a structure being created
with \fInilsym\fR if the slot type is \fIsymbol\fR,
\fInilstruct\fR if the slot type is \fIstruct\fR, zero if the slot
is of type \fIint\fR, and Lisp \fInil\fR
if the slot is of type \fIlisp\fR or \fIsetof <any type>\fR.
Note that it is up to the user to decide upon the meaning of
\fInilsym\fR and \fInilstruct\fR during further processing.
For example, you must decide for your own application whether
a \fInilstruct\fR filling the MObject slot of a MTrans indicates
that nothing was said or that what was said is unknown.
.PP
Often you may desire closer control over the default values of
a particular slot within individual instances.
For example, suppose you had a definition of Person that
includes several pieces of information about a person:
.DS
(create base  Person
	(Identity  symbol)
	(Age  int)
	(Salary  int)
	(Health  symbol) )
.DE
The Identity slot would be filled in with a unique symbol for
that person (such as the symbol John), the Age slot would contain
the age in years, the Salary slot would get the person's monthy salary
in dollars, and the Health slot would contain a \fIsymbol\fR indicating
their state of health.
Now in creating an individual instance of a Person
the Identity slot should be always filled in, but we may desire the
other slots to be defaulted to 30 (years), 20000 (dollars) and Healthy.
However, under the default system described so far, these would be
defaulted to zero, zero and \fInilsym\fR.
PEARL provides the ability to specify individual defaults for
each slot of a particular structure type.
This is done at \fIbase\fR creation time by following the type
within a slot with the new default value.
Thus our definition of Person would be:
.DS
(create base  Person
	(Identity  symbol)
	(Age  int  30)
	(Salary  int  20000)
	(Health  symbol  Healthy) )
.DE
Although the main purpose of a call to \fIcreate base\fR is to define
a structure, it also creates a special individual of the type
being defined which has its slots filled with the default values.
For this reason this individual is called the \fBdefault instance\fR
of that type.
It is a structure instance like any other, only a
pointer to it is kept with the type definition, and it is consulted
whenever an instance of that type is constructed.
Thus the default values (either the user-defined defaults or
the standard defaults) will always be used whenever the user
declines to fill in a slot of a structure instance.
For more on defaults, see the discussion of inheriting in
section 19 on creating expanded structures.
.NH
Using Patterns For More Flexible and Powerful Retrieval
.PP
If the fetching mechanisms described so far were the
only sort of fetching that we could do, \fIfetch\fR
(and PEARL) would not be very useful.
What is needed is a way to only partially specify the
values in the structure to be fetched.
Note that the default mechanism does not accomplish this,
since all slots are specified at creation time, even if they
get \fInilsym\fR, \fInilstruct\fR, or \fInil\fR for a value.
What is needed is the ability to specify a \fIdon't care\fR
value for slots whose values should not affect the matching
process during retrieval.
The easiest way to accomplish this in PEARL is to create
a type of object called a \fBpattern\fR.
A \fIpattern\fR is similar to an \fIindividual\fR instance of
a structure except that a special pattern-matching variable
called \fB?*any*\fR which means \fIdon't care\fR or \fImatch anything\fR
is used as the default value for unspecified slots.
(The reason for its name will be clear after the description
of pattern-matching variables later in this section.
Even more detail on pattern-matching variables and more powerful
patterns is provided in sections 21-23 on the matching process,
blocks, lexically scoped variables, and the
unbinding of variables.)
.PP
Patterns are created with \fIcreate\fR using \fIpattern\fR
as the first argument.
Other than this, their syntax is exactly the same as individuals.
An example of a \fIpattern\fR creation is:
.DS
(create pattern  PTrans  JohnWentSomewhere
	(Actor  John)
	(Object  John) )
.DE
This pattern would match any instance of PTrans in which John
was both the actor and the object being moved.
(Note that this pattern is stored in the Lisp variable
JohnWentSomewhere in the same way as other individuals.)
The main use of patterns is as arguments to \fIfetch\fR, as in:
.DS
(setq  PotentialGoings  (fetch  JohnWentSomewhere) )
.DE
\fIFetch\fR will return a stream containing all PTranses in the
data base in which John was the actor and object, regardless
what the From and To slots contain.
More complex examples can be created.
Patterns can be embedded as in:
.DS
(create pattern  MTrans  InformJohnGoingSomewhere
	(MObject  (PTrans  (Actor  John)
			   (Object  John) ) ) )
.DE
Since all unspecified slots are filled with ?*any*, this pattern
will return any MTranses concerning any of John's PTranses
when passed to \fIfetch\fR.
Thus, if we insert InformLeaving from above in the data base:
.DS
(insertdb  InformLeaving)
.DE
then the following will fetch that object:
.DS
(nextitem  (fetch  InformJohnGoingSomewhere) )
.DE
.PP
Usually one is interested in a more specific piece of information.
For example, if you knew that John told Carol something and wanted
to find out what it was, then you could do this two ways.
One is to create a pattern, fetch it and look at the MObject slot of
the result:
.DS
(create pattern  MTrans  WhatDidJohnTellCarol
	(Actor  John)
	(From  John)
	(To  Carol) )
(setq  Result  (firstfetch  WhatDidJohnTellCarol) )
(path  get  Result  'MObject)
.DE
However, you might prefer to use a pattern which explicitly
shows that you want that value and gives you a slightly easier
way to get at it.
In this case, you can specify a pattern-matching variable
in the MObject slot of the pattern.
A pattern-matching variable is created by preceding an atom with a
question mark \fB?\fR as in \fI?What\fR.
The question mark is a read macro character which reads the next
atom and builds the list \fI(*var* What)\fR out of it (or
\fI(*global* What)\fR if \fIWhat\fR has previously been declared
global to PEARL;
see below for more on global variables.).
During matching, this variable will get bound to the value
of the slot it gets matched against:
.DS
(create individual  MTrans  WhatDidJohnTellCarol
	(Actor  John)
	(MObject  ?What)
	(From  John)
	(To  Carol) )
(firstfetch  WhatDidJohnTellCarol)
.DE
To access the value of a pattern-matching variable in
a structure, one uses either the function \fBvalueof\fR
(which is an expr) or the fexpr \fBvarvalue\fR.
Both functions have two arguments: the name of the
pattern-matching variable whose value you want and
the structure it occurs in (which is evaluated internally
by \fIvarvalue\fR).
Thus both of the following are equivalent:
.DS
(valueof   \fB'\fRWhat  WhatDidJohnTellCarol)
(varvalue  What  WhatDidJohnTellCarol)
.DE
.NH
Marking Structures During Creation For More Efficient Retrieval
.PP
Besides specifying what type each structure is, the simplest
piece of information that \fIinsertdb\fR would like the user
to give it through \fIcreate\fR concerns which slot(s) of
a type would be most likely to contain unique information
about a particular instance of that type.
This information is used to differentiate instances of the
type from each other, so that they will be hashed into
different hash buckets.
This is similar to the "keys" that many data base systems ask for.
For PTrans, the Actor slot is often the best choice for this role.
For Person, the Identity slot would be the best choice for this role.
Such unique slots are indicated to \fIcreate\fR when defining a
type by placing an asterisk '*' before the slotname in a
(<slotname> <type>) pair.
For example, our new definitions of PTrans and Person
to take advantage of this would look like:
.DS
(create base  PTrans
	(* Actor  symbol)
	(   Object  symbol)
	(   From  symbol)
	(   To  symbol) )
(create base  Person
	(* Identity  symbol)
	(   Age  int  30)
	(   Salary  int  20000)
	(   Health  symbol  Healthy) )
.DE
If you execute this when you have already executed the other examples
in this document, PEARL will warn you that you are redefining the
base structures PTrans and Person.
This is all right, since that is precisely what we want to happen.
However, the previous instances of PTrans will remain hashed in the
more inefficient way and will not match any later PTrans structures
that are defined. 
If you find these warnings annoying when redefining structures,
they may be turned off by setting the special variable
\fB*warn*\fR to \fInil\fR instead of the initial \fIt\fR.
(Note that the Lisp scanner requires a space (or other
white space) to separate the asterisk from the slotname.
Otherwise one would have the slotname \fI*Actor\fR).
.PP
Any number of starred slots may be provided within a structure
definition, but usually only one or two are necessary.
How one decides which slots should be starred is an
art, and depends significantly on your application and the nature
of your data.
The basic rule of thumb is to choose those slots
whose values vary the most widely from instance to instance.
A bad choice will not usually cause the system to bomb or
operate incorrectly in any way, but when it comes time to
fetch an object back out of the data base the system may have
to take the time to scan a large amount of the data base
rather than finding the desired object very rapidly.
Thus execution time is usually the only penalty one pays
for an improper choice of slots to star.
.PP
However, there is one type of use of a slot which can cause
problems in combination with hashing information.
It involves the use of pattern-matching variables and will
serve as a useful example of how to use variables and of how
\fIinsertdb\fR and \fIfetch\fR use the hashing
information to insert and find objects.
The key difference between them is that while \fIinsertdb\fR
inserts an object in as many places as it can, \fIfetch\fR only
looks for it in the \fBbest\fR place.
(What we mean by best will be more obvious after section 13.)
.PP
The problem situation occurs when you wish to insert items
into the data base which contain a variable in the starred
slot (representing general knowledge) and then use,
as a pattern, a structure with that slot filled.
Thus, the following sequence will fail to find Thing
in the data base and instead will return \fInil\fR:
.DS
(create base  Thing
	(*  One  int) )
.DE
.DS
(dbcreate individual  Thing  DBThing
	  (One  ?O)
	  (Two  2) )
.DE
.DS
(nextitem (fetchcreate individual  Thing  PatThing
	               (One  1)
	               (Two  2) )
.DE
This fails \fIsimply because of the hashing\fR.
Let us see why.
When \fIinsertdb\fR is asked to put something into the data base,
it seeks to put it as many places as the hashing information
indicates are good places to want to look for it.
With no hashing information at all, the only thing \fIinsertdb\fR
can do is to put the object with all other objects of its type.
Thus, with no hashing information, all Things are put together in
the same hash bucket.
With the hashing information, \fIinsertdb\fR would like to put
DBThing in a second (and better) place based on the fact that it
is a Thing \fIand\fR on the value of its One slot.
Unfortunately, its One slot has an unbound variable in it and does
not provide any information which is useful.
Thus the hashing process puts DBThing into the data base in 
only one place.
However, when \fIfetch\fR indexes PatThing, it uses the hashing
information to determine that it should look in the data base
under the best combination which is \fIThing + 1\fR.
Since DBThing is not there, it is not found.
If we remove the asterisk, this sequence will return
DBThing with ?O bound to 1 because both DBThing and PatThing will
get indexed into the same spot (along with all other Things).
Thus you should be very careful when determining how to hash 
types of structures when you intend to insert them into
the data base with variables in them.
(An alternative solution which could be more efficient if used
carefully is to use the function \fIfetcheverywhere\fR which is
described in section 13.
This problem can also sometimes be solved with the use of adjunct
variables, described in section 14.)
.PP
After more of the system has been described and examples of fetching
and inserting have been given the user will have a better
understanding of this process.
.PP
As another example, let us now create and insert an instance
of our new PTrans which has the Actor slot starred:
.DS
(dbcreate individual  PTrans  Trip
	  (Actor  John)
	  (Object  John)
	  (From  Office)
	  (To  Home) ) 
.DE
This would insert Trip with all other PTranses and, because of the
starred slot Actor, also with any other PTranses with a value of
John in the Actor slot.
Next we redefine and recreate the MTrans:
.DS
(create base  MTrans 
	(*  Actor  symbol)
	(    MObject  struct)
	(    From  symbol)
	(    To  symbol) )
.DE
.DS
(create individual  MTrans  InformLeaving
	(Actor  John)
	(MObject  (PTrans  Leaving
		           (Actor  John)
		           (Object  John)
		           (From  Office)
		           (To  Home) ) )
	(From  John)
	(To  Carol) )
.DE
reinsert the PTrans from the MTrans:
.DS
(insertdb  Leaving)
.DE
and finally create and insert two other instances of a PTrans,
one with different values in the From and To slots
and one with different values in the Actor and Object slot:
.DS
(create individual  PTrans  Trip
	(Actor  John)
	(Object  John)
	(From  Home)
	(To  School) ) 
.DE
.DS
(create individual  PTrans
	(Actor  Ted)
	(Object  Ted)
	(From  Office)
	(To  Home) )
.DE
Note that this last PTrans will be indexed under the combination
of PTrans and Ted and thus will not be in the same hash bucket we
look in when fetching Trip (which is indexed by PTrans and John):
.DS
(setq  PotentialTrips  (fetch  Trip) )
(setq  Result  (nextitem  PotentialTrips)
PotentialTrips
.DE
Notice the form of the stream PotentialTrips at this point.
.NH
Printing Structures, Symbols and Other PEARL Objects
.PP
As mentioned in the beginning, PEARL stores symbols and
structures (and their definitions) in hunks of memory
that are circularly linked.
Lisp cannot print out the contents of these blocks in a useful way.
Franz Lisp sometimes goes into an infinite loop trying to print them
and the best UCI Lisp can do is tell you its address,
like #2934, which is not very informative.
As mentioned above, the PEARL prompt-read-eval-print loop knows how
to print these in symbolic form.
However, when you want your own programs to print
them, PEARL provides you with two pairs of functions
to convert these blocks into more readable form.
The first we will discuss is the function \fBvalform\fR.
\fIValform\fR takes a \fIstruct\fR, a \fIsymbol\fR or any other type
of PEARL or Lisp object as an argument and returns a
Lisp S-expression describing the object.
Thus if one calls \fIvalform\fR on our PTrans in Trip:
.DS
(setq  TripAsList  (valform  Trip) )
.DE
the Lisp variable TripAsList will contain the S-expression:
.DS
(PTrans (Actor John) (Object John) (From Home) (To School) )
.DE
Note that \fIvalform\fR does not cause the PTrans to be printed out
at the user's terminal, it is merely a function that returns an
S-expression (just as the Lisp function \fIlist\fR does.)
PEARL functions will operate upon structures and symbols only
when they are in their internal form, so the primary reason
for converting structures to S-expressions is to print them
(or to modify them for use as new input to \fIcreate\fR).
So PEARL provides a more useful function \fBvalprint\fR
that is effectively \fI(sprint (valform <argument>) )\fR.
(\fBSprint\fR is a function provided by UCI Lisp or Franz PEARL
which prints a Lisp expression in a nicely indented form.
There are more details on \fIsprint\fR in the appendix on UCI Lisp
functions added to PEARL.)
\fIValprint\fR is normally used within a Lisp program to
print out any PEARL construct onto the user's terminal
and it is also used by the default print function in the
PEARL prompt-read-eval-print loop.
Try typing the following and notice that they are the
same except that the second value is slightly indented.
.DS
(valprint  Trip)
Trip
.DE
Like \fIsprint\fR, \fIvalprint\fR will accept a second integer
argument telling it which column to start printing in.
The default \fIpearlprintfn\fR uses a value of 4 for this argument
to make the items typed by the user more distinguisable from the 
results typed by PEARL.
.PP
There is one other form of each of these two functions.
The functions \fBfullform\fR and \fBfullprint\fR are
like \fIvalform\fR and \fIvalprint\fR but they print
more complete information.
If you type
.DS
(fullprint  Trip)
.DE
you will notice that the result has two mysterious
\fInil\fRs in each slot.
These represent other forms of information (predicates
and hooks or demons) which can be added to structures
and which will be described later.
At the moment therefore, \fIvalform\fR and \fIvalprint\fR
are all that the user need remember.
.PP
Note also from above that when a pattern with \fI?*any*\fR is printed,
only the name of that variable is printed, and not its value.
(Try typing JohnWentSomewhere and InformJohnGoingSomewhere
if you do not remember what this looked like.)
If a PEARL pattern-matching variable has not been bound,
PEARL indicates this by printing no value.
If a variable is bound, both the variable name and
its value are printed.
Later when you learn how to put your own variables
in slots, this will become more useful.
.PP
When given a data base, these functions assume that the user does
not really want the complete contents of the data base printed out
and so simply print \fI(database: <databasename>)\fR.
To actually have the complete contents of a data base printed out,
use the function \fBprintdb\fR.
With no argument, it prints the default data base.
Otherwise, it expects its argument to evaluate to a data base.
A print function which prints all the internal information contained
in a structure or its definition is \fBdebugprint\fR.
.NH
Error Messages, Bugs, and Error Handling Abilities
.PP
Due to the complex implemention of PEARL and the lack
of facilities in Lisp for easily distinguishing between
types of input, a user's error in using PEARL will not
show up as soon as it occurs, but may instead cause some
unfathomable part of PEARL to bomb out sometime later.
If this should happen, the user might try using the Lisp
trace facilities, but will often find little useful information.
This sad state of affairs is currently unavoidable due to the 
difficulty of catching user errors where they first occur.
This is partly due to our inability to predict what kinds of
errors users are most likely to make.
.PP
PEARL checks as much as it can, but many features are impossible
or prohibitively expensive to check.
The best strategy for the
user to follow is to examine his last interaction with PEARL.
If the error occurred in the bowels of \fIcreate\fR, then there is a
good chance that the user did something wrong in the details of
a slot description in the call to \fIcreate\fR, since gross structural
errors in such calls are checked for.
Inspect your call closely.
.PP
Other errors can be even more difficult, since a function call
may blow up or fail to produce the desired result due to bad
data passed to \fIcreate\fR several calls ago.
A general rule of thumb to use in tracking down mystifying
errors is to check out the definitions of the structures
involved in the function that failed.
Thus if \fIpath\fR blows up, one should determine the type of
the structure passed to \fIpath\fR, and then check the 
\fIcreate\fR call that defined that type.
.PP
Sometimes PEARL may appear to the user to be doing the wrong thing,
but due to PEARL's complex semantics, the user is really at fault.
To make matters worse, there is of course always the chance that
the error really \fBis\fR in PEARL.
Every effort has been made to minimize this chance, and at the
moment there are no known major errors (except those indicated
in this documentation), but as with any complex evolving
software system there is always the chance of obscure errors.
It has been our experience that most errors
are due to the user (including the implementors) not completely
understanding the semantics of some PEARL feature.
This documentation is an effort to minimize this type of error.
For any error which you commit in which PEARL gives what
you consider an unreasonable response, feel free to report
it and we will consider trying to catch it.
These or any other complaints, bugs or suggestions should be
mailed to Joe Faletti via Arpanet or Unix mail
(Kim.Faletti@Berkeley or ucbvax!kim.faletti).
.NH
Short-Circuiting and Redirecting Create Using !, $ and Atoms
.PP
Sometimes, when creating an individual structure,
one may want to fill a slot with an already created structure
that is pointed to by some atom or returned by some function
(or with whatever type of value the slot requires).
In this case, one does not wish to (or cannot) describe the
value for a slot as a list of atoms.
To handle this situation, PEARL allows you to list a Lisp expression
which evaluates to the desired internal form (that is, a form
which needs no processing by \fIcreate\fR), preceding it with
an exclamation point \fB"!"\fR.
The structure (or other object) resulting from evaluating
the Lisp expression will be tested to ensure it is the right type
of value and, if it is, inserted in the newly created structure
as the value of that slot.
(The mnemonic idea of this symbol is as a sort
of "barrier" meaning \fIStop processing here!!! and take this
(almost) literally!!!\fR)  For example, after using
.DS
(create individual  PTrans  Ptrans23
	(Actor  John)
	(Object  John)
	(To  Home) )
.DE
to create an individual PTrans, leaving it in internal form in the
atom Ptrans23, you can then insert this PTrans into a new MTrans
with:
.DS
(create individual  MTrans
	(Actor  Bob)
	(MObject  !  Ptrans23)
	(To  Carol) )
.DE
.PP
At other times the user may want to take the result of evaluating
some Lisp code and splice it into the Lisp expression describing the
structure being created at the point where the description of the
value of a slot would occur.
In this case, you wish some Lisp code to be evaluated and then
you wish \fIcreate\fR to build a value for this slot
by further processing (scanning) the result of this evaluation.
To this end, PEARL will evaluate any slot value preceded by a
\fB"$"\fR and insert its result into the \fIcreate\fR call,
proceeding to process it just as if
the user had typed it in directly.
So if one stores the atom Alice in Name with
.DS
(setq  Name  'Alice) ; the atom Alice, not the symbol Alice
		     ;   (or the value of s:Alice).
.DE
or possibly
.DS
(setq  Name  (read) )
.DE
with the user having typed \fIAlice\fR, then \fI$  Name\fR in
.DS
(create individual  PTrans
	(Actor  $  Name)
	(Object  $  Name)
	(From  Home)
	(To  NewYork) )
.DE
is equivalent to having Alice typed as the Actor and Object
values: \fIcreate\fR evaluates Name and then processes its
value \fIAlice\fR as input.
Thus, the PTrans will be equivalent to
.DS
(create individual  PTrans
	(Actor  Alice)
	(Object  Alice)
	(From  Home)
	(To  NewYork) )
.DE
The power of this construct occurs when Name is a atom whose
value changes at run time (as when it is read above) or the
\fIcreate\fR call is within a loop in which Name takes on many
different values.
.PP
In summary, both ! and $ cause the evaluation of the Lisp
expression following them.
However, ! stops the usual processing and expects an
internal value, whereas $ continues the usual
processing and expects a Lisp description of the value.
When you need either ! or $, you will know it!
Until then, do not worry if you do not understand them very well!
.PP
If the expression you want evaluated is simply an atom
bound to a value of the appropriate type, you need not use the !.
Whenever \fIcreate\fR is looking for a value of a particular
type, and finds a bound atom instead, it evaluates the atom and
if it is bound to the correct type of value, that value is used.
This is only done in \fIsymbol\fR slots when the atom is not a
symbolname and in \fIinteger\fR slots if the atom is not from
the ordinal type (if any) associated with the slot.
.NH
More Flexible Hash Selection
.PP
The use of stars (asterisks *) to indicate useful slots for hashing
described earlier is only one of many hashing schemes that PEARL allows.
This section describes the others, and how the user can control them.
The first point to note is that even with the star hashing a single
structure can be hashed in several different ways.
Thus if one thinks that in a particular program PTrans will be
frequently fetched from the data base given only the
Actor \fBor\fR only the Object (that is, the program might only
know the Actor and desire the whole PTrans, or know only
the Object and desire the whole PTrans) the user should
star \fBboth\fR the Actor and Object slots within
the definition of PTrans.
When PEARL stores a PTrans into the data base, it will index
it under both (PTrans + Actor) and (PTrans + Object) in addition
to the usual indexing with all other PTranses.
In general, any number of slots can be starred.
.PP
Another type of hashing does not use the type of the structure in
creating a hash index.
If the symbol colon (:) is used before the
name of a slot, objects of that type will be hashed under that slot
value only.
Thus if the Actor slot of the PTrans definition was
preceded by a colon instead of a star, then instances of PTrans
would be hashed under the value of the Actor slot alone rather the
value of the (PTrans + Actor).
This would be useful in the case in which one were interested in
fetching any structure in which a particular value, say the
symbol John, appered in a coloned slot.
For example all structures in which John appeared in the Actor slot
could be fetched at once (and very efficiently).
.PP
A third type of hashing is \fBstar-star\fR or \fBdouble-star (**)
hashing\fR.
If a double star is used instead of a single star,
PEARL will use \fBtriple hashing\fR.
Only one triple hashing is allowed per structure.
Triple hashing requires that two, and only two slots be double starred.
If PTrans were to be defined in the following way:
.DS
(create base  PTrans
	(**  Actor  symbol)
	(**  Object  symbol)
	(      From  symbol)
	(      To  symbol) )
.DE
then when an instance of a PTrans is created, it will be hashed
into the data base under a combination of the three values
(PTrans + Actor + Object).
As with all hashing, if a slot is necessary to a particular type
of hashing but is unfilled (or filled with \fInilsym\fR or
\fInilstruct\fR) the hashing will not occur.
Triple hashing is used when one wants fast access to all
individuals of a particular type with two slots likely to have
fairly unique values.
In the case of PTrans, this would allow one fast access to all
PTranses in which John PTranses Mary somewhere.
Distinctions this fine are not usually necessary, and as it
is slightly more expensive at creation and fetching time,
it should only be used when the user is sure of the need for it.
.PP
A fourth type of hashing is \fBcolon-colon\fR or \fBdouble colon (::)
hashing\fR.
It has the same relation to colon hashing as double star
hashing has to star hashing.
If the **'s in the above are replaced with ::, the hashing will be
on (Actor + Object) ignoring the fact that the structure is a PTrans.
This might be useful in fetching all structures involving John and Mary.
As with double star hashing, double colon hashing should be used
sparingly and only one such hashing pair may be used in a type.
.PP
However, it is possible to combine the use of any of these
hashing methods in a single structure.
Thus one could have both double colon hashing and double star
hashing, as well as several * and : hashings as well.
Given several ways, PEARL uses the one
which the most complex one is used during
fetching, since that should provide the greatest degree of
discrimination between items (that is, most likely to narrow
down the choices).
If the value in a slot intended to take part in hashing is unbound
or otherwise not useful, then the next most specific method it used.
Given the values which are considered useful and the hashing
information for the type of structure, the hierarchy of buckets
to be chosen is as follows:
.DS
**  hashing
::  hashing
*  hashing
:  hashing
.DE
.PP
In section 9 we discussed a problem that arises when the pattern
you are using is more specific than the structures in the data base.
In this case, \fIfetch\fR looks in the data base in the most
specific place and does not find what it is looking.
One alternative is to eliminate the hashing that causes this problem
but this will force \fIfetch\fR to look through a large number of items.
If you do not intend to look all the way through the stream
returned by \fIfetch\fR, there is a version of fetch which will
build the stream out of all the ways the pattern could be fetched.
This function is called \fBfetcheverywhere\fR and will return a
stream made up of the (up to five) hash buckets that its pattern
could be -- potentially expensive if you intend to process the
whole thing.
.PP
In addition to these four methods of hashing, and the simplest one
based on the type of structure only, there are several
hashing labels which are modifiers on these methods and
affect what values are used to compute the index.
.PP
The remaining hashing flags do not introduce any new types
of hashing, but rather modify the way the existing types work.
To motivate these, consider the implementation of Goal withing CD.
In early versions of CD, there were several different types of
goals, including Delta-Prox (goal of being near something),
Delta-Poss (goal of possessing something), and so on.
In general these delta goals were of the form
(Delta-<some CD primitive> (Actor ...) (Objective ...) ).
This lead to an explosion of Delta-goals
(e.g. Delta-Move-Fingers-Within-Telephone-Dial),
and a new way of handling goals was established.
This was simply that all Goals were to have the form:
.DS
(create base  Goal
	(Planner  symbol)
	(Objective  struct) )
.DE
where the Objective would be filled with the appropriate structure,
whether it was a simple Poss or the $DialPhone script.
This change makes CD much cleaner, but poses somewhat of
a problem for hashing.
One of the major uses of hashing within some AI programs
written in PEARL is to associate plans with goals.
So it is best if this process is efficient.
.PP
As an example of this problem (using the early form of Delta-goals):
.DS
; Declaration of PlanFor rules.
(create base  PlanFor
	(*  Objective  struct)
	(*  Plan  struct) )
.DE
.DS
(create base  Delta-Prox
	(Planner  symbol)
	(Location  symbol) )
.DE
.DS
(create base  Walk-Plan
	(Planner  symbol)
	(From  symbol)
	(To  symbol) )
.DE
.DS
; Store in the data base the fact that walking is a way of accomplishing
;    a Delta-Prox goal.
(dbcreate individual  PlanFor
          (Goal  (Delta-Prox  (Planner  ?X)
			      (Location  ?Y) ) )
          (Plan  (Walk-Plan  (Planner  ?X)
 			     (From  nilsym)
 			     (To  ?Y) ) ) )
.DE
This structure simply says the fact that if one has a goal of being
somewhere, then one plan for doing this is to walk.
Or, using the rule in reverse, if you note that someone is
walking to some location, then you might infer that they had
a goal of being at that location.
Note that after being put into the data base, the rule can be easily
fetched by presenting either half of it as a pattern.
.PP
Thus if a planning program has a goal of doing the action in
the atom GoalAct, then it can query the data base for
any direct plans for doing Act by:
.DS
(fetchcreate individual  PlanFor
	     (Goal  !  GoalAct)
	     (Plan  ?*any*) )
.DE
So if GoalAct happened to be a Delta-Prox goal, then the
rule above would be fetched.
However the revised form of goals hides the unique nature of
the Delta-goal, and the best one could do is fetch all PlanFor rules
that have a structure of type Goal in their Goal slot.
This is a serious loss since \fIall PlanFors\fR have a Goal
in their Goal slot;
thus the system would have to look through all
PlanFors whenever it was trying to fetch one.
What is needed is a way of telling PEARL that when hashing on Goals,
never hash the structure type Goal, but rather use the
item that fills the Objective slot of the Goal.
This would solve our problem nicely, as now all
PlanFors would be hashed on the name of the Objective (Prox,
Dial-Phone, etc.), and a list of all PlanFors would not have to be
searched to find a particular one, rather the system could just hash
directly to it.
.PP
To indicate to PEARL that this \fBhash aliasing\fR is desired,
place an ampersand '&' before the slot name to be substituted
for the structure name when defining the structure.
Thus Goal would be declared:
.DS
(create base  Goal
	(    Planner  symbol)
	(&  Objective  struct) )
.DE
Naturally only one slot can be selected for hash aliasing.
.PP
In this way, Goals change the way in which other structures
use them to index but the way in which Goals themselves
are indexed will not be affected.
Since many other types of structures are likely to contain Goals,
we must be careful about how this affects the hashing of all of them.
It might be the case that PlanFor was the only structure
indexed based on Goals which would benefit from hash aliasing
and that some structures would actually be hurt by this
because they expected Goals to be only one of many types
of values.
In this case, putting the control of how Goals get used by
other structures into the definition of Goal is a bad idea.
Instead, the control can be moved up into only the
problematic structures.
These structures can simply add the \fB">"\fR hash label to
a starred slot, causing PEARL to use the first starred
slot of the slot-filling structure instead of its type.
For example, when we put a both \fB"*"\fR and \fB">"\fR on the Goal
slot of PlanFor then it will always use the first starred
slot of the Goal in its Goal slot:
.DS
(create base  Goal
	(    Planner  symbol)
	(*  Objective  struct))
.DE
.DS
(create base  PlanFor
	(*  >  Goal  struct)
	(        Plan  struct))
.DE
Thus, the use of \fB">"\fR hashing is called \fBforced aliasing\fR since
the structure filling a slot has very little control over it.
.PP
However, there is one way for a structure to affect
how forced aliasing happens.
If the user wanted to also star the Planner slot of Goal,
but wanted the Objective slot to be used in cases of forced
aliasing, then the use of an \fB"^"\fR on the Objective slot will
allow that:
.DS
(create base  Goal
	(*       Planner  symbol)
	(*  ^  Objective  struct))
.DE
thus allowing Goals inserted directly into the data base to be
indexed by the combinations \fIGoal + Planner\fR and
\fIGoal + Objective\fR while other objects containing Goals would
use the Objective slot rather than Goal \fIOtherObject + Objective\fR.
.PP
On the other hand, if most structures containing Goals would
benefit from the use of the hash aliasing label \fB"&"\fR in Goal,
but only one or two are hurt by it, the use of \fB"&"\fR in Goal
can be overridden by the structures which will contain Goals
by adding the \fB"<"\fR hash label to the starred slot to produce
\fBanti-aliasing\fR.
This gives the controlling structure the last word
over how it is hashed.
.DS
(create base  Goal
	(    Planner  symbol)
	(&  Objective  struct))
.DE
.DS
(create base  OffendedStructure
	(*  <  Slot  struct))
.DE
Thus, the anti-aliasing \fB"<"\fR means \fIjust for this hashing, turn
off hash aliasing (if any) of any structure filling this slot\fR.
.PP
The proper use of hash aliasing and anti-aliasing,
like all the hashing specifiers is an art that must be learned by
applying them to real systems, and the correct hash directives
for a particular system rely critically upon the statistics of
that particular system operating upon a particular set of data.
The hashing mechanism was designed to give the user benefit in
proportion to the effort expended in determining hash labels.
With no effort, the structure type provides some help.
With the addition of each label or pair of labels,
an item to be inserted into the data base is indexed into
another location in the hash table.
Thus the cost of \fIextra\fR labels is simply the time to
find another hash bucket (a few adds and multiplies), and add
the item to the front of the list implying the time and
space incurred by one cons-cell.
.NH
Using Predicates to Constrain Fetching
.PP
Sometimes when you are creating a pattern to fetch a structure,
giving the overall form of the structure is not specific enough.
In particular, it is often desirable to restrict the value of a
slot to a subrange.
For example, using the structure Health:
.DS
(create base  Health
	(Actor  symbol)
	(Level  int) )
.DE
one might want to find out who is sick by creating a pattern
that only matches those Health structures in which the Level
is less than -1 (on a scale from -10 to 10 perhaps).
This can be done by simply writing a predicate (say Sick)
which expects to be given the value of the slot being matched
against as its one argument:
.DS
(de Sick  (Num)
    (lessp  Num  -1) )
.DE
Then you simply add its name after the value
within the <slotname filler> pair of the pattern:
.DS
(create pattern  Health  HealthPattern
	(Actor  ?Person)
	(Level  ?Level  Sick) )
.DE
Given these definitions, a (fetch HealthPattern) would pass
the Level slotfiller of each Health structure it
found in the data base to the predicate Sick.
If Sick returned true (non-\fInil\fR) then it would
consider the slot to have matched whereas a
\fInil\fR from Sick would be considered a mismatch.
There are no standard predicates for users to use for these
purposes, but they are relatively easy to create as needed.
.PP
However, one often has a predicate which has more than one
argument only one (or none) of which are the slot value.
For example, one might want to include a special variable
or the value of some other slot of the structure or the
structure itself.
To make this easy PEARL allows predicates to be arbitrary
s-expressions which may contain any of several special forms
for which PEARL substitutes the current slot or structure.
.PP
If a predicate includes an asterisk \fB*\fR, this is replaced by
the value of the current slot (in the structure being matched
against).
If it includes a double asterisk \fB**\fR, this is replaced
by the whole structure being matched against.
If you want the value of another slot in the current structure,
precede its name with an equal sign (as in \fB=SlotName\fR to
have the value of the slot named SlotName inserted).
There is a readmacro \fB"="\fR which converts \fI=S\fR into 
\fI(*slot* S)\fR, just as the readmacro \fB"?"\fR converts ?X into
\fI(*var* X)\fR (or \fI(*global* X)\fR) for pattern-matching variables.
While processing predicates before executing them, PEARL will
look for these three constructs and replace any of them with the
appropriate value, so pattern-matching variables can also be
used in predicates.
.PP
If there are several predicates on a slot, they are run in
succession until one returns nil or they have all been run.
Thus, a list of predicates provides the effect of a conditional
\fIand\fR.
Thus, although PEARL knows nothing special about logical
connectives like \fIor\fR and \fIand\fR, the effect of a
the usual Lisp \fIand\fR is automatically implied and
the conditional \fIor\fR of Lisp can be had by using the
s-expression type of predicate.
If you wish things to run regardless of their results,
providing the effect of unconditional \fIand\fR, use hooks (demons).
.PP
The above was one of two types of predicates available.
To motivate the other type, consider the case of wanting
to fetch all MTranses about the occurence of a PTrans.
This could be accomplished in one of two ways.
The first is:
.DS
; In this pattern example, all slots are automatically filled
;     with ?*any* except the MObject which must be a PTrans.
(create pattern  MTrans
	(MObject  (PTrans) ) )
.DE
Since this method actually results in \fI?*any*\fR being
matched against the fillers in each of the PTrans's
slots, it is a bit inefficient.
.PP
The second way uses \fBstructure predicates\fR
to avoid this matching by specifying merely that the filler
of the MObject slot must be a PTrans structure.
This is done by listing the name of a previously
defined structure after a pattern-matching variable:
.DS
(create pattern  MTrans
	(MObject  ?Obj  PTrans) )
.DE
PEARL will then bind Obj to any structure that is a PTrans
(or expanded PTrans) and match successfully without
examining any of the slots of that PTrans.
PEARL can tell the difference between these two types of
predicates since one will have some sort of function declaration
and the other will be the name of a defined structure.
In the case of a function with the
same name as a structure (which the user should never do as it
invites errors) the name's structure role takes precedence.
.PP
Since a similar effect is sometimes desired on slots of type
\fIsymbol\fR, a similar but more complex mechanism is provided
with symbols and with structures which failed the above test.
If the name of a predicate on a slot of type symbol or structure
is the name of a type of structure, PEARL will assume that what
you want to know about the value in this slot is whether there
is anything in the data base of the type specified by the structure
predicate with the slot value in its first slot.
Thus, if the data base contains an item saying that the symbol
John represents a person:
.DS
(symbol  John)
(dbcreate individual  Person
	  (Identity  John))
.DE
then fetching a pattern with a symbol slot which has a Person
predicate on it:
.DS
(fetchcreate pattern  Thing
	     (Slot  ?X  Person))
.DE
will cause the equivalent of a fetch from the (default) data base
of the pattern (Person (Identity John)).
Note that this implies that the first slot of a structure enjoys
somewhat of a pre-eminence and that this means that one should
carefully choose which slot to put first.
For efficiency however, \fIfetch\fR is not actually used.
The function actually used is \fBdisguisedas\fR which expects
the slot filler, the structure definition (not default instance)
and an optional data base to look in.
Slot filler may be either a symbol or structure.
.PP
This second type of predicate can also result in a kind of
inefficiency which you might like to avoid.
By putting a variable in the MObject slot of the MTrans along with
a PTrans structure predicate, we preclude PEARL from hashing the
object in any useful way, forcing it to look through all MTranses
instead of only MTranses with PTranses in their MObject slot.
Since patterns are most often less specific than the objects in
the data base, this can make a big difference.
Another problem with a variable plus a structure predicate is that the
structure predicate is either based on fetches and the first slot or it
is limitted to matching the type only.
We might sometimes want a more complicated structure to be used
as a predicate.
However, if we opt instead for the more efficient fetching and
matching by putting a structure in the slot, we have lost the
ability to have a variable bound during the match.
.PP
To allow you both to help improve the hashing and matching of a
structure and also to bind a variable as a side effect, PEARL
provides a mechanism to attach an \fBadjunct variable\fR to the slot.
This adjunct variable in a slot is bound as a side effect whenever the
values in the slot of the two structures were already bound, have
already been matched successfully and all predicates and slot hooks
have been run.
Adjunct variables may be local, lexically scoped or global, just
as any other variable.
To use an adjunct variable, include the variable \fIafter\fR the
value preceded by a colon and preceding any predicates or slot hooks.
For example, 
.DS
(create pattern  MTrans
	(MObject  (PTrans  (Actor  John) )  :  ?Obj) )
.DE
would match any MTrans about John PTransing something, and also
bind the adjunct variable ?Obj to the actual PTrans structure
that applied.
.PP
Since PEARL uses hunks to create so many types of values of its
own, it also provides a set of predicates to test an item to see
what type it is.
Many of them are quite definitely kludges since they depend upon
certain bizarre structures existing only in PEARL-created items
and not in user-created items and thus should not be depended
upon totally.
These functions are \fBstreamp\fR, \fBdatabasep\fR, \fBblockp\fR,
\fBdefinitionp\fR, \fBpsymbolp\fR (to distinguish from Franz Lisp
\fIsymbolp\fR), \fBstructurep\fR,
\fBsymbolnamep\fR, and \fBstructurenamep\fR.
.NH
More Useful Slot Types
.PP
These last few examples begin to show the restricted nature of basic
integer values and of labelling slots as being of type \fIstruct\fR.
If the values in an integer slot will range between -10 and 10,
then you would like to say that.
If the values which will fill a slot of type structure will
be Events or Acts or States, you would like to specify that.
PEARL provides mechanisms to fill both of these needs.
.PP
In the case of an integer slot to be filled with values from a range
of -10 to 10, these integer values do not represent "levels of health"
very well either.
Rather than saying that a person's "health level"
is -2, you might like to say it was "Sick".
In fact, you would
probably like to say that the values of the slot will be one from
among the set of values "Dead, Critical, Sick, OK, Healthy and InThePink".
Moreover, you might like to specify that these values are to be
associated with integer values in such a way that the ordering
you specified holds and you may or may not want to specify precisely
what integer values should be associated with these atoms.
In other words, you would like a type which consists of a set of
values with a linear ordering on them, similar to the Pascal scalar or
enumeration type.
.PP
Such a type exists in PEARL and is created by a call to
the function \fBordinal\fR.
For example, to create an ordered set of values to represent
levels of various states when you want the actual
integer values to be created by PEARL, you would say:
.DS
(ordinal  Levels  (Low  Middle  High))
.DE
which would associate the numbers 1, 2, and 3 with Low, Middle and
High respectively.
If you want to specify the values to be associated with each name,
you simply list the value after each name.
Thus, to create a set of values for use in the integer Level
slot of Health above, you might say the following (the values need
not be listed in order):
.DS
(ordinal  HealthLevels  (Dead -10  Critical -6  Sick -2  OK 2
				   Healthy 6  InThePink 10))
.DE
Among the actions that \fIordinal\fR performs are the following:
.IP 1.
The assoc-list of names and values for the ordinal type can be
accessed by evaluating the atom built by prepending \fBo:\fR to
the name of the ordinal type.
Given the name of an ordinal type, the function \fBordatom\fR builds
this atom.
Thus \fIo:Levels\fR contains (and \fI(eval (ordatom 'Levels))\fR returns)
the value \fI((Low . 1) (Middle . 2) (High . 3))\fR.
.IP 2.
Atoms consisting of the name of the ordinal type concatenated
with a colon and the value name are created and set to the value
they represent.
Thus \fILevels:Low\fR is set to 1, \fILevels:Middle\fR is set to 2, etc.
.IP 3.
Two atoms with \fB:min\fR and \fB:max\fR concatenated to the
name of the ordinal type are created and set to the lowest
and highest integer values in the type.
Thus \fIHealthLevels:min\fR is -10, and \fIHealthLevels:max\fR is 10.
.IP 4.
The name of the ordinal type is added the list of all ordinal type
names kept in the special variable \fB*ordinalnames\fR*.
.IP 5.
The name of the ordinal type is stored with the slot
so that the print functions can convert from the
integer value back into the name.
Since the default value for integers is zero but most
ordinals will not have a zero value, the print functions will
print \fB*zero-ordinal-value*\fR instead of zero.
.PP
Having created an ordinal type, it is then possible to declare in
a structure definition that a slot will contain values of that type.
The use of values from this type is \fBnot enforced\fR
by PEARL but allows the definitions of integer slots to be
more readable, allows the use of the names of values instead
of their associated integers when creating individuals and
allows PEARL to print the more readable information when
printing an integer slot.
The special atoms created allow predicates, hooks (demons) and
other functions to refer to these values without knowing
their associated integers.
We can now redefine Health to use HealthLevels:
.DS
(create base  Health
	(Actor  symbol)
	(Level  HealthLevels) )
.DE
and create an individual which says that John is in
the pink of health:
.DS
(create individual  Health
	(Actor  John)
	(Level  InThePink) )
.DE
.PP
Declaring a slot to be of type \fIstruct\fR is similarly
unenlightening, so PEARL will accept the name of a
structure type in its place.
For example, we can make the following definitions:
.DS
(create base  Person
	(*  Identity  symbol) )
(create base  Health
	(Actor  Person)
	(Level  HealthLevels) )
.DE
and the Actor slot of Health will be of type \fIstruct\fR.
However, there is currently no extra type checking implied
by this declaration (although it is being considered), but
again it improves the readability of declarations tremendously.
.NH
Attaching Hooks to Structures (If-Added Demons)
.PP
A fairly old construct within AI is that of demons.
In their pure form they could be thought of as asynchronous
parallel processes that watch everything going on within a
system, lying in wait for a particular set of conditions to occur.
These conditions might be a block-manipulating program stacking
some blocks too high to be stable, or a data base program violating
a consistency constraint.
The main problem with classical demons was that in their most flexible
form they gobble up far too much system time, as well as being very
hard to program as it was hard to see just when they might pop up
during the execution of a program.
.PP
In an attempt to control the implementation of demons and at the same
time provide the user with increased control over the built-in PEARL
functions, PEARL allows the user to attach pieces of code to
structures that will be run when specific PEARL (or user) functions
access particular types of data or pieces of data at particular
places in the code.
Thus, PEARL provides a general but restricted and fairly efficient
ability to control the operation of specific functions on specific
pieces of data by providing \fBhooks\fR in the PEARL functions
which check for requests within structures that certain functions
be run when they are accessed in certain ways.
Thus PEARL has two useful sub-breeds of \fBhooks\fR which
watch over either
.IP a.
the value of a particular slot of a particular individual structure,
referred to as \fIslot hooks\fR.
.IP b.
operations upon all individuals of a particular base structure type
referred to as \fIbase hooks\fR.
.PP
Like predicates, hooks can either be the name of a function to
run or a Lisp s-expression to be evaluated.
If an s-expression, they can include the special forms 
\fB**\fR representing the current structure or \fB*\fR representing
the value of the current slot on slot hooks and of the current
structure on base hooks.
Variables or slot names preceded by \fB=\fR are also allowed
(just as in predicates), referring to variables or slots in
the current structure.
If hooks are run by functions which take two items as arguments,
like \fImatch\fR, then the special form \fB>**\fR may
be used to represent the \fBother\fR structure (which \fB>\fR is
meant to suggest) and \fB>*\fR may be used for the value in this
slot of the other structure.
(In the case of functions of only one argument, \fI>*\fR and
\fI>**\fR are the same as \fI**\fR and \fI*\fR.)
In functions which take two arguments, the special form \fB?\fR
may be used to represent the result that the function intends to
return.
(This will be \fI*pearlunbound*\fR in hooks which run before the
function has done its job.)
.PP
When hooks run in the context of a call to \fIpath\fR,
two special variables are available: \fB*pathtop*\fR which
is the topmost structure passed to path and \fB*pathlocal*\fR
which is the current innermost structure whose slot is
being accessed.
When hooks are run in the context of a call to a function which
deals with a data base, then the special variable \fBdb\fR
will contain the data base currently being used.
.PP
The functions used to fill in the special forms like *, **, =slot,
and variables before evaluation come in two flavors and are
called \fBfillin1\fR and \fBfillin2\fR.
\fIFillin1\fR is designed for hooks which run on single structures
and expects as arguments:
.IP a.
the function (s-expression) to fill in,
.IP b.
the slot value (or item if a base hook) to use for \fI*\fR,
.IP c.
the structure to use for \fI**\fR, and
.IP d.
the definition for the item provided as the third argument
(for interpretation of \fI=slot\fR forms).
.PP
\fIFillin2\fR is designed for hooks which run on two structures and
produce a result and expects as arguments:
.IP a.
the function (s-expression) to fill in,
.IP b-c.
the slot values (or structures if a base hook) to use for \fI*\fR and \fI>*\fR,
.IP d-e.
the structures to use for \fI**\fR and \fI>**\fR,
.IP f.
the definition for the structure provided as the fourth argument, and
.IP g.
the result the function intends to return to use for \fI?\fR.
.PP
Four functions for running hooks are provided for the user, two
for running slot hooks and base hooks for single items and two for
running slot hooks and base hooks for pairs of items.
\fBRunslothooks1\fR expects to be given the invoking function's
name, the structure and name of the slot on which to run the slot
hooks, and the value to be used for \fI*\fR.
\fBRunslothooks2\fR expects to be given the invoking function's
name, the two structures and name of the slot in them on which to
run the slot hooks, and the values to be used for \fI*\fR and \fI>*\fR.
\fBRunbasehooks1\fR expects to be given the invoking function's name
and the structure whose base hooks are to be run.
\fBRunbasehooks2\fR expects the invoking function's name, the two
structures whose base hooks are to be run and the result the
calling function plans to return.
.PP
If present, base hooks are run by most major PEARL functions.
If a base hook is labelled with \fI<foo\fR then the function
\fIfoo\fR will execute the hook just after entry and whatever
initialization is necessary.
If a base hook is labelled with \fI>foo\fR then the function \fIfoo\fR
will execute the hook just before exitting.
Slot hooks are run by most major PEARL functions which look through
the slots of a structure.
If a slot hook is labelled with \fI<foo\fR then the function \fIfoo\fR
will execute the hook just before processing the slot.
If a slot hook is labelled with \fI>foo\fR then the function \fIfoo\fR
will execute the hook just after processing the slot.
.PP
However, hooks can be turned off selectively or completely.
By setting the atoms \fB*runallslothooks*\fR and
\fB*runallbasehooks*\fR to nil, you can completely disable
the running of all hooks.
This is useful for debugging and also helps improve efficiency
a bit if you do not use hooks at all.
There is also an atom to go with each PEARL function (of the form
\fB*run...hooks*\fR) which can be used to disable hooks for selected
functions.
The following is a complete table of what PEARL functions run hooks
and the names of the labels that invoke them and the atoms that
control their running:
.LD
Base hooks are run by:			\kminvoked by hooks labelled:
    create expanded			\h'|\nmu'<expanded or >expanded 
    create individual			\h'|\nmu'<individual or >individual 
    create pattern			\h'|\nmu'<pattern or >pattern 
    smerge				\h'|\nmu'<smerge or >smerge 
    nextitem				\h'|\nmu'<nextitem or >nextitem 
    standardfetch *			\h'|\nmu'<fetch or >fetch 
    expandedfetch *			\h'|\nmu'<fetch or >fetch 
    fetcheverywhere *			\h'|\nmu'<fetch or >fetch 
    insertdb				\h'|\nmu'<insertdb or >insertdb 
    removedb				\h'|\nmu'<removedb or >removedb 
    nextequal				\h'|\nmu'<nextequal or >nextequal 
    indb				\h'|\nmu'<indb or >indb 
    standardmatch			\h'|\nmu'<match or >match 
    basicmatch				\h'|\nmu'<match or >match 
    strequal				\h'|\nmu'<strequal or >strequal 
_________
* \fIfetch\fR does not run hooks on function structures.
.sp 2
Slot hooks are run by:			\h'|\nmu'invoked by hooks labelled:
    standardmatch			\h'|\nmu'<match or >match
    basicmatch				\h'|\nmu'<match or >match
    strequal				\h'|\nmu'<strequal or >strequal
    path put				\h'|\nmu'<put or >put
    path clear				\h'|\nmu'<clear or >clear
    path addset				\h'|\nmu'<addset or >addset
    path delset				\h'|\nmu'<delset or >delset
    path addpred			\h'|\nmu'<addpred or >addpred
    path delpred			\h'|\nmu'<delpred or >delpred
    path get				\h'|\nmu'<get or >get
    path getpred			\h'|\nmu'<getpred or >getpred
    path gethook			\h'|\nmu'<gethook or >gethook
    path apply				\h'|\nmu'<apply or >apply
.sp 2
Hooks of both kinds are controlled by these atoms, initially t:
    *runallslothooks*  -- controls all slot hooks.
    *runallbasehooks*  -- controls all base hooks.
    *runputpathhooks*			\h'|\nmu'*runclearpathhooks*
    *runaddsetpathhooks*		\h'|\nmu'*rundelsetpathhooks*
    *runaddpredpathhooks*		\h'|\nmu'*rundelpredpathhooks*
    *rungetpathhooks*			\h'|\nmu'*rungetpredpathhooks*
    *rungethookpathhooks*		\h'|\nmu'*runapplypathhooks*
    *runmatchhooks*			\h'|\nmu'*runsmergehooks*
    *runindividualhooks*		\h'|\nmu'*runexpandedhooks*
    *runpatternhooks*			\h'|\nmu'*runnextitemhooks*
    *runfetchhooks*			\h'|\nmu'*runinsertdbhooks*
    *runremovedbhooks*			\h'|\nmu'*runindbhooks*
    *runnextequalhooks*			\h'|\nmu'*runstrequalhooks*
.DE
.PP
It is likely that hooks attached to a particular function would like to run
the same function in such a way that hooks will not be invoked.
Or in general, it is possible that you will want to run some PEARL function
in such a way that it is "hidden" from hooks.
To make this easy, a macro is provided called \fBhidden\fR which temporarily
sets the atom \fI*run...hooks*\fR to nil, runs a command and then restores
the former value of that atom.
For this to work correctly, you \fBmust\fR invoke the function you wish hidden
with the name corresponding to the "..." in its \fI*run...hooks*\fR atom.
Thus, you can hide the creation of an individual from hooks by executing:
.DS
(hidden (individual PTrans ....) )
.DE
(see Section 27 for the macro \fIindividual\fR) but \fBnot\fR by executing:
.DS
(hidden (create individual PTrans ....) )
.DE
A parallel function \fBvisible\fR temporarily sets the associated
atom to \fIt\fR before evaluating the function.
.PP
One of the reasons that hooks are checked for both before and after
a PEARL function does its job is to provide the user with the
opportunity to affect the result of the particular task.
In the simplest case, a hook simply executes a piece of code
and does not directly affect the function it is labelled with.
However, if the value returned by a hook is a list whose \fIcar\fR
is either \fB*done*\fR, \fB*fail*\fR, and \fB*use*\fR, then the action
of that function will be modified.
If the result of a hook which runs before the task starts with
\fI*done*\fR, then the hook is presumed to have accomplished what the
PEARL function was supposed to have done and the function will return
immediately with the \fIcadr\fR of the hook's result if there is
one, or else with the structure being operated on (for base hooks)
or the value in the slot (for slot hooks).
If the result of a hook which runs after the task starts with
\fI*done*\fR, then the function will return immediately with the
\fIcadr\fR of the hook's result if there is one, or else with
the result that was going to be return anyway.
.PP
If the result of a hook which runs before the task starts with
\fI*fail*\fR, then the hook is presumed to have determined that the
PEARL function should quit and the function will return
immediately with the \fIcadr\fR of the hook's result if there is one,
or else with the atom \fI*fail*\fR.
If the result of a hook which runs after the task starts with
\fI*fail*\fR, then the function will return immediately with the
\fIcadr\fR of the hook's result (which may be nil).
.PP
If the result of a hook which runs before the task starts with
\fI*use*\fR, then the hook is presumed to have determined that the
PEARL function should use a different value instead of the originally
provided one and the function will use the \fIcadr\fR of the hook's
result for the rest of the task.
If the result of a hook which runs after the task starts with
\fI*use*\fR, then the function will replace its intended result with
the \fIcadr\fR of the hook's result (which may be nil).
Thus, for example, a slot hook labelled with \fI<match\fR can
short-circuit the matching of a slot and one labelled with
\fI<match\fR can reverse the decision made by matching of a slot.
Similarly, a base hook labelled with \fI<match\fR can use its own matching
algorithm and one labelled with \fI>match\fR can modify the result of the
whole match.
.PP
Obviously, these all should be used with great care.
Note that \fIreturn immediately\fR means without even running
any other slot hooks on that slot for slot hooks or without
running any other base hooks on that structure for base hooks.
.PP
For example consider the case of a structure representing someone's
order in a Chinese restaurant.
As items are added to the order, it would be nice if there was a
magical slot TotalBill that contained the current
running total of the cost of the items ordered.
Demons, being such magical creatures, fill the bill nicely.
However, we only wish to have our demon-like hooks
activated when particular slots are filled (added to or accessed).
First consider the simple case in which an order consists of
three items only, the name of the soup and one or two entrees:
.DS
(create base  Chinese-Food-Entree
	(Name  lisp)
	(Price  int) )
.DE
.DS
(create base  Chinese-Dinner-Order
	(Soup  Chinese-Food-Entree)
	(Entree1  Chinese-Food-Entree)
	(Entree2  Chinese-Food-Entree)
	(TotalBill  int) )
.DE
.DS
(create individual  Chinese-Food-Entree
	(Name  (Hot And Sour Soup) )
	(Price  323) )
.DE
.DS
(create individual  Chinese-Food-Entree
	(Name  (Sizzling Rice Soup) )
	(Price  349) )
.DE
.DS
(create individual  Chinese-Food-Entree
	(Name  (Lingnan Beef) )
	(Price  399) )
.DE
.DS
(create individual  Chinese-Food-Entree
	(Name  (Mandarin Chicken) )
	(Price  367) )
.DE
.DS
(create individual  Chinese-Food-Entree
	(Name  (Shrimp Cantonese) )
	(Price  479) )
.DE
.DS
; an undetermined meal is created.
(create individual  Chinese-Dinner-Order Meal
	(Soup  ^  if  >put  (Maintain-Total  *  **  =TotalBill) )
	(Entree1  ^  if  >put  (Maintain-Total  *  **  =TotalBill) )
	(Entree2  ^  if  >put  (Maintain-Total  *  **  =TotalBill) )
	(TotalBill  0) )
.DE
Note that a slot hook is put after the value in a slot by using
the word \fBif\fR (or \fBhook\fR) followed by the appropriate label
for the invoking function followed by the function name or
s-expression to be evaluated.
Note also that when you want to put hooks on slots of an individual but
do not want to specify a value, the use of \fB"^"\fR will instruct
\fIcreate\fR to copy the default value instead.
If the Maintain-Total function is properly specified, whenever
one replaces one of the food slots with a real dish using
the \fIputpath\fR function, the Maintain-Total function would be
activated and would add the price of that meal to the running total
in the TotalBill slot.
If one changed one's mind a lot, it would be necessary to include
another hook Remove-Price which would be activated by a \fIclearpath\fR.
This would require adding the \fIif-cleared\fR hook
\fI"if >clear Remove-Price"\fR after the \fIif-put\fR hook:
.DS
(create individual  Chinese-Dinner-Order  ChangingMeal
	(Soup  ^  if  >put  (Maintain-Total  *  **  =TotalBill)
	          if  >clear  (Remove-Price  *  **  =TotalBill) )
	(Entree1  ^ if  >put  (Maintain-Total  *  **  =TotalBill)
		    if  >clear  (Remove-Price  *  **  =TotalBill) )
	(Entree2  ^ if  >put  (Maintain-Total  *  **  =TotalBill)
		    if  >clear  (Remove-Price  *  **  =TotalBill) )
	(TotalBill  0) )
.DE
The code for the two hooks follows:
.DS
(de Maintain-Total  (Food  Meal  CurrentMealTotal)
    (putpath  Meal  '(TotalBill)
	      (*plus  CurrentTotal
		      (getpath  Food  '(Price) ) ) ) )
.DE
.DS
(de Remove-Price  (Food  Meal  CurrentMealTotal)
    (putpath  Meal  '(TotalBill)
	      (*plus  CurrentTotal
		      (getpath  Food  '(Price) ) ) ) )
.DE
.PP
A more flexible meal order structure would not have three slots
for food, but rather a single slot of type \fIsetof struct\fR.
Then entries would be added by the \fIaddsetpath\fR functions,
and the \fIif-put\fR hook would be an \fIif-addset\fR hook but the
code would essentially be the same.
.PP
To attach a base hook to a structure, the first "slot" in its definition
must start with one of the atoms \fBif\fR or \fBhook\fR.
The rest of the slot must then contain a sequence of labels for invoking
functions and function names or s-expressions to be evaluated.
For example, to invoke \fIvalprint\fR before and a user function called
\fIverify\fR afterwards whenever a PTrans is inserted into the data base,
you would define PTrans as follows:
.DS
(create base  PTrans
	(if <insertdb (valprint * 5)
	    >insertdb (verify *))
	(* Actor  symbol)
	(   Object  symbol)
	(   From  symbol)
	(   To  symbol) )
.DE
.PP
Recall that PEARL provides a print function called \fBfullprint\fR
which for most structures seen so far printed two extra \fInil\fRs
in each slot.
If a slot has predicates, the first \fInil\fR will be replaced by
a list of them.
If the slot has hooks, the second \fInil\fR will be
replaced by a list of cons-cells with the invoking function in the
\fIcar\fR and the hook in the \fIcdr\fR.
.PP
The invocation of hooks labelled with other forms of \fIpath\fR are similar
except for \fIapply\fR.
If \fI(path <apply Fcn ...)\fR or \fI(path >apply Fcn ...)\fR is executed,
then any hooks which are labelled with Fcn will be run.
.PP
At this point the syntax of a slot in a definition or individual has become
quite complicated, so we summarize with the following BNF grammar:
.DS
{ a b c }	means select one of a, b, or c.
[ XXX ]		means optionally XXX.
XXX *		means zero or more XXX's
x | y		means x or y
.DE
.ID
<BaseSlot> ::=  (
		<HashLabels>
		<SlotName>
		<SlotType>
		<InheritOrValue>
		<AdjunctVariable>
		<PredicatesAndHooks>
		)
<IndividualSlot> ::=  (
		      <SlotName>
		      <InheritOrValue>
		      <AdjunctVariable>
		      <PredicatesAndHooks>
		      )
<ExpandedSlot> ::= <BaseSlot> | <IndividualSlot>
.sp 1
<HashLabels>  ::=  { "&" "^" "*" "**" ":" "::" ">" "<" } * 
<SlotType>  ::=  { "struct" "symbol" "int" "lisp" }  |
		 "setof" <SlotType>  |  <OrdinalName>  |
		 <StructureName>
<InheritOrValue>  ::=  <Value>  |  "^"  |  "nil"  |
                     "==" <Value>  |  ":=" <Value>
<Value> ::= <integer>  |  <atom>  |  <list>  |  <Variable>
<AdjunctVariable>  ::=   [ ":" <Variable> ]
<Variable>  ::=  ?<atom>
<PredicatesAndHooks>  ::=  { <Predicate>  |  <Hook> } *
<Predicate>  ::=  <StructureName>  |  <S-Expression>
<Hook>  ::=  "if" <atom> <HookFunction>
<HookFunction>  ::=  <atom>  |  <S-Expression>
.DE
.NH
Creating and Manipulating Multiple Data Bases
.PP
Without any effort on the user's part, a single data base of a
default size exists in PEARL when it starts up.
It is called \fB*maindb*\fR and is pointed to by the special
variable \fB*db*\fR which is assumed by all functions which use a
data base to point to the default data base (that is, the data
base to be used when an expected data base argument is missing).
.PP
To build another data base, choose a name for it and call the
function \fBbuilddb\fR which is an nlambda (fexpr) expecting
the name of the new data base.
You may build as many as you wish and store whichever one you want
in \fI*db*\fR.
.PP
Sometimes one may wish to clear out the data base and start out with a
clean slate.
To make this easy, there is a special function \fBcleardb\fR
which expects either zero or one data bases as arguments
and does the job.
If it receives no arguments, then the default data base is cleared.
\fICleardb\fR removes everything from the data base,
but does not actually delete (or reclaim the storage space of) the
objects within the data base.
But if the objects inside are not pointed to by any program
variables, they are gone for good.
(\fICleardb\fR clears out \fIonly\fR the named data base and not
data bases that it may be built upon as described in the next section.)
.PP
Data bases contain two parts, referred to as \fIdb1\fR and \fIdb2\fR.
\fIDb1\fR contains items which are indexed under only their type
or using single-colon hashing.
Its default size is 29.
\fIDb2\fR contains items which are indexed under two or three
values.
Its default size is 127.
These sizes are chosen to be prime numbers which are just barely
smaller than a power of two.
(This choice was made to take full advantage of hunks in Franz Lisp
which are always allocated to be a power of two.)
The ratio between the two sizes is approximately 1 to 4.
The size for data bases may be chosen by specifying the
power of two that you wish \fIdb2\fR to close to.
.PP
The function \fBsetdbsize\fR expects an integer between 2 and 13
representing the power to which two should be raised.
The default data base size is thus the result of calling
\fIsetdbsize\fR with an argument of 7.
To change the default size, you should call \fIsetdbsize\fR
in your \fI.init.prl\fR file, before creating any data bases of your
own.
\fISetdbsize\fR rebuilds \fI*maindb*\fR (without putting
anything into the new one) and releases all other data bases.
Thus, it should not \fInormally\fR be used at any time after the
processing of the \fI.init.prl\fR file.
(In the Franz Lisp version, although this full range of values is
accepted, the largest a data base in the 1 to 4 ratio can be
is 29 + 127 since hunks are limitted to 128 words.
However, an argument of 9 to \fIsetdbsize\fR will set the sizes
of both data bases to 127.)
Related special variables are \fB*db1size*\fR and
\fB*db2size*\fR which are set by \fIsetdbsize\fR and
\fB*availablesizes*\fR which contains the assoc-list used
to associate the power of two to a size.
.NH
Creating a Forest of Data Bases
.PP
Although having multiple data bases which are unconnected is often
enough, it is sometimes convenient to build onto an already
existing data base in a tree-like fashion.
For example, in a story understanding program, one might want
to have the default data base containing long-term knowledge
and then add a data base to contain the knowledge specific to a
particular story being processed.
In large applications, it can also help to split up special kinds
of knowledge to improve efficiency even more than PEARL's hashing
already does.
With only the ability to build separate data bases, searching for
a fact which might be either general knowledge or specific
knowledge learned from the story would require two fetches, one
from each data base.
However, if the story data base is built on top of the main data
base then simply fetching an item from the story data base will
also include fetching from the main data base.
To build another data base upon an existing one, use the function
\fBbuilddb\fR with two arguments, the name of the new data base
and the name of the old one to build onto:
.DS
(builddb  *story*  *maindb*)
(builddb  *future*  *maindb*)
.DE
These two statements will build two data bases on top of the main
one such that fetching from *story* will look both in it and in
*maindb* but not in *future*.
You can then build further upon any of these if you wish.
Note however, that the second argument must be \fIthe name of the
data base to build upon\fR and cannot be \fI*db*\fR to build upon
the default data base.
Also, if the second argument is missing, then the new data base is
isolated, not built on top of the default data base.
.PP
If your program builds many data bases, it is likely that some of
them will be temporary ones.
If this is so, it is possible to release a data base so that the
space can be garbage collected or reused for a later data base.
To release a data base, pass the actual data base (not its name)
to the function \fBreleasedb\fR.
If the data base is not a leaf of the data base tree, then the
space will not actually be released until all its children
are released also but PEARL will no longer accept it as a data
base argument.
.PP
A list of the names of the currently active data bases is
maintained by PEARL in the special variable \fB*activedbnames*\fR.
.NH
Creating Expanded Subtypes of Previously Defined Objects
.PP
Within CD, as in many applications, you may have many different structures
with some slots with the same name.
PEARL allows this, as it can always tell which type of structure
you are using, and thus it behaves just as if you had used
unique names for all slots.
But sometimes the fact that two different structure types have
slots with the same names is more than a coincidence:
there may be various semantic similarities
between the similar parts of the two structures.
PEARL has a mechanism for creating such structures using the
\fBexpanded\fR selector to \fIcreate\fR.
Basically, you must first define a base structure that contains
all the identical parts of two or more structures, and then you
must define the structures themselves as \fIthe base plus the differences\fR.
A good example of this from CD involves Acts.
All Acts within CD have an Actor slot, and all of
these slots have the same meaning.
That is, whatever is going on, the person in the actor slot is the
motivating force.
So we may first define this common part as a normal
base structure:
.DS
(create base  Act
	(*  Actor  symbol) )
.DE
and then we can define the various acts as expansions upon this base:
.DS
(create expanded  Act  PTrans
	(Object  symbol)
	(From  symbol)
	(To  symbol) )
.DE
.DS
(create expanded  Act  MTrans
	(MObject  struct)
	(From  symbol)
	(To  symbol) )
.DE
.DS
(create expanded  Act  ATrans
	(Object  symbol)
	(From  symbol)
	(To  symbol) )
.DE
.DS
(create expanded  Act  Injest
	(Object  symbol)
	(Through  symbol) )
.DE
Note that we did \fBnot\fR have to list the Actor slot,
it was \fBinherited\fR from the base structure Act.
The structure to be expanded need not be a base structure,
but could itself be an \fIexpanded\fR structure.
Thus we can capture the similarities of the various Transfers with:
.DS
(create expanded  Act  Trans
	(From  symbol)
	(To  symbol) )
.DE
followed by
.DS
(create expanded  Trans  PTrans
	(Object  symbol) )
.DE
.DS
(create expanded  Trans  MTrans
	(MObject  symbol) )
.DE
.DS
(create expanded  Trans  ATrans
	(Object  symbol) )
.DE
In expanded definitions as in base definitions one can
specify hashing and default information in the usual way.
However one can selectively inherit some of this
information from the structure being expanded.
Thus in our first Act example, since we specified star hashing on the
Actor slot, all the structures that we defined in terms of Act
have star hashing on their Actor slot by default.
If we had not wanted this for ATrans, we could have specified this
simply by listing the Actor slot over again without the asterisk.
However, since PEARL requires old slots in expanded structures
to also provide a new value, we need some way to say \fIinherit the
same old value\fR.
This is done by putting an up-arrow \fB"^"\fR where PEARL expects
to find a value, just as when you want to inherit the default
value but add hooks or predicates when creating individuals.
.DS
(create expanded  Act  ATrans
	(Actor  ^)
	(From  symbol) )
.DE
We also could have added colon hashing to the Actor slot by
listing it above as normal.
However, we cannot change the type of a slot and including a type
name after \fIActor\fR will cause PEARL to try to interpret that
type name as a value, (resulting in any of several errors,
depending on the type).
Thus, the hashing information for any slot is inherited from
above, \fIunless\fR it the slot appears in the expanded structure.
.PP
Default values are inherited in almost the same way.
The exception is that if in the original structure
the default is preceded by the symbol \fB":="\fR (rather than being
preceded by either nothing or the symbol \fB"=="\fR), expansions of that
structure will not inherit this value, but instead will get the
standard default for that type.
So if one defines:
.DS
(symbol  Pandora)
.DE
.DS
(create base  Act
	(Actor  symbol  Pandora) )

		or
.DE
.DS
(create base  Act
	(Actor  symbol  ==  Pandora) )
.DE
.DS
(create expanded  Act  PTrans
	(From  symbol) )
.DE
then all PTranses will have Pandora as their default Actor, whereas with:
.DS
(create base  Act
	(Actor  symbol  :=  Pandora) )
.DE
.DS
(create expanded  Act  PTrans
	(From  symbol) )
.DE
only the default instance of Act will have Pandora in its Actor
slot and the default Actor of PTrans will just be the usual
default for \fIsymbol\fR-valued slots which is \fInilsym\fR.
Which type of default inheritance to use depends upon the
application, and must be decided on a case by case basis.
.PP
Given this hierarchy, it is often useful to check whether an
object is of a certain type or an expanded version of it.
Two functions provide this ability with slightly different
arguments.
\fBIsa\fR expects an item and the name of the type you want to
check for.
\fBIsanexpanded\fR expects two instances.
Thus the following are always true for any structure X:
.DS
(isa  X  (pname X))
(isanexpanded  X  X)
.DE
Two related functions are \fBnullstruct\fR and \fBnullsym\fR which
are functions for testing for \fInilstruct\fR and \fInilsym\fR
(similar to \fInull\fR for \fInil\fR).
.NH
Fetching Expanded Structures
.PP
To make the extra information that \fIexpanded\fR structures provide
more useful, a special version of \fIfetch\fR called \fBexpandedfetch\fR
is provided which takes the hierarchy of structures defined into
account when fetching.
For example, using the above hierarchical
definitions of Act, Trans, PTrans, MTrans, and ATrans, you can insert
three different Transes into the data base:
.DS
(dbcreate individual  PTrans
	  (Actor  Pandora)
	  (Object  Pandora) )
.DE
.DS
(dbcreate individual  MTrans
	  (Actor  Pandora)
	  (To  Pandora) )
.DE
.DS
(dbcreate individual  ATrans
	  (Actor  Pandora)
	  (From  Pandora) )
.DE
and then to fetch all Transes performed by Pandora, you could use:
.DS
(create pattern  Trans  TransPattern
	(Actor  Pandora) )
.DE
.DS
(expandedfetch  TransPattern)
.DE
Once you start using expanded structures, you usually want to be
able to use the function name \fIfetch\fR and mean \fIexpandedfetch\fR. 
To this end, the standard fetch function is actually called
\fBstandardfetch\fR.
This leaves the function \fBfetch\fR to be bound to whichever
fetch function you wish.
It is initially given the same function definition as
\fIstandardfetch\fR.
.NH
How Two Objects Match
.PP
When a fetch from the data base is performed, the pattern provided
is only used to construct a stream containing that pattern and the
appropriate hash bucket from the data base;
no matching (comparing)
between the pattern and objects in the data base occurs.
Thus the stream contains pointers to all data base items in the
same hash bucket, regardless of their likelihood of
matching the pattern.
When elements are extracted from the stream with the function
\fInextitem\fR, the pattern is "matched" against successive
items from the hash bucket until one matches (and is returned)
or until the potential items run out (and \fInil\fR is returned).
.NH 2
When Is a Pattern Not a Pattern?
.PP
To understand the process with which two objects are
matched, it is necessary to understand what is meant by
a \fIpattern\fR in the context of matching.
The term \fIpattern\fR has been used in two ways in PEARL.
It has been used previously in this documentation in
a specialized sense which is only relevant in the context
of creating a \fIpattern\fR.
The use of the \fIpattern\fR selector to \fIcreate\fR is simply a
variation on \fIcreate individual\fR which uses the match-anything
variable ?*any* as the default for unspecified slots instead
of the usual default values (either the one inherited from the
base definition or the default for the type of slot).
It is called creating a \fIpattern\fR because the
change of default is usually only useful for constructing a pattern.
.PP
However, the use of the function \fIcreate\fR with object
selector \fIpattern\fR is \fBnot\fR the only way to create a
pattern which can be matched;
in fact, it is only useful for
forming simple patterns.
\fBAny\fR individual structure in PEARL can be used as a pattern.
If a fully specified structure (that is, one with an actual value
in all of its slots) is used as a pattern for fetching, it will
only match objects which are equal to it in a manner similar to
\fIequal\fR (versus \fIeq\fR) in Lisp.
(An exception to this occurs when patterns with pattern-matching
variables are stored in the data base.)
Thus a fully specified pattern is only useful for
determining whether a particular fact (object) is in the data base.
Any object is a pattern but the interesting patterns will not
be fully specified;
rather, they will have unspecified slots
which contain pattern-matching variables instead of values.
The details of the matching process will now be described.
.NH 2
The Matching Process
.PP
In general, the matching procedure takes two structures and either,
neither or both may contain pattern-matching variables.
So conceptually, both are patterns.
If the structures are not definitionally the same type
then the match fails automatically.
Otherwise, each structure is viewed as a sequence of slots
which are successively "matched" between the two structures.
Two structures of the same type match if and only if each of
their slots "matches" the corresponding slot of the other structure.
Each slot is of one of four types (\fIstruct\fR, \fIsymbol\fR, \fIint\fR,
or \fIlisp\fR), or is a \fIsetof\fR one of these types.
Regardless of its type, each slot is filled in one of four ways:
.IP (1)
The slot may contain an actual value of its type (for example,
a slot of type \fIstruct\fR may contain a PTrans).
.IP (2)
The slot may contain a variable which is local to the structure
(pattern-matching variables are local unless otherwise specified).
.IP (3)
The slot may contain a global variable, declared previously by a
call to the function \fIglobal\fR with the variable's name as argument.
.IP (4)
The slot may contain the special match-anything variable ?*any*.
.LP
If the slot contains a variable (other than ?*any*) which has not
been bound then it may become bound as a side effect of the
matching process.
All local pattern-matching variables are unbound at the start
of the matching process.
When a local variable is bound to a real
value during the matching process (it will never be bound to a
variable), it will not be unbound again but for the purposes of
matching will be treated as if the slot were filled with that value.
.PP
Let us now examine each of the pairings of slot values
which may occur and how they are matched.
If either of the two slots being matched contains the
special variable ?*any*, then the slots match by definition,
regardless of the contents of the other slot.
If both slots contain variables that are unbound, the slots
do not normally match, (even if the two variables are textually
the same name).
(Since some users want two unbound variables to match,
the value to be returned in this case is stored in the
special variable \fB*matchunboundsresult*\fR whose
initial value is \fInil\fR.
Setting this variable to non-\fInil\fR will cause two unbound
variables to match immediately but will not cause their
predicates to be run.)
If one slot contains an unbound variable (and the other
a bound variable or a value), then the predicates and
restrictions of the slot with the unbound variable are
tested, and hooks on that slot labelled
with \fImatch\fR are run to see if the unbound variable
should be bound to the bound value.
If so, then the unbound variable is bound to the value
of the other slot, and the two slots match.
Note that only the predicates and hooks on the
structure containing the unbound variable are run while
the symbols *, **, and =<slotname> refer to the other
structure (with the bound value in it).
If the predicates or restrictions return \fInil\fR,
the two slots do not match, the variable
is not bound, and the entire match fails.
.PP
If both slots contain either bound variables or values, then the values
of the two slots are compared.  If the slot is of type \fIstruct\fR,
then the entire matching algorithm is recursively applied.
If the slot is of types \fIint\fR or \fIlisp\fR,
then \fIequal\fR is used.
If the type is \fIsymbol\fR, then the two values must
be the same symbol.
Regardless of the type, restrictions associated with the slot
are executed until one fails or there are no more to run.
All must succeed for the match to succeed.
If the match succeeds, then any hooks
with the label \fImatch\fR are run.
.PP
The difference between the two types of variables is one of scope.
Normal variables (for PEARL) do not need to be declared, and
may be used in any structure by typing in \fI?<var>\fR during a
\fIcreate\fR (note that \fIputpath\fR is incapable of
installing variables).
The scope of these variables is only over the structure
in which they are typed.
Thus the variable \fI?V\fR typed into two different creations of
structures are in no way connected (in the same manner as two
local variables V in different Pascal subroutines are unrelated.)
If one becomes bound, the other is unaffected.
On the other hand, if a variable name is previously declared
as \fBglobal\fR:
.DS
(global  G)
.DE
then all instances of the variable name ?G are the same
(similar to global variables in Pascal).
The list of global variables is kept in the special variable \fB*globallist*\fR.
.PP
As mentioned before, when two structures are matched, all
normal (local) variables in both structures are unbound
(bound to the value \fI*pearlunbound*\fR) before any
slots are compared.
This is to ensure that any bindings induced by a previous
unsuccessful (or successful for that matter) match are removed.
This rule is useful because the type of matching that
early PEARL users have needed is in matching most
patterns against fully-specified values (that is, cases
in which one slot is always bound and the other either
bound or unbound).
Global variables are \fBnot\fR unbound before each match,
so they can be used to reflect global contexts.
They are given the value *\fIpearlunbound*\fR at the
time they are declared and remain bound thereafter unless
explicitly unbound by the user.
To unbind a global variable, you may use use the function
\fBunbind\fR, a fexpr which requires
the name of a (previously declared) global variable:
.DS
(unbind  G)
.DE
or use \fIsetq\fR and the function \fBpunbound\fR which
simply returns the atom \fI*pearlunbound*\fR:
.DS
(setq  G  (punbound) )
.DE
The function \fBpboundp\fR will test the value of a Lisp
(not PEARL) variable to see if it is \fI*pearlunbound*\fR.
The function \fBglobalp\fR will determine whether the variable
passed to it has been declared global.
.PP
Global variables should be used with care so that
they are not set by unsuccessful matches.
Generally this is achieved by first collecting the value
desired into a local variable via a series of matches
(only the last of which succeed), and then using the result of
this success to cause a further action which is guaranteed to
correctly bind the value of the global variable.
(These actions may be hooks which rebind the global
variable every time the local one is bound.
Effectively, this is a way to say \fIalways unbind this particular
global variable before matches\fR.
The action also could be performed by the user's program
when the right value is found.)
.PP
Each structure or tree of structures built by a call to \fIcreate\fR
constructs an individual assoc(association)-list of all the local
variables in that structure.
This assoc-list is stored with the root of the tree, thus
achieving local uniqueness of variables within a structure.
Global variables are bound values of the Lisp atom of
the same name and are accessed in the usual way.
To access the value of a local variable in a structure,
one uses either the function \fBvalueof\fR (which is an expr)
or the fexpr \fBvarvalue\fR both of which have two
arguments: the name of the variable whose value
you want and the structure it occurs in (evaluated internally by
\fIvarvalue\fR).
For example, to get the value of ?G in X, use either of:
.DS
(valueof  'G  X)
(varvalue  G  X)
.DE
Thus PEARL uses both deep and shallow binding.
.PP
The match algorithm is available to the user as a
separate function by the name \fBstandardmatch\fR.
This function unbinds all local variables before
proceeding with the match (using the macro \fBunbindvars\fR)
and again afterwards if the match failed.
A function which assumes that all local variables have been
unbound already and proceeds just as \fIstandardmatch\fR
would is \fBbasicmatch\fR.
The function name used to access the matching function by
\fInextitem\fR and all other built-in PEARL functions is
\fBmatch\fR which is normally given the same function definition
as \fIstandardmatch\fR but can be bound to whichever match function
you wish.
A function which compares two structures for equality without
affecting the values of their variables is available as
\fBstrequal\fR.
Since it does not bind variables, it also does not execute
predicates although it does run base hooks and slot hooks labelled
with \fIstrequal\fR.
A function parallel to \fInextitem\fR which uses \fIstrequal\fR
instead of \fImatch\fR is available as \fBnextequal\fR.
.PP
This rest of this section covers other ways to access and affect
the values of variables.
It will make more sense after reading the next section on blocks
but fits in better here so you should probably leave it for your
second reading.
.PP
Recall that the question mark read macro expands into either
\fI(*var* <varname>)\fR or \fI(*global* <varname>)\fR.
These two forms are not normally meant to be evaluated.
However, for convenience, there are two functions \fB*var*\fR and
\fB*global*\fR which return the value of the variable whose name
is their argument.
That is, if \fI?X\fR expands into \fI(*global* X)\fR, executing it
will returned the value of the atom X.
Thus \fIX\fR and \fI?X\fR are equivalent for a global variable.
For a local or lexically scoped variable, in which \fI?X\fR
expands into \fI(*var* X), the function \fI*var*\fR looks in
three places for a variable with the name \fIX\fR.
.IP 1.
First it looks to see if the special variable
\fB*currentstructure*\fR has been bound to a structure by
the user, and if so, looks in its variable list.
.IP 2.
If this fails, it looks in the special variable
\fB*currentpearlstructure*\fR for a structure.
This variable is set by various PEARL functions like
\fIcreate\fR, \fIfetch\fR, \fIpath\fR, and \fInextitem\fR
to the top level structure they last operated on.
.IP 3.
If this fails, it looks in the currently open block on
top of \fI*blockstack*\fR if there is one.
.IP 4.
If this fails, it returns \fInil\fR.
.LP
Note that the atom \fI*currentstructure*\fR is there simply for
the use of the user and is never set by PEARL.
.PP
A related function is \fBsetv\fR which takes a question-mark
variable, a value and an optional environment and sets that
variable in that environment or else in the default environment
described above to that value.
The environment can be either a structure or a block.
This stops with an error message if it fails to find a variable 
by that name in the specified or default environment.
.NH
Binding Blocks of Structures Together Via Common Variables
.PP
It is sometimes the case that you wish to create a group of
structures which are closely related in some way and which you
wish to tie together via pattern-matching variables.
For example, a \fIframe\fR might be considered such a loosely
connected group of structures.
In this case what is desired is for the pattern-matching variables
to \fIactually be the same\fR.
Normally however, if you create several structures in PEARL with
variables having the same name, each has its own local variable
with that name and they are totally unrelated.
If on the other hand, you declared them to be global, then all
structures having variables with that name would refer to the same
variable and it would no be unbound before matching.
For this purpose, PEARL provides variables of an intermediate
nature which are local to only a small group of structures and
which are all unbound before any one of the structures takes
parting in matching.
.PP
These variables are called \fBlexically scoped\fR (although if
the related functions \fIblock\fR and \fIendblock\fR are called
dynamically, they also provide a breed of dynamic scoping).
To declare a set of lexically-scoped variables, thus opening a
(nested) scope for them, use the function \fBblock\fR,
so named because of the similarity to the concept of a block
in Algol-like languages.
The function \fIblock\fR is a fexpr which in its simplest form
expects one argument which should be a list of new variables:
.DS
(block  (A  B  C))
.DE
Such a call to \fIblock\fR creates an unnamed block containing
these variables and any occurrences of variables with these
names in any structures \fIcreated\fR after this call will
refer to these lexically-scoped variables.
Thus, no structure created after the above call to \fIblock\fR
can contain a local variable called A, B, or C.
(However, if a variable has been previously declared to be global
this overrides \fBall\fR future declarations with \fIblock\fR.
Once again, global pattern-matching variables are to be
used with \fIextreme caution\fR.)
.PP
If you use several blocks, especially nested blocks,
it is helpful to give them names.
For this purpose, \fIblock\fR will accept two arguments, the first
an atom to name the block and the second the list of new variables.
For example:
.DS
(block  Name  (A  B  C))
.DE
.PP
To end the most recent block, use the fexpr \fBendblock\fR.
This function accepts any of three types of arguments.
If last block was unnamed, simply use:
.DS
(endblock)
.DE
If the last block was named, you must provide \fIendblock\fR
with this name:
.DS
(endblock  Name)
.DE
This is provided as a protection against unbalanced calls to
\fIblock\fR and \fIendblock\fR.
If you wish to end the most recent block, regardless of what
its name is, use
.DS
(endblock  *)
.DE
To end several blocks at once, you can use the fexpr
\fBendanyblocks\fR which ends all blocks back through
the one whose name matches its argument.
Again no argument (\fInil\fR) means the last unnamed block.
An argument of \fB"*"\fR causes PEARL to end all currently
open blocks.
A shorthand for \fI(endanyblocks *)\fR is \fB(endallblocks)\fR.
.PP
The function \fIblock\fR builds an assoc-list of
the variables listed.
If the block is nested, the assoc-list of the enclosing block is
hooked to the end of its assoc-list, thus providing a complete
assoc-list of all the variables available in the block.
A side effect of \fIblock\fR is that this assoc-list is bound to
the name of the block.
The block itself (the block's name plus this assoc-list) is available
as \fIb:<blockname>\fR so that the above call to block binds
\fIName\fR to
.DS L
((A  .  *pearlunbound*)  (B  .  *pearlunbound*)  (C  .  *pearlunbound*))
.DE
and \fIb:Name\fR to
.DS
(Name  (A  .  *pearlunbound*)  (B  .  *pearlunbound*)
       (C  .  *pearlunbound*))
.DE
If a block is unnamed, PEARL calls it \fIunnamedblock\fR and the
corresponding variables are set.
The special variable \fB*blockstack*\fR contains a stack of all the
currently active blocks.
The effect of ending a block is to pop it off this stack.
Once a block is closed, it is still accessible through the Lisp
variable \fIb:<blockname>\fR.
Given the name of a block, the function \fBblockatom\fR will build
this atom for you.
.PP
It is possible to return to the scope of an earlier block with the
fexpr \fBsetblock\fR which expects the name of a named block.
This will have the effect of ending all currently open blocks and
setting the current block stack to contain this block.
Note that this block will contain all the variables of any blocks
it is nested in but that it is not possible to close off these
block selectively.
Thus, the block stack will contain only one block with all the
variables in its complete assoc-list.
.NH
Controlling the Unbinding of Variables by Match
.PP
It is sometimes desireable to use the filled-in result pattern
of a \fIfetch\fR or \fImatch\fR as a pattern for a further
\fIfetch\fR (or \fImatch\fR) or to otherwise store and restore
the current values of variables (for example, to allow
backtracking algorithms and/or hypothetical assertions).
Since all bound local variables would normally be unbound during this
further fetching or matching, this would not be possible given the
mechanism described so far.
To accomplish this action, which can be considered as "pushing"
the context of the current assoc-list,
you should use one of several functions provided for this purpose.
The function \fBfreezebindings\fR takes a structure as argument
and moves all bound variables from its normal assoc-list to a
backup so that \fIfetch\fR will not unbind them.
The function \fBthawbindings\fR takes a structure as argument and
will undo this action, restoring the assoc-list to its complete state.
These two functions affect the structure plus any bound variables
in all enclosing blocks.
To freeze or thaw only a single structure, use \fBfreezestruct\fR
and \fBthawstruct\fR.
To freeze or thaw only a single block, use \fBfreezeblock\fR
and \fBthawblock\fR which expect the name of a block as an
argument.
.PP
Above it was mentioned that two structures will match if
and only if they both are of the same type.
Actually the system has been extended to allow the matching
of a structure of one type with another of a type derived
from the first via a \fIcreate expanded\fR.
The extra slots of the larger (expanded)
structure are ignored during the match.
.PP
Lastly it should be mentioned that the matching rules are
an evolving system, and may be amended as experience
with their use is accumulated.
The rules may seem a bit complex at first, but in use they
are fairly natural.
The rules are biased towards efficiency (like much of PEARL).
The designers felt that hiding exponential time-complexity
processing within the language would lead users to
construct inefficient programs without realizing it.
Thus several "features" of other complex AI matchers are not built in.
The user must implement these individually at a higher level.
It has been our experience that this leads to much cleaner designs.
.NH
Function Structures
.PP
In using PEARL, it is sometimes handy to escape into Lisp in
a "\fIstructure\fRd" way.
Although PEARL allows ad hoc escapes by way of its hooks
and the ! and $ evaluation operators defined above,
the philosophy in PEARL \fBfunction structures\fR
is to allow structured escapes that restrict the generality
of the escape to the minimum necessary for the task.
At times you may wish to equate Lisp functions with their expected
arguments with PEARL structures with their associated slots.
For example while you may wish to describe an action in a program
as fetching an item from the data base, you may actually be
unable to describe the item as a structure and/or be unable or
unwilling to actually store it in the data base.
Instead, you will sometimes want the value to be provided by
a function called at fetching time instead of a structure in the
data base.
.PP
Take as an example the case of keeping track of whether any two
objects are near each other.
One possible way to do this is to keep structures in the data base
which record for each pair of objects that are near each other the
fact that they are near each other:
.DS
(create base  Near
	(Object1  struct)
	(Object2  struct))
.DE
Then determining whether two objects are near each other would
require a simple fetch.
However, if you are dealing with a large number of objects which
are moving around quite a bit but only want to know about nearness
once in a while, it might be easier or more efficient to compute
whether two objects are near each other only on demand.
In this case, you might like to write a function called Near
which expects two arguments.
However, for consistency, you may not want to design your program
so that it knows what things can be fetched and what things need
computing.
So you would like to define a structure which looks like our
definition of Near above but which actually invokes the
function Near.
.PP
To do this, one may create the function Near (which must be an
expr) and also a structure of type \fIfunction\fR named Near:
.DS
(de Near  (x  y)
    ... mechanism to actually determine nearness ... )

(create function  Near
	(Object1  struct)
	(Object2  struct))
.DE
and then can create an individual of it for fetching:
.DS
(create individual  Near  IsNear
	(Object1  John)
	(Object2  Office))

(fetch  IsNear)
.DE
Note that the format of function structures within PEARL
is the same as that of structures.
However, the name of the actual Lisp function to be called must
match the type name of the \fIfunction\fR structure, and the
arguments must occur in the same order and be of the same types
as the slots which will contain the actual arguments to the function.
.PP
As another simple example, to define a \fIfunction\fR structure
to correspond to the function \fIgetpath\fR, we would use the following:
.DS
(create function  getpath
	(Item  struct)
	(Path  lisp) )
.DE
and then an actual instance:
.DS
(create individual  getpath  Minst
	(Item  !  Mtrans1)
	(Path  '(MObject) ) )
.DE
This example is not too useful.
As a more realistic use, consider a program to return all
the MObjects of all MTranses that are in the data base:
.DS
(create function  nextitem
	(Stream  lisp) )
.DE
.DS
(create pattern  MTrans  MPat1
	(MObject  ?X) )
.DE
.DS
(global  MStream)
(setq  MStream  (fetch  MPat1) )
.DE
.DS
(create individual  getpath  Minst2
	(Item  (nextitem  (Stream  ?MStream) ) )
	(Path  '(MObject) )
.DE
.DS
(setq  Stream1  (fetch  Minst2) )
.DE
Note the recursive use of the data base: the \fIfetch\fR of
Minst2 will cause a \fIgetpath\fR to be executed.
But PEARL must first get the two arguments to pass on to
\fIgetpath\fR which causes the function \fInextitem\fR
to be evaluated, getting the next MTrans in MStream to
pass to \fIgetpath\fR. 
.PP
Thus, function structures provide a way to describe a function and
its arguments through a PEARL structure and then to include,
in a pattern to fetch or in a structure slot,
a function call which will provide the desired value
at fetching time.
However, this only works during fetching.
.PP
The function used by PEARL to execute a function
structure is \fBevalfcn\fR.
It takes an item as its argument and returns the result of
applying the associated expr to its slot values if the item
is a function structure.
If the item is a single structure it returns the item untouched.
If the item is a list of structures, it applies itself
recursively with \fImapcar\fR.
No other PEARL functions currently know about function structures
as being any different than other individual structures.
.NH
More About the PEARL Top Level Loop and History Mechanism
.PP
The PEARL prompt-read-eval-print loop includes two features which
make PEARL easier to work with than the usual top level of Lisp.
Both features were designed in imitation of the Berkeley Unix
shell program \fIcsh\fR.
.PP
The first is an aliasing mechanism which provides the ability to
use various atoms as aliases for commonly executed s-expressions.
If you type an atom to the top level and it has the property
\fBalias\fR, the value of its \fIalias\fR property will be
evaluated instead.
Thus, if you do a
.DS
(putprop  'dir  '(dir)  'alias)  ; in UCI Lisp
	  or
(putprop  'ls  '(exec  ls)  'alias)  ; in Franz Lisp
.DE
then if you type the atom \fIdir\fR or \fIls\fR repectively
to the top level, you will get the contents of your
directory printed out.
Two such built-in atoms are \fBhistory\fR which will
run the function \fIhistory\fR and print out your last
64 commands (see below) and \fBh\fR which will print the last 22
commands (one crt screenful).
The aliasing mechanism can be turned off (saving a \fIget\fR for
each atom you use at the top level) by setting the special
variable \fB*usealiases*\fR to \fInil\fR.
.PP
PEARL's top level also includes a simplified command-history mechanism.
As you type in expressions to the top level of PEARL, they are
stored away for future reference.
The results of evaluating each expression are also kept.
The commands and their results are kept in two hunks
whose default size is 64.
The hunk containing the commands is kept in the special
variable \fB*history*\fR and the hunk containing the results
is kept in the special variable \fB*histval*\fR
To change the number of commands remembered, set the special
variable \fB*historysize*\fR to something other than 64
in your \fI.init.prl\fR.
It cannot be changed later.
(If you are a novice user of PEARL, we recommend that you not
change it to be smaller, since the history command can sometimes
be helpful to someone helping you to debug something after you
have fiddled with it a while.)
.PP
The commands you type are squirrelled away so that you can ask
PEARL to re-execute them, thus saving the pain of retyping
a complicated expression.
To access the previous commands, the readmacro \fB"!"\fR is
provided.
To access the results of the previous commands,
the readmacro \fB"$"\fR is provided.
(The exclamation point is in imitation of the cshell;
the dollar sign is meant to suggest "value".)
These readmacros peek at the next character to determine what to do.
We discuss the variations available on these two readmacros in
parallel, since many of them coincide.
.PP
The simplest and most useful forms are \fB"!!"\fR and \fB"$$"\fR
which effectively re-execute and reprint the last command or its result.
Actually, both forms are executed, but the dollard sign macro
always returns its value quoted so that its effect is usually to
just reprint the result of the previous command.
Note that since these are readmacros which simply return the
last s-expression typed or its value, you can use them to build up
more complex commands.
For example:
.DS
pearl>  (fetch  Item)
    (*stream:*  . . .)
pearl>  (nextitem  !!)
.DE
will cause the fetch to be repeated and then do a \fInextitem\fR on it.
However, it is much more efficient to use the \fI$$\fR form in
this case, since what you really want is to do a \fInextitem\fR
on the result of the \fIfetch\fR in the last command:
.DS
pearl>  (fetch  Item)
    (*stream:*  . . .)
pearl>  (nextitem  $$)
.DE
.PP
The commands are numbered as you type them, starting with zero.
Although the values wrap around in the hunks, the \fIhistory number\fR
continues to climb.
The current history number is available in the special
variable \fB*historynumber*\fR.
To access a particular command or its value, you may type you may
follow an exclamation point or dollar sign with the number of the
command.
Thus \fB!23\fR and \fB$23\fR are the 23rd command and its result.
If you don't remember the command's number you can use the
function name or a prefix of it.
Thus \fB!fetch\fR and \fB$fetch\fR will access the last \fIfetch\fR
or its value.
Or \fB!fe\fR and \fB$fe\fR will access the last command starting
with \fIfe\fR or its value.
If there was a reference to an atom (instead of a list) with that
name or with that as a prefix somewhere, then the atom will be
evaluated again.
For exclamation point, this is a waste of typing except for long
atom names.
For dollar sign, it provides you a way of recovering the value of
a variable that has since changed.
(As a side effect of implementing this, PEARL contains a function
\fBprefix\fR which expects two lists and determines whether the
first is a prefix of the second, considered as a list of atoms.
Thus, PEARL just calls \fIprefix\fR on the results of \fIexplode\fRing
two atoms.)
.PP
Here the parallel between the two macros ends.
.PP
There are five forms which work only with exclamation point and
refer only to the last s-expression typed.
They are essentially ways to pick individual top-level elements
out of the last command:
.DS
\fB!^\fR	the first argument
\fB!$\fR	the last argument
\fB!*\fR	the complete set of arguments
\fB!:0\fR	the function name
\fB!:n\fR	the nth argument
.DE
Both macros are splicing macros so that their values may be
spliced into the current s-expression.
\fB!*\fR is designed so that the following will work:
.DS
pearl>  (add  1  2  3  4)
    10
pearl>  (times  !*)
(times  1  2  3  4)
    24
.DE
.PP
To see the last 64 commands you gave printed out, use the function
\fBhistory\fR (or type the atom \fBhistory\fR).
If you don't want all 64 commands, \fIhistory\fR will accept an
integer argument telling how many you want.
Thus the aliases on \fIhistory\fR and \fIh\fR are:
.DS
(putprop  'history  '(history)  'alias)
(putprop  'h  '(history  22)  'alias)
.DE
If you use the command numbers often, you might like to have the
history number printed out before each command.
To have the history number printed just before the PEARL prompt,
set the special variable \fB*printhistorynumber*\fR to a
non-\fInil\fR value.
The default value is f\Inilf\R.
.PP
Whenever you use the ! or $ history mechanisms, the line you type in
will be reprinted in its expanded form on the next line using
the current \fIpearlprintfn\fR.
If you wish to modify your own read macros so that they also will
cause this reprinting, simply have them set the special
variable \fB*readlinechanged*\fR to a non-\fInil\fR value.
.PP
It is sometimes useful to have a function return no value.
That is, you often do not want the value of the function to be
printed by the top level loop.
In particular, functions which print values often return ugly
values afterward.
To get around this problem, the PEARL top level disables printing
of the value returned by a function if it returns the atom
\fB*invisible*\fR.
All of the PEARL print functions return this value.
.PP
It is sometimes useful to be able to save the current state of a
PEARL run for later.
There are two functions to allow this.
If you wish to save a version which will continue exactly where
you left off (at the top level), use the function
\fBsavecontinue\fR which expects zero, one or two arguments.
If you wish to save a version which will read in
the \fI.start.prl\fR file when it starts up, use \fBsavefresh\fR.
(If you also want \fI.init.prl\fR read in, change the value of the
special variable \fB*firststartup*\fR to \fIt\fR beforehand but
be careful not to put functions which may only be run once in it.)
Note however that you cannot save Franz PEARL on top of the file
you are running;
trying to will result in the \fIDumplisp failed\fR
error message from Franz Lisp.
Note also that a saved PEARL uses about 1500 blocks or 750kbytes on
the disk so this should be used sparingly.
(Exceeding the disk quota will result in the same error message.)
In the Franz Lisp version, if the number of arguments to either of
these functions is:
.IP 0:
It will be saved as \fIpearl\fR in the current directory.
.IP 1:
The argument is assumed to be a (relative) file name to save under.
.IP 2:
The result of concatenating the two arguments together with a
\fB/\fR between them will be the file name used.
(This is for UCI Lisp compatibility.)
.LP
In the UCI Lisp version, if the number of arguments is:
.IP 0:
It will be saved as \fIpearl\fR in the current directory.
.IP 1:
The argument is assumed to be a file name for the current directory.
.IP 2:
They must be a directory and a file name to save in.
.NH
Looping and Copying Functions
.PP
PEARL includes several loop macros.
The first two were included simply for use by the implementation but
might be useful to the user.
They are the \fBfor\fR and \fBwhile\fR macros which both expand
into a \fIprog\fR wrapped around a \fIprogn\fR.
A call to the \fIwhile\fR macro should be of the form:
.DS
(while <test>
       EXPR1
       EXPR2
       ...
       EXPRn)
.DE
The <test> is evaluated before each execution of the loop.
If it is non-\fInil\fR, the EXPRi are evaluated in sequence.
This continues until <test> return nil in which case the last
value returned by EXPRn is returned.
Since the while expands into a \fIprog\fR, any of the EXPRi may
call the function \fIreturn\fR, terminating the loop prematurely
and returning the value given to \fIreturn\fR.
.PP
A call to the \fIfor\fR macro should be of the form:
.DS
(for <var> <initial> <final>
     EXPR1
     EXPR2
     ...
     EXPRn)
.DE
<initial> and <final> should evaluate to integers.
The EXPRi are repeatedly evaluated in sequence with <var> being
set to the values ascending from <initial> to <final>.
If <initial> is greater than <final>, nothing is done.
<var> is a prog variable which disappears after the \fIfor\fR
executes.
The value returned is the last value of EXPRn and \fIreturn\fR
provides a premature exit with a value as in \fIwhile\fR.
.PP
The fexpr \fBforeach\fR expects a stream and a function (or macro)
and applies the function to each element returned by successive
calls to \fInextitem\fR on the stream.
Unfortunately it only returns \fInil\fR at this time.
Eventually, other useful looping structures may be provided.
.PP
Since PEARL provides several new types of values, it provides a
few functions to copy them.
In particular, the standard Lisp function \fBcopy\fR has been
redefined to avoid trying to copy anything that is not a cons-cell.
There are several ways to copy structures, described below.
The rest of PEARL values either are too complicated to copy
(data bases), can be copied with \fIcopy\fR (streams) or else
make no sense to copy (symbols, blocks).
.PP
For copying structures, there are currently two functions.
The one you are most likely to want is \fBscopy\fR which expects a
single structure argument and returns a new structure with the
same values in it.
However, the new structure will differ from the old in several
important ways.
First of all, copying a bound variable will result in the actual
value being inserted in the new copy.
When copying an unbound variable, the new structure will receive
a local variable with the same name and this variable will
be installed in the slot.
All variables so installed will be installed in the top level
structure regardless of where they came from in the original.
The only exception to this is lexically-scoped variables.
When the new structure is built, it will be built within any
currently open blocks and any of its unbound variables whose names
match variables from the current block(s) will be identified with
those block variables.
Global variables are similarly reinstalled only if they are unbound.
Adjunct variables are also installed \fIonly if\fR they are
unbound, since if they are bound their purpose will already have
been served and their bound values installed in other slots
referring to them.
.PP
A variation on \fIscopy\fR which replaces all unbound
variables from the original with \fI?*any*\fR is called
\fBpatternize\fR.
After (and during) the running of these copying functions, the
resulting top-level structure is kept in the special variable
\fB*currenttopcopy*\fR.
.PP
The situation sometimes arises where you have already built a
structure and have a new structure with information that should be
merged into the old one.
Rather than use \fIpath\fR to copy each relevant slot, you can use
\fBsmerge\fR which expects as arguments the old structure to merge
into and the new structure from which to take values.
All unfrozen variables in the old structure are unbound first and
then any unbound variable whose counterpart in the new structure
is bound gets replaced (\fBnot set\fR) with this value.
The old structure being merged into must be of the same type or
an expanded version of the new structure.
.NH
Miscellaneous Variations and Abbreviations
.PP
People very quickly get tired of typing the relatively long
function names that PEARL uses.
As a result, a large number of abbreviations and macros have
been included in PEARL.
We recommend that the shortest ones be used primarily at
the top level, since they are easily subject to typographic
errors.
Most the abbreviations are in \fIcreate\fR and are summarized by
the following table:
.DS
   The function or atom:       May \kmbe abbreviated:
	create			   \h'|\nmu'cr
	individual		   \h'|\nmu'ind
	pattern			   \h'|\nmu'pat
	expanded		   \h'|\nmu'exp
	function		   \h'|\nmu'fn
.DE
Thus, \fI(cr pat ....)\fR is equivalent to
\fI(create pattern ....)\fR.
.PP
In addition, a large number of macros for popular combinations of
functions are included:
.ID
    The s-expression:               Is exp\kmanded into by the macro:
(create base ...)		\h'|\nmu'(cb  ...)
				\h'|\nmu'(base  ...)
(create individual ...)		\h'|\nmu'(ci  ...)
				\h'|\nmu'(individual  ...)
				\h'|\nmu'(ind  ...)
(create expanded ...)		\h'|\nmu'(ce  ...)
				\h'|\nmu'(expanded  ...)
				\h'|\nmu'(pexp  ...)
(create pattern ...)		\h'|\nmu'(cp  ...)
				\h'|\nmu'(pattern  ...)
				\h'|\nmu'(pat  ...)
(create function ...)		\h'|\nmu'(cf  ...)
				\h'|\nmu'(pfunction  ...)
				\h'|\nmu'(fn  ...)
.sp 1
(insertdb  (create  ...)  nil)	\h'|\nmu'(dbcreate  ...)
				\h'|\nmu'(dbcr  ...)
`(quote  ,(create  ...))	\h'|\nmu'(inlinecreate  ...)
(fetch  (create  ...) nil)	\h'|\nmu'(fetchcreate  ...)
`(fetch  (quote  ,(create  ...))  nil)	\h'|\nmu'(inlinefetchcreate  ...)
(nextitem  (fetch  ...) )	\h'|\nmu'(firstfetch  ...)
.sp 1
(valprint  ...)				\h'|\nmu'(vp  ...)
(fullprint  ...)			\h'|\nmu'(fp  ...)
.DE
(\fIpexp\fR and \fIpfunction\fR are so named to avoid conflict
with the exponential function \fIexp\fR and the function quoting
function \fIfunction\fR.)
.PP
The automatic setq feature of \fIcreate\fR that causes an atom
to be bound to the item created is available throughout
\fIcreate\fR.
In all cases, the special variable \fB*lastcreated*\fR is
set to the item.
In addition:
.DS
This combination:          Causes \kmthis atom to be set:
(create base  X ...		\h'|\nmu'X
(create base  X Y ...		\h'|\nmu'Y
(create expanded  X Y ...	\h'|\nmu'Y
(create expanded  X Y Z ...	\h'|\nmu'Z
(create individual  X ...	\h'|\nmu'(none)
(create individual  X Y ...	\h'|\nmu'Y
(create individual  X X ...	\h'|\nmu'(none, the second X is ignored)
(create pattern  X ...		\h'|\nmu'(none)
(create pattern  X Y ...	\h'|\nmu'Y
(create pattern  X X ...	\h'|\nmu'(none, the second X is ignored)
.DE
.PP
When creating an object, wherever a recursive call to \fIcreate\fR
is implied by a structure in a slot of type structure, you may start
with one of the types \fIindividual\fR, \fIpattern\fR, \fIbase\fR,
\fIexpanded\fR, \fIfunction\fR to change the type of object
being created.
Whenever it isn't given, the type of the toplevel \fIcreate\fR,
which is kept in the special variable
\fB*currentcreatetype*\fR is used.
For example, in
.DS
(create pattern  x
	(a  (individual  y))
	(b  (base  z  (s1  ...)  ...))
	(c  (w)))
.DE
where a, b, and c are all slots of type structure, slot a
will contain an individual y which the attendant defaults
filled in, slot b will contain the default instance of a
newly created type z, and slot c will contain a pattern w
with \fI?*any*\fR as defaults.
.PP
Since each Lisp stores its functions in a different place, PEARL
includes a macro \fBaliasdef\fR which expects the names of an new
and a old function name and copies the function definition of the
old one to the new one.
In the case of Lisps which store the function definition on the
property list, \fIaliasdef\fR requires a third argument which is
the name of the property that the definition is kept under.
.NH
Low Level Access Functions.
.PP
There are a large number of functions for setting and accessing
the various part of structures, symbols, and data bases which are
primarily intended for the use of PEARL.
In general, the access functions are called \fBget...\fR where
"..." is the name of the information about the structure.
The functions which change information are called \fBput...\fR.
It is not generally safe to use the \fIput...\fR functions but the
\fIget...\fR functions can sometimes be useful to the user.
For a complete list of the functions, see the index.
If you don't recognize the function by name, you don't need it so
we don't bother to further document them.
Since most of them expect a slot number, it is useful to know
about the macro \fBnumberofslot\fR which requires the name of a
slot and the definition of a structure (which can be accessed
with \fIdefatom\fR or \fId:<structurename>\fR.) and returns the
corresponding slot number.
.bp
.NH
Appendix of UCI Lisp functions added to Franz PEARL
.PP
Since PEARL was originally written in UCI Lisp, there are many functions
from UCI Lisp that it needed.
We also wrote others to move our other programs.
The number is too great to document each one.
If the function is described with an equal sign, as in
\fI"fn = other"\fR then the function definition of the Franz Lisp
function \fIother\fR has been put under \fIfn\fR.
Thus it might not behave quite the same as in UCI Lisp.
If no equivalence is given, it was written from scratch which is
slightly more likely to mimic UCI Lisp.
In this case, see the UCI Lisp manual for details.
.PP
The functions used for the PEARL top level loop in the Franz Lisp
version plus changes to the fixit debugger and the trace package
are briefly described here also.
.PP
The Franz Lisp version of PEARL is normally loaded with both the Fixit
debugger and the trace package already loaded.
This is done to avoid getting the versions which do not know how to print
PEARL objects.
In addition, the Fixit debugger is attached to all available hooks for
going into the break package, since it is much more similar to the UCI Lisp
break package than the standard Franz Lisp break package is.
Both the debugger and trace package use the function
\fBbreakprintfn\fR to print values.
The \fImsg\fR function uses the function \fBmsgprintfn\fR
to print values.
Either can be bound to whatever function you wish.
To disengage the Fixit debugger, read the Franz manual chapter on exception
handling.
See Note 4 below for more on features added to the Fixit debugger.
.LP
.nf
Atoms and Variables:
*dskin* -- special variable -- initial value: t.  See Note 1 below.
*file* -- special variable -- initial value: nil.  Used by \fIdskin\fR
       and function definition functions.
*invisible* -- special atom -- not printed by \fIdskin\fR if returned
	    by a value when it is evaluated.

Functions:
*append = append
(breakprintfn value lmar rmar) -- used by \fItrace\fR and \fIdebug\fR.
*dif = diff
*eval = eval
*great = greaterp
*less = lessp
*max = max
(msgprintfn value lmar rmar) -- used by \fImsg\fR.
*nconc = nconc
*plus = plus
*times = times
(addprop 'id 'value 'prop)
(allsym itemorpair) -- fexpr
(apply* 'fcn 'args) -- macro -- This is provided to act like UCI Lisp's
	\fIapply#\fR.  The asterisk is used because of the special meaning
	of # in Franz Lisp.  Unlike Franz Lisp's \fIfuncall\fR and
	\fIapply\fR, this does what you would expect with macros!
atcat = concat
(boundp 'item)
clrbfi = drain
consp = dtpr
(de fcnname arglist &rest body) -- macro -- See Note 2 below.
(debug-replace-function-name 'cmd 'frame) -- Used by the modified
	Fixit debugger to handle the "> newfcnname" facility.
(defp 'to 'from [prop]) -- macro -- Ignores \fIprop\fR and just
      copies the function definition.
(defv var val) -- fexpr
(df fcnname arglist &rest body) -- macro -- See Note 2 below.
(dm fcnname arglist &rest body) -- macro -- See Note 2 below.
(dremove 'elmt 'l)
(drm char lambda) -- macro -- See Note 2 below.
(dskin filename1 filename2 ....) -- See Note 1 below.
(dskin1 '*file*)
(dskin2 'port)
(dsm char lambda) -- macro -- See Note 2 below.
(enter 'v 'l)
(every 'fcn 'args) -- macro -- Potential problem when compiled.
expandmacro = macroexpand
(funl &rest body) -- macro -- Expands into (function (lambda ...)).
(ge 'x) -- macro
(gensym1 'ident 'val)
gt = >
(initsym atomorpair1 ...) -- fexpr
(intersection 'set1 'set2)
(islambda 'fcn) -- Is \fIfcn\fR a lambda (expr)?
(le 'x) -- macro
(length '*u*)
lineread = readl (below)
(litatom 'x) -- macro
lt = <
mapcl = mapcar
memb = member
(msg ...) -- macro -- Some features may be missing.  The function
	  used to print is \fImsgprintfn\fR, initially bound to 
	       (or (eq '*invisible* ...)
	           (patom (valform ...)))
(nconc1 'l 'elmt)
(nequal 'arg1 'arg2)
(newsym atom) -- fexpr
noduples = union (below)
(nth 'l 'num)
(oldsym atomorpair) -- fexpr
(pearl-break-err-handler) -- Should be tied to ER%tpl if you want the
	standard Franz Lisp break (not much of a) package.
	Same as standard Franz Lisp \fIbreak-err-handler\fR except
	that it uses the function \fIbreakprintfn\fR.
(pearl-top-level) -- The PEARL top level loop.
(pearl-top-level-init) -- The initial function called when PEARL starts up.
	This is the code that reads in the init files and sets any unset
	PEARL parameters.
peekc = tyipeek
(pop q) -- macro
(push var 'val) -- macro
(readl ['flag]) -- fexpr
(readl1 'flag)
remove = delete
(remprops 'item 'proplist)
(remsym atomorpairlist) -- fexpr
(save fcnname) -- fexpr -- Saves function or macro definition under 
	the property \fIolddef\fR.  Saves macro character definitions
	under \fIoldmacro\fR.
(selectq ...) -- macro
(some 'fcn 'list) -- macro -- Potential problem when compiled.
(sprint 'item ['lmar ['rmar]]) -- See Note 3 below.
(subset 'fcn 'list) -- macro
(timer (defun timer fexpr (request)$?
(unbound) -- macro
(union 'list1 ['list2 ...])
(unsave fcnname) -- fexpr -- See \fIsave\fR.
.fi
.PP
\fBNote 1:\fR A simplified but extended imitation of the UCI Lisp function
\fBdskin\fR is provided in PEARL.
It is an nlambda which requires the file extensions to be provided.
There is a special variable \fB*dskin*\fR which controls whether
the expression read in is printed and/or whether the result of
evaluating it is printed.
.DS L
*dskin* = nil	means neither
*dskin* = t	means result only
*dskin* = 'name	means the name of the variable in setq \fIor\fR the name
		of the function in de, df, dm, dsm, drm, defmacro,
		defun, or def \fIor\fR the name of the type in create.
*dskin* = 'both	means both t and 'name.
.DE
The default value of *dskin* is t.
.PP
File names are always printed before they are opened.
The print function used for values is the current function
definition of \fBdskprintfn\fR.
The default function definition in PEARL is:
.DS
(de dskprintfn  (*printval*)
    (cond  ((atom  *printval*)  (patom  *printval*))
	   (  t  (print  (valform  *printval*)))))
.DE
.PP
\fBNote 2:\fR  For better compatibility with UCI Lisp, PEARL contains
macros for the function and read macro definition functions 
\fBde, df, dm, dsm,\fR and \fBdrm\fR.
They have been defined to save the old definitions automatically
and to return \fI(fcnname Redefined)\fR when this is the case.
\fIDe, df,\fR and \fIdm\fR save the old definition under the
property '\fIolddef\fR.
\fIDsm\fR and \fIdrm\fR save the old definition under the
property '\fIoldmacro\fR.
(The current definition of a readmacro is kept by Franz under the
property '\fImacro\fR.)
If the function definition is read in by \fIdskin\fR,
then the current file name which is in the special variable
\fB*file*\fR is put under the property '\fIsourcefile\fR.
.PP
\fBNote 3:\fR  A function similar to the UCI Lisp \fBsprint\fR is included,
including the printmacro facility and the optional second argument
saying which column to start in.
In addition, there is an optional third argument saying which column
to try not to go beyond (that is a right margin).
A slight addition has been made to the printmacro feature (feature 1 below).
During \fIsprinting\fR, if the atom in the function position in a list
has the printmacro property one of four things will happen during
\fIsprinting\fR:
.IP 1.
If the printmacro property value is a string and the item to be
printed has a nil \fIcdr\fR, then the string will be printed instead
of the item.
.IP 2.
If the printmacro property value is a string and the item to be
printed has two items in it, then the string will be printed followed
immediately by the \fIcadr\fR of the item.
.IP 3.
If the printmacro property value is a string but the item to be
printed is longer than two elements, then it will be \fIsprinted\fR in
the normal fashion (i.e., the printmacro will be ignored).
.IP 4.
Otherwise, the printmacro property value will be applied
to the rest of the arguments.
It should be a function which expects three arguments, the item
to be printed, a left column to start in and a right column to
try not to go beyond.
A good default value for the right column argument seems to be zero.
If the function under the printmacro property returns nil,
then \fIsprint\fR assumes that it decided not to print the item
and prints it in the usual way.
.PP
\fBNote 4:\fR  The Fixit debugger now accepts a command of the
form \fB>  newname\fR whenever either an undefined function or
unbound variable error occurs.  As in UCI Lisp, newname is not
evaluated in the case of an undefined function but is evaluated
in the case of an unbound variable.
Note that the blank is required (unlike UCI Lisp).
This is not guaranteed to work if you move around the stack first.
.bp
.NH
Appendix of Franz Lisp functions added to UCI Lisp PEARL
.PP
The following is a summary of the functions added to the UCI Lisp
version of PEARL to make it compatible with Franz Lisp.
Where the details are not obvious, see the Franz Lisp manual.
\fBNote:\fR Most \fImacros\fR listed in the index which are
labelled with asterisks are not available in UCI Lisp PEARL, since
the implementor must specifically request that they stick around.
.PP
\fIDskin\fR, the break package, and \fImsg\fR have been changed
to use the functions \fBdskprintfn\fR, \fBbreakprintfn\fR,
\fBmsgprintfn\fRfor printing.
.LP
.nf
(addtoaddress 'n 'address) -- expr -- Used by \fIcxr\fR and
	\fIrplacx\fR.  Written in LAP code.
(apply* 'fcn 'args) -- macro -- Equivalent to \fIapply#\fR.
(buildalist ...) --- expr --- Used by \fIdefmacro\fR.
(combineskels ...) -- expr -- Used by \fIquasiquote\fR.
(convert ...) --- expr --- Used by \fIdefmacro\fR.
(cxr 'index 'hunk) -- expr -- A hunk is a block of memory.  Provides
	random access to a single cell of a hunk.  (Uses
	\fIaddtoaddress\fR and \fIeven\fR.)
(defmacro macroname arglist body) -- macro -- \fIDefmacro\fR provides
	a slightly more intelligent macro facility.  \fIBody\fR is
	processed to look for occurrences of the arguments in
	\fIarglist\fR which are replaced with the appropriate form
	of \fIca..r\fR.  If an argument is preceded by \fI&rest\fR,
	then it gets the list of the rest of the arguments.
	The Franz Lisp version has many more features not included
	in the PEARL version.
(even 'x) -- expr -- Is \fIx\fR even? Used by \fIcxr\fR and
	\fIrplacx\fR to determine which half of a cons-cell to use.
(isconst ...) -- expr -- Used by \fIquasiquote\fR.
(makhunk 'size) -- expr -- Calls the UCI Lisp function \fIgetblk\fR,
	requesting a block of memory which is half of \fIsize\fR, since
	each piece of a UCI Lisp block of core is a cons-cell.
(msg ...) -- fexpr -- Modified to use \fImsgprintfn\fR to print
	values of evaluated elements of the print list.
(pearl-top-level) -- the PEARL top level loop. 
(pearl-top-level-init) -- The initial function called when PEARL starts up.  
(rplacx 'index 'hunk 'val) -- expr -- Provides random access storage into
	a block of memory.  (Uses \fIaddtoaddress\fR and \fIeven\fR.)
(quasiquote 'skel) -- expr -- called by the quasi-quote readmacro
	character backquote \fB`\fR.  Equivalent to the quasiquote
	functions defined in Charniak[2] with different invoking
	characters to match those of Franz Lisp.
	Unquote is comma \fB","\fR and splice-unquote is \fB",@"\fR.
	Uses \fIcombineskels\fR and \fIisconst\fR.
.fi
.bp
.NH
Bibliography
.SM
.IP [1]
Bobrow, D., and Winograd, T. "An Overview of KRL, a Knowledge
Representation Language."
\fICognitive Science\fR 1:1 (1977).
.IP [2]
Charniak, E., Riesbeck, C., and McDermott, D.
\fIArtificial Intelligence Programming\fR.
Hillsdale, New Jersey: Lawrence Erlbaum Associates, 1980.
.IP [3]
Faletti, J., and Wilensky, R. "The Implementation of PEARL:
A Package for Efficient Access to Representations In Lisp",
forthcoming ERL technical report, UCB.
.IP [4]
Greiner, R., and Lenat, D. "A Representation Language Language."
In \fIProc. First NCAI\fR. Stanford, CA, August, 1980,
165-169.
.IP [5]
Roberts, I., and Goldstein, R.
"NUDGE, A Knowledge-Based Scheduling Program."
In \fIProc. IJCAI-77\fR. Cambridge, MA, August, 1977, 257-263.
.IP [6]
Schank, R. \fIConceptual Information Processing\fR.
Amsterdam: North Holland, 1975.
.IP [7]
Wilensky, R. "Understanding Goal-Based Stories",
Technical Report 140, Computer Science Department,
Yale University, New Haven, CT, September 1978.
.IP [8]
Wilensky, R.
"Meta-Planning: Representing and Using Knowledge about Planning in Problem
Solving and Natural Language Understanding."
\fICognitive Science\fR 5:3 (1981).
.bp
.nr PS 9
.nr VS 11p
.ps 9
.vs 11p
.NH
Index of Global Variables and Functions With Their Arguments
.PP
All functions are exprs (or lexprs) unless otherwise listed.
Functions with one or more asterisks for a page number are not
documented other than in this index because they were not
actually intended for use by the PEARL user.
A single asterisk * means it is primarily intended for use by
PEARL but might be useful and will generally work right.
A double asterisk ** means it will generally only work
within PEARL's code, since it expects certain
external prog variables to exist and be set correctly.
A triple asterisk *** means it is dangerous to use.
Note that it is dangerous to redefine any functions in this list,
although it should be all right to redefine any macros.
.LP
.nr PS 8
.nr VS 10p
.ps 8
.vs 10p
.nf
*activedbnames* -- special variable -- initial value: nil			    \ki40
*any*conscell* -- special variable -- value: '(*any* . *pearlunbound*)	\h'|\niu'*
*availablesizes* -- special variable -- value:	\h'|\niu'39
	((-1. . 1.) (0. . 1.) (1. . 1.) (2. . 3.) (3. . 7.)
	 (4. . 13.) (5. . 29.) (6. . 61.) (7. . 127.) . . . .
		Franz Lisp: . . . (8. . 127.) (9. . 127.) (10. . 127.)
				  (11. . 127.) (12. . 127.) (13. . 127.))
		UCI Lisp:  . . .  (8. . 251.) (9. . 509.) (10. . 1021.)
				  (11. . 2039.) (12. . 4093.) (13. . 8191.))
*blockstack* -- special variable -- initial value: nil	\h'|\niu'48
*currentcreatetype* -- special variable -- initial value: base	\h'|\niu'56
*currentpearlstructure* -- special variable -- initial value: nil	\h'|\niu'46
*currentstructure* -- special variable -- initial value: nil	\h'|\niu'46
*currenttopcopy* -- special variable -- initial value: <UNBOUND>	\h'|\niu'55
*currenttopcreated* -- special variable -- initial value: (nilstruct)	\h'|\niu'8
.sp
db -- special variable -- default initial value: <UNBOUND>	\h'|\niu'33
*db* -- special variable -- default value: the *maindb* data base	\h'|\niu'12
*db1size* -- special variable -- default initial value: 29	\h'|\niu'39
*db2size* -- special variable -- default initial value: 127	\h'|\niu'39
*done* -- special atom	\h'|\niu'35
.sp
*fail* -- special atom	\h'|\niu'35
*file* -- special variable -- initial value: nil	\h'|\niu'60
*firstartup* -- special variable -- initial value: t	\h'|\niu'53
*function-stream:* -- special atom	\h'|\niu'13
*globallist* -- special variable -- initial value: nil	\h'|\niu'45
.sp
*history* -- special variable -- value: command history hunk	\h'|\niu'51
*historynumber* -- special variable -- initial value: 0	\h'|\niu'52
*historysize* -- special variable -- default value: 64	\h'|\niu'51
*histval* -- special variable -- value: value history hunk	\h'|\niu'51
*invisible* -- special atom	\h'|\niu'53
.sp
*lastcreated* -- special variable -- initial value: (nilstruct)	\h'|\niu'8
*lastsymbolnum* -- special variable -- initial value: -1	\h'|\niu'*
*maindb* -- special variable -- default value: the main data base	\h'|\niu'11
*matchunboundsresult* -- special variable -- initial value: nil	\h'|\niu'44
*ordinalnames* -- special variable -- initial value: nil	\h'|\niu'31
.sp
*pathlocal* -- special variable -- initial value: <UNBOUND>	\h'|\niu'33
*pathtop* -- special variable -- initial value: <UNBOUND>	\h'|\niu'33
*pearlprompt* -- special variable -- default value: "pearl> "	\h'|\niu'3, 4
*pearlunbound* -- special atom	\h'|\niu'45
*printhistorynumber* -- special variable -- initial value: nil	\h'|\niu'53
.sp
*readlinechanged* -- special variable -- initial value: nil	\h'|\niu'53
*runaddpredpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runaddsetpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runallbasehooks* -- special variable -- initial value: t	\h'|\niu'33
*runallslothooks* -- special variable -- initial value: t	\h'|\niu'33
.sp
*runapplypathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runclearpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*rundelpredpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*rundelsetpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runexpandedhooks* -- special variable -- initial value: t	\h'|\niu'34
*runfetchhooks* -- special variable -- initial value: t	\h'|\niu'34
*rungethookpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*rungetpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*rungetpredpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runindbhooks* -- special variable -- initial value: t	\h'|\niu'34
*runindividualhooks* -- special variable -- initial value: t	\h'|\niu'34
*runinsertdbhooks* -- special variable -- initial value: t	\h'|\niu'34
*runmatchhooks* -- special variable -- initial value: t	\h'|\niu'34
*runnextequalhooks* -- special variable -- initial value: t	\h'|\niu'34
*runnextitemhooks* -- special variable -- initial value: t	\h'|\niu'34
*runpatternhooks* -- special variable -- initial value: t	\h'|\niu'34
*runputpathhooks* -- special variable -- initial value: t	\h'|\niu'34
*runremovedbhooks* -- special variable -- initial value: t	\h'|\niu'34
*runsmergehooks* -- special variable -- initial value: t	\h'|\niu'34
*runstrequalhooks* -- special variable -- initial value: t	\h'|\niu'34
.sp
*stream* -- special atom	\h'|\niu'13
*stream:* -- special atom	\h'|\niu'13
*toplevelp* -- special variable -- initial value: <UNBOUND>	\h'|\niu'*
*unhashablevalues* -- special variable -- initial value:	\h'|\niu'*
	(0 unbound *pearlunbound* nilsym (nilstruct))
*use* -- special atom	\h'|\niu'35
*usealiases* -- special variable -- initial value: t	\h'|\niu'51
*warn* -- special variable -- initial value: t	\h'|\niu'17
*zero-ordinal-value* -- special variable -- initial value: 0	\h'|\niu'31
.sp
! -- splicing macro	\h'|\niu'52
$ -- splicing macro	\h'|\niu'52
= -- read macro	\h'|\niu'28
? -- read macro	\h'|\niu'16
.sp
(addalist 'var 'inst) -- macro	\h'|\niu'*
(addbasehook 'conscell 'item) -- macro	\h'|\niu'*
(addhistory 'line)	\h'|\niu'*
(addpredpath 'item 'path 'pred)	\h'|\niu'10
(addsetpath 'item 'path 'value)	\h'|\niu'10
.sp
(addtoexpansionlists) -- macro	\h'|\niu'**
(adjvarset 'var 'val) -- macro	\h'|\niu'*
(allocdef numofslots) -- macro	\h'|\niu'*
(allocval numofslots) -- macro	\h'|\niu'*
(applypath 'fcn 'item 'path)	\h'|\niu'10
.sp
(base name [storage] slot1 ...) -- macro	\h'|\niu'56
(basicmatch 'item1 'item2)	\h'|\niu'46
(block [blockname] varlist) -- fexpr	\h'|\niu'47
(blockatom 'symbol)	\h'|\niu'48
(blockp 'potblock)	\h'|\niu'30
.sp
(breakprintfn '*printval*)	\h'|\niu'58, 59
(builddb newdb [olddb]) -- fexpr	\h'|\niu'38
(buildintvalue 'intval 'bppset) -- macro	\h'|\niu'*
(buildslot) -- macro	\h'|\niu'**
(buildstructvalue 'structdesc) -- macro	\h'|\niu'*
(buildsymbolvalue 'symname) -- macro	\h'|\niu'*
(buildvalue 'value 'typenum 'ppset)	\h'|\niu'*
.sp
(cb name [storage] slot1 ...) -- macro	\h'|\niu'56
(ce basename newname [storage] slot1 ...) -- macro	\h'|\niu'56
(cf name [storage] slot1 ...) -- macro	\h'|\niu'56
(checkandrunbasehooks2 'fcn 'item1 'item2) -- macro	\h'|\niu'**
(checkandrunslothooks2 'fcn 'hooks 'val1 'val2 'item1 'item2) -- macro	\h'|\niu'**
(checkrunhandlebasehooks1 'fcn 'runhooksatom) -- macro	\h'|\niu'**
(checkrunhandleslothooks1 'fcn 'runhooksatom) -- macro	\h'|\niu'**
(ci basename [storage] slot1 ...) -- macro	\h'|\niu'56
.sp
(cleardb ['db])	\h'|\niu'39
(cleardb1 'db)	\h'|\niu'39
(cleardbactive 'db) -- macro	\h'|\niu'*
(clearhashandformat 'slotnum 'defblock) -- macro	\h'|\niu'*
(clearpath 'item 'path)	\h'|\niu'10
.sp
(compatible 'slotnum 'item1 'item2) -- macro	\h'|\niu'*
(connectdb 'newdb 'olddb)	\h'|\niu'*
(consistentvalue 'val 'predlist 'typenum 'item) -- macro	\h'|\niu'*
(constructvalue) -- macro	\h'|\niu'**
(convertpreds 'pred)	\h'|\niu'*
(copy 'list)	\h'|\niu'54
(copypatternslot) -- macro	\h'|\niu'**
(copyslice) -- macro	\h'|\niu'**
(copyslot 'nameblock) -- macro	\h'|\niu'**
.sp
(cp basename [storage] slot1 ...) -- macro	\h'|\niu'56
(cr selector ...) -- fexpr	\h'|\niu'55
(create selector ...) -- fexpr	\h'|\niu'5
(createbase 'newname 'slots)	\h'|\niu'*
(createexpanded 'oldname 'newname 'slots)	\h'|\niu'*
(createfunction 'fcnname 'slots)	\h'|\niu'*
(createindividual 'basename 'slots)	\h'|\niu'*
(createpattern 'basename 'slots)	\h'|\niu'*
.sp
(databasep 'potdb)	\h'|\niu'30
(dbcr selector ...) -- macro	\h'|\niu'56
(dbcreate selector ...) -- macro	\h'|\niu'12, 56
(debugprint 'item)	\h'|\niu'21
(defatom 'symbol)	\h'|\niu'7
.sp
(defaultfortype 'typenum) -- macro	\h'|\niu'*
(definitionp 'potdef)	\h'|\niu'30
(delpredpath 'item 'path 'pred)	\h'|\niu'10
(delsetpath 'item 'path 'value)	\h'|\niu'10
(disguisedas 'filler 'struct ['db])	\h'|\niu'29
(disguisedas1 'filler 'struct 'db)	\h'|\niu'29
.sp
(dobasehooks2< 'fcn 'runhookatom) -- macro	\h'|\niu'**
(dobasehooks2> 'fcn 'runhookatom) -- macro	\h'|\niu'**
(doslothooks2< 'fcn 'runhookatom) -- macro	\h'|\niu'**
(doslothooks2> 'fcn 'runhookatom) -- macro	\h'|\niu'**
(dskprintfn '*printval*)	\h'|\niu'60
.sp
(endallblocks)	\h'|\niu'48
(endanyblocks blockname) -- fexpr	\h'|\niu'48
(endblock [blockname]) -- fexpr	\h'|\niu'47
(enforcetype 'value 'typenum)	\h'|\niu'*
(equalvalue 'xval 'yval 'typenum) -- macro	\h'|\niu'*
(evalfcn 'item)	\h'|\niu'51
.sp
(executehook1 fcn value item defblock) -- macro	\h'|\niu'**
(executehook2 fcn val1 val2 item1 item2 defblock result) -- macro	\h'|\niu'**
(expanded basename newname [storage] slot1 ...) -- macro	\h'|\niu'56
(expandedfetch 'item ['db])	\h'|\niu'42
(expandedfetch1 'item 'db)	\h'|\niu'42
.sp
(fcnslot) -- macro	\h'|\niu'**
(fetch 'item ['db])	\h'|\niu'12, 43
(fetch1 'item 'db)	\h'|\niu'12, 43
(fetcheverywhere 'item ['db])	\h'|\niu'19, 25
(fetcheverywhere1 'item 'db)	\h'|\niu'19, 25
(fetchcreate selector ...) -- macro	\h'|\niu'14, 56
(fillbaseslot) -- macro	\h'|\niu'**
(fillin1 'fcn 'value 'item 'defblock)	\h'|\niu'33
(fillin2 'fcn 'val1 'val2 'item1 'item2 'defblock 'result)	\h'|\niu'33
(fillindivslot) -- macro	\h'|\niu'**
.sp
(findnextblockstart) -- macro	\h'|\niu'**
(findslotnum) -- macro	\h'|\niu'**
(findstructsymbolpair 'defblock 'symbol) -- macro	\h'|\niu'**
(firstfetch pattern) -- macro	\h'|\niu'14, 56
(fn name [storage] slot1 ...) -- macro	\h'|\niu'56
.sp
(followpath 'item 'path)	\h'|\niu'*
(for val 'init 'final &rest 'body) -- macro	\h'|\niu'54
(foreach 'stream fcn) -- fexpr	\h'|\niu'54
(fp 'item ['lmar ['rmar]])	\h'|\niu'56
(freezebindings 'struct)	\h'|\niu'48
(freezeblock 'blockname)	\h'|\niu'49
(freezestruct 'struct)	\h'|\niu'49
.sp
(fullform 'item)	\h'|\niu'20
(fullprint 'item ['lmar ['rmar]])	\h'|\niu'20, 37
(fullprint1 'item 'lmar 'rmar)	\h'|\niu'20, 37
(fullslotform) -- macro	\h'|\niu'**
.sp
(getalist 'inst) -- macro	\h'|\niu'57
(getalistcp 'inst) -- macro	\h'|\niu'57
(getbasehooks 'defblock) -- macro	\h'|\niu'57
(getdb1 'db) -- macro	\h'|\niu'57
(getdb2 'db) -- macro	\h'|\niu'57
(getdbactive 'db) -- macro	\h'|\niu'57
(getdbchildren 'db) -- macro	\h'|\niu'57
(getdbname 'db) -- macro	\h'|\niu'57
(getdbparent 'db) -- macro	\h'|\niu'57
(getdefaultinst 'defblock)	\h'|\niu'57
(getdefinition 'valblock)	\h'|\niu'57
(getenforce 'slotnum 'defblock) -- macro	\h'|\niu'57
(getexpansionlist 'defblock) -- macro	\h'|\niu'57
(getformatinfo 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash* 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash** 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash1 'num1 'db1) -- macro	\h'|\niu'57
(gethash2 'num1 'num2 'db2) -- macro	\h'|\niu'57
(gethash3 'num1 'num2 'num3 'db2) -- macro	\h'|\niu'57
(gethash: 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash:: 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash< 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethash> 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethashalias 'defblock) -- macro	\h'|\niu'57
(gethashinfo 'slotnum 'defblock) -- macro	\h'|\niu'57
(gethashvalue 'slotnum 'item 'defblock)	\h'|\niu'*
.sp
(gethookpath 'item 'path)	\h'|\niu'10
(getisa 'valblock) -- macro	\h'|\niu'57
(getpath 'item 'path)	\h'|\niu'10
(getpname 'defblock) -- macro	\h'|\niu'57
(getppset 'slotnum 'defblock) -- macro	\h'|\niu'57
(getpred 'slotnum 'inst) -- macro	\h'|\niu'57
(getpredpath 'item 'path)	\h'|\niu'10
.sp
(getsinglevalue 'slotnum 'item)	\h'|\niu'*
(getslot 'slotnum 'inst) -- macro	\h'|\niu'57
(getslothooks 'slotnum 'inst) -- macro	\h'|\niu'57
(getslotname 'slotnum 'defblock) -- macro	\h'|\niu'57
(getslottype 'slotnum 'defblock) -- macro	\h'|\niu'57
(getstructlength 'defblock) -- macro	\h'|\niu'57
(getstructorsymnum 'strsym) -- macro	\h'|\niu'57
.sp
(getsymbol 'symname)	\h'|\niu'4
(getsymbolpname 'symbolitem) -- macro	\h'|\niu'57
(getuniquenum 'defblock) -- macro	\h'|\niu'57
(getvalue 'slotnum 'inst)	\h'|\niu'57
(getvarandvalue 'slotnum 'inst 'var)	\h'|\niu'57
(getvarval 'slotnum 'inst) -- macro	\h'|\niu'57
.sp
(*global* varname) -- fexpr	\h'|\niu'46
(global variable) -- fexpr	\h'|\niu'45
(globalp 'variable)	\h'|\niu'45
(handlehookresult 'oldval 'newval) -- macro	\h'|\niu'**
(hashablevalue 'slotnum 'item 'defblock) -- macro	\h'|\niu'**
(hashslot) -- macro	\h'|\niu'**
.sp
(hidden 'command) -- macro	\h'|\niu'35
(higheroreq 'item1 'item2) -- macro	\h'|\niu'*
(history ['num])	\h'|\niu'53
(ind basename [storage] slot1 ...) -- macro	\h'|\niu'56
(indb 'item ['db])	\h'|\niu'14
(indb1 'item 'db)	\h'|\niu'14
(individual basename [storage] slot1 ...) -- macro	\h'|\niu'56
.sp
(inheritvalue 'structdef) -- macro	\h'|\niu'**
(inlinecreate selector ...) -- macro	\h'|\niu'14, 56
(inlinefetchcreate selector ...) -- macro	\h'|\niu'14, 56
(insertdb 'item ['db])	\h'|\niu'12
(insertdb1 'item 'db)	\h'|\niu'12
.sp
(insidecreate selector ...) -- fexpr	\h'|\niu'**
(insidefetch patdef expdefs) -- macro	\h'|\niu'**
(insidefetcheverywhere patdef expdefs) -- macro	\h'|\niu'**
(insidepatternize 'item)	\h'|\niu'**
(insidescopy 'item)	\h'|\niu'**
(installadjunct 'adjunctvar) -- macro	\h'|\niu'**
(installglobal 'globalvar) -- macro	\h'|\niu'**
(installvar 'varname) -- macro	\h'|\niu'**
.sp
(instatom 'symbol)	\h'|\niu'7
(isa 'item1 'name)	\h'|\niu'42
(isanexpanded 'item1 'item2)	\h'|\niu'42
(islambda 'fcnname)	\h'|\niu'*
.sp
(match 'item1 'item2)	\h'|\niu'46
(msgprintfn '*printval*)	\h'|\niu'58, 62
(newnum) -- macro	\h'|\niu'*
(nextequal 'stream)	\h'|\niu'46
(nextitem 'stream)	\h'|\niu'13
(noalias) -- macro	\h'|\niu'**
.sp
(nullstruct 'item)	\h'|\niu'42
(nullsym 'item)	\h'|\niu'42
(numberofslot 'slotname 'defblock) -- macro	\h'|\niu'57
(onesymbol) -- macro	\h'|\niu'**
(ordatom 'symbol)	\h'|\niu'31
(ordinal name vallist) -- fexpr	\h'|\niu'30
.sp
(pat basename [storage] slot1 ...) -- macro	\h'|\niu'56
(path fcn 'item 'pathlist ['val]) -- macro	\h'|\niu'9
(pattern basename [storage] slot1 ...) -- macro	\h'|\niu'56
(patternize 'item) -- macro	\h'|\niu'55
(patternizeslot) -- macro	\h'|\niu'**
(pboundp 'a)	\h'|\niu'45
.sp
(pearlprintfn '*printval*)	\h'|\niu'3, 4
(pexp basename newname [storage] slot1 ...) -- macro	\h'|\niu'56
(pfunction name [storage] slot1 ...) -- macro	\h'|\niu'56
(pname 'item)	\h'|\niu'4
(ppsetform 'slotval 'ppsetname)	\h'|\niu'*
.sp
(prefix 'item1 'item2)	\h'|\niu'52
(prefixcommandhistory)	\h'|\niu'*
(prefixcommandvalue)	\h'|\niu'*
(printdb ['db])	\h'|\niu'21
(printdb1 'db)	\h'|\niu'21
(psymbolp 'potsymbol)	\h'|\niu'30
(punbound)	\h'|\niu'45
.sp
(punboundatomp 'yyy)	\h'|\niu'*
(putalist 'alist 'inst) -- macro	\h'|\niu'*
(putalistcp 'alist 'inst) -- macro	\h'|\niu'*
(putbasehooks 'hooklist 'defblock) -- macro	\h'|\niu'*
(putdb1 'db1 'db) -- macro	\h'|\niu'***
(putdb2 'db2 'db) -- macro	\h'|\niu'***
(putdbchildren 'childlist 'db) -- macro	\h'|\niu'***
(putdbname 'name 'db) -- macro	\h'|\niu'*
(putdbparent 'parent 'db) -- macro	\h'|\niu'***
(putdef 'defblock 'valblock) -- macro	\h'|\niu'***
(putdefaultinst 'valblock 'defblock) -- macro	\h'|\niu'***
(putenforce 'slotnum 'defblock) -- macro	\h'|\niu'***
(putexpansionlist 'explist 'defblock) -- macro	\h'|\niu'***
(putformatinfo 'slotnum 'hashnum 'defblock) -- macro	\h'|\niu'***
(puthash* 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthash** 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthash1 'num1 'db1 'item) -- macro	\h'|\niu'*
(puthash2 'num1 'num2 'db2 'item) -- macro	\h'|\niu'*
(puthash3 'num1 'num2 'num3 'db2 'item) -- macro	\h'|\niu'*
(puthash: 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthash:: 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthash< 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthash> 'slotnum 'defblock) -- macro	\h'|\niu'***
(puthashalias 'hashnum 'defblock) -- macro	\h'|\niu'***
(puthashinfo 'slotnum 'hashnum 'defblock) -- macro	\h'|\niu'***
(putisa 'isa 'valblock) -- macro	\h'|\niu'***
.sp
(putpath 'item 'path 'value)	\h'|\niu'10
(putpname 'name 'defblock) -- macro	\h'|\niu'***
(putppset 'slotnum 'setname 'defblock) -- macro	\h'|\niu'*
(putpred 'slotnum 'value 'inst) -- macro	\h'|\niu'*
(putslot 'slotnum 'value 'inst) -- macro	\h'|\niu'***
(putslothooks 'slotnum 'slothooklist 'inst) -- macro	\h'|\niu'*
(putslotname 'slotnum 'slotname 'defblock) -- macro	\h'|\niu'***
(putslottype 'slotnum 'typenum 'defblock) -- macro	\h'|\niu'***
(putstructlength 'size 'defblock) -- macro	\h'|\niu'***
(putsymbolpname 'name 'block) -- macro	\h'|\niu'***
(putuniquenum 'num 'defblock) -- macro	\h'|\niu'***
(putvarval 'slotnum 'value 'inst) -- macro	\h'|\niu'***
(reallitatom 'potatom)	\h'|\niu'*
.sp
(releasedb 'db)	\h'|\niu'38
(removedb 'item ['db])	\h'|\niu'12
(removedb1 'item 'db)	\h'|\niu'12
(removeslot) -- macro	\h'|\niu'**
(revassq 'value 'alist)	\h'|\niu'*
(runbasehooks1 'fcn 'item)	\h'|\niu'33
(runbasehooks2 'fcn 'item1 'item2 'result)	\h'|\niu'33
(runslothooks1 'fcn 'item 'slotname 'value)	\h'|\niu'33
(runslothooks2 'fcn 'item1 'item2 'slotname 'val1 'val2)	\h'|\niu'33
.sp
(savecontinue 'directory 'name)	\h'|\niu'53
(savefresh 'directory 'name)	\h'|\niu'53
(savepearl)	\h'|\niu'*
(scopy 'item) -- macro	\h'|\niu'55
(scopyslot) -- macro	\h'|\niu'**
(setblock blockname) -- fexpr	\h'|\niu'48
.sp
(setdbactive 'db) -- macro	\h'|\niu'***
(setdbsize 'poweroftwo)	\h'|\niu'39
(setv var 'val 'environment) -- fexpr	\h'|\niu'47
(slotequal 'slotnum 'item1 'item2)	\h'|\niu'*
(slotnametonumber 'slotname 'defblock) -- macro	\h'|\niu'**
(smerge 'build 'from)	\h'|\niu'55
.sp
(standardfetch 'item ['db])	\h'|\niu'43
(standardfetch1 'item 'db)	\h'|\niu'43
(standardmatch 'item1 'item2)	\h'|\niu'46
(streamp 'potstream)	\h'|\niu'30
(streamtolist 'stream)	\h'|\niu'14
.sp
(strequal 'item1 'item2)	\h'|\niu'46
(structurenamep 'potname)	\h'|\niu'30
(structurep 'potstruct)	\h'|\niu'30
(symatom 'symbol)	\h'|\niu'4
(symbol name1 name2 ...) -- fexpr	\h'|\niu'4
(symbole 'symname)	\h'|\niu'4
(symbolnamep 'potname)	\h'|\niu'30
.sp
(thawbindings 'struct)	\h'|\niu'49
(thawblock 'blockname)	\h'|\niu'49
(thawstruct 'struct)	\h'|\niu'49
(unbind globalvar) -- fexpr	\h'|\niu'45
(unbindvars 'structure) -- macro	\h'|\niu'46
(unboundatomp 'yyy)	\h'|\niu'*
.sp
(valform 'item)	\h'|\niu'20
(valprint 'item ['lmar ['rmar]])	\h'|\niu'20
(valprint1 'item 'lmar)	\h'|\niu'20
(valslotform) -- macro	\h'|\niu'**
(valueof 'var 'struct)	\h'|\niu'17
.sp
(*var* varname) -- fexpr	\h'|\niu'46
(varset 'var 'val) -- macro	\h'|\niu'*
(varvalue var 'val) -- fexpr	\h'|\niu'17
(visible 'command) -- macro	\h'|\niu'35
(vp 'item ['lmar ['rmar]])	\h'|\niu'56
(while 'val &rest 'body) -- macro	\h'|\niu'54
.fi
.bp
.nr PS 9
.nr VS 11p
.ps 9
.vs 11p
.NH
Concept Index
.LP
.nr PS 8
.nr VS 10p
.ps 8
.vs 10p
.nf
abbreviations						      \ki55-56
accessing slots of structures	\h'|\niu'8-10
accessing structure default instances	\h'|\niu'7
accessing structure definitions	\h'|\niu'7
accessing symbols	\h'|\niu'4
.sp
adding slots to structures	\h'|\niu'40
adding to the data base	\h'|\niu'12
adjunct variables	\h'|\niu'30
affecting forced aliasing (^)	\h'|\niu'27
ako's (expanded structures)	\h'|\niu'40-42
.sp
aliasing of commands	\h'|\niu'51
aliasing in hashing	\h'|\niu'27
ampersand (&) hashing	\h'|\niu'26
and, in predicates	\h'|\niu'28
anti-aliasing in hashing (<)	\h'|\niu'27
*any*	\h'|\niu'15
automatic storing of structures	\h'|\niu'8, 56
.sp
base hooks	\h'|\niu'32-37
bases	\h'|\niu'5
blocks	\h'|\niu'47-48
building structures	\h'|\niu'5
building upon data bases	\h'|\niu'38, 39
.sp
changing slots of structures	\h'|\niu'8
clearing data bases	\h'|\niu'39
colon (:) hashing	\h'|\niu'23
colon-colon (::) hashing	\h'|\niu'24
.sp
command aliasing	\h'|\niu'51
command history	\h'|\niu'51-53
command history, printing	\h'|\niu'53
compatibility functions (UCI, Franz)	\h'|\niu'58-62
.sp
controlling running of hooks	\h'|\niu'33-34
controlling results with hooks	\h'|\niu'35
controlling unbinding of variables	\h'|\niu'48-49
converting from internal form	\h'|\niu'20
copy redefined	\h'|\niu'54
copying structures	\h'|\niu'55
.sp
creating data bases	\h'|\niu'38, 39
creating patterns	\h'|\niu'15-16
creating base structures	\h'|\niu'5
creating individual structures	\h'|\niu'6
creating symbols	\h'|\niu'4
.sp
data bases	\h'|\niu'11
data bases, building upon	\h'|\niu'39
data bases, clearing	\h'|\niu'39
data bases, creating	\h'|\niu'38
data bases, fetching from	\h'|\niu'12, 19, 25, 42, 43, 46
data bases, freeing	\h'|\niu'40
data bases, inserting into	\h'|\niu'12
data bases, printing	\h'|\niu'21
data bases, releasing	\h'|\niu'40
data bases, removing from	\h'|\niu'12
data bases, setting size of	\h'|\niu'39
.sp
debugging	\h'|\niu'21
debugging print	\h'|\niu'21
declaring global variables	\h'|\niu'45
.sp
default fetch function	\h'|\niu'43
default instance for a structure	\h'|\niu'15
default instance, accessing	\h'|\niu'7
default match function	\h'|\niu'46
default printing functions	\h'|\niu'20, 58, 60-61, 62
default values for slots	\h'|\niu'14-15
defaults, inherited	\h'|\niu'41-42
.sp
defining structures	\h'|\niu'5
defining symbols	\h'|\niu'4
definitions of structures, accessing	\h'|\niu'7
deleting from the data base	\h'|\niu'12
demons (hooks)	\h'|\niu'32-37
.sp
disguising in path	\h'|\niu'10-11
disguising in predicates	\h'|\niu'29
don't-care matching variable	\h'|\niu'15
double-colon (::) hashing	\h'|\niu'24
double-star (**) hashing	\h'|\niu'24
dumping PEARL for later	\h'|\niu'53
.sp
efficiency despite variables	\h'|\niu'30
enumerated (ordinal) types	\h'|\niu'30
environment for variable evaluation	\h'|\niu'46-47
environment, top level	\h'|\niu'51-53
environments, in hooks	\h'|\niu'33
.sp
equality of structures	\h'|\niu'46
equivalences of functions (UCI-Franz)	\h'|\niu'58-62
error messages	\h'|\niu'21
evaluating function structures	\h'|\niu'51
evaluating in create	\h'|\niu'22
expanded structures	\h'|\niu'40
expanded structures, fetching	\h'|\niu'42
.sp
feedback, sending	\h'|\niu'21
fetch, standard	\h'|\niu'46
fetching expanded structures	\h'|\niu'42
fetching from all buckets	\h'|\niu'19, 25
fetching from the data base	\h'|\niu'12 , 19, 25, 42, 43, 46
fetching with equality (not matching)	\h'|\niu'46
.sp
filling in special forms (in hooks)	\h'|\niu'33
for loop	\h'|\niu'54
forced aliasing (>)	\h'|\niu'26
forest of data bases	\h'|\niu'39-40
freeing data bases	\h'|\niu'40
freezing variables	\h'|\niu'48-49
.sp
function equivalences (UCI-Franz)	\h'|\niu'58-62
function structures	\h'|\niu'49-51
function structures, evaluating	\h'|\niu'51
getting symbols	\h'|\niu'4
global variables	\h'|\niu'45
greater-than (>) hashing	\h'|\niu'26
.sp
hash aliasing (&)	\h'|\niu'26
hash marking	\h'|\niu'17, 23-27
hashing problems	\h'|\niu'18
hashing with variables	\h'|\niu'30
hiding functions from hooks	\h'|\niu'35
hierarchy of structures	\h'|\niu'40
.sp
history mechanism	\h'|\niu'51-3
history number, printing in prompt	\h'|\niu'53
hooks	\h'|\niu'32-37
hooks, affecting result with	\h'|\niu'35
hooks, controlling running of	\h'|\niu'33-34
hooks, hiding functions from	\h'|\niu'35
hooks, making functions visible to	\h'|\niu'35
hooks, multi-argument	\h'|\niu'28
hooks, running	\h'|\niu'33-34
.sp
if-added functions (hooks)	\h'|\niu'32-37
indirection in path	\h'|\niu'10-11
individuals	\h'|\niu'6
inheritance in structures	\h'|\niu'41-42
(.)init.prl file	\h'|\niu'2-3
.sp
inserting in the data base	\h'|\niu'12
instances	\h'|\niu'6
integer slots	\h'|\niu'30
internal access functions	\h'|\niu'57
internal form printing	\h'|\niu'21
.sp
invisible functions to hooks	\h'|\niu'35
invisible results from functions	\h'|\niu'53
isa's (expanded structures)	\h'|\niu'40-42
less-than (<) hashing	\h'|\niu'27
lexically scoped variables	\h'|\niu'47-48
.sp
looping functions	\h'|\niu'54
low level access functions	\h'|\niu'57
macros, special	\h'|\niu'56
main data base	\h'|\niu'11
marking structures for hashing	\h'|\niu'17, 23-27
.sp
match, standard	\h'|\niu'46
match, without unbinding variables	\h'|\niu'46
match-anything variable	\h'|\niu'15
matching process	\h'|\niu'44
matching two structures	\h'|\niu'43
matching unbound variables	\h'|\niu'44
matching-variables	\h'|\niu'16-17
.sp
merging structures	\h'|\niu'55
modified input line, printing	\h'|\niu'53
multi-argument matching predicates	\h'|\niu'28, 32
next item in a stream	\h'|\niu'13
nilstruct(ure)	\h'|\niu'14
nilsym(bol)	\h'|\niu'14
.sp
or, in predicates	\h'|\niu'28
ordinal types	\h'|\niu'30-31
path functions	\h'|\niu'10
path indirection	\h'|\niu'10-11
pattern-matching variables	\h'|\niu'16-17
.sp
patterns	\h'|\niu'12, 15, 43
patterns in matching	\h'|\niu'43
predicates for object types	\h'|\niu'30
predicates in matching	\h'|\niu'27-29
predicates in matching, when run	\h'|\niu'44
predicates in matching, multi-argument	\h'|\niu'28
.sp
print names	\h'|\niu'4
printing PEARL objects	\h'|\niu'20
printing command history	\h'|\niu'53
printing data bases	\h'|\niu'21
printing functions	\h'|\niu'20
printing functions, standard	\h'|\niu'3-4, 58, 60-61, 62
printing history number in prompt	\h'|\niu'53
printing modified input line	\h'|\niu'53
printing warnings	\h'|\niu'17
.sp
processing a stream	\h'|\niu'13
prompt	\h'|\niu'3-4
prompt-read-eval-print loop	\h'|\niu'2-3, 51
read-eval-print loop	\h'|\niu'2-3, 51
redirecting in create (! and $)	\h'|\niu'22
releasing data bases	\h'|\niu'40
removing from the data base	\h'|\niu'12
.sp
reporting bugs	\h'|\niu'21
retrieving from the data base	\h'|\niu'12
returning invisible results	\h'|\niu'53
running hooks	\h'|\niu'33-34
running under Franz Lisp	\h'|\niu'2
running under UCI Lisp	\h'|\niu'3
.sp
saving PEARL for later	\h'|\niu'53
scalar types	\h'|\niu'30
short-circuiting in create	\h'|\niu'22
side effect setting of adjunct variables	\h'|\niu'30
size of data bases	\h'|\niu'39
.sp
slot hooks	\h'|\niu'32-37
slot names to numbers	\h'|\niu'57
slot types	\h'|\niu'6
slot types, more specific	\h'|\niu'30
slot values	\h'|\niu'8-10
slot values in hooks	\h'|\niu'32
slot values in predicates	\h'|\niu'28
.sp
special forms in hooks	\h'|\niu'32
special forms in predicates	\h'|\niu'28
special forms, filling in	\h'|\niu'33
special macros	\h'|\niu'56
standard fetch function	\h'|\niu'43
standard match function	\h'|\niu'46
.sp
star (*) hashing	\h'|\niu'17, 23
star-star (**) hashing	\h'|\niu'24
(.)start.prl file	\h'|\niu'2-3
startup files	\h'|\niu'2-3
storing structures in the data base	\h'|\niu'12
storing of structures in atoms	\h'|\niu'8, 56
streams	\h'|\niu'13
.sp
structure equality	\h'|\niu'46
structure matching	\h'|\niu'44-45
structure predicates	\h'|\niu'28-29
structure slots, further typing	\h'|\niu'30
structured escapes to Lisp	\h'|\niu'49-51
structures	\h'|\niu'5
structures, copying	\h'|\niu'55
structures, expanded	\h'|\niu'40
structures, function	\h'|\niu'49-51
structures, merging	\h'|\niu'55
.sp
symbols	\h'|\niu'4
testing for nilstruct	\h'|\niu'42
testing for nilsym	\h'|\niu'42
testing for object types	\h'|\niu'30
thawing variables	\h'|\niu'48-49
.sp
top level loop	\h'|\niu'2-3, 51
top level loop functions	\h'|\niu'59, 62
triple (**) hashing	\h'|\niu'24
type tests for objects	\h'|\niu'30
types in structure slots	\h'|\niu'31-2
.sp
unbinding global variables by match (lack of)	\h'|\niu'45
unbinding global variables by user	\h'|\niu'45
unbinding local variables by match	\h'|\niu'45-6
unbinding local variables by user	\h'|\niu'46
unbinding of variables, controlling	\h'|\niu'48-49
up-arrow (^) hashing	\h'|\niu'27
.sp
values of variables	\h'|\niu'17, 46
values of variables, setting	\h'|\niu'47
variables in hooks	\h'|\niu'32
variables in predicates	\h'|\niu'28
variables with hashing	\h'|\niu'30
variable, accessing values	\h'|\niu'17, 46
variables, adjunct	\h'|\niu'30
variables, controlling unbinding	\h'|\niu'48-49
variables, freezing	\h'|\niu'48-49
variables, global	\h'|\niu'45
variables, lexically scoped	\h'|\niu'47-48
variable, setting values	\h'|\niu'47
variables, side effects	\h'|\niu'30
variables, thawing	\h'|\niu'48-49
variables, unbinding	\h'|\niu'46
.sp
visible functions to hooks	\h'|\niu'35
warnings	\h'|\niu'17
while loop	\h'|\niu'54
.fi
.nr PS 10
.nr VS 12p
.ps 10
.vs 12p
.bp 0
.DS C
.LG
\fBTable of Contents\fR
.SM
.DE
.DS L
1.  Introduction                                                                                           \ka  1
2.  Running PEARL               \h'|\nau'  2
      2.1.  Under Franz Lisp    \h'|\nau'  2
      2.2.  Under UCI Lisp      \h'|\nau'  3
3.  Creating Simple Objects     \h'|\nau'  4
      3.1.  Defining Symbols               \h'|\nau'  4
      3.2.  Defining Structures            \h'|\nau'  5
4.  Creating Individual Instances of Defined Structures \h'|\nau'  6
5.  Accessing Slots of Structures \h'|\nau'  8
6.  Storing In and Retrieving From the Data Base -- The Simplest Way \h'|\nau'11
      6.1  Storing In the Data Base: \fIInsertdb\fR and \fIRemovedb\fR\h'|\nau'11
      6.2  Retrieving Hash Buckets From the Data Base: \fIFetch\fR \h'|\nau'12
      6.3  Accessing the Results of \fIFetch\fR: \fINextitem\fR \h'|\nau'13
7.  The Default Values for Unspecified Slots \h'|\nau'14
8.  Using \fIPattern\fRs For More Flexible and Powerful Retrieval \h'|\nau'15
9.  Marking Structures During Creation For More Efficient Retrieval \h'|\nau'17
10. Printing Structures, Symbols and Other PEARL Objects \h'|\nau'20
11. Error Messages, Bugs, and Error Handling Abilities \h'|\nau'21
12. Short-Circuiting and Redirecting \fICreate\fR Using !, $ and Atoms \h'|\nau'22
13. More Flexible Hash Selection \h'|\nau'23
14. Using Predicates to Constrain Fetching \h'|\nau'27
15. More Useful Slot Types \h'|\nau'30
16. Attaching Hooks to Structures (If-Added Demons) \h'|\nau'32
17. Creating and Manipulating Multiple Data Bases \h'|\nau'38
18. Creating a Forest of Data Bases \h'|\nau'39
19. Creating Expanded Subtypes of Previously Defined Objects \h'|\nau'40
20. Fetching Expanded Structures \h'|\nau'42
21. How Two Objects \fIMatch\fR \h'|\nau'43
      21.1  When Is a Pattern not a \fIPattern\fR? \h'|\nau'43
      21.2  The Matching Process \h'|\nau'44
22. Binding Blocks of Structures Together Via Common Variables \h'|\nau'47
23. Controlling the Unbinding of Variables by \fIMatch\fR \h'|\nau'48
24. Function Structures \h'|\nau'49
25. More About the PEARL Top Level Loop and History Mechanism \h'|\nau'51
26. Looping and Copying Functions \h'|\nau'54
27. Miscellaneous Variations and Abbreviations \h'|\nau'55
28. Low Level Access Functions \h'|\nau'57
29. Appendix of UCI Lisp functions added to Franz PEARL \h'|\nau'58
30. Appendix of Franz Lisp functions added to UCI Lisp PEARL \h'|\nau'62
31. Bibliography \h'|\nau'63
32. Index of Global Variables and Functions With Their Arguments \h'|\nau'64
33. Concept Index \h'|\nau'71
.DE
EndOfFile
cat >  pearl/pearl.1  << 'EndOfFile'
.TH PEARL 1 "29 March 1983"
.UC 4
.SH NAME
pearl \- P\s-2EARL\s0 AI programming language
.SH SYNOPSIS
.B pearl
.SH DESCRIPTION
.I Pearl
is an AI programming language built on top of F\s-2RANZ\s0\ L\s-2ISP\s0.
P\s-2EARL\s0 (Package for Efficient Access to Representations in Lisp)
was developed with space and time efficiencies in mind.
In addition to providing the usual AI facilities such as slot-filler
objects, demons and associative data bases,
P\s-2EARL\s0 introduces stronger typing on slots,
user-assisted hashing mechanisms,
and a forest of data bases.
.LP
There are too many functions to list here; one should refer to the
reports listed below.
.SH AUTHORS
P\s-2EARL\s0 was implemented at Berkeley by Joseph Faletti and Michael Deering
under the direction of Robert Wilensky.
P\s-2EARL\s0 was originally implemented under UCILisp on a DEC 2040, moved
without modification to a PDP 10 under TOPS 10, and then (with
significant modification) to a VAX 11/780 under F\s-2RANZ\s0\ L\s-2ISP\s0.
.SH SEE ALSO
Deering, M., Faletti, J., and Wilensky, R.  1981.
P\s-2EARL\s0:  An Efficient Language for Artificial Intelligence Programming.
In the
.I
Proceedings of the Seventh International Joint Conference on Artificial Intelligence.  
.R
Vancouver, British Columbia.  August, 1981.
.br
.sp 1
Deering, M., Faletti, J., and Wilensky, R.  1982.
.I
The P\s-2EARL\s0 Users Manual.
.R
Berkeley Electronic Research Laboratory Memorandum No.
UCB/ERL/M82/19.  March, 1982.
EndOfFile
cat >  pearl/ptags  << 'EndOfFile'
/^\(de /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(df /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(dm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(drm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(dsm /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(def/	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(putd /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(setsyntax /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(setq /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(aliasdef /	{ print $2 "	" FILENAME "	/^" $0 "$/" }
/^\(create base /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(create individual /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(create pattern /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(create expanded /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(create function /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcreate base /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcreate individual /	{ print $4 "	"  FILENAME  "	/^" $0 "$/" }
/^\(dbcreate pattern /	{ print $4 "	"  FILENAME  "	/^" $0 "$/" }
/^\(dbcreate expanded /	{ print $4 "	"  FILENAME  "	/^" $0 "$/" }
/^\(dbcreate function /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(cr base /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(cr ind /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(cr pat /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(cr exp /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(cr fn /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcr base /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcr ind /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcr pat /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcr exp /	{ print $4 "	" FILENAME  "	/^" $0 "$/" }
/^\(dbcr fn /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(cb /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
/^\(ci /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(cp /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(ce /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(cf /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
/^\(base /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
/^\(ind /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(pat /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(exp /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(fn /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
/^\(individual /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(pattern /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(expanded /	{ print $3 "	" FILENAME  "	/^" $0 "$/" }
/^\(pfunction /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
/^\(ordinal /	{ print $2 "	" FILENAME  "	/^" $0 "$/" }
EndOfFile
cat >  pearl/template  << 'EndOfFile'
 TTTTTTTTT  EEEEEEE  M	   M   PPPPP   L	 AA    TTTTTTTTT  EEEEEEE
     T	    E	     MM   MM   P    P  L	A  A	   T	  E
     T	    EEEEE    M M M M   PPPPP   L       AAAAAA	   T	  EEEEE
     T	    E	     M	M  M   P       L       A    A	   T	  E
     T	    EEEEEEE  M	   M   P       LLLLLL  A    A	   T	  EEEEEEE
 
    Structure Definition Information Template
 
    Header
    ||=========================================||
    ||	0   unique number	   (integer)   ||
    ||	1   *pearldefinition* tag  (atom ptr)  ||
    ||	2   length		   (integer)   ||
    ||	3   default instance	   (core ptr)  ||
    ||	4   isa 		   (core ptr)  ||
    ||	5   print name		   (atom ptr)  ||
    ||	6   hash alias		   (integer)   ||
    ||	7   hash focus		   (integer)   ||
    ||	8   expansion list	   (list ptr)  ||
    ||	9   base hooks		   (lisp ptr)  ||
    ||=========================================||
 
    and for each slot (multiply slot number by 4 and add):
    ||=========================================||
    ||	+6  free (28)! enforce (1) ! hash (6)  ||
    ||	+7  type number 	   (integer)   ||
    ||	+8  slot print name	   (atom ptr)  ||
    ||	+9  pp set info 	   (atom ptr)  ||
    ||=========================================||
 
 
 
 
    Structure Instance Template
 
    Header
    ||=========================================||
    ||	0   definition		   (core ptr)  ||
    ||	1   *pearlinst* tag        (atom ptr)  ||
    ||	2   a-list and alist copy  (conscell)  ||
    ||	3   abbreviation           (atom ptr)  ||
    ||=========================================||
 
    and for each slot (multiply slot number by 4 and add):
    ||=========================================||
    ||	+0  value type             (integer)   ||
    ||	+1  value         	   ( ? ptr)    ||
    ||	+2  predicate list	   (list ptr)  ||
    ||	+3  slothook list 	   (list ptr)  ||
    ||=========================================||
 
 
 
    symbol template
 
    ||=========================================||
    ||	0   unique number	   (integer)   ||
    ||	1   *pearlsymbol* tag      (atom ptr)  ||
    ||	2   print name		   (atom ptr)  ||
    ||=========================================||
 
 
 
    data bases
 
    header
    ||=========================================||
    ||	0   name		   (atom ptr)  ||
    ||	1   *pearldb* tag	   (atom ptr)  ||
    ||	2   children		   (lisp ptr)  ||
    ||	3   active		   (t or nil)  ||
    ||	4   parent		   (lisp ptr)  ||
    ||	5   db1 		   (core ptr)  ||
    ||	6   db2 		   (core ptr)  ||
    ||=========================================||
 
    and for each hash slot i (a small 1 hash db and then a large 2/3 hash db):
    ||=========================================||
    ||	i   hash bucket 	   (lisp ptr)  ||
    ||=========================================||
 

    block template (3 cons-cells)
 
    b:Name ---+
              |
    ||========V================================||
    || Name        (atom)  | ptr to vars part  ||
    ||==========================|==============||
                                |
		    ||==========V==============================||
         Name --->  || ptr to 2nd conscell | ptr to free vars  ||
		    ||==========|==============================||
				|
		    ||==========V==============================||
		    || ptr to frozen vars  | *pearlunbound*    ||
		    ||=========================================||
EndOfFile
cat >  pearl/update.ms  << 'EndOfFile'
.ND
.nr LL 75n
.nr LT 80n
.rm CF
.ds LH PEARL Documentation
.ds CH Update
.ds RH Page %
.po 1.50i
.ls 1
.hy 14
.LP
.bp 76
.DS C
.LG
\fBUpdate of Changes
Through
PEARL 3.9
April 1983\fR
.SM
.DE
.SH
1. Introduction
.PP
This appendix describes the changes that have been made to PEARL since
the original manual was produced.
It is designed to parallel the sections of the manual so that the
original index can be used to find changes.
.PP
PEARL is now distributed with Franz Lisp (starting with Opus 38.58).
The earliest version of PEARL distributed (with 38.58) was PEARL 3.6.
The current update corresponds to version 3.9 and is being distributed
with the Franz Opus 38.69 available with 4.2 BSD Unix.
The current major and minor version numbers for PEARL are stored in
the special variables \fIpearlmajorversion\fR and \fIpearlminorversion\fR
respectively.
.PP
With the change in mail protocols and addition of new machines at
Berkeley, the form of addresses for bugs and suggestions have been
simplified.
Bugs, suggestions or queries should be sent to 
\fIPearl\-Bugs@Berkeley\fR or \fIucbvax!pearl\-bugs\fR.
.SH
2. Running PEARL
.PP
PEARL is currently only maintained under Franz Lisp.
The current version could be moved back to UCI Lisp (or to other
Lisps) fairly easily but has not been for lack of need.
Lisp Machine Lisp is the most likely Lisp that PEARL will be moved
to next but it has not been done, mostly because of conflicts in the
use of the colon character and lack of access to a Lisp Machine.
.SH
2.1 Under Franz Lisp
.PP
Since PEARL is now part of Franz Lisp, it should be available as
\fI/usr/ucb/pearl\fR or wherever you find \fIlisp\fR on your system.
.PP
The \fI.start.pearl\fR and \fI.init.pearl\fR files are actually
called \fIstart.prl\fR and \fIinit.prl\fR and may optionally be
prefixed with a dot "." and/or suffixed with either ".o" or ".l" just
as in Franz.
The use of the dot prefix and of the ".o" or ".l" is preferred
and fastest.
Thus PEARL will read the first file found in the following
sequence: \fI.init.prl.o\fR, \fI.init.prl.l\fR, \fI.init.prl\fR,
\fIinit.prl.o\fR, \fIinit.prl.l\fR, or \fIinit.prl\fR and similarly
for \fIstart.prl\fR.
Franz's special variable \fI$ldprint\fR is lambda-bound to \fInil\fR during
the reading of these two files to disable the printing of
"[load .init.prl]".
.SH
5. Accessing Slots of Structures
.PP
Doing a "\fIpath \fBput\fR" on a slot containing a variable will
not set the variable.
Rather it replaces the variable with the value provided. 
.SH
10. Printing Structures, Symbols and Other PEARL Objects
.PP
The various printing functions still exist but all call a single
formatting function with various options controlled by special atoms.
The principle functions are \fBallform\fR which does the building of a
printable list form for internal PEARL structures and \fBallprint\fR
which calls \fIallform\fR.
\fIAllform\fR uses the following global variables to determine what
form to build:
.IP 1.
\fB*abbrevprint*\fR -- a non-\fInil\fR value causes abbreviations
to be used whenever possible for any structure except the top level
structure passed to a print function.
Abbreviations are described at the end of this section.
The new functions \fBabbrevform\fR and \fBabbrevprint\fR
lambda-bind this to \fIt\fR and then call \fIallform\fR.
\fIfullform\fR binds this to \fInil\fR.
.IP 2.
\fB*fullprint*\fR -- a non-\fInil\fR value causes complete information
including hooks and predicates to be given when present.
\fIFullform\fR (and thus \fIfullprint\fR) lambda-binds this to \fIt\fR
and calls \fIallform\fR.
\fIAbbrevform\fR binds this to \fInil\fR.
.LP
\fIValform\fR lambda-binds both to \fInil\fR.
The default value of both is are also \fInil\fR, so that the default action of
\fIallform\fR when used by itself will be like \fIvalform\fR unless these
special variables are changed.
All the default print functions automatically use \fIallprint\fR so that
they can all be changed by changes to the default values of
\fI*abbrevprint*\fR and \fI*fullprint*\fR.
.LP
Two other special atoms which affect the behavior of all the printing
functions are:
.IP 3.
\fB*uniqueprint*\fR -- a non-\fInil\fR value causes a structure which is
encountered more than once during the same top-level call to a
print function to be translated into exactly the same cons-cells.
This saves on cons-cells and also makes it possible for the \fI\-\-form\fR
functions to handle circular structures, although \fIsprint\fR and thus
the \fI\-\-print\fR functions cannot handle the result.
Since most people seldom have duplications within a structure,
the default is \fInil\fR (off).
The assoc\-list of already translated structures is stored in the
special atom \fB*uniqueprintlist*\fR.
.IP 4.
\fB*quiet*\fR -- a non-\fInil\fR value disables all printing by any of
PEARL's print functions, providing an easy way to disable printing
all at once.
There is also a function called \fBquiet\fR which behaves like
\fIprogn\fR, except that it lambda-binds \fI*quiet*\fR to \fIt\fR
during the evaluation of its arguments, providing a local island
of "quiet".
.PP
The standard print functions are designed to handle any Lisp structure.
Thus, they spend a significant amount of time determining what kind of
object they have been passed.
For situations in which you know exactly what type of object you want
printed, the functions 
\fBstructureform/structureprint\fR, \fBsymbolform/symbolprint\fR,
and \fBstreamform/streamprint\fR are provided.
They assume you know what you are doing and do not ensure that
you give them the right type of value.
.PP
Adapting PEARL to fit an improvement in Franz, the atoms
\fIshowstack-printer\fR and \fItrace-printer\fR are bound to
the functions \fBpearlshowstackprintfn\fR and \fBpearltraceprintfn\fR.
\fBNote\fR the addition of "pearl" to the beginning of these.
The name of \fIbreakprintfn\fR was also changed to
\fBpearlbreakprintfn\fR but it is not currently lambda-bindable.
.SH
10.1. Abbreviations
.PP
As people build larger deeper structures it becomes useful to have
some of them abbreviated during printing if they are internal to the
structure being printed.
When an individual (including default instance) structure is created,
an abbreviation atom is stored in it.
This abbreviation is chosen as follows:
.IP 1.
If the option in \fIcreate\fR of having a structure automatically
stored in an atom is used, then that atom is the one used as an
abbreviation.
Thus the structure created by \fI(create individual x Pete)\fR will
be given the abbreviation \fIPete\fR.
.IP 2.
If that option is not used, then default instances will be
given the abbreviation \fIi:x\fR (where x is the structure type name)
and individuals at the top level will be given a name \fInewsym\fR-ed
from the name of their type.
Thus \fI(create base x)\fR will make a default instance abbreviated
\fIi:x\fR and the first structure created with \fI(create individual x)\fR
will be abbreviated \fIx0\fR.
.IP 3.
\fIScopy\fR and related functions that create new structures from old
ones \fIgensym\fR the new structure's abbreviation from that of the
old structure.
.SH
11. Error Messages, Bugs, and Error Handling Abilities
.PP
Bugs, complaints and suggestions of useful features (to be added to
the current list of 30 or so things on the wish list) should be
mailed by electronic mail to \fBPearl\-Bugs@Berkeley\fR or
\fBucbvax!pearl\-bugs\fR.
.SH
12. Short-Circuiting and Redirecting Create Using !, $ and Atoms
.PP
If an atom is encountered where a value-description was expected in
any type of slot, and it is bound to a value of the right type,
its value is inserted into the slot.
For \fIsymbols\fR, this is done if the atom is not a symbol name.
For \fIstructures\fR, the atom must evaluate to a structure.
For \fILisp\fR slots, it must simply be bound.
For \fIsetof\fR slots, its value is checked for being of the appropriate
type, including depth of nesting.
.PP
Note also that a change in the internal representation has made it possible
to allow \fBeven atoms\fR in slots of type \fIlisp\fR.
.SH
13. More Flexible Hash Selection
.PP
Because we have never gotten around to adding fetch functions to take
advantage of colon and colon-colon hashing and these two methods
really are not useful in normal fetching, they are currently ignored.
.PP
For situations in which you wish to create an expanded structure and
add new hashing marks to an old slot (rather than replace them),
preceding new hash marks with a plus ("+") will cause the old
hashing information to be copied before processing the new hashing.
.PP
Thus, the sequence
.DS
(cb x (* a int))
(ce x y (a ^))
(ce x z (+ : a ^))
(ce x w (: + a ^)) ; anomalous use of +
.DE
will result in:
.DS
* hashing in x,
no hashing in y,
both * and : hashing in z, and
only * hashing in w (because of misplacement of +).
.DE
.PP
Several new hashing methods have been added to PEARL.
.PP
A hashing mechanism using the label \fB***\fR has been added called
"triple-star hashing".
If slots are labeled with *** and \fBall\fR slots so marked are filled
with useful values, then the item is hashed under the type of structure
plus the values of all these slots.
During fetching, this is considered the most useful (that is,
specific) hash method.
.PP
A hashing mechanism using the label \fB&&\fR has been added called
"hash focusing".
It is designed for people using a data base all of
whose entries are of the same type (not required, just common
for this application) and enables the contents of a single slot
to be used to better discriminate them.
Examples of such structures are "planfors", inference rules,
or almost any other such extremely-common binary predicates.
If a slot labeled && is found when inserting into the database then
the item is hashed as if it were the item in the slot so labeled.
At fetching time, && is considered less useful than *** or **
and more useful than * or nothing.
.PP
This differs from & (hash aliasing) in that hash focusing
affects how a structure itself is inserted and fetched, while
& simply affects how structures containing this type of
structure are treated.
For example, suppose the unique numbers of A, B, and C
respectively are 1, 2, and 3.
C is a symbol.
A has one slot X with * and && hashing.
B has one slot Y of type symbol with * hashing.
Then a structure like (A (X (B (Y C)))) will be indexed the
following ways and \fIfetcheverywhere\fR (see below) will find
it in the following order: the && method will be used first
which uses the 2 and 3 from B and its C, (ignoring the 1 of A),
and also simply 2 from B;
the * on A uses the type of B thus using 1 and 2;
it is also looked for under the 1 of A without using 2 or 3.
If B had an & in its slot then the * on A is affected by & on B thus
using 1 and 3 (ignoring the 2 of B).
.PP
Thus, if you consider A, B, and C to be three levels of information
in the structure, an item can be hashed under any combination of two
of those levels.
The normal * method uses levels 1 and 2,
the aliasing & method ignores level 2 and uses levels 1 and 3,
and the new focussing && method ignores level 1 and uses levels 2 and 3.
In addition, the item can be put under 1, 2 or 3 individually by
various combinations of marks (1 = none, 2 = :, 3 = :+&).
The only unavailable combination of the three is all of them.
.SH
16. Attaching Hooks to Structures (If-Added Demons)
.PP
Slot hooks are now always inherited and added to, rather than replaced.
If the hooks and predicates of a slot are preceded by \fBinstead\fR
then inheriting does not happen and hooks and predicates are replaced.
.PP
The atoms for path hooks were misnamed in such a way that you could not
use \fIhidden\fR and \fIvisible\fR.
Instead of \fI*rungethooks*\fR, and other \fI*run...hooks*\fR forms,
they are now \fB*rungetpathhooks*\fR and other \fB*run...pathhooks*\fR.
Note that they must be called as (\fIXXX\fRpath ...) and not
(path\ \fIXXX\fR ...) when used with \fIhidden\fR and \fIvisible\fR.
.SH
17. Creating and Manipulating Multiple Data Bases
.PP
The function \fIsetdbsize\fR can now be done at any time and
will remove all current databases before changing the size,
warn the user (if \fI*warn*\fR is set) and recreate \fI*maindb*\fR
with the special variable \fI*db*\fR pointing to it.
.PP
The function \fIcleardb\fR is now a local database clearer
and its effects do not extend up the database hierarchy.
.SH
19. Creating Expanded Subtypes of Previously Defined Objects
.PP
Hashing in old slots inherited by new expanded structures can now be
added to by preceding the new hash marks with plus ("+").
See section 13 above.
.PP
The name of an old slot inherited by a new expanded structure may be
changed by following the new name by the old slotname preceded with
an equal sign.
Thus for example:
.DS
pearl> (create base X (A struct))
    (X (A (nilstruct)))
pearl> (create expanded X Y (B =A) (C .....))
    (Y (B (nilstruct)) (C .....)))
.DE
Note that there may not be a space between the equal sign and the slot
name since \fI=\fR is a read macro which expands \fI=A\fR into
\fI(*slot* A)\fR but leaves a single space-surrounded equal sign alone.
The actual effect is to add another name to the slot so that it can be
later referenced with either name.
.SH
20. Fetching Expanded Structures
.PP
A fetching function called \fBfetcheverywhere\fR exists which gathers
\fBall\fR the buckets the object could have been hashed into and
builds a stream out of all of them (potentially five buckets).
There is currently no "expanded" counterpart, since it has the potential
of returning \fI5 times the-depth-of-the-hierarchy\fR buckets.
.SH
21.2 The Matching Process
.PP
During matching, if an unbound global variable is set and
the match later fails, the value is restored to \fI*pearlunbound*\fR.
The names of variables that are set are saved in the special variable
\fB*globalsavestack*\fR.
.PP
Formerly, there was only one match function which was used by both
\fIstandardfetch\fR and \fIexpandedfetch\fR and which therefore would
match two structures if they were hierarchically related.
This is really inappropriate for the standard fetching, so 
there are now two regular match functions, \fIstandardmatch\fR and
\fIbasicmatch\fR, which will only match two structures of the same type,
and two expanded match functions, \fIstandardexpandedmatch\fR and
\fIbasicexpandedmatch\fR, which will match two structures which are
related hierarchically (one above the other) on the slots they have
in common.
Streams built by \fIstandardfetch\fR use the regular versions and
and streams built by \fIexpandedfetch\fR use the expanded versions.
.PP
There are now two functions \fBmemmatch\fR and \fBmemstrequal\fR which
are like \fImemq\fR except that they use \fImatch\fR and \fIstrequal\fR
respectively instead of \fIeq\fR.
.PP
As of version 3.8, PEARL will now do \fBunification\fR of variables in
pattern matching.
To turn it on, call the function \fBuseunification\fR.
(The current implementation precludes turning it off once it is on but
this may be remedied in later versions if we can figure out what it
means to stop unifying.)
.SH
26. Looping and Copying Functions
.PP
The function \fIscopy\fR no longer deletes bound adjunct variables.
.PP
The standard Franz function \fIcopy\fR is no longer redefined since
the standard version now avoids the copying of hunks.
.PP
The functions \fIscopy\fR and \fIpatternize\fR are now exprs rather
than macros.
.PP
The new function \fBvarreplace\fR permanently "freezes" the values
of slots containing bound variables by replacing all bound variables
in an item with their values.
.PP
A variation on \fIscopy\fR called \fBintscopy\fR ("internal scopy")
is designed to do the copying as if the copied item were internal to
another outer item, thus sharing its local and block variables.
Its arguments are the item to be copied and the outer item in whose
scopy the copying should be done.
.SH
29. Appendix of UCI Lisp functions added to Franz PEARL
.PP
The definitions of \fIde\fR, \fIdf\fR, \fIdm\fR, \fIdrm\fR and \fIdsm\fR
have been modified so that if the special variable \fB*savedefs*\fR
is \fInil\fR then old definitions of functions are not saved.
This is especially useful in compiling (and as a result, assembly
and loading) since it will speed them up quite a bit.
This also disables the saving of the name of the file that the
definition was in.
The variable \fI*savedefs*\fR is normally \fIt\fR which causes these
macros to act as before, saving the definition, etc.
If \fI*savedefs*\fR is \fInil\fR, then they simply expand into the
appropriate \fIdefun\fR or \fIsetsyntax\fR.
The following lines should be included in a file to have this effect
only at compile time:
.DS
(eval-when (compile)
	(declare (special *savedefs*))
	(setq *savedefs* nil))
.DE
.LP
If you also want to permanently disable this feature in a lisp, that
loads \fIucisubset.l\fR, simply put a \fI(setq *savedefs* nil)\fR
in your \fI.lisprc\fR file AFTER the loading of \fIucisubset.l\fR.
.PP
The function \fIremove\fR is no longer made equivalent to Franz's
\fIdelete\fR so that Franz's \fIremove\fR can be used.
The functions \fInth\fR, \fIpush\fR and \fIpop\fR are no longer
defined by PEARL, since the new Franz versions are better.
(UCI Lisp users note: This switches the arguments to \fIpush\fR.)
.SH
32. Index of Global Variables and Functions With Their Arguments
.PP
All special variables in PEARL are now defined with \fIdefvar\fR so
that \fIfasl\fR'ing in \fIpearl.o\fR at compile time will automatically
declare them special again.
.PP
All the exprs whose names were of the form \fIXXXX1\fR where
\fIXXXX\fR was the name of a lexpr which was a principle function
of PEARL were eliminated (i.e., absorbed by the other form).
.SH
34. Compiling Lisp+PEARL Files.
.PP
To compile a file of mixed Lisp and PEARL functions with \fIliszt\fR,
you must first load in the function definitions and special
declarations of PEARL by loading the object code.  
This is the file \fIpearl.o\fR which is normally kept in the
\fI/usr/lib/lisp\fR directory and will found automatically by
\fIload\fR.
.PP
Thus, the following should normally be included at the
beginning of a PEARL file you wish to compile:
.DS
(eval-when (compile)
	(declare (special defmacro-for-compiling))
	(setq defmacro-for-compiling t)
	(load 'pearl.o))
(declare (macros t))
.DE
.rm CF
.rm LH
.rm CH
.rm RH
.bp
.DS C
.LG
\fBUpdate of Changes
Through
PEARL 3.9
April 1983
.sp 1
Table of Contents\fR
.SM
.DE
.DS L
1.  Introduction                                                                                           \ka76
2.  Running PEARL               \h'|\nau'76
      2.1.  Under Franz Lisp    \h'|\nau'76
5.  Accessing Slots of Structures \h'|\nau'76
10. Printing Structures, Symbols and Other PEARL Objects \h'|\nau'76
      10.1.  Abbreviations \h'|\nau'77
11. Error Messages, Bugs, and Error Handling Abilities \h'|\nau'78
12. Short-Circuiting and Redirecting \fICreate\fR Using !, $ and Atoms \h'|\nau'78
13. More Flexible Hash Selection \h'|\nau'78
16. Attaching Hooks to Structures (If-Added Demons) \h'|\nau'79
17. Creating and Manipulating Multiple Data Bases \h'|\nau'80
19. Creating Expanded Subtypes of Previously Defined Objects \h'|\nau'80
20. Fetching Expanded Structures \h'|\nau'80
21.2  The Matching Process \h'|\nau'80
26. Looping and Copying Functions \h'|\nau'81
29. Appendix of UCI Lisp functions added to Franz PEARL \h'|\nau'81
32. Index of Global Variables and Functions With Their Arguments \h'|\nau'81
34. Compiling Lisp+PEARL Files \h'|\nau'82
.DE
EndOfFile
cat >  pearl/alias.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; alias.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Aliases for various functions -- some for history's sake, some
;    for abbreviation's sake 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; For history:
;(aliasdef 'powercopy 'copy 'subr)
(aliasdef 'minform 'valform 'subr)
(aliasdef 'minprint 'valprint 'subr)
(aliasdef 'listform 'fullform 'subr)
(aliasdef 'shortform 'valform 'subr)
(aliasdef 'listprint 'fullprint 'subr)
(aliasdef 'shortprint 'valprint 'subr)
(aliasdef 'insert-db 'insertdb 'subr)
(aliasdef 'next-item 'nextitem 'subr)
(aliasdef 'remove-db 'removedb 'subr)
(aliasdef 'expanded-fetch 'expandedfetch 'subr)
(aliasdef 'symbol-e 'symbole 'subr)
(aliasdef 'combine-skels 'combineskels 'subr)
(aliasdef 'quasi-quote 'quasiquote 'subr)
(aliasdef 'define-set 'ordinal 'fsubr)
(aliasdef 'usersave 'savefresh 'subr)
(aliasdef 'user-save 'usersave 'subr)
(aliasdef 'pearl-rep-loop 'pearlreploop 'subr)

; Abbreviations:
(aliasdef 'cr 'create 'fsubr)
(aliasdef 'dbcr 'dbcreate 'macro)
(aliasdef 'ppath 'path 'macro)
(aliasdef 'vp 'valprint 'subr)
(aliasdef 'fp 'fullprint 'subr)
(aliasdef 'ap 'abbrevprint 'subr)
(aliasdef 'dp 'debugprint 'subr)
(aliasdef 'pdb 'printdb 'subr)

; vi: set lisp:
EndOfFile
cat >  pearl/create.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; create.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for creating, copying, and merging structures.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Create a new structure of one of the five types:
;     BASE:        build a new structure with all new slots.
;     EXPANDED:    build new slots in addition to slots inherited from
;                     a BASE or EXPANDED structure.
;     INDIVIDUAL:  create an instance of a BASE or EXPANDED structure,
;                     filling in slots or inheriting defaults from above.
;     PATTERN:     create an instance of a BASE or EXPANDED structure but
;                     fill in unspecified slots with ?*ANY*.
;     FUNCTION:    build a new structure with slots describing the
;                     arguments to the function.
 
; Generalized syntax for this function is:
;
; (CREATE <StructureType> <ExpandedorBaseName> <NewItemName>
;         [{HashingInfo} <OldSlotName> {{{:=} <SlotValue>} | ^}
;                        { : <Variable> }
;                        {<ListOfRestrictionStructureOrSlotIfNames>} ]
;    . . . . . . .
;         [{HashingInfo} <NewSlotName> <Type> {{{:=} <SlotValue>} | ^}
;                        { : <Variable> }
;                        {<ListOfRestrictionStructureOrSlotIfNames>} ] )
 
; BASE structures have no <ExpandedorBaseName> and only new slots.
; EXPANDED structures should have at least one new slot and inherit
;       default values from the <ExpandedorBaseName>.
; INDIVIDUAL structures have only old slots and inherit default values from
;       the <ExpandedorBaseName>;  if the <NewItemName> occurs, the atom
;       <NewItemName> is set to point to the internal form which is also
;       returned as the value of CREATE.
; PATTERN structures have only old slots and all unspecified slots are
;       set to ?*ANY* rather than inheriting a default.
; FUNCTION structures have no <ExpandedOrBaseName> and only new slots.
;       They are interpreted as functions to be run rather than structures
;       to be accessed when they are MATCHed, FETCHed or PATHed.
;
; The structure created is always stored in the SPECIAL variable *LASTCREATED*
;       in addition to the <NewItemName> if specified and the atom formed
;       by prepending a 'd:' to the front of the <ExpandedOrBaseName>.
;
; If the SlotValue for a slot in a BASE or EXPANDED structure is preceded
;       by a :=, then the slot is filled with this value but it is not
;       used as the default for this slot in future INDIVIDUALS and
;       EXPANDEDS.
; If the SlotValue is not preceded by a :=, then the value represents a
;       default to be inherited by INDIVIDUALs and new EXPANDEDS.
 
; This just sets the two atoms *toplevelp* and *currentcreatetype*
;   and calls the real workhorse "insidecreate".
(df create (l)
  (setq *toplevelp* t)
  (setq *currentcreatetype* (car l))
  (apply (function insidecreate) l))
 
; Pick apart the atoms before the slots, handle them and pass the
;    rest on to the appropriate version of create XXX.
(df insidecreate (l)
  (let ((type (car l))
	(abbrev (cond (*toplevelp* '*buildabbrev*)
		      ( t nil)))
	(name1 (cadr l))
	(name2 (caddr l))
	(name3 (cadddr l))
	slots)
       (cond ((reallitatom name2)
	      (setq abbrev name2)
	      (setq slots (cdddr l))
	      (cond ((reallitatom name3)
		     (setq abbrev name3)
		     (setq slots (cddddr l)))
		    ( t  (setq name3 name2))))
	     ( t (setq name3 (setq name2 name1))
		 (setq slots (cddr l))))
       (and (memq type '(ind individual pat pattern))
	    (eq name1 name3)
	    (setq name3 '*lastcreated*))
       (set name3
	    (setq *lastcreated*
		  (selectq type
			   ((individual ind)
			    (createindividual name1 abbrev slots))
			   (base
			    (createbase name1 abbrev slots))
			   ((expanded exp)
			    (createexpanded name1 name2 abbrev slots))
			   ((pattern pat)
			    (createpattern name1 abbrev slots))
			   ((function fn)
			    (createfunction name1 abbrev slots))
			   (otherwise (msg t "CREATE: Illegal selector: " type
					   " in created structure: " l t)
				      (pearlbreak)))))))
 
; Create a new structure and insert it in the database.
(defmacro dbcreate (&rest rest)
  `(insertdb (create .,rest)))

(defmacro cb (&rest rest)
  `(create base .,rest))

(defmacro ci (&rest rest)
  `(create individual .,rest))

(defmacro ce (&rest rest)
  `(create expanded .,rest))

(defmacro cp (&rest rest)
  `(create pattern .,rest))

(defmacro cf (&rest rest)
  `(create function .,rest))
 
(defmacro base (&rest rest)
  `(create base .,rest))

(defmacro ind (&rest rest)
  `(create individual .,rest))

(defmacro individual (&rest rest)
  `(create individual .,rest))

(defmacro pexp (&rest rest)
  `(create expanded .,rest))

(defmacro expanded (&rest rest)
  `(create expanded .,rest))

(defmacro pat (&rest rest)
  `(create pattern .,rest))

(defmacro pattern (&rest rest)
  `(create pattern .,rest))

(defmacro fn (&rest rest)
  `(create function .,rest))
 
(defmacro pfunction (&rest rest)
  `(create function .,rest))
 
;  Put a *VAR* variable in the structure's assoc-list and return the cons-cell.
(defmacro installvar (varname)
  `(cond ((eq '*any* ,varname) *any*conscell*)
	 ; else, if there, return it.
	 ((assq ,varname (getalist *currenttopcreated*)))
	 ; else, add it (which also returns the special conscell).
	 (  t   (addalist ,varname *currenttopcreated*))))
 
; Install an adjunct variable in the slot.
(defmacro installadjunct (adjunctvar)
  `(let (var)
	(cond ((dtpr ,adjunctvar)
	       (setq var (cadr ,adjunctvar))
	       (selectq (car ,adjunctvar)
			(*var* (installvar var))
			(*global* var)
			(otherwise
			 (msg t "CREATE: no adjunct variable given after colon "
			      "-- rest of slot is: " ,adjunctvar slot t)
			 (pearlbreak))))
	      (  t  (msg t "CREATE: no adjunct variable given after colon. "
			 "Rest of slot is: " ,adjunctvar slot t)
		    (pearlbreak)))))

(dm handlepossibleadjunctvar (none) ; but assumes SLOT, SLOTVALUE, & VALUETYPE.
  '(let ((adjunctvar (car slot)))
	(and (eq adjunctvar ':)
	     (cond ((neq valuetype 'CONSTANT)
		    (msg t "CREATE: Adjunct variables not allowed in "
			 "slots whose values are also variables." t)
		    (pearlbreak))
		   ( t (setq slot (cdr slot)) ; throw away ":".
		       (setq adjunctvar (pop slot))
		       (setq valuetype 'ADJUNCT)
		       (setq slotvalue (cons slotvalue
					     (installadjunct adjunctvar))))))))

; Ensure that value is of type TYPENUM (used after ! or on value in atom
;    where setof value expected).  Value returned (t / never) is used
;    only in evaluating atom.  If error, doesn't return.
(de enforcetype (value typenum)
  (or (selectq typenum
	       (0 (structurep value))
	       (1 (psymbolp value))
	       (2 (numberp value))
	       (3 (not (reallitatom value)))
	       (otherwise
		(apply (function and)
		       (mapcar (funl (singlevalue)
				     (enforcetype singlevalue
						  (- typenum 4)))
			       value))))
      (progn (msg t "CREATE: Value after ! or bound to atom in SETOF "
		  "slot is of wrong type.  Value is: " value t)
	     (pearlbreak))))

; Get the value for a slot.
; If preceded by an ! then it is already in internal form but verify this.
; If is preceded by a $ then it should be evaluated before continuing
;    processing (on its value).
(dm constructvalue (none)
  '(let ((typenum (getslottype slotnum defblock))
	 (ppset   (getppset    slotnum defblock)))
	(selectq (car slot)
		 (\!  (setq slot (cdr slot))
		      (setq newvalue (eval (pop slot)))
		      (enforcetype newvalue typenum)
		      (setq valuetype 'CONSTANT)
		      (setq slotvalue newvalue))
		 (\$  (setq slot (cdr slot))
		      (setq newvalue (eval (pop slot)))
		      (setq valuetype 'CONSTANT)
		      (setq slotvalue (buildvalue newvalue typenum ppset)))
		 (otherwise
		  (cond ((and (dtpr (car slot))
			      (eq (caar slot) '*var*))
			 (setq valuetype 'LOCAL)
			 (setq newvalue (cadr (pop slot)))
			 (setq slotvalue (installvar newvalue)))
			((and (dtpr (car slot))
			      (eq (caar slot) '*global*))
			 (setq valuetype 'GLOBAL)
			 (setq slotvalue (cadr (pop slot))))
			(  t  (setq valuetype 'CONSTANT)
			      (setq slotvalue
				    (buildvalue (pop slot) typenum ppset))))))))
 
; Generate the default value for slots of the given type.
(defmacro defaultfortype (typenum)
  `(selectq ,typenum
	    (0 (eval (instatom 'nilstruct)))
	    (1 (eval (symatom 'nilsym)))
	    (2 0)
	    (3 nil)))
 
; Look at the ISA to find the default value, or the else use
;    the default default for that type.
(defmacro inheritvalue (structdef)
  `(let ((isa ,structdef))
	(cond ((or (null isa)
		   (not (getenforce slotnum isa)))
	       (setq slotvalue (defaultfortype (getslottype slotnum defblock)))
	       (setq valuetype 'CONSTANT))
	      ( t (let ((default (getdefaultinst isa)))
		       (setq slotvalue (getslotvalue slotnum default))
		       (setq valuetype (getslotvaluetype slotnum default)))))))
 
; Look for predicates and hooks.  Use tconc to keep in order.
(dm handlepredicatesandhooks (none)
  '(progn
    (setq predlist (ncons nil))
    (setq slothooklist (ncons nil))
    (while (setq fcn (pop slot))
	   (cond ((atom fcn)
		  (cond ((eq fcn 'instead)
			 ; Don't inherit hooks.
			 (putpred slotnum nil valblock))
			((memq fcn '(if hook))
			 ; A hook follows.
			 (tconc slothooklist (cons (pop slot) (pop slot))))
			; Structure predicate.
			((structurenamep fcn)
			 (tconc predlist (eval (defatom fcn))))
			; Otherwise, a predicate name.
			( t (tconc predlist fcn))))
		 ; Otherwise an s-expression predicate.
		 ( t (tconc predlist fcn))))
    (putpred      slotnum
		  (nconc (car predlist) (getpred slotnum valblock))
		  valblock)
    (putslothooks slotnum
		  (nconc (car slothooklist) (getslothooks slotnum valblock))
		  valblock)))

; Build a new slot in the current structure.
(dm buildslot (none)
  '(progn
    (setq slotname (pop slot))
    (clearhashandformat slotnum defblock)
    ; To gather hashing and enforce information before installing in defblock.
    (setq hashcollect 0)
    (setq reqstruct nil)

    ; Check for hashing marks first.
    (while (selectq slotname
		    ; First starred slot used for > hashing if no & present.
		    (*   (and (\=& 0 first*edslot)
			      (setq first*edslot (minus slotnum)))
			 (addhash*   hashcollect))
		    (**  (addhash**  hashcollect))
		    (*** (addhash*** hashcollect))
		    (&   (cond ((not (\=& 0 hashalias))
				(msg t "CREATE: Only 1 hash alias (&) or "
				     "selected slot (^) allowed in: "
				     newname t)
				t)
			       ( t (setq hashalias slotnum))))
		    (^   (cond ((not (\=& 0 hashalias))
				(msg t "CREATE: Only 1 hash alias (&) or "
				     "selected slot (^) allowed in: "
				     newname t)
				t)
			       ( t (setq hashalias (minus slotnum)))))
		    (&&  (cond ((not (\=& 0 hashfocus))
				(msg t "CREATE: Only 1 hash focus (&&) "
				     "allowed in: " newname t)
				t)
			       ( t (setq reqstruct t)
				   (setq hashfocus slotnum))))
		    (:   (addhash:   hashcollect))
		    (::  (addhash::  hashcollect))
		    (>   (addhash>   hashcollect))
		    (<   (addhash<   hashcollect)))
	   (setq slotname (pop slot)))
    (and (\=& 0 (length slot))
	 (progn (msg t "CREATE: Missing slot name and/or type in slot number "
		     slotnum " of structure: " newname t)
		(pearlbreak)))

    ;  Slotname now holds the slotname.  Should be checked for duplicates!!
    (putslotname slotnum (ncons slotname) defblock)

    ; Now look for the type.
    (setq typenum 0)
    (setq slottype (pop slot))
    (while (selectq slottype
		    (struct (setq reqstruct nil)
			    nil)     ; i. e., add 0 to TYPENUM.
		    (symbol (setq typenum (1+ typenum))  nil)
		    (int    (setq typenum (+ 2 typenum))  nil)
		    (lisp   (cond ((not (\=& 0 typenum))
				   (msg t "CREATE: <setof lisp> not allowed. "
					"Type changed to <lisp> in slot "
					slotname " of " newname t)
				   (setq typenum 3) nil)
				  ((not (\=& 0 hashcollect))
				   (setq hashcollect 0)
				   (msg t "CREATE: No hashing allowed on "
					"<lisp> slots in slot " slotname
					" of " newname t)))
			    (setq typenum 3) nil)
		    (setof (setq typenum (+ 4 typenum))    t)
		    (otherwise
		     ; Either an ordinal type ==> integer,
		     ;   or a structure name ==> struct, or an error.
		     (cond ((memq slottype *ordinalnames*)
			    (setq typenum (+ 2 typenum)) nil)
			   ((structurenamep slottype)
			    (setq reqstruct nil)
			    nil)     ; i. e., add 0 to TYPENUM.
			   (  t  (msg t "CREATE: Illegal type: " slottype
				      " in slot: " slotname " of " newname t)
				 nil))))
	   (setq slottype (pop slot)))
    (and reqstruct
	 (progn (msg t "CREATE: && hashing only allowed on STRUCT slots."
		     t " Bad slot is called " slotname
		     " and is of type " slottype t)
		(pearlbreak)))
    ; Save the last word of the type which is possibly a structure or
    ; ordinal type name for future use.
    (putppset slotnum slottype defblock)
    (putslottype slotnum typenum defblock)

    ; Next, look for a value, or ^ to inherit from above;
    ;     these may be preceded by := or == to determine future
    ;     "enforcing" (should be less strong term) of this default.
    (setq slotvalue nil)
    (setq valuetype nil)
    (setq enforce (pop slot))
    (selectq enforce
	     (:\=  (cond ((eq (car slot) '^)
			  (setq slot (cdr slot))
			  (inheritvalue nil))
			 ( t (constructvalue))))
	     (\=\= (addenforce hashcollect)
		   (cond ((eq (car slot) '^)
			  (setq slot (cdr slot))
			  (inheritvalue nil))
			 ( t (constructvalue))))
	     ((^ nil)
	      (addenforce hashcollect)
	      (inheritvalue nil))
	     (otherwise (push enforce slot)
			(addenforce hashcollect)
			(constructvalue)))

    (handlepossibleadjunctvar)

    ; Hash, enforce, slotvalue and valuetype can now be installed.
    (puthashandenforce slotnum hashcollect defblock)
    (putslotvaluetype  slotnum valuetype   valblock)
    (putslotvalue      slotnum slotvalue   valblock)

    (handlepredicatesandhooks)))
 
; Create a new structure of type BASE:  a structure with ALL NEW slots.
(de createbase (newname abbrev slots)
  (and (eq newname 'nilstruct)
       (boundp (defatom 'nilstruct))
       (progn (msg t "CREATE BASE: Cannot redefine nilstruct." t)
	      (pearlbreak)))
  (and (structurenamep newname)
       *warn*
       (msg t "CREATE BASE: Warning: Creating a new definition"
	    " of an existing structure: " newname t))
  (prog (defblock slotname slottype enforce fcn ppset slot length isa
		  typenum valblock predlist slothooklist
		  first*edslot basehooks basehookbefore newvalue reqstruct
		  hashalias hashfocus hashcollect slotvalue valuetype)

	; Process base hooks if the first "slot" is named "if" or "hook".
	(cond ((memq (caar slots) '(if hook))
	       (setq basehookbefore (cdr (pop slots)))
	       (setq basehooks (ncons nil))

	       ; Use tconc to preserve order.
	       (while basehookbefore ; is not NIL
		      (tconc basehooks (cons (pop basehookbefore)
					     (pop basehookbefore))))
	       (setq basehooks (car basehooks)))
	      ( t (setq basehooks nil)))

	; Allocate hunks for definition and default instance (valblock)
	;     based on number of slots.
	(setq defblock (allocdef (setq length (length slots))))
	(setq valblock (allocval length))
	(puttypetag '*pearldef* defblock)
	(puttypetag '*pearlinst* valblock)
	(cond (*toplevelp* (setq *currenttopcreated* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
	      ( t (putbothalists *currenttopalists* valblock)))

	(putdef defblock valblock)
	(putdefaultinst valblock defblock)
	(set (instatom newname) valblock)
	(set (defatom newname) defblock)
	(and abbrev
	     (cond ((eq abbrev '*buildabbrev*)
		    (putabbrev (instatom newname) valblock))
		   ( t (putabbrev abbrev valblock))))
	(putuniquenum (newnum) defblock)
	(putstructlength length defblock)
	(putisa nil defblock)
	(putexpansionlist nil defblock)
	(putbasehooks basehooks defblock)
	(putpname newname defblock)

	(setq hashalias 0)
	(setq hashfocus 0)
	(setq first*edslot 0)
	(for slotnum 1 length
	     (setq slot (pop slots))
	     (buildslot))

	(cond ((\=& 0 hashalias) (puthashalias first*edslot defblock))
	      ( t  (puthashalias hashalias defblock)))
	(puthashfocus hashfocus defblock)

	(return valblock)))
 
; Create a new individual just for this slot.
(defmacro buildstructvalue (struct)
  `(cond ((and (atom ,struct)                      ; if an atom
	       (boundp ,struct)                    ; and bound
	       (structurep (eval ,struct)))        ; to a structure,
	  (eval ,struct))                          ; evaluate it.
	 ; Otherwise, recursively call create.
	 ( t (selectq (car ,struct)
		      ; New create type in slot.
		      ((ind individual pat pattern fn function
			    base exp expanded)
		       (let ((*currentcreatetype* (car ,struct)))
			    (apply (function insidecreate) ,struct)))
		      (otherwise
		       ; Otherwise, use current create type.
		       (apply (function insidecreate)
			      (cons *currentcreatetype* ,struct)))))))
 
; Get a pointer to the symbol.
(defmacro buildsymbolvalue (sym)
  `(cond ((symbolnamep ,sym)   (eval (symatom ,sym)))
	 ; If not a symbol name, then ...
         ((and (atom ,sym)                      ; if an atom
	       (boundp ,sym)                    ; and bound
	       (psymbolp (eval ,sym)))          ; to a symbol,
	  (eval ,sym))                          ; evaluate it.
	 ; Otherwise, error.
	 ( t  (msg t "CREATE: " ,sym " is used in a slot of type SYMBOL but "
		   "neither is the name of a symbol nor evaluates to one." t)
	      (pearlbreak))))
 
; Get an integer using PPSET if not an integer.
(defmacro buildintvalue (intval bppset)
  `(let (assocval)
	(cond ((numberp ,intval) ,intval)
	      ; Ordinal type given for ppset.
	      ((and ,bppset    ; is not NIL.
		    (setq assocval (assq ,intval (eval (ordatom ,bppset)))))
	       (cdr assocval))
	      ; Some other atom which is bound to an integer.
	      ((and (atom ,intval)
		    (boundp ,intval)
		    (numberp (eval ,intval)))
	       (eval ,intval))
	      ; Otherwise, error.
	      ( t (msg t "CREATE: Unbound atom or non-integer value: "
		       ,intval " in integer slot." t) 
		  (pearlbreak)))))
 
; Construct a new value of the specified type using the pplist if necessary
(de buildvalue (value typenum ppset)
  (selectq typenum
	   (0 (buildstructvalue value))
	   (1 (buildsymbolvalue value))
	   (2 (buildintvalue    value ppset))
	   (3 value) ; i.e., could be anything they want.
	   (otherwise
	    (cond ((and (atom value)
			(boundp value)
			(enforcetype (eval value) typenum))
		   (eval value))
		  ( t (mapcar (funl (singlevalue)
				    (buildvalue singlevalue
						(- typenum 4) ppset))
			      value))))))
 
; Return the position number of SLOTNAME in structure DEFBLOCK.
(defmacro slotnametonumber (slotname defblock)
  `(progn
    (setq slotlocation 0)
    (for slotnum 1 (getstructlength ,defblock)
	 (and (memq ,slotname (getslotname slotnum ,defblock))
	      (setq slotlocation slotnum)))
    slotlocation))
 
; Find the slotname in SLOT, put it in SLOTNAME, and find its SLOTNUM.
(dm findslotnum (none)
  '(progn
    (setq slotname slot)
    (while (memq (car slotname) '(* ** *** & ^ && : :: < > +))
	   (setq slotname (cdr slotname)))
    (cond ((and (dtpr (cadr slotname))
		(eq '*slot* (car (cadr slotname))))
	   (setq slotname (cadr (cadr slotname)))
	   (minus (slotnametonumber slotname olddefblock)))
	  ( t (setq slotname (car slotname))
	      (slotnametonumber slotname olddefblock)))))
 
; Look up through ISA links and add name to Expansion Lists.
;    Assumes PROG vars NEWNAME and OLDDEFBLOCK.
(dm addtoexpansionlists (none)
  '(progn
    (setq isa olddefblock)
    (while isa         ; is not null
	   (putexpansionlist (cons defblock (getexpansionlist isa)) isa)
	   (setq isa (getisa isa)))))
 
; Copy definition for one slot.
(dm copyslice (none)
  '(progn
    (putslottype      slotnum (getslottype      slotnum olddefblock) defblock)
    (putslotname      slotnum (getslotname      slotnum olddefblock) defblock)
    (putppset         slotnum (getppset         slotnum olddefblock) defblock)
    (puthashandformat slotnum (gethashandformat slotnum olddefblock) defblock)))
 
; Copy default values, predicates, and hooks for one slot.
(dm copyslot (none)
  '(progn
    (putslotvaluetype slotnum (getslotvaluetype slotnum oldvalblock) valblock)
    (putslotvalue     slotnum (getslotvalue     slotnum oldvalblock) valblock)
    (putpred          slotnum (getpred          slotnum oldvalblock) valblock)
    (putslothooks     slotnum (getslothooks     slotnum oldvalblock) valblock)))
 
; Copy an old slot from an ISA into the current structure.
(dm fillbaseslot (none)
  '(progn
    (cond ((<& slotnum 0)
	   (setq slotnum (minus slotnum))
	   (setq newslotnamep t))
	  ( t (setq newslotnamep nil)))

    ; First check for changed hashing.
    (setq slotname (pop slot))
    (clearhashandformat slotnum defblock)
    (setq hashcollect 0)
    (while (selectq slotname
		    (*   (and (\=& 0 first*edslot)
			      (setq first*edslot (minus slotnum)))
			 (addhash*   hashcollect) t)
		    (**  (addhash**  hashcollect) t)
		    (*** (addhash*** hashcollect) t)
		    (&   (cond ((not (\=& 0 hashalias))
				(msg t "CREATE EXPANDED: Only 1 hash alias "
				     "(&) or selected slot (^) allowed in: "
				     newname t)
				t)
			       ( t (setq hashalias slotnum))))
		    (^   (cond ((not (\=& 0 hashalias))
				(msg t "CREATE EXPANDED: Only 1 hash alias "
				     "(&) or selected slot (^) allowed in: "
				     newname t)
				t)
			       ( t (setq hashalias (minus slotnum)))))
		    (&&  (cond ((not (\=& 0 hashfocus))
				(msg t "CREATE EXPANDED: Only 1 hash focus "
				     "(&&) allowed in: " newname t)
				t)
			       ( t (setq hashfocus slotnum))))
		    (:   (addhash:   hashcollect) t)
		    (::  (addhash::  hashcollect) t)
		    (>   (addhash>   hashcollect) t)
		    (<   (addhash<   hashcollect) t)
		    (+   (setq hashcollect (gethashinfo slotnum olddefblock))
			 t))
	   (setq slotname (pop slot)))

    (and (\=& 0 (length slot))
	 (progn (msg t "CREATE EXPANDED: Missing slot name and/or value in: "
		     newname t)
		(pearlbreak)))

    (and newslotnamep
	 (pop slot)
	 (addslotname slotnum slotname defblock))

    ; Next, check for value or ^, possibly preceded by := or ==.
    (setq enforce (pop slot))
    (selectq enforce
	     (:\= (cond ((eq (car slot) '^)  ; a waste.
			 (setq slot (cdr slot))
			 (inheritvalue (getisa defblock)))
			( t (constructvalue))))
	     (\=\= (addenforce hashcollect)
		   (cond ((eq (car slot) '^)
			  (setq slot (cdr slot))
			  (inheritvalue (getisa defblock)))
			 ( t (constructvalue))))
	     ((^ nil)  (addenforce hashcollect)
		       (inheritvalue (getisa defblock)))
	     (otherwise (push enforce slot)
			(addenforce hashcollect)
			(constructvalue)))
    
    (handlepossibleadjunctvar)

    ; Hash, enforce, slotvalue and valuetype can now be installed.
    (puthashandenforce slotnum hashcollect defblock)
    (putslotvaluetype  slotnum valuetype   valblock)
    (putslotvalue      slotnum slotvalue   valblock)

    (handlepredicatesandhooks)))
 
; Create a new structure of type EXPANDED:  build new slots in
;    addition to slots inherited from a BASE or EXPANDED structure.
(de createexpanded (basename newname abbrev slots)
  (and (eq newname 'nilstruct)
       (progn (msg t "CREATE EXPANDED: Cannot redefine nilstruct." t)
	      (pearlbreak)))
  (and (structurenamep newname)
       *warn*
       (msg t "CREATE EXPANDED: Warning: Creating a new definition of "
	    "an existing structure: " newname t))
  (or (structurenamep basename)
      (progn (msg t "CREATE EXPANDED: " basename
		  " is not the name of a previously declared structure." t
		  "     New name is " newname ". Slots are: " slots t)
	     (pearlbreak)))
  (prog (defblock valblock oldvalblock olddefblock slotname
		  slottype enforce slot oldlength length slotnum
		  typenum slotnumlist beginslots predlist slothooklist
		  fcn ppset isa first*edslot slotlocation basehooks
		  basehookbefore newvalue result item reqstruct
		  newslotnamep hashalias hashfocus hashcollect
		  slotvalue valuetype)
	(setq olddefblock (eval (defatom basename)))
	(setq oldlength (getstructlength olddefblock))
	
	; Handle base hooks, if first "slot" is called "if" or "hook".
	(cond ((memq (caar slots) '(if hook))
	       (setq basehookbefore (cdr (pop slots)))
	       (setq basehooks (ncons nil))
	       (while basehookbefore ; is not NIL
		      (tconc basehooks (cons (pop basehookbefore)
					     (pop basehookbefore))))
	       (setq basehooks (nconc (car basehooks)
				      (getbasehooks olddefblock))))
	      ( t (setq basehooks (getbasehooks olddefblock))))
	
	; Create a list of slotnumbers for the slotnames in SLOTS,
	; meanwhile also determining the LENGTH.
	(setq beginslots slots)   ; save to process again.
	(setq slotnumlist (ncons nil))
	(setq length oldlength)
	(while (setq slot (pop slots))
	       (cond ((not (\=& 0 (setq slotnum (findslotnum))))
		      ; Old slot name or new name for old slot (negative).
		      (tconc slotnumlist slotnum))
		     ; Otherwise, new slot name: increase length.
		     (  t   (setq length (1+ length))
			    (tconc slotnumlist length))))
	(setq slotnumlist (car slotnumlist))
	(setq slots beginslots)
	
	; Allocate new hunks.
	(setq defblock (allocdef length))
	(setq valblock (allocval length))
	(puttypetag '*pearldef* defblock)
	(puttypetag '*pearlinst* valblock)
	(cond (*toplevelp* (setq *currenttopcreated* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
	      ( t (putbothalists *currenttopalists* valblock)))

	(putdef defblock valblock)
	(putdefaultinst valblock defblock)
	(set (instatom newname) valblock)
	(set (defatom newname) defblock)
	(and abbrev
	     (cond ((eq abbrev '*buildabbrev*)
		    (putabbrev (instatom newname) valblock))
		   ( t (putabbrev abbrev valblock))))
	(putuniquenum (newnum) defblock)
	(putstructlength length defblock)

	; Set up the hierarchy of ISAs.
	(putisa olddefblock defblock)
	(putexpansionlist nil defblock)
	(addtoexpansionlists)

	(putbasehooks basehooks defblock)
	(putpname newname defblock)
	(setq oldvalblock (getdefaultinst olddefblock))

	; (puthashalias 0   defblock)
	(setq hashalias 0)
	(setq hashfocus 0)
	(or (<& (setq first*edslot (gethashalias olddefblock)) 0)
	    (setq first*edslot 0))
	; Copy old slots in first.
	(for slotnum 1 oldlength
	     (copyslice)
	     (copyslot olddefblock))
	; Run base hooks attached to the base we are expanding.
	(and (getbasehooks olddefblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '<expanded *runexpandedhooks*)
	     (setq valblock item))

	; For each slot, if it's new, build a new slot;
	;                if it's old, fill it in differently.
	(while (setq slot (pop slots))
	       (setq slotnum (pop slotnumlist))
	       (cond ((>& slotnum oldlength)
		      (buildslot))
		     (  t  (fillbaseslot))))
	(cond ((\=& 0 hashalias) (puthashalias first*edslot defblock))
	      ( t (puthashalias hashalias defblock)))
	(cond ((\=& 0 hashfocus) (puthashfocus (gethashfocus olddefblock)
					       defblock))
	      ( t (puthashfocus hashfocus defblock)))

	; Run base hooks attached to the base we are expanding.
	(and (getbasehooks olddefblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '>expanded *runexpandedhooks*)
	     (setq valblock item))
	(return valblock)))
 
; Fill in an individual slot with the value specified.  If the value is
;   prefaced by the character "^" then the value should be inherited from
;   above but there are still predicates and/or IFs to process.
(dm fillindivslot (none)
  '(progn
    (setq slotname (pop slot))
    ; Find slot number.
    (and (\=& 0 (setq slotnum (slotnametonumber slotname defblock)))
	 (progn (msg t "CREATE: Undefined slot: " slotname
		     ", in individual or pattern: " basename)
		(pearlbreak)))
    (cond ((\=& 0 (length slot))
	   (msg t "Missing value in: CREATE INDIVIDUAL (or PATTERN) "
		basename ".  Remaining slots are: " slots t)
	   (pearlbreak))
	  ; If ^, inherit.
	  ((eq (car slot) '^)
	   (setq slot (cdr slot))
	   (inheritvalue defblock))
	  ; Otherwise, construct a new value and insert.
	  ( t (constructvalue)))
    
    (handlepossibleadjunctvar)

    ; Store type and value.
    (putslotvaluetype  slotnum valuetype   valblock)
    (putslotvalue      slotnum slotvalue   valblock)

    (handlepredicatesandhooks)))
 
; Create a new structure of type INDIVIDUAL:  an instance of a
;    BASE or EXPANDED structure.  Slots are either filled explicitly
;    or they inherit defaults from above.
(de createindividual (basename abbrev slots)
  (or (structurenamep basename)
      (progn (msg t "CREATE INDIVIDUAL: " basename
		  " is not the name of a previously declared structure."
		  t "     Slots are: " slots t)
	     (pearlbreak)))
  (prog (defblock valblock slotname length slotnum oldvalblock
		  isa typenum ppset slot predlist slothooklist fcn
		  slotlocation newvalue result item
		  slotvalue valuetype)

	; Find definition and allocate hunk for individual.
	(setq defblock (eval (defatom basename)))
	(setq valblock (allocval (setq length (getstructlength defblock))))
	(puttypetag '*pearlinst* valblock)
	(cond (*toplevelp* (setq *currenttopcreated* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
	      ( t (putbothalists *currenttopalists* valblock)))

	(and abbrev
	     (cond ((eq abbrev '*buildabbrev*)
		    (putabbrev (eval `(newsym ,(getpname defblock))) valblock))
		   ( t (putabbrev abbrev valblock))))
	(putdef defblock valblock)
	(setq oldvalblock (getdefaultinst defblock))

	; Copy slots from old structure first, then run base hooks.
	(for slotnum 1 length
	     (copyslot defblock))
	(and (getbasehooks defblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '<individual *runindividualhooks*)
	     (setq valblock item))

	; Replace copied values for slots that are actually listed
	;    then run base hooks.
	(while (setq slot (pop slots))
	       (fillindivslot))
	(and (getbasehooks defblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '>individual *runindividualhooks*)
	     (setq valblock item))
	(return valblock)))
 
; Copy default values, predicates, and hooks for one slot.
(dm copypatternslot (none)
  '(progn
    (putslotvaluetype slotnum 'LOCAL                             valblock)
    (putslotvalue     slotnum *any*conscell*                     valblock)
    (putpred          slotnum (getpred      slotnum oldvalblock) valblock)
    (putslothooks     slotnum (getslothooks slotnum oldvalblock) valblock)))
 
; Create a new structure of type PATTERN:  an instance of a BASE or
;    EXPANDED structure.  Unspecified slots are filled with ?*ANY*.
(de createpattern (basename abbrev slots)
  (prog (defblock valblock oldvalblock slotname length slotnum isa
		  slotlocation slot predlist slothooklist fcn typenum
		  ppset newvalue result item slotvalue valuetype)
	(or (structurenamep basename)
	    (progn (msg t "CREATE PATTERN: " basename
			" is not the name of a previously declared structure."
			t)
		   (pearlbreak)))

	; Get definition and allocate hunk for pattern.
	(setq defblock (eval (defatom basename)))
	(setq valblock (allocval (setq length (getstructlength defblock))))
	(setq oldvalblock (getdefaultinst defblock))
	(puttypetag '*pearlinst* valblock)
	(cond (*toplevelp* (setq *currenttopcreated* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
	      ( t (putbothalists *currenttopalists* valblock)))

	(putdef defblock valblock)
	(and abbrev
	     (cond ((eq abbrev '*buildabbrev*)
		    (putabbrev (eval `(newsym ,(getpname defblock))) valblock))
		   ( t (putabbrev abbrev valblock))))

	; Copy slot values from base and run base hooks on base structure.
	(for slotnum 1 length
	     (copypatternslot))
	(and (getbasehooks defblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '<pattern *runpatternhooks*)
	     (setq valblock item))

	; Fill in new values for any slots listed and run base hooks.
	(while (setq slot (pop slots))
	       (fillindivslot))
	(and (getbasehooks defblock)
	     (setq item valblock)
	     (checkrunhandlebasehooks1 '>pattern *runpatternhooks*)
	     (setq valblock item))
	(return valblock)))
 
; Create a new structure of type FUNCTION: a structure with slots
;    describing the arguments to the function of the same name.
(de createfunction (fcnname abbrev slots)
  ; Function must already be defined and be a lambda (expr).
  (cond ((islambda fcnname)
	 (putprop fcnname t 'functionstruct)
	 (createbase fcnname abbrev slots))
	( t  (msg t "CREATE FUNCTION: Only lambdas (exprs) allowed as "
		  "function structures: " fcnname slots t)
	     (pearlbreak))))
 
; vi: set lisp:
EndOfFile
cat >  pearl/db.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; db.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for building and releasing a forest of data bases.
;    See the file "template" plus the discussion in the "lowlevel.l" file for
;        a picture and an idea of how data bases are arranged internally.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Clear out the *db* conscells in the two parts of the data base,
;    thus releasing the old buckets for GC, IF they aren't pointed
;    to from elsewhere.
(de cleardb (&optional (db *db*))
  (let ((parent (getdbparent db))
	(db1 (getdb1 db))
	(db2 (getdb2 db)))
       (cond (parent (connectdb db parent))
	     (  t  (for slotnum 0 (1- *db1size*)
			(rplacd (cxr slotnum db1) nil))
		   (for slotnum 0 (1- *db2size*)
			(rplacd (cxr slotnum db2) nil))))
       t))
 
; Used by builddb to connect the sibling's buckets with its parent's.
; Also used by cleardb on a sibling.
(de connectdb (newdb olddb)
  (let ((newdb1 (getdb1 newdb))
	(newdb2 (getdb2 newdb))
	(olddb1 (getdb1 olddb))
	(olddb2 (getdb2 olddb)))
       (for slotnum 0 (1- *db1size*)
	    (rplacd (cxr slotnum newdb1) (cxr slotnum olddb1)))
       (for slotnum 0 (1- *db2size*)
	    (rplacd (cxr slotnum newdb2) (cxr slotnum olddb2)))
       t))
 
; Set the size for data bases to 2 to the "poweroftwo" -- actually
;    the next smaller prime number.
;    *Availablesizes* is in inits.l and is designed to
;        make the data bases a factor of 4 apart
;        EXCEPT in Franz, where the largest are equal-sized.
(de setdbsize (poweroftwo)
  (let (pair rebuilddb)
       (and *activedbnames*
	    (progn (and *warn*
			(msg t "SETDBSIZE: Warning: Size change "
			     "is causing the release of all databases."
			     t "     You must rebuild all "
			     "but the default yourself." t))
		   (mapcar (funl (dbname) (releasedb (eval dbname)))
			   (copy *activedbnames*))
		   (setq rebuilddb t)
		   ))
       (and (or (<& poweroftwo 2.)
		(>& poweroftwo 13.))
	    (progn (msg t "SETDBSIZE: Database size is a power to raise 2 to"
			t "    and must be greater than 1 and less than 14."
			t "    It cannot be " poweroftwo "." t)
		   (pearlbreak)))
       (or (setq pair (assq poweroftwo *availablesizes*))
	   (progn (msg t "SETDBSIZE: "
		       "Database sizes are integer powers to raise 2 to." t)
		  (pearlbreak)))
       (setq *db2size* (cdr pair))
       ; The sizes of the two parts of the data base are 
       ;   in a 1 to 4 ratio.
       (setq pair (assq (- poweroftwo 2.) *availablesizes*))
       (setq *db1size* (cdr pair))
       (and rebuilddb
	    (setq *db* (builddb *maindb*)))
       t))
 
; (BUILDDB NEWDB OLDDB)  Build an extension to OLDDB called NEWDB.  If OLDDB
;     is NIL then build at the bottom level, else add as a leaf of the tree.
; The new data base is stored under the atom which is its name,
;     unlike the rest of PEARL objects (i.e., no special-prefix atom).
; Each new leaf has each of its hash buckets tied into the buckets of the
;     parent so that nextitem need not know how many data bases it is
;     dealing with.
(df builddb (l)
  (let ((newdbname (car l))
	(olddbname (cadr l)))
       (and (memq newdbname *activedbnames*)
	    (progn (msg t "BUILDDB: " newdbname
			" is already an active database name." t)
		   (pearlbreak)))
       (and olddbname
	    ; Two db's given but old one bad.
	    (not (memq olddbname *activedbnames*))
	    (progn (msg t "BUILDDB: " olddbname
			" is not an active database name." t)
		   (pearlbreak)))
       (let ((newdb (makhunk 7))
	     (olddb (and olddbname
			 (eval olddbname)))
	     (db1 (makhunk *db1size*))
	     (db2 (makhunk *db2size*)))
	    (push newdbname *activedbnames*)
	    (putdbname newdbname newdb)
	    (set newdbname newdb)
	    (puttypetag '*pearldb* newdb)
	    (putdbchildren nil newdb)
	    (setdbactive newdb)
	    (putdbparent olddb newdb)
	    (putdb1 db1 newdb)
	    (putdb2 db2 newdb)
	    ; add the *db* conscells.
	    (for slotnum 0 (1- *db1size*)
		 (rplacx slotnum db1 (cons '*db* nil)))
	    (for slotnum 0 (1- *db2size*)
		 (rplacx slotnum db2 (cons '*db* nil)))
	    (and olddb ; Two db's.
		 ; add to parent's children.
		 (putdbchildren (cons newdb (getdbchildren olddb))
				olddb)
		 ; Connectdb does the extra work for adding to the tree.
		 (connectdb newdb olddb))
	    newdb)))
 
; Release a data base.   If its children are also released, then
;    it can be garbage collected.  If not, do not mark it inactive
;    until they are.
(de releasedb (db)
  (and (not (databasep db))
       (progn (msg t "RELEASEDB: Argument is not a database." t)
	      (pearlbreak)))
  (let ((dbname (getdbname db))
	(parent (getdbparent db)))
       (and (not (memq dbname *activedbnames*))
	    (progn (msg t "RELEASEDB: Trying to release an inactive database: "
			db t)
		   (pearlbreak)))
       (cond ((null (getdbchildren db))    ; No children.
	      (setq *activedbnames* (delq (getdbname db) *activedbnames*))
	      (and (equal *activedbnames* '(nil))
		   (setq *activedbnames* nil))
	      (set dbname (unbound))
	      (putdbname nil db)
	      (and parent
		   (putdbchildren (delq db (getdbchildren parent)) parent))
	      (cleardbactive db)
	      (putdbparent nil db)
	      (while (and parent                        ; There's a parent --
			  (null (getdbchildren parent)) ; with 0 children --
			  (not (getdbactive parent)))   ; that's inactive.
		     (cleardb parent)
		     (putdb1 nil parent)
		     (putdb2 nil parent)
		     ; Save next parent with prog1 and then remove self from
		     ; parent's child list and clear out own parent pointer
		     (setq parent
			   (prog1
			    (getdbparent parent)  ; To be the new parent
			    (and (getdbparent parent)
				 (putdbchildren
				  (delq parent
					(getdbchildren (getdbparent parent)))
				  (getdbparent parent))
				 )
			    (putdbparent nil parent))))
	      (cleardb db)
	      (puttypetag '*pearlinactivedb* db)
	      (putdb1 nil db)
	      (putdb2 nil db))
	     ( t (setq *activedbnames* (delq dbname *activedbnames*))
		 (and (equal *activedbnames* '(nil))
		      (setq *activedbnames* nil))
		 (set dbname (unbound))
		 (putdbname nil db)
		 (cleardbactive db)
		 (puttypetag '*pearlinactivedb* db)
		 (putdb1 nil db)
		 (putdb2 nil db)))
       t))
 

; vi: set lisp:
EndOfFile
cat >  pearl/fix.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fix.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  The fixit debugger modified to use "pearlfixprintfn" and to allow
;    use of "> fcnname" or "> 'newvalue" in case of an undefined
;    function or unbound variable respectively.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Modified for use with PEARL by Joe Faletti 1/6/82

;; (eval-when (compile eval)
;;   (or (get 'cmumacs 'version) (load 'cmumacs)))
;  Only the necessary functions are included, below
;  dv (=defv), ***, lineread, and ty

;--- dv :: set variable to value 
; (dv name value)   name is setq'ed to value (no evaluation) 
;       (same as defv)
;
(defmacro dv (name value)
  `(setq ,name ',value))

;--- *** :: comment macro
;
(defmacro *** (&rest x) nil)

(defmacro lineread (&optional (x nil)) 
  `(%lineread ,x))

(def ty (macro (f) (append '(exec cat) (cdr f))))

; LWE 1/11/81 Hack hack....
;
; LWE 1/11/81 Bet you didn't know this, but this won't work INTERPRETED,
;	      but Dave assures me it works compiled. (In MACLisp...)
; 
(declare (special cmd frame x cnt var init label part incr limit selectq))

(dv fixfns
    ((*** This is FIXIT written by David Touretzky and adapted to Franz by Don
      Cohen)
     (declare (special framelist rframelist interrupt-handlers handler-labels)
              (special prinlevel prinlength evalhook-switch traced-stuff)
              (special lastword piport hush-debug)
              (*fexpr editf step type))
     (sstatus feature fixit)
     (*rset t)
     ER%tpl
     fixit
     debug
     debug-iter
     debug1
     debug-bktrace
     Pdebug-print
     Pdebug-print1
     debug-findcall
     debug-scanflist
     debug-scanstk
     debug-getframes
     debug-nextframe
     debug-upframe
     debug-dnframe
     debug-upfn
     debug-dnfn
     debug-showvar
     debug-nedit
     debug-insidep
     debug-findusrfn
     debug-findexpr
     debug-replace-function-name
     debug-pop
     debug-where
     debug-sysp
     interrupt-handlers
     handler-labels
     (or (boundp 'traced-stuff) (setq traced-stuff nil))
     (or (boundp 'evalhook-switch) (setq evalhook-switch nil))
     (setq hush-debug nil)))

(or (boundp 'traced-stuff) (setq traced-stuff nil))
(or (boundp 'evalhook-switch) (setq evalhook-switch nil))
(or (boundp 'debug-sysmode) (setq debug-sysmode nil))
(setq hush-debug nil)

(*** This is FIXIT written by David Touretzky and adapted to Franz by Don Cohen)

(declare (special framelist rframelist interrupt-handlers handler-labels)
         (special prinlevel prinlength evalhook-switch traced-stuff)
         (special lastword piport hush-debug debug-sysmode)
         (*fexpr editf step type)
	 (special system-functions\))

(sstatus feature fixit)

(*rset t)

(progn 'compile
  (dv ER%tpl fixit)
  (dv ER%brk fixit)
  (dv ER%err fixit)
  )

(def fixit
  (nlambda (l)
    (prog (piport)
          (do nil (nil) (eval (cons 'debug l))))))

(def debug
  (nlambda (params)
    (prog (cmd frame framelist rframelist nframe val infile)
          (setq infile t)
          (and evalhook-switch (step nil))
          (setq rframelist
                (reverse
                 (setq framelist
                       (or (debug-getframes)
                           (list
                            (debug-scanstk '(nil) '(debug)))))))
          (setq frame (debug-findexpr (car framelist)))
          ;(tab 0)
                         ; top level ones and calls to err and break.
          (cond
           ((and (car params) (not (eq (car params) 'edit)))
            (terpri)
;            (princ '|;debug |)
;            (princ params)
	    (princ (cadddr params))
	    (cond ((cddddr params)
		   (princ '| -- |)
		   (princ (cddddr params))))
            (terpri)
            (go loop)))
          (Pdebug-print1 frame nil)
          (terpri)
          (cond (hush-debug (setq hush-debug nil) (go loop))
                ((not (memq 'edit params)) (go loop)))
          (drain nil)
          (princ '|type e to edit, <cr> to debug: |)
          (setq val (tyi))
          (cond ((or (\=& val 69) (\=& val 101))
                 (and (errset (debug-nedit frame))
                      (setq cmd '(ok))
                      (go cmdr)))
                ((or (\=& val 78) (\=& val 110)) (terpri) (debug-pop)))
     loop (terpri)
          (princ ':)
          (cond ((null (setq cmd (lineread)))
		 (terpri) (reset)))
     cmdr (cond
           ((dtpr (car cmd))
            (setq val (eval (car cmd) (cadddr frame)))
            (pearlfixprintfn val)
;            (print (valform val))
            (terpri)
            (go loop)))
          (setq nframe (debug1 cmd frame))
          (and (not (atom nframe)) (setq frame nframe) (go loop))
          (print (or nframe (car cmd)))
          (princ '" Huh? - type h for help")
          (go loop))))

(def debug-iter
  (macro (x)
    (cons 'prog
          (cons 'nil
                (cons 'loop
                      (cons (list 'setq 'nframe (cadr x))
                            '((setq cnt (|1-| cnt))
                              (and (or (null nframe) (\=& 0 cnt))
                                   (return nframe))
                              (setq frame nframe)
                              (go loop))))))))

(def debug1
  (lambda (cmd frame)
    (prog (nframe val topframe cnt item)
          (setq topframe (car framelist))
          (or (eq (typep (car cmd)) 'symbol) (return nil))
	  ; if "> name", replace function name with new atom
	  (and (eq (car cmd) '>)
	       (return (debug-replace-function-name cmd topframe)))
          (and (eq (getchar (car cmd) 1) 'b)
               (eq (getchar (car cmd) 2) 'k)
               (return (debug-bktrace cmd frame)))
          (setq cnt
                (cond ((fixp (cadr cmd)) (cadr cmd))
                      ((fixp (caddr cmd)) (caddr cmd))
                      (t 1)))
          (and (<& cnt 1) (setq cnt 1))
          (setq item
                (cond ((symbolp (cadr cmd)) (cadr cmd))
                      ((symbolp (caddr cmd)) (caddr cmd))))
          (and item
               (cond ((memq (car cmd) '(u up))
                      (setq cmd (cons 'ups (cdr cmd))))
                     ((memq (car cmd) '(d dn))
                      (setq cmd (cons 'dns (cdr cmd))))))
          (selectq (car cmd)
                   (top (Pdebug-print1 (setq frame topframe) nil))
                   (bot (Pdebug-print1 (setq frame (car rframelist)) nil))
                   (p (Pdebug-print1 frame nil))
                   (pp (valprint (caddr frame)))
                   (where (debug-where frame))
                   (help
                    (cond ((cdr cmd) (eval cmd))
                          (t (ty |/usr/lisp/doc/fixit.ref|))))
                   ((\? h) (ty |/usr/lisp/doc/fixit.ref|))
                   ((go ok)
                    (setq frame (debug-findexpr topframe))
                    (cond ((eq (caaddr frame) 'debug)
                           (freturn (cadr frame) t))
                          (t (fretry (cadr frame) frame))))
                   (pop (debug-pop))
                   (step (setq frame (debug-findexpr frame))
                         (step t)
                         (fretry (cadr (debug-dnframe frame)) frame))
                   (redo (and item
                              (setq frame
                                    (debug-findcall item frame framelist)))
                         (and frame (fretry (cadr frame) frame)))
                   (return (setq val (eval (cadr cmd)))
                           (freturn (cadr frame) val))
                   (edit (debug-nedit frame))
                   (editf
                    (cond ((null item)
                           (setq frame
                                 (or (debug-findusrfn (debug-nedit frame))
                                     (car rframelist))))
                          ((dtpr (getd item))
                           (errset (funcall 'editf (list item))))
                          (t (setq frame nil))))
                   (u (debug-iter (debug-upframe frame))
                      (cond
                       ((null nframe) (terpri) (princ '|<top of stack>|)))
                      (Pdebug-print1 (setq frame (or nframe frame)) nil))
                   (d (setq nframe
                            (or (debug-iter (debug-dnframe frame)) frame))
                      (Pdebug-print1 nframe nil)
                      (cond ((eq frame nframe)
                             (terpri)
                             (princ '|<bottom of stack>|))
                            (t (setq frame nframe))))
                   (up (setq nframe (debug-iter (debug-upfn frame)))
                       (cond
                        ((null nframe) (terpri) (princ '|top of stack|)))
                       (setq frame (or nframe topframe))
                       (Pdebug-print1 frame nil))
                   (dn (setq frame
                             (or (debug-iter (debug-dnfn frame))
                                 (car rframelist)))
                       (Pdebug-print1 frame nil)
                       (cond
                        ((not (eq frame nframe))
                         (terpri)
                         (princ '|<bottom of stack>|))))
                   (ups (setq frame
                              (debug-iter
                               (debug-findcall item frame rframelist)))
                        (and frame (Pdebug-print1 frame nil)))
                   (dns (setq frame
                              (debug-iter
                               (debug-findcall item frame framelist)))
                        (and frame (Pdebug-print1 frame nil)))
		   (sys (setq debug-sysmode (not debug-sysmode))
			(patom "sysmode now ")(patom debug-sysmode) (terpr))
		   (otherwise 
		    (cond ((not (dtpr (car cmd)))
			   (*** should there also be a boundp test here)
			   (debug-showvar (car cmd) frame))
			  (t (setq frame (car cmd))))))
          (return (or frame item)))))

(def debug-replace-function-name
  (lambda (cmd frame) (prog (oldname newname errorcall nframe)
    (setq errorcall (caddr frame))
    (cond ((eq (caddddr errorcall) '|eval: Undefined function |)
	   (setq oldname (cadddddr errorcall))
	   (setq newname (cadr cmd))
	   (setq cnt 3)
	   (setq frame (debug-iter (debug-dnframe frame)))
	   (dsubst newname oldname frame)
	   (fretry (cadr frame) frame))
          ((eq (caddddr errorcall) '|Unbound Variable:|)
	   (setq oldname (cadddddr errorcall))
	   (setq newname (eval (cadr cmd)))
	   (setq cnt 3)
	   (setq frame (debug-iter (debug-dnframe frame)))
	   (dsubst newname oldname frame)
	   (fretry (cadr frame) frame))
	  ( t (return nil))))))

(def debug-bktrace
  (lambda (cmd oframe)
    (prog (sel cnt item frame nframe)
          (mapc '(lambda (x)
                         (setq sel
                               (cons (selectq x
                                              (f 'fns)
                                              (a 'sysp)
                                              (v 'bind)
                                              (e 'expr)
                                              (c 'current)
					      (otherwise 'bogus))
                                     sel)))
                (cddr (explodec (car cmd))))
          (setq item
                (cond ((eq (typep (cadr cmd)) 'symbol) (cadr cmd))
                      ((eq (typep (caddr cmd)) 'symbol) (caddr cmd))))
          (cond ((debug-sysp item) (setq sel (cons 'sysp sel)))
                ((not (memq 'sysp sel))
                 (setq sel (cons 'user sel))))
          (setq cnt
                (cond ((fixp (cadr cmd)) (cadr cmd))
                      ((fixp (caddr cmd)) (caddr cmd))
                      (item 1)))
          (cond ((null cnt)
                 (setq frame
                       (cond ((memq 'current sel) oframe)
                             (t (car rframelist))))
                 (go dbpr))
                ((null item)
                 (setq frame (car framelist))
                 (and (or (not (memq 'user sel))
                          (atom (caddr (car framelist)))
                          (not (debug-sysp (caaddr (car framelist)))))
                      (setq cnt (|1-| cnt)))
                 (setq frame
                       (cond ((\=& 0 cnt) frame)
                             ((memq 'user sel)
                              (debug-iter (debug-dnfn frame)))
                             (t (debug-iter (debug-dnframe frame)))))
                 (setq frame (or frame (car rframelist)))
                 (go dbpr))
                (t (setq frame (car framelist))))
          (setq frame
                (cond ((and (\=& cnt 1)
                            (not (atom (caddr (car framelist))))
                            (eq item (caaddr (car framelist))))
                       (car framelist))
                      ((debug-iter (debug-findcall item frame framelist)))
                      (t (car rframelist))))
     dbpr (Pdebug-print frame sel oframe)
          (cond ((eq frame (car rframelist))
                 (terpri)
                 (princ '|<bottom of stack>|)
                 (terpri))
                (t (terpri)))
          (cond
           ((memq 'bogus sel)
            (terpri)
            (princ (car cmd))
            (princ '| contains an invalid bk modifier|)))
          (return oframe))))

(def Pdebug-print
  (lambda (frame sel ptr)
    (prog (curframe)
          (setq curframe (car framelist))
     loop (cond ((not
                  (and (memq 'user sel)
                       (not (atom (caddr curframe)))
                       (debug-sysp (caaddr curframe))))
                 (Pdebug-print1 curframe sel)
                 (and (eq curframe ptr) (princ '|   <--- you are here|)))
                ((eq curframe ptr)
                 (terpri)
                 (princ '|  <--- you are somewhere in here|)))
          (and (eq curframe frame) (return frame))
          (setq curframe (debug-dnframe curframe))
          (or curframe (return frame))
          (go loop))))

(def Pdebug-print1
  (lambda (frame sel)
    (prog (prinlevel prinlength varlist)
          (and (not (memq 'expr sel))
               (setq prinlevel 2)
               (setq prinlength 5))
          (cond
           ((atom (caddr frame))
            (terpri)
            (princ '|   |)
            (pearlfixprintfn (caddr frame))
;            (print (valform (caddr frame)))
            (princ '| <- eval error|)
            (return t)))
          (and (memq 'bind sel)
               (cond ((memq (caaddr frame) '(prog lambda))
                      (setq varlist (cadr (caddr frame))))
                     ((and (atom (caaddr frame)) (dtpr (getd (caaddr frame))))
                      (setq varlist (cadr (getd (caaddr frame))))))
               (mapc (function
                      (lambda (v)
                              (debug-showvar v
                                             (or (debug-upframe frame)
                                                 frame))))
                     (cond ((and varlist (atom varlist)) (ncons varlist))
                           (t varlist))))
          (and (memq 'user sel)
               (debug-sysp (caaddr frame))
               (return nil))
          (cond ((memq (caaddr frame) interrupt-handlers)
                 (terpri)
                 (princ '<------------)
                 (print (cadr (assq (caaddr frame) handler-labels)))
                 (princ '-->))
                ((eq (caaddr frame) 'debug)
                 (terpri)
                 (princ '<------debug------>))
                ((memq 'fns sel)
                 (terpri)
                 (and (debug-sysp (caaddr frame)) (princ '|  |))
                 (print (caaddr frame)))
                (t (terpri)
		   (pearlfixprintfn 
		     (cond ((eq (car frame) 'eval) (caddr frame))
			   (t (cons (caaddr frame) (cadr (caddr frame))))))
;                   (print
;		    (valform
;		     (cond ((eq (car frame) 'eval) (caddr frame))
;			   (t (cons (caaddr frame) (cadr (caddr frame)))))))
		   ))
          (or (not (symbolp (caaddr frame)))
              (eq (caaddr frame) (concat (caaddr frame)))
              (princ '|  <not interned>|))
          (return t))))

(def debug-findcall
  (lambda (fn frame flist)
    (prog nil
     loop (setq frame (debug-nextframe frame flist nil))
          (or frame (return nil))
          (cond ((atom (caddr frame))
                 (cond ((eq (caddr frame) fn) (return frame)) (t (go loop))))
                ((eq (caaddr frame) fn) (return frame))
                (t (go loop))))))

(def debug-scanflist
  (lambda (frame fnset)
    (prog nil
     loop (or frame (return nil))
          (and (not (atom (caddr frame)))
               (memq (caaddr frame) fnset)
               (return frame))
          (setq frame (debug-dnframe frame))
          (go loop))))

(def debug-scanstk
  (lambda (frame fnset)
    (prog nil
     loop (or frame (return nil))
          (and (not (atom (caddr frame)))
               (memq (caaddr frame) fnset)
               (return frame))
          (setq frame (evalframe (cadr frame)))
          (go loop))))

(def debug-getframes
  (lambda nil
    (prog (flist fnew)
          (setq fnew
                (debug-scanstk '(nil)
                               (cons 'debug interrupt-handlers)))
     loop (and (not debug-sysmode)
	       (not (atom (caddr fnew)))
               (eq (caaddr fnew) 'debug)
               (eq (car (evalframe (cadr fnew))) 'apply)
               (memq (caaddr (evalframe (cadr fnew))) interrupt-handlers)
               (setq fnew (evalframe (cadr fnew))))
          (and (not debug-sysmode)
	       (null flist)
               (eq (car fnew) 'apply)
               (memq (caaddr fnew) interrupt-handlers)
               (setq fnew (evalframe (cadr fnew))))
          (and (not debug-sysmode)
	       (eq (car fnew) 'apply)
               (eq (typep (caaddr fnew)) 'symbol)
               (not (eq (caaddr fnew) (concat (caaddr fnew))))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and (not debug-sysmode)
	       (not (atom (caddr fnew)))
               (memq (caaddr fnew) '(evalhook* evalhook))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and (not debug-sysmode)
	       (eq (car fnew) 'apply)
               (eq (caaddr fnew) 'eval)
               (cadadr (caddr fnew))
               (or (not (fixp (cadadr (caddr fnew))))
                   (\= (cadadr (caddr fnew)) -1))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and fnew
               (setq flist (cons fnew flist))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (return (nreverse flist)))))

(def debug-nextframe
  (lambda (frame flist sel)
    (prog nil
          (setq flist (cdr (memq frame flist)))
          (and (not (memq 'user sel)) (return (car flist)))
     loop (or flist (return nil))
          (cond
           ((or (atom (caddr (car flist)))
                (not (debug-sysp (caaddr (car flist)))))
            (return (car flist))))
          (setq flist (cdr flist))
          (go loop))))

(def debug-upframe
  (lambda (frame)
    (debug-nextframe frame rframelist nil)))

(def debug-dnframe
  (lambda (frame)
    (debug-nextframe frame framelist nil)))

(def debug-upfn
  (lambda (frame)
    (debug-nextframe frame rframelist '(user))))

(def debug-dnfn
  (lambda (frame)
    (debug-nextframe frame framelist '(user))))

(def debug-showvar
  (lambda (var frame)
    (terpri)
    (princ '|   |)
    (princ var)
    (princ '| = |)
    (pearlfixprintfn
     ((lambda (val) (cond ((atom val) '\?) (t (car val))))
      (errset (eval var (cadddr frame)) nil)))))
;    (print
;     (valform
;      ((lambda (val) (cond ((atom val) '\?) (t (car val))))
;       (errset (eval var (cadddr frame)) nil))))))

(def debug-nedit
  (lambda (frame)
    (prog (val body elem nframe)
          (setq elem (caddr frame))
          (setq val frame)
     scan (setq val (debug-findusrfn val))
          (or val (go nofn))
          (setq body (getd (caaddr val)))
          (cond ((debug-insidep elem body)
                 (princ '\=)
                 (print (caaddr val))
                 (edite body
                        (list 'f (cons '\=\= elem) 'tty:)
                        (caaddr val))
                 (return frame))
                ((or (eq elem (caddr val)) (debug-insidep elem (caddr val)))
                 (setq val (debug-dnframe val))
                 (go scan)))
     nofn (setq nframe (debug-dnframe frame))
          (or nframe (go doit))
          (and (debug-insidep elem (caddr nframe))
               (setq frame nframe)
               (go nofn))
     doit (edite (caddr frame)
                 (and (debug-insidep elem (caddr frame))
                      (list 'f (cons '\=\= elem) 'tty:))
                 nil)
          (return frame))))

(def debug-insidep
  (lambda (elem expr)
    (car (errset (edite expr (list 'f (cons '\=\= elem)) nil)))))

(def debug-findusrfn
  (lambda (frame)
    (cond ((null frame) nil)
          ((and (dtpr (caddr frame))
                (symbolp (caaddr frame))
                (dtpr (getd (caaddr frame))))
           frame)
          (t (debug-findusrfn (debug-dnframe frame))))))

(def debug-findexpr
  (lambda (frame)
    (cond ((null frame) nil)
          ((and (eq (car frame) 'eval) (not (atom (caddr frame))))
           frame)
          (t (debug-findexpr (debug-dnframe frame))))))

(def debug-pop
  (lambda nil
    (prog (frame)
	  (setq frame (car framelist))
     l    (cond ((null (setq frame (evalframe (cadr frame))))(reset)))
	  (cond ((and (dtpr (caddr frame))(eq (caaddr frame) 'debug))
		 (freturn (cadr frame) nil)))
	  (go l))))

(def debug-where
  (lambda (frame)
    (prog (lev diff nframe)
          (setq lev (- (length framelist) (length (memq frame rframelist))))
          (setq diff (- (length framelist) lev 1))
          (Pdebug-print1 frame nil)
          (terpri)
          (cond ((\=& 0 diff) (princ '|you are at top of stack.|))
                ((\=& 0 lev) (princ '|you are at bottom of stack.|))
                (t (princ '|you are |)
                   (princ diff)
                   (cond ((\=& diff 1) (princ '| frame from the top.|))
                         (t (princ '| frames from the top.|)))))
          (terpri)
          (and (or (atom (caddr frame)) (not (eq (car frame) 'eval)))
               (return nil))
          (setq lev 0)
          (setq nframe frame)
     lp   (and (setq nframe (debug-findcall (caaddr nframe) nframe framelist))
               (setq lev (|1+| lev))
               (go lp))
          (princ '|there are |)
          (princ lev)
          (princ '| |)
          (princ (caaddr frame))
          (princ '|'s below.|)
          (terpri))))

(def debug-sysp
  (lambda (x)
    (and (sysp x) (symbolp x) (not (dtpr (getd x))))))

(dv interrupt-handlers (fixit))

(dv handler-labels
    ((fixit error)
     (debug-ubv-handler ubv)
     (debug-udf-handler udf)
     (debug-fac-handler fac)
     (debug-ugt-handler ugt)
     (debug-wta-handler wta)
     (debug-wna-handler wna)
     (debug-iol-handler iol)
     (debug-*rset-handler rst)
     (debug-mer-handler mer)
     (debug-gcd-handler gcd)
     (debug-gcl-handler gcl)
     (debug-gco-handler gco)
     (debug-pdl-handler pdl)))


(or (boundp 'traced-stuff) (setq traced-stuff nil))

(or (boundp 'evalhook-switch) (setq evalhook-switch nil))

(setq hush-debug nil)


;; other functions grabbed from other cmu files to make this file complete
;; unto itself

;- from sysfunc.l

(defun build-sysp nil
  (do ((temp (oblist) (cdr temp))
       (sysfuncs))
      ((null temp)(setq system-functions\ sysfuncs));atom has ^G at end
      (cond ((getd (car temp))
	     (setq sysfuncs (cons (car temp) sysfuncs))))))

(defun sysp (x) ; (cond ((memq x system-functions\)t))
	(memq x '(funcallhook* funcallhook evalhook evalhook* 
			       continue-evaluation)))

(or (boundp 'system-functions\) (build-sysp))

(defun fretry (pdlpnt frame)
  (freturn pdlpnt
	   (cond ((eq (car frame) 'eval) (eval (caddr frame) (cadddr frame)))
		 ((eq (car frame) 'apply)
		  (eval `(apply ',(caaddr frame) ',(cadaddr frame)) 
			(cadddr frame))))))


; - from cmu.l

(def %lineread
  (lambda (chan)
	  (prog (ans)
	   loop (setq ans (cons (read chan 'EOF) ans))
		(cond ((eq (car ans) 'EOF) (return (reverse (cdr ans)))))
	   loop2(cond ((eq 10 (tyipeek chan)) (return (reverse ans)))
		      ((memq (tyipeek chan) '(41 93))
		       (tyi chan)
		       (go loop2))
		      (t (go loop))))))


(aliasdef 'pearlbreak 'fixit)

; vi: set lisp:
EndOfFile
cat >  pearl/franz.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;; franz.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Franz-dependent PEARL functions, declarations, and initializations
;      that don't use PEARL functions.
;  Functions to make Franz accept UCI Lisp functions are in ucisubset.l
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Version numbers, major and minor.
(defvar pearlmajorversion 3)
(defvar pearlminorversion 9)
;3.1: Use of lets and other speedups and new slot encoding.
;3.2: Slot encoding applied to speeded-up match.
;3.3: New faster hashing.
;3.4: Type tags added to symbols, instances, definitions and databases.
;3.5: New print functions.
;3.6: Made hooks additive and fixed global variables in failed matches.
;3.7: Minor bug fixes in scopy and hooks.
;3.8: Unification added; minor bug fixes in setv and create.
;3.9: Bug fixes in blocks and freezing; selectq becomes selectq*.

; db:
(declare (*fexpr builddb))
(defvar *pearldb*)
(defvar *pearlinactivedb*)
(defvar db)
(defvar *db1size*)
(defvar *db2size*)

(defvar *availablesizes* '((-1. . 1.) (0. . 1.) (1. . 1.) (2. . 3.)
			   (3. . 7.) (4. . 13.) (5. . 29.) (6. . 61.)
			   (7. . 127.) (8. . 127.) (9. . 127.)
			   (10. . 127.) (11. . 127.)
			   (12. . 127.) (13. . 127.)))
;((
; For UCI Lisp or Franz    (7. . 127.) (8. . 251.) (9. . 509.)
;   with vectors (soon?).  (10. . 1021.) (11. . 2039.)
;			   (12. . 4093.) (13. . 8191.)))
; (setq buildpplst nil)

(defvar *maindb*)
(defvar *db*)
(defvar *activedbnames* nil)

; vars:
(declare (*fexpr varvalue setv *var* *global* global unbind))
(declare (*fexpr block endblock endanyblocks setblock))

; hook:
(defvar *runallslothooks* t)
(defvar *runallbasehooks* t)

(defvar *runputpathhooks* t)
(defvar *runclearpathhooks* t)
(defvar *runaddsetpathhooks* t)
(defvar *rundelsetpathhooks* t)
(defvar *runaddpredpathhooks* t)
(defvar *rundelpredpathhooks* t)
(defvar *rungetpathhooks* t)
(defvar *rungetpredpathhooks* t)
(defvar *rungethookpathhooks* t)
(defvar *runapplypathhooks* t)

(defvar *runmatchhooks* t)
(defvar *runsmergehooks* t)
(defvar *runindividualhooks* t)
(defvar *runexpandedhooks* t)
(defvar *runpatternhooks* t)
(defvar *runnextitemhooks* t)
(defvar *runfetchhooks* t)
(defvar *runinsertdbhooks* t)
(defvar *runremovedbhooks* t)
(defvar *runindbhooks* t)
(defvar *runnextequalhooks* t)
(defvar *runstrequalhooks* t)

; symord and create and scopy (and all):
(defvar *pearlunbound*)
(defvar *equivclass*)
(defvar *invisible*)
(defvar *warn* t)

(defvar *pearlsymbol*)
(defvar *pearldef*)
(defvar *pearlinst*)

(declare (*fexpr pearlbreak symbol ordinal create cr insidecreate))
(defvar nilstruct)
(defvar d:nilstruct)
(defvar i:nilstruct)
(defvar s:nilsym)
(defvar *lastcreated*)
(defvar *toplevelp*)
(defvar *currenttopcreated*)
(defvar *currenttopalists*)
(defvar *currenttopcopy*)
(defvar *currentcreatetype*)
(defvar *ordinalnames* nil)
(defvar *globallist* nil)
; So that unique numbers start at 0.
(defvar *lastsymbolnum* -1)
(defvar *unhashablevalues*)
(defvar *any*conscell*)
(defvar *blockstack* nil)
(defvar *zero-ordinal-value* 0)
(defvar *currentpearlstructure* nil)
(defvar *currentstructure* nil)
(defvar *scopieditems*)

; path:
(defvar *pathtop*)
(defvar *pathlocal*)

; print:
(declare (*fexpr foreach quiet))
(defvar *fullprint* nil)
(defvar *abbrevprint* nil)
(defvar *uniqueprint* nil)
(defvar *uniqueprintlist* nil)
(defvar *streamprintlength* 2)
(defvar *quiet* nil)
(defvar prinlevel)
(setq prinlevel 7)
(defvar printvar)
(defvar pearltraceprintfn)
(defvar pearlshowstackprintfn)
(defvar pearlbreakprintfn)
(defvar pearlfixprintfn)
(defvar msgprintfn)
(defvar pearltracebreakprintfn)
(defvar pearlprintfn)
(defvar dskprintfn)
(defvar trace-printer)
(setq trace-printer 'pearltraceprintfn)
(defvar showstack-printer)
(setq showstack-printer 'pearlshowstackprintfn)
(defvar top-level-print)
(setq top-level-print 'pearltracebreakprintfn)

; if t, then enters and exits to tracing are quiet,
;   but info is still kept so (tracedump) will work
(defvar \$tracemute)

; hash:
(defvar *stream*)
(defvar *stream:*)
(defvar *function-stream:*)
(defvar *slotvalues* (makhunk 64))
(defvar *hashingmarks* (makhunk 64))
; (and via lowlevel.l):
(defvar *multiproducts* '(16. 256. 4096. 65536. 1048576. 16777216.
			      268435456. 42944967296.))

; match:
(defvar *matchunboundsresult* nil)
(defvar *globalsavestack* nil)
(defvar *equivsavestack* nil)
(defvar *unifyunbounds* nil)
(defvar xvar)
(defvar yvar)

; history:
(defvar *historynumber* -1.)
(defvar *historysize* 64.)
(defvar *usealiases* t)
(defvar *history* (makhunk *historysize*))
(defvar *histval* (makhunk *historysize*))
(defvar *printhistorynumber* nil)
(defvar *readlinechanged*)

; PEARL-top-level:
(defvar *firststartup* t)
(defvar *pearlprompt* '|pearl> |)
(declare (*fexpr savepearl))

; Franz: PEARL-top-level:
(defvar pearl-title (concat " plus PEARL "
			    pearlmajorversion "."
			    pearlminorversion))
(defvar franz-not-virgin)
(defvar pearl-top-level-init)
(defvar top-level)
(defvar franz-minor-version-number)
(defvar franz-top-level)
(defvar +)
(defvar ++)
(defvar +++)
(defvar *)
(defvar **)
(defvar ***)
(defvar ER%tpl)
(defvar ER%brk)
(defvar ER%err)
(defvar evalhook)
(defvar \$gcprint)
(defvar funcallhook)
(defvar tpl-errlist)
(defvar user-top-level)
(defvar top-level-eof)

; PEARL-break-err-handler or trace or fixit debugger:
(defvar break-level-count)
(defvar debug-level-count)
(defvar errlist)

; (funl (x...) body) expands to (function (lambda (x...) body)).
(defmacro funl (&rest rest)
  `(function (lambda .,rest)))

; Various Lisps store functions different ways.  Check for
;    lambda-ness (expr-ness).
(de islambda (fcn)
  (and (neq 'binary (type fcn))
       (setq fcn (getd fcn)))
  (or (and (eq 'binary (type fcn))
	   (eq 'lambda (getdisc fcn)))
      (and (dtpr fcn)
	   (eq 'lambda (car fcn)))))

; Tests for an actual literal atom rather than nil!!
(defmacro reallitatom (potatom)
  `(let ((pot ,potatom))
	(and (symbolp pot)
	     pot)))
 
; To avoid problems with UCI Lisp's unbound, we use a special value
;   for PEARL (pattern-matching) variables to indicate unboundness.
(dm punbound (none)
  ''*pearlunbound*)

(defmacro pboundp (a)
  `(neq ,a (punbound)))

(defmacro punboundatomp (yyy)
  `(eq ,yyy (punbound)))

;(aliasdef 'To 'From 'Property) means define To to be the same as From
;   (under Property in UCILisp).  HOWEVER, in Franz it means copy the
;   function definition of To to From and ignore Property.
(defmacro aliasdef (to from property)
  `(putd ,to (getd ,from)))

; vi: set lisp:
EndOfFile
cat >  pearl/hash.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; hash.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for hashing, inserting, and fetching items into the
;    data bases, plus operating on streams.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Find the next item on the CDDR list of the stream that matches the CADR of
; the stream and return it, also updating the stream.
(de nextitem (stream)
  (or (streamp stream)
      (progn (msg t "NEXTITEM: Not a stream: " stream t)
	     (pearlbreak)))
  (setq stream (cdr stream))	          ; Throw away the *STREAM*.
  (cond ((eq t (car stream))	          ; This means function structure.
	 (prog1 (evalfcn (cdr stream))
		(rplacd (rplaca stream nil) nil)))
	((null (cadr stream)) nil)        ; Test for empty stream
	; Stream built by standardfetch.
	; To debug or modify this, you must draw a picture of what
	;   standardfetch built because of the way it is written.
	((not (dtpr (cadr stream)))
	 (prog (item result)
	       (setq item (car stream))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<nextitem *runnextitemhooks*)
	       (while (and (cdr stream)
			   (or (eq (cadr stream) '*db*)
			       (not (match item (cadr stream)))))
		      (rplacd stream (cddr stream)))
	       (setq item (cadr stream))
	       (rplacd stream (cddr stream))
	       (checkrunhandlebasehooks1 '>nextitem *runnextitemhooks*)
	       (return item)))
	; Stream built by expandedfetch (or fetcheverywhere).
	; To debug or modify this, you must draw a picture of what
	;   expandedfetch built because of the way it is written.
	((not (dtpr (caadr stream)))
	 (prog (item result)
	       (setq item (car stream))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<nextitem *runnextitemhooks*)
	       (while (and (cdr stream)
			   (or (eq (caadr stream) '*db*)
			       (not (expandedmatch item (caadr stream)))))
		      (or (car (rplaca (cdr stream) (cdadr stream)))
			  (rplacd stream (cddr stream))))
	       (setq item (caadr stream))
	       (or (not (cdr stream))
		   (car (rplaca (cdr stream) (cdadr stream)))
		   (rplacd stream (cddr stream)))
	       (checkrunhandlebasehooks1 '>nextitem *runnextitemhooks*)
	       (return item)))))
 
(defmacro hashinfo (slotnum)
  `(cxr ,slotnum *hashingmarks*))

(defmacro sethashinfo (slotnum value)
  `(rplacx ,slotnum *hashingmarks* ,value))

(defmacro slotval (slotnum)
  `(cxr ,slotnum *slotvalues*))

(defmacro storeslot (slotnum value)
  `(rplacx ,slotnum *slotvalues* ,value))

; If there is anything to hash this slot on, say so and put it in HASHV.
(defmacro hashablevalue (slotnum item defblock hashinfo)
  `(not (memq (setq hashv (gethashvalue ,slotnum ,item ,defblock ,hashinfo))
	      *unhashablevalues*)))
 
; If this slot is to take part in a hashing combination, (and it is the
;    second one in :: or ** hashing), then add it to the right hash bucket.
(dm hashslot (none)
  '(cond ((\=& 0 hashinfo) nil) ; No hashing to be done
	 ((hashablevalue slotnum item defblock hashinfo) ; Sets HASHV
	  (and (gethash*  hashinfo)
	       (puthash2  unique hashv db2 item))
;	  (and (gethash:  hashinfo)
;	       (puthash1  hashv db1 item))
	  (and (gethash** hashinfo)
	       (cond ((null mark**)
		      ; First one found.
		      (setq mark** hashv))
		     ; Second one found
		     ((neq t mark**)
		      (puthash3 unique mark** hashv db2 item)
		      (setq mark** t))
		     ; Third or greater found.
		     (  t  (msg t "HASH: More than two **'s in: "
				(getpname defblock) t))))
;	  (and (gethash:: hashinfo)
;	       (cond ((null mark::)
;		      ; First one found.
;		      (setq mark:: hashv))
;		     ; Second one found
;		     ((neq t mark::)
;		      (puthash2 mark:: hashv db2 item)
;		      (setq mark:: t))
;		     ; Third or greater found.
;		     (  t  (msg t "HASH: More than two ::'s in: "
;				(getpname defblock) t))))
	  (and (gethash*** hashinfo)
	       (cond ((null mark***)
		      ; First one found.
		      (setq mark*** (ncons hashv)))
		     ; Later ones found.
		     (  t  (tconc mark*** hashv))))
)))
 
; For each of the four ways of hashing, or else just based on the type,
;    check to see if the pattern can be hashed that way and if so,
;    RETURN the right hashbucket.  If the previous one can't be done,
;    try the next one but stop with the first that can be done.
;    The order is ***, **, ::, &&, *, and :.
(dm insidestandardfetch (none)
  '(cond ((prog2
	   (for slotnum 1 length
		(and (gethash*** (hashinfo slotnum))
		     (cond ((eq (punbound)
				(setq hashv (slotval slotnum)))
			    (setq mark nil)
			    (return nil))
			   ((null mark)
			    (setq mark (ncons nil))
			    (tconc mark hashv)
			    nil)
			   ( t  (tconc mark hashv)))))
	   mark)
	  (gethashmulti unique (car mark) db2))
	 ((for slotnum 1 length
	       (and (gethash** (hashinfo slotnum))
		    (cond ((eq (punbound)
			       (setq hashv (slotval slotnum)))
			   (return nil))
			  ((null mark) (setq mark hashv) nil)
			  ( t (return (gethash3 unique mark hashv db2)))))))
;	 ((for slotnum 1 length
;	       (and (gethash:: (hashinfo slotnum))
;		    (cond ((eq (punbound)
;			       (setq hashv (slotval slotnum)))
;			   (return nil))
;			  ((null mark) (setq mark hashv) nil)
;			  ( t (return (gethash2 mark hashv db2)))))))
	 ((and (not (\=& 0 focus))
	       (pboundp (setq hashv (slotval focus))))
	  (recursetoinsidestandardfetch (getslotvalue focus item) db1 db2))
	 ((for slotnum 1 length
	       (and (gethash* (hashinfo slotnum))
		    (and (pboundp (setq hashv
					(slotval slotnum)))
			 (return (gethash2 unique hashv db2))))))
;	 ((for slotnum 1 length
;	       (and (gethash: (hashinfo slotnum))
;		    (and (pboundp (setq hashv
;					(slotval slotnum)))
;			 (return (gethash1 hashv db1))))))
	 ( t (gethash1 unique db1))))
 
(de recursetoinsidestandardfetch (item db1 db2)
  (let* ((defblock (getdefinition item))
	 (length (getstructlength defblock))
	 (*slotvalues* (makhunk (1+ length)))
	 (*hashingmarks* (makhunk (1+ length)))
	 (unique (getuniquenum defblock))
	 mark hashv focus hashinfo)
	(setq focus (gethashfocus defblock))
	(for slotnum 1 length
	     (setq hashinfo (gethashinfo slotnum defblock))
	     (sethashinfo slotnum hashinfo)
	     (or (and (\=& 0 hashinfo)
		      (not (\=& focus slotnum)))
		 (storeslot slotnum
			    (gethashvalue slotnum item defblock hashinfo))))
	(insidestandardfetch)))

; Return a pair consisting of the ITEM and a hash-bucket-list that should
; have what we are looking for in it.
(de standardfetch (item &optional (db *db*))
  (cond ((get (pname item) 'functionstruct)
	 (cons '*stream* (cons t item)))
	( t (prog (mark defblock bucket db1 db2 hashv result focus
			length hashinfo unique)
		  (setq defblock (getdefinition item))
	          (setq *currentpearlstructure* item)
		  (checkrunhandlebasehooks1 '<fetch *runfetchhooks*)
		  (setq db1 (getdb1 db))
		  (setq db2 (getdb2 db))
		  (setq length (getstructlength defblock))
		  (setq focus (gethashfocus defblock))
		  (for slotnum 1 length
		       (setq hashinfo (gethashinfo slotnum defblock))
		       (sethashinfo slotnum hashinfo)
		       (or (and (\=& 0 hashinfo)
				(not (\=& focus slotnum)))
			   (storeslot slotnum
				      (gethashvalue slotnum item
						    defblock hashinfo))))
		  (setq unique (getuniquenum defblock))
		  (setq bucket (insidestandardfetch))
		  (checkrunhandlebasehooks1 '>fetch *runfetchhooks*)
		  (return (cons '*stream* (cons item bucket)))))))
 
(aliasdef 'fetch 'standardfetch)

(de expandedfetch (item &optional (db *db*))
  (cond ((get (pname item) 'functionstruct)
	 (cons '*stream* (cons t item)))
	( t (prog (mark defblock defblocklist buckets db1 db2 hashv result
			focus length hashinfo)
		  (setq defblock (getdefinition item))
	          (setq *currentpearlstructure* item)
		  (checkrunhandlebasehooks1 '<fetch *runfetchhooks*)
		  (setq db1 (getdb1 db))
		  (setq db2 (getdb2 db))
		  (setq length (getstructlength defblock))
		  (setq focus (gethashfocus defblock))
		  (for slotnum 1 length
		       (setq hashinfo (gethashinfo slotnum defblock))
		       (sethashinfo slotnum hashinfo)
		       (or (and (\=& 0 hashinfo)
				(not (\=& focus slotnum)))
			   (storeslot slotnum
				      (gethashvalue slotnum item
						    defblock hashinfo))))
		  (setq defblocklist (cons defblock
					   (getexpansionlist defblock)))
		  ; Note that instead of being one list, buckets is a
		  ;    list of lists.
		  (setq buckets
			(mapcar
			 (funl (expandeddefblock)
			       (let ((unique (getuniquenum expandeddefblock)))
				    (insidestandardfetch)))
			 defblocklist))
		  (dremove nil buckets)
		  (checkrunhandlebasehooks1 '>fetch *runfetchhooks*)
		  (return (cons '*stream* (cons item buckets)))))))
 
; Find the object EVERYWHERE it might be: ; (Well, only 1 for each hash method).
; For each of the four ways of hashing, plus just based on the type,
;    check to see if the pattern can be hashed that way and if so,
;    return the right hash bucket. A list of these lists is made.
;    NIL's are removed in the main function.
;    The order is ***, **, ::, &&, *, and :.
(dm insidefetcheverywhere (none)
  '(let ((bucketlist (ncons nil)))
	(for slotnum 1 length
	     (and (gethash*** (hashinfo slotnum))
		  (cond ((eq (punbound)
			     (setq hashv (slotval slotnum)))
			 (setq mark nil)
			 (return nil))
			((null mark) (setq mark (ncons hashv)) nil)
			( t  (tconc mark hashv)))))
	(and mark
	     (tconc bucketlist
		    (gethashmulti unique (car mark) db2))
	     (setq mark nil))
	(for slotnum 1 length
	     (and (gethash** (hashinfo slotnum))
		  (cond ((eq (punbound)
			     (setq hashv (slotval slotnum)))
			 (return nil))
			((null mark) (setq mark hashv) nil)
			( t (tconc bucketlist
				   (gethash3 unique mark hashv db2))
			    (setq mark nil)
			    (return nil)))))
	(and (not (\=& 0 focus))
	     (pboundp (setq hashv (slotval focus)))
	     (tconc bucketlist
		    (recursetoinsidestandardfetch (getslotvalue focus item)
						  db1 db2)))
	(for slotnum 1 length
	     (and (gethash* (hashinfo slotnum))
		  (and (pboundp (setq hashv
				      (slotval slotnum)))
		       (tconc bucketlist
			      (gethash2 unique hashv db2)))))
	(tconc bucketlist
	       (gethash1 unique db1))
	(car bucketlist)))

; Return a list consisting of the ITEM and a list of hash-bucket-list
;   that must have what we are looking for in it if it's there.
(de fetcheverywhere (item &optional (db *db*))
  (cond ((get (pname item) 'functionstruct)
	 (cons '*stream* (cons t item)))
	( t (prog (mark defblock buckets db1 db2 hashv result focus
			length hashinfo unique)
		  (setq defblock (getdefinition item))
		  (setq length (getstructlength defblock))
		  (setq focus (gethashfocus defblock))
		  (for slotnum 1 length
		       (setq hashinfo (gethashinfo slotnum defblock))
		       (sethashinfo slotnum hashinfo)
		       (or (and (\=& 0 hashinfo)
				(not (\=& focus slotnum)))
			   (storeslot slotnum
				      (gethashvalue slotnum item
						    defblock hashinfo))))
	          (setq *currentpearlstructure* item)
		  (checkrunhandlebasehooks1 '<fetch *runfetchhooks*)
		  (setq db1 (getdb1 db))
		  (setq db2 (getdb2 db))
		  (setq unique (getuniquenum defblock))
		  (setq buckets (insidefetcheverywhere))
		  (dremove nil buckets)
		  (checkrunhandlebasehooks1 '>fetch *runfetchhooks*)
		  (return (cons '*stream* (cons item buckets)))))))
 
; Discover if a hash alias is to be used.
(dm noalias (none)
  '(cond ((>& alias 0)
	  (cond ((gethash< hashinfo)
		 (cond ((gethash> hashinfo) nil) ; < > cancels
		       ( t t)))
		( t nil)))
	 ( t (cond ((gethash< hashinfo) t)
		   ( t (cond ((gethash> hashinfo) nil) ; < > cancels
			     ( t t)))))))
 
; Get the value that should be hashed for the given slot of ITEM
;     else return unbound.
(de gethashvalue (slotnum item defblock hashinfo)
  (let
   ((potential (getvalue slotnum item))
    alias)
   (cond ((null potential) nil)
	 ((pboundp potential)
	  (let ((potdef (getdefinition potential)))
	       (selectq (getslottype slotnum defblock)
			(0 (setq alias (gethashalias potdef))
			   (cond ((or (noalias)
				      (\=& 0 alias))
				  (getuniquenum potdef))
				 ( t
				  (setq alias (abs alias))
				  (gethashvalue alias potential potdef
						(gethashinfo alias potdef)))))
			(1  (getuniquenum potential)) ; Symbol.
			(2  potential)                ; Integer.
			(3  (punbound))               ; Lisp not hashed.
			(otherwise nil))))            ; SetOf not hashed (YET).
	 ( t (punbound)))))

; Fetch the first item matching the pattern.
(defmacro firstfetch (pattern)
  `(nextitem (fetch ,pattern)))
 
(defmacro fetchcreate (&rest rest)
  `(fetch (create .,rest)))
 
(defmacro inlinefetchcreate (&rest rest)
  `(fetch (quote ,(create rest))))
 
(defmacro inlinecreate (&rest rest)	   
  `(quote ,(create rest)))
 
; Build a value to pass to the function for the parameter for this slot.
(dm fcnslot (none)
  '(let ((slotv (getvalue slotnum item))
	 (type (getslottype slotnum defblock)))
	(cond ((eq slotv (punbound))       (punbound))
	      ((and (<& type 4)
		    (or (not (\=& 0 type))
			(not (get (getpname (getdefinition slotv))
				  'functionstruct))))        slotv)
	      ((\=& 0 type)
	       (evalfcn slotv))
	      ((\=& 0 (boole 1 3 type))
	       (mapcar (function evalfcn) slotv))
	      ( t slotv))))
 
; Evaluate a function structure.
(de evalfcn (item)
  (cond ((dtpr item) (mapcar (function evalfcn) item))
	((not (get (getpname (getdefinition item)) 'functionstruct)) item)
	( t (let* ((defblock (getdefinition item))
		   (length (getstructlength defblock))
		   (fcncall (ncons nil))
		   slotv)
		  (tconc fcncall (getpname defblock))
		  (for slotnum 1 length
		       (tconc fcncall (fcnslot)))
		  (apply* (caar fcncall) (cdar fcncall))))))
 
; A kludge to be removed (with disguisedas) when we implement VIEWS.
(defmacro getstructorsymnum (strsym) 
  `(cond ((psymbolp ,strsym) (getuniquenum ,strsym))
	 (  t  (getuniquenum (getdefinition ,strsym)))))
 
; (DISGUISEDAS Filler Struct DB) means "Is filler a struct?
; if there is an item in the data base DB of the form
;	   (STRUCT (<first slot> FILLER) ... )
; then return it.   If not, return NIL.
(de disguisedas (filler struct &optional (db *db*))
  (prog (fillernum bucket db2 item value)
	(setq db2 (getdb2 db))
	(setq fillernum (getstructorsymnum filler))
	(setq bucket (remq '*db*
			   (gethash2 (getuniquenum struct) fillernum db2)))
	loop
	(cond ((null bucket) (return nil))
	      ((and (eq struct (getdefinition (setq item (pop bucket))))
		    (neq (punbound) (setq value (getvalue 1 item)))
		    (eq (getstructorsymnum value) fillernum))
	       (return item))
	      ( t (go loop)))))

(de insertbyfocus (focus item db1 db2)
  (prog (unique mark** mark:: mark*** defblock
		value hashinfo hashv focusslotnum)
	(setq defblock (getdefinition focus))
	(setq unique (getuniquenum defblock))
	(puthash1 unique db1 item)
	(and (not (\=& 0 (setq focusslotnum (gethashfocus defblock))))
	     (pboundp (setq value (getvalue focusslotnum focus)))
	     (insertbyfocus value item db1 db2))
	(for slotnum 1 (getstructlength defblock)
	     (setq hashinfo (gethashinfo slotnum defblock))
	     (cond ((\=& 0 hashinfo) nil)
		   ((hashablevalue slotnum focus defblock hashinfo) ; Sets HASHV
		    (and (gethash*  hashinfo)
			 (puthash2  unique hashv db2 item))
;	            (and (gethash:  hashinfo)
;	                 (puthash1  hashv db1 item))
		    (and (gethash** hashinfo)
			 (cond ((null mark**)
				; First one found.
				(setq mark** hashv))
			       ; Second one found
			       ((neq t mark**)
				(puthash3 unique mark** hashv db2 item)
				(setq mark** t))
			       ; Third or greater found.
			       (  t  (msg t "HASH: More than two **'s in: "
					  (getpname defblock) t))))
;	            (and (gethash:: hashinfo)
;	                 (cond ((null mark::)
;		                ; First one found.
;		                (setq mark:: hashv))
;		               ; Second one found
;		               ((neq t mark::)
;		                (puthash2 mark:: hashv db2 item)
;		                (setq mark:: t))
;		               ; Third or greater found.
;		               (  t  (msg t "HASH: More than two ::'s in: "
;				          (getpname defblock) t))))
		    (and (gethash*** hashinfo)
			 (cond ((null mark***)
				; First one found.
				(setq mark*** (ncons hashv)))
			       ; Later ones found.
			       (  t  (tconc mark*** hashv))))
		    )))
	(and mark***
	     (puthashmulti unique (car mark***) db2 item))))

; We must put this struct into the data base somewhere,
; perhaps in several places.
(de insertdb (item &optional (db *db*))
  (or item
      (progn (msg t "Trying to INSERTDB a nil item: " item t)
	     (pearlbreak)))
  (and (dtpr item)
       (progn (msg t "Trying to INSERTDB a cons-cell: " item t)
	      (pearlbreak)))
  (cond ((get (getpname (getdefinition item)) 'functionstruct)
	 (evalfcn item))
	(  t
	 (prog (unique mark** mark:: mark*** defblock db1 db2
		       value hashinfo hashv result focus)
	       (setq defblock (getdefinition item))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<insertdb *runinsertdbhooks*)
	       (setq unique (getuniquenum defblock))
	       (setq db1 (getdb1 db))
	       (setq db2 (getdb2 db))
	       (puthash1 unique db1 item)
	       (and (not (\=& 0 (setq focus (gethashfocus defblock))))
		    (pboundp (setq value (getvalue focus item)))
		    (insertbyfocus value item db1 db2))
	       
	       (for slotnum 1 (getstructlength defblock)
		    (setq hashinfo (gethashinfo slotnum defblock))
		    (hashslot))
	       (and mark***
		    (puthashmulti unique (car mark***) db2 item))
	       (checkrunhandlebasehooks1 '>insertdb *runinsertdbhooks*)
	       (return item)))))
 
; For each way that this slot can be hashed, destructively remove the
;     item from the correct bucket.  Expects SLOTNUM, DEFBLOCK, ITEM,
;     MARK**, MARK::, MARK***, HASHV, UNIQUE, DB1, DB2.
(dm removeslot (none)
  '(cond ((\=& 0 hashinfo) nil) ; No hashing to be done
	 ((hashablevalue slotnum item defblock hashinfo) ; Sets HASHV
	  (and (gethash*  hashinfo)
	       (delq item (gethash2 unique hashv db2)))
;	  (and (gethash:  hashinfo)
;	       (delq item (gethash1 hashv db1)))
	  (and (gethash** hashinfo)
	       (cond ((null mark**)
		      (setq mark** hashv))
		     ((neq t mark**)
		      (delq item (gethash3 unique mark** hashv db2))
		      (setq mark** t))
		     (  t  (msg t "More than two **'s in: "
				(getpname defblock) t))))
;	  (and (gethash:: hashinfo)
;	       (cond ((null mark::)
;		      (setq mark:: hashv))
;		     ((neq t mark::)
;		      (delq item (gethash2 mark:: hashv db2))
;		      (setq mark:: t))
;		     (  t  (msg t "More than two ::'s in: "
;				(getpname defblock) t))))
          (and (gethash*** hashinfo)
	       (cond ((null mark***)
		      ; First one found.
		      (setq mark*** (ncons hashv)))
		     ; Later ones found.
		     (  t  (tconc mark*** hashv))))
)))
 
(de removebyfocus (focus item db1 db2)
  (prog (unique mark** mark:: mark*** defblock hashinfo hashv focusslotnum)
	(setq defblock (getdefinition focus))
	(setq unique (getuniquenum defblock))
 	(dremove item (gethash1 unique db1))
	(and (not (\=& 0 (setq focusslotnum (gethashfocus defblock))))
 	     (removebyfocus (getvalue focusslotnum focus) item db1 db2))
	(for slotnum 1 (getstructlength defblock)
	     (setq hashinfo (gethashinfo slotnum defblock))
	     (cond ((\=& 0 hashinfo) nil)
		   ((hashablevalue slotnum focus defblock hashinfo) ; Sets HASHV
		    (and (gethash*  hashinfo)
			 (delq item (gethash2 unique hashv db2)))
;	            (and (gethash:  hashinfo)
;	                 (delq item (gethash1 hashv db1)))
	            (and (gethash** hashinfo)
			 (cond ((null mark**)
				(setq mark** hashv))
			       ((neq t mark**)
				(delq item (gethash3 unique mark** hashv db2))
				(setq mark** t))
			       (  t  (msg t "More than two **'s in: "
					  (getpname defblock) t))))
;	            (and (gethash:: hashinfo)
;	                 (cond ((null mark::)
;		                (setq mark:: hashv))
;		               ((neq t mark::)
;		                (delq item (gethash2 mark:: hashv db2))
;		                (setq mark:: t))
;		               (  t  (msg t "More than two ::'s in: "
;			          	(getpname defblock) t))))
		    (and (gethash*** hashinfo)
			 (cond ((null mark***)
				; First one found.
				(setq mark*** (ncons hashv)))
			       ; Later ones found.
			       (  t  (tconc mark*** hashv))))
		    )))
	(and mark***
	     (delq item (gethashmulti unique mark*** db2)))
	))

; We may have to remove this struct from several places so look
;   every place it might have been hashed.
(de removedb (item &optional (db *db*))
  (or item
      (progn (msg t "Trying to REMOVEDB a nil item: " item t)
	     (pearlbreak)))
  (and (dtpr item)
       (progn (msg t "Trying to REMOVEDB a cons-cell: " item t)
	      (pearlbreak)))
  (or (structurep item)
      (progn (msg t "Trying to REMOVEDB a non-structure: " item t)
	     (pearlbreak)))
  (cond ((get (getpname (getdefinition item)) 'functionstruct) nil)
	(  t
	 (prog (unique mark** mark:: mark*** defblock db1 db2
		       hashinfo hashv result focus)
	       (setq defblock (getdefinition item))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<removedb *runremovedbhooks*)
	       (setq unique (getuniquenum defblock))
	       (or db
		   (setq db *db*))
	       (setq db1 (getdb1 db))
	       (setq db2 (getdb2 db))
	       (delq item (gethash1 unique db1))
	       (and (not (\=& 0 (setq focus (gethashfocus defblock))))
		    (removebyfocus (getvalue focus item) item db1 db2))
	       (for slotnum 1 (getstructlength defblock)
		    (setq hashinfo (gethashinfo slotnum defblock))
		    (removeslot))
	       (and mark***
		    (delq item (gethashmulti unique mark*** db2)))
	       (checkrunhandlebasehooks1 '>removedb *runremovedbhooks*)
	       (return item)))))
 
; Find the next item on the CDDR list of the stream that is STREQUAL to
; the CADR of the stream and return it, also updating the stream.
(de nextequal (stream)
  (or (streamp stream)
      (progn (msg t "NEXTEQUAL:  not a stream: " stream t)
	     (pearlbreak)))
  (setq stream (cdr stream))	 ; Throw away the *STREAM*.
  (cond ((eq t (car stream))	 ; This means function structure.
	 (prog1 (evalfcn (cdr stream))
		(rplacd (rplaca stream nil) nil)))
	((null (cadr stream)) nil)   ; Test for empty stream
	; Stream built by standardfetch.
	; To debug or modify this, you must draw a picture of what
	;   standardfetch built because of the way it is written.
	((not (dtpr (cadr stream)))
	 (prog (item result)
	       (setq item (car stream))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<nextequal *runnextequalhooks*)
	       (while (and (cdr stream)
			   (or (eq (cadr stream) '*db*)
			       (not (strequal item (cadr stream)))))
		      (rplacd stream (cddr stream)))
	       (cond ((cadr stream)
		      (setq item (cadr stream)))
		     ( t (setq item nil)))
	       (rplacd stream (cddr stream))
	       (checkrunhandlebasehooks1 '>nextequal *runnextequalhooks*)
	       (return item)))
	; Stream built by expandedfetch (or fetcheverywhere).
	; To debug or modify this, you must draw a picture of what
	;   expandedfetch built because of the way it is written.
	((not (dtpr (caadr stream)))
	 (prog (item result)
	       (setq item (car stream))
	       (setq *currentpearlstructure* item)
	       (checkrunhandlebasehooks1 '<nextequal *runnextequalhooks*)
	       (while (and (cdr stream)
			   (or (eq (caadr stream) '*db*)
			       (not (strequal item (caadr stream)))))
		      (or (car (rplaca (cdr stream) (cdadr stream)))
			  (rplacd stream (cddr stream))))
	       (cond ((cadr stream)
		      (setq item (caadr stream)))
		     ( t (setq item nil)))
	       (or (not (cdr stream))
		   (car (rplaca (cdr stream) (cdadr stream)))
		   (rplacd stream (cddr stream)))
	       (checkrunhandlebasehooks1 '>nextequal *runnextequalhooks*)
	       (return item)))))
 
; Find out if an EQUAL ITEM is in the DB by using FETCH and then
;  applying NEXTEQUAL.
(de indb (item &optional (db *db*))
  (prog (result newitem answer)
	(setq *currentpearlstructure* item)
	(checkrunhandlebasehooks1 '<indb *runindbhooks*)
	(setq newitem nil)
	(and (setq answer (nextequal (fetch item db)))
	     (setq newitem (setq item answer)))
	(checkrunhandlebasehooks1 '>indb *runindbhooks*)
	(and newitem
	     (neq item newitem)
	     (setq answer item))
	(return answer)))

; (FOREACH STREAM FCN) applies FCN to each element returned by
;    NEXTITEM from STREAM.
(df foreach (l)
  (let ((stream (eval (car l)))
	(fcn (cadr l))
	item)
       (while (setq item (nextitem stream))
	      (apply* fcn (ncons item)))))
 
; Convert a stream to a list of actual matchers.
(de streamtolist (stream)
  (let ((result (ncons nil))
	item)
       (while (setq item (nextitem stream))
	      (tconc result item))
       (car result)))
 

; vi: set lisp:
EndOfFile
cat >  pearl/history.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; history.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for adding a command to the command history, printing
;    the command history, processing aliased atoms and handling
;    the history-invoking splice macros ! and $.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Given two lists of atoms, determine if the first is a prefix of the second.
(de prefix (item1 item2)
  (prog ()
	prefixloop
	(cond ((null item1) (return t))      ; item1 ran out first: succeed.
	      ((null item2) (return nil))    ; item2 ran out first: fail.
	      ((neq (car item1) (car item2)) ; no match: fail.
	       (return nil))
	      ; Otherwise, try next atoms.
	      ( t (setq item1 (cdr item1))
		  (setq item2 (cdr item2))
		  (go prefixloop)))))

; Add the LINE to the *history* hunk in the *historynumber* spot,
;   after possibly replacing it with its alias (for atoms) saved
;   on the property list under the ALIAS property.
(de addhistory (line)
  (let (alias)
       ; Replace with alias if there is one.
       (and *usealiases*
	    (litatom line)
	    (setq alias (get line 'alias))
	    (setq line alias))
       
       ; Store in the command history table.
       (setq *historynumber* (1+ *historynumber*))
       (rplacx (\\ *historynumber* *historysize*)
	       *history*
	       (copy line))	; To eliminate macroexpansions.
       
       ; If it has been changed by read macros, print it out again.
       (cond (*readlinechanged*
	      (pearlprintfn line)
	      (terpri)))
       line))
 
; Print the command history.   Optional argument determines how
;   many commands get printed, otherwise, the whole history.
(de history narg
  (cond ((\=& 0 narg)
	 (cond ((ge *historynumber* *historysize*)
	        (for command (1+ (- *historynumber* *historysize*))
		     *historynumber*
		     (msg t command  ": "
			  (cxr (\\ command *historysize*)
			       *history*))))
	       ( t (for command 0 *historynumber*
			(msg t command ": " (cxr command *history*))))))
	( t 
	 (cond ((ge *historynumber* (arg 1))
	        (for command (1+ (- *historynumber* (arg 1)))
		     *historynumber*
		     (msg t command  ": "
			  (cxr (\\ command *historysize*)
			       *history*))))
	       ( t (for command 0 *historynumber*
			(msg t command ": " (cxr command *history*)))))))
  '*invisible*)
 
; Look for a command with the next atom as a prefix and return the command.
(de prefixcommandhistory ()
  (let* ((wanted (read))
	 (wanthead (explode wanted))
	 (commandnum *historynumber*)
	 (stoppingcommand (cond ((ge *historynumber* *historysize*)
				 (- *historynumber* *historysize*))
				( t -1.)))
	 commandhead)
	(setq *readlinechanged* t)
	(while (and (>& commandnum stoppingcommand)
		    (not (prefix wanthead
				 (prog2 (setq commandhead
					      (cxr (\\ commandnum
							      *historysize*)
						   *history*))
					(setq commandhead
					      (explode
					       (cond ((atom commandhead)
						      commandhead)
						     ( t (car commandhead)))))
					))))
	       (setq commandnum (1- commandnum)))
	
	(cond ((>& commandnum stoppingcommand)
	       (ncons (cxr (\\ commandnum *historysize*)
			   *history*)))
	      ( t (ncons (concat '\! wanted))))))
 
; History command invoker.
(dsm \!
  (lambda ()
	  (let
	   (num whole)
	   (selectq (tyipeek)
		    (33. (readc)				; !!
			 (setq *readlinechanged* t)
			 (ncons (cxr (\\ *historynumber* *historysize*)
				     *history*)))
		    (58. (readc) (setq num (read))		; !:
			 (setq *readlinechanged* t)
			 (setq whole (cxr (\\ *historynumber* *historysize*)
					  *history*))
			 (cond ((atom whole) (ncons whole))
			       (  t	  (ncons (nth num whole)))))
		    (94. (readc)				; !^
			 (setq *readlinechanged* t)
			 (setq whole (cxr (\\ *historynumber* *historysize*)
					  *history*))
			 (cond ((atom whole) (ncons whole))
			       (  t	  (ncons (cadr whole)))))
		    (42. (readc)				; !*
			 (setq *readlinechanged* t)
			 (setq whole (cxr (\\ *historynumber* *historysize*)
					  *history*))
			 (cond ((atom whole) (ncons whole))
			       (  t	  (cdr whole))))
		    (36. (readc)				; !$
			 (setq *readlinechanged* t)
			 (setq whole (cxr (\\ *historynumber* *historysize*)
					  *history*))
			 (cond ((atom whole) (ncons whole))
			       (  t	  (ncons (last whole)))))
		    (9.  (ncons '\!))				; !Tab
		    (10. (ncons '\!))				; !LF
		    (13. (ncons '\!))				; !CR
		    (32. (ncons '\!))				; !Blank
		    (41. (ncons '\!))				; !rpar
		    ((48. 49. 50. 51. 52. 53. 54. 55. 56. 57.)	; !Number
		     (setq *readlinechanged* t)
		     (setq num (read))
		     (ncons (cxr (\\ num *historysize*)
				 *history*)))
		    (otherwise (prefixcommandhistory)))		; !Prefix
	   )))
 
; Look for a command with the next atom as a prefix and return its value.
(de prefixcommandvalue ()
  (let* ((wanted (read))
	 (wanthead (explode wanted))
	 (commandnum *historynumber*)
	 (stoppingcommand (cond ((ge *historynumber* *historysize*)
				 (- *historynumber* *historysize*))
				( t -1.)))
	 commandhead)
	(setq *readlinechanged* t)
	(while (and (>& commandnum stoppingcommand)
		    (not (prefix wanthead
				 (prog2 (setq commandhead
					      (cxr (\\ commandnum
							      *historysize*)
						   *histval*))
					(setq commandhead
					      (explode
					       (cond ((atom commandhead)
						      commandhead)
						     ( t (car commandhead)))))
					))))
	       (setq commandnum (1- commandnum)))
	
	(cond ((>& commandnum stoppingcommand)
	       (cxr (\\ commandnum *historysize*)
		    *histval*))
	      ( t (concat '\$ wanted)))))
 
; History command result invoker.
(dsm \$
  (lambda ()
	  (let
	   (num whole)
	   (ncons
	    (selectq (tyipeek)
		     (36. (readc)				; $$
			  (setq *readlinechanged* t)
			  (list 'quote
				(cxr (\\ *historynumber* *historysize*)
				     *histval*)))
		     (9.  '\$)					; $Tab
		     (10. '\$)					; $LF
		     (13. '\$)					; $CR
		     (32. '\$)					; $Blank
		     (41. '\$)					; !rpar
		     ((48. 49. 50. 51. 52. 53. 54. 55. 56. 57.)	; $Number
		      (setq *readlinechanged* t)
		      (setq num (read))
		      (list 'quote (cxr (\\ num *historysize*)
					*histval*)))
		     (otherwise ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; $Prefix
				(list 'quote (prefixcommandvalue))))))))

; vi: set lisp:
EndOfFile
cat >  pearl/hook.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; hook.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for filling in, running and processing the results of
;    both slot and base hooks.  Also, hidden and visible.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Convert an equal sign followed by an atom into (*SLOT* atom) 
;    for use in both predicates and hooks.
(drm \=
  (lambda ()
	  (let ((nextchar (tyipeek)))
	       (cond ((\=&  9. nextchar) '\=)
		     ((\=& 10. nextchar) '\=)
		     ((\=& 13. nextchar) '\=)
		     ((\=& 32. nextchar) '\=)
		     ((\=& 41. nextchar) '\=)
		     ((eqstr (ascii nextchar) '\=)
		      (readc)
		      '\=\=)
		     ( t  (list '*slot* (read)))))))
 
; Convert a slotname into a slot number for a particular type of structure.
(defmacro numberofslot (slotname defblock)
  `(for slotnum 1 (getstructlength ,defblock)
	(and (memq ,slotname (getslotname slotnum ,defblock))
	     (return slotnum)))
  )
 
; Fill a predicate or hook (FCN) in with the right things, using
;         VALUE  for   *  or  >*,
;	  ITEM   for   ** or  >** and to find variables and slotvalues,
;     and DEFBLOCK to find slotnumbers.
(de fillin1 (fcn value item defblock)
  (cond ((null fcn) nil)
	((atom fcn) (cond ((eq '** fcn) (list 'quote item))
			  ((eq '* fcn) (list 'quote value))
			  ((eq '>** fcn) (list 'quote item))
			  ((eq '>* fcn) (list 'quote value))
			  ( t fcn)))
	((dtpr fcn)
	 (cond ((eq '*slot* (car fcn))
		(list 'quote
		      (getvalue (numberofslot (cadr fcn) defblock)
				item)))
	       ((eq '*var* (car fcn))
		(list 'quote
		      (valueof (cadr fcn) item)))
	       ((eq '*global* (car fcn))
		(cadr fcn))
	       ( t (mapcar (funl (x) (fillin1 x value item defblock))
			   fcn))))
	(  t  fcn)))

; Fill a two-item predicate or hook (FCN) in with the right things, using
;         VAL1   for   *
;         VAL2   for   >*
;	  ITEM1  for   ** and to find variables and slotvalues,
;	  ITEM2  for   >**
;         RESULT for   ?
;     and DEFBLOCK to find slotnumbers.
; Must be made into a LEXPR in UCI Lisp because of number of arguments.
(de fillin2 (fcn val1 val2 item1 item2 defblock result)
  (cond ((null fcn) nil)
	((atom fcn) (cond ((eq '** fcn)  (list 'quote item1))
			  ((eq '>** fcn) (list 'quote item2))
			  ((eq '* fcn)   (list 'quote val1))
			  ((eq '>* fcn)  (list 'quote val2))
			  ((eq '\? fcn)  (list 'quote result))
			  ( t fcn)))
	((dtpr fcn)
	 (cond ((eq '*slot* (car fcn))
		(list 'quote
		      (getvalue (numberofslot (cadr fcn) defblock)
				item1)))
	       ((eq '*var* (car fcn))
		(list 'quote
		      (valueof (cadr fcn) item1)))
	       ((eq '*global* (car fcn))
		(cadr fcn))
	       ( t (mapcar (funl (x) (fillin2 x val1 val2
					      item1 item2
					      defblock result))
			   fcn))))
	( t   fcn)))
 
; If an atom, apply it, else fill it in and evaluate it.
(defmacro executehook1 (fcn value item defblock)
  `(cond ((atom ,fcn) (apply* ,fcn (ncons ,value)))
	 (  t  (eval (fillin1 ,fcn ,value ,item ,defblock)))))
 
; If an atom, apply it, else fill it in and evaluate it.
(defmacro executehook2 (fcn val1 val2 item1 item2 defblock result)
  `(cond ((atom ,fcn) (apply* ,fcn (list ,val1 ,val2)))
	 (  t  (eval (fillin2 ,fcn ,val1 ,val2
			      ,item1 ,item2 ,defblock ,result)))))

; If slothooks are supposed to be run, run them and check for *done*,
;    *fail* or *use*, doing the appropriate thing.  Can almost be
;    used alone but assumes SLOTNUM, ITEM, RESULT, and VALUE.
(defmacro checkrunhandleslothooks1 (fcn runhooksatom)
  `(and *runallslothooks*
	,runhooksatom
	(setq result
	      (let ((defblock (getdefinition item))
		    (alist (getslothooks slotnum item))
		    (retvalue nil)
		    pair)
		   (while (and (not retvalue)
			       (setq pair (pop alist)))
			  (and (eq (car pair) ,fcn)
			       (setq retvalue
				     (executehook1 (cdr pair) value
						   item defblock))
			       (or (and (dtpr retvalue)
					(memq (car retvalue)
					      '(*fail* *done* *use*)))
				   (setq retvalue nil))))
		    retvalue))
	(dtpr result)
	(selectq (car result)
		 (*done* (and (cdr result)
			      (return (cadr result)))
			 (return value))
		 (*fail* (and (cdr result)
			      (return (cadr result)))
			 (return '*fail*))
		 (*use* (setq value (cadr result))))))

; *done* and *fail* cause an immediate return.  *use* changes the
;     value that was going to be used.
(defmacro handlehookresult (oldval newval)
  `(and (dtpr ,newval)
	(selectq (car ,newval)
		 (*done* (and (cdr ,newval)
			      (return (cadr ,newval)))
			 (return ,oldval))
		 (*fail* (and (cdr ,newval)
			      (return (cadr ,newval)))
			 (return '*fail*))
		 (*use* (setq ,oldval (cadr ,newval))))))

; If slothooks are supposed to be run, run them and check for *done*,
;    *fail* or *use*, doing the appropriate thing.  Can almost be
;    used alone but assumes RESULT and ITEM.
(defmacro checkrunhandlebasehooks1 (fcn runhooksatom)
  `(and *runallbasehooks*
	,runhooksatom
	(setq result
	      (let ((retvalue nil)
		    alist
		    pair
		    defblock)
		   (and item
			(setq defblock (getdefinition item))
			(setq alist (getbasehooks defblock)))
		   (while (and (not retvalue)
			       (setq pair (pop alist)))
			  (and (eq (car pair) ,fcn)
			       (setq retvalue
				     (executehook1 (cdr pair) item
						   item defblock))
			       (or (and (dtpr retvalue)
					(memq (car retvalue)
					      '(*fail* *done* *use*)))
				   (setq retvalue nil))))
		   retvalue))
	(dtpr result)
	(selectq (car result)
		 (*done* (and (cdr result)
			      (return (cadr result)))
			 (return item))
		 (*fail* (and (cdr result)
			      (return (cadr result)))
			 (return '*fail*))
		 (*use* (setq item (cadr result))))))

; If slothooks are supposed to be run, run them.  Assumes SLOTNUM,
;    ITEM, and VALUE.  This is not a standalone function, since it
;    does not handle RESULT but rather returns it.
(defmacro checkandrunslothooks2 (fcn hooks val1 val2 item1 item2)
  `(let ((defblock (getdefinition ,item1))
	 (retvalue nil)
	 pair)
	(while (and (not retvalue)
		    (setq pair (pop ,hooks)))
	       (and (eq (car pair) ,fcn)
		    (setq retvalue
			  (executehook2 (cdr pair) ,val1 ,val2
					,item1 ,item2 defblock result))
		    (or (and (dtpr retvalue)
			     (memq (car retvalue)
				   '(*fail* *done* *use*)))
			(setq retvalue nil))))
	 retvalue))

; Assumes XVAL or YVAL is where you want changes.
(defmacro doslothooks2< (fcn runhookatom)
  `(cond ((and *runallslothooks*
	       ,runhookatom)
	  (setq newxval nil)
	  (setq newyval nil)
	  (and (setq xhooks (getslothooks slotnum item1))
	       (setq newxval
		     (checkandrunslothooks2 ,fcn xhooks xval yval
					    item1 item2)))
	  (and (setq yhooks (getslothooks slotnum item2))
	       (setq newyval
		     (checkandrunslothooks2 ,fcn yhooks yval xval
					    item2 item1)))
	  (handlehookresult xval newxval)
	  (handlehookresult yval newyval))))

; Assumes RESULT is where you want changes.
(defmacro doslothooks2> (fcn runhookatom)
  `(cond ((and *runallslothooks*
	       ,runhookatom)
	  (setq newxval nil)
	  (setq newyval nil)
	  (and (setq xhooks (getslothooks slotnum item1))
	       (setq newxval
		     (checkandrunslothooks2 ,fcn xhooks xval yval
					    item1 item2)))
	  (and (setq yhooks (getslothooks slotnum item2))
	       (setq newyval
		     (checkandrunslothooks2 ,fcn yhooks yval xval
					    item2 item1)))
	  (handlehookresult result newxval)
	  (handlehookresult result newyval))))

(defmacro checkandrunbasehooks2 (fcn item1 item2)
  `(let* ((retvalue nil)
	  (defblock (getdefinition ,item1))
	  (alist (getbasehooks defblock))
	  pair)
	 (while (and (not retvalue)
		     (setq pair (pop alist)))
		(and (eq (car pair) ,fcn)
		     (setq retvalue
			   (executehook2 (cdr pair) ,item1 ,item2
					 ,item1 ,item2 defblock result))
		     (or (and (dtpr retvalue)
			      (memq (car retvalue)
				    '(*fail* *done* *use*)))
			 (setq retvalue nil))))
	 retvalue))

; Assumes ITEM1 and ITEM2 are where you want changes.
(defmacro dobasehooks2< (fcn runhookatom)
  `(cond ((and *runallbasehooks*
	       ,runhookatom)
	  (setq newitem1 (checkandrunbasehooks2 ,fcn item1 item2))
	  (setq newitem2 (checkandrunbasehooks2 ,fcn item2 item1))
	  (handlehookresult item1 newitem1)
	  (handlehookresult item2 newitem2))))

; Assumes RESULT is where you want changes.
(defmacro dobasehooks2> (fcn runhookatom)
  `(cond ((and *runallbasehooks*
	       ,runhookatom)
	  (setq newitem1 (checkandrunbasehooks2 ,fcn item1 item2))
	  (setq newitem2 (checkandrunbasehooks2 ,fcn item2 item1))
	  (handlehookresult result newitem1)
	  (handlehookresult result newitem2))))

; Runbasehooks for single items for the user.
(de runbasehooks1 (fcn item)
  (and (null item)
       (progn (msg t "RUNBASEIFS1: Null item given to run hooks on." t)
	      (pearlbreak)))
  (let* ((retvalue nil)
	 (defblock (getdefinition item))
	 (alist (getbasehooks defblock))
	 pair)
	(while (and (not retvalue)
		    (setq pair (pop alist)))
	       (and (eq (car pair) fcn)
		    (setq retvalue (executehook1 (cdr pair) item item defblock))
		    (or (and (dtpr retvalue)
			     (memq (car retvalue) '(*fail* *done* *use*)))
			(setq retvalue nil))))
	retvalue))

; Runbasehooks for two items for the user.
(de runbasehooks2 (fcn item1 item2 result)
  (and (null item1)
       (progn (msg t "RUNBASEIFS2: Null first item given to run hooks on." t)
	      (pearlbreak)))
  (and (null item2)
       (progn (msg t "RUNBASEIFS2: Null second item given to run hooks on." t)
	      (pearlbreak)))
  (let* ((retvalue nil)
	 (defblock (getdefinition item1))
	 (alist (getbasehooks defblock))
	 pair)
	(while (and (not retvalue)
		    (setq pair (pop alist)))
	       (and (eq (car pair) fcn)
		    (setq retvalue
			  (executehook2 (cdr pair) item1 item2
					item1 item2 defblock result))
		    (or (and (dtpr retvalue)
			     (memq (car retvalue) '(*fail* *done* *use*)))
			(setq retvalue nil))))
	retvalue))

; Run slot hooks for the slot named SLOTNAME for one item for the user.
(de runslothooks1 (fcn item slotname value)
  (and (null item)
       (progn (msg t "RUNSLOTIFS1: Null item given to run hooks on." t)
	      (pearlbreak)))
  (let* ((retvalue nil)
	 (defblock (getdefinition item))
	 (slotnum (numberofslot slotname defblock))
	 (alist (getslothooks slotnum item))
	 pair)
	(while (and (not retvalue)
		    (setq pair (pop alist)))
	       (and (eq (car pair) fcn)
		    (setq retvalue
			  (executehook1 (cdr pair) value item defblock))
		    (or (and (dtpr retvalue)
			     (memq (car retvalue) '(*fail* *done* *use*)))
			(setq retvalue nil))))
	retvalue))

; Run slot hooks for the slot named SLOTNAME for two items for the user.
; Must be made into a LEXPR in UCI Lisp because of number of arguments.
(de runslothooks2 (fcn item1 item2 slotname val1 val2 result)
  (and (null item1)
       (progn (msg t "RUNSLOTIFS1: Null first item given to run hooks on." t)
	      (pearlbreak)))
  (and (null item2)
       (progn (msg t "RUNSLOTIFS1: Null second item given to run hooks on." t)
	      (pearlbreak)))
  (let* ((retvalue1 nil)
	 (retvalue2 nil)
	 (defblock (getdefinition item1))
	 (slotnum (numberofslot slotname defblock))
	 (alist (getslothooks slotnum item1))
	 pair)
	(while (and (not retvalue1)
		    (setq pair (pop alist)))
	       (and (eq (car pair) fcn)
		    (setq retvalue1
			  (executehook2 (cdr pair) val1 val2
					item1 item2 defblock result))
		    (or (and (dtpr retvalue1)
			     (memq (car retvalue1) '(*fail* *done* *use*)))
			(setq retvalue1 nil))))
	(setq defblock (getdefinition item2))
	(setq slotnum (numberofslot slotname defblock))
	(setq alist (getslothooks slotnum item2))
	(while (and (not retvalue2)
		    (setq pair (pop alist)))
	       (and (eq (car pair) fcn)
		    (setq retvalue2
			  (executehook2 (cdr pair) val2 val1
					item2 item1 defblock result))
		    (or (and (dtpr retvalue2)
			     (memq (car retvalue2) '(*fail* *done* *use*)))
			(setq retvalue2 nil))))
	(cons retvalue1 retvalue2)))

; Run command with its associated *run...hooks* atom set to nil
;    temporarily with a let so that its hooks WON'T be run.
(defmacro hidden (command)
  (let ((name (concat '*run (car command) 'hooks*)))
       `(let ((,name nil))
	     ,command)))

; Run command with its associated *run...hooks* atom set to t
;    temporarily with a let so that its hooks WILL be run.
(defmacro visible (command)
  (let ((name (concat '*run (car command) 'hooks*)))
       `(let ((,name t))
	     ,command)))

; vi: set lisp:
EndOfFile
cat >  pearl/inits.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; inits.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Expressions which set the values of special variables and create
;    nilsym and nilstruct and which use PEARL functions and so must
;    be done AFTER everything is loaded.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(progn
  ; A very special cell.
  (setq *any*conscell* (cons '*any* (punbound)))
  ; Define the default symbol.
  (or (boundp (symatom 'nilsym))
      (symbol nilsym))
  ; Define the default empty structure.
  (or (boundp (defatom 'nilstruct))
      (create base nilstruct))
  ; Values that should not take part in hashing.
  ;   Used to include ",(eval (defatom 'nilstruct)) ,(eval (symatom 'nilsym))".
  (setq *unhashablevalues* `(nil ,(punbound) ,(unbound)))
  (putprop 'history '(history) 'alias)
  (putprop 'h '(history 22) 'alias)
  (defprop quote "'" printmacro)
  (defprop pearlequals "=" printmacro)
  (defprop *var* "?" printmacro)
  (defprop *global* "?" printmacro)
  (setdbsize 7.)
  (builddb *maindb*)
  (setq *db* *maindb*)
  )

; vi: set lisp:
EndOfFile
cat >  pearl/lowlevel.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;; lowlevel.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros (mostly) for accessing structures, symbols and definitions.
;    See the file "template" for a picture of how structures and
;    symbols and data bases are arranged to explain the simplest
;    of the functions below.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.
 
; Throughout the code for PEARL:
;    defblock:  will contain a definition of a structure,
;    valblock:  will contain an instance of a structure,
;    slotnum:   will contain a slot number to index into a structure.
; An attempt has been made throughout the rest to similarly name
;    things to be obvious.

; These macros are designed so that PEARL can be moved to a new Lisp
;     simply by implementing the functions "makhunk", "cxr", and
;     "rplacx" to behave as they do in Franz Lisp.

(defmacro getdefaultinst (defblock)
  `(cxr 3 ,defblock))
 
(defmacro getdefinition (valblock)
  `(cxr 0 ,valblock))
 
(defmacro allocdef (numofslots)
  `(makhunk (+ 10 (* 4 ,numofslots))))
 
(defmacro allocval (numofslots)
  `(makhunk (+ 4 (* 4 ,numofslots))))
 
(defmacro puttypetag (tag hunk)
  `(rplacx 1 ,hunk ,tag))
 
(defmacro gettypetag (hunk)
  `(cxr 1 ,hunk))
 
(defmacro putstructlength (size defblock)
  `(rplacx 2 ,defblock ,size))
 
(defmacro getstructlength (defblock)
  `(cxr 2 ,defblock))
 
(defmacro putuniquenum (num defblockorsym)
  `(rplacx 0 ,defblockorsym ,num))
 
(defmacro getuniquenum (defblockorsym)
  `(cxr 0 ,defblockorsym))
 
; Generate a new unique number.
(dm newnum (none)
  '(setq *lastsymbolnum* (1+ *lastsymbolnum*)))
 
; Special atom for each structure's definition.
(de defatom (symbol)
  (concat 'd: symbol))
 
; Special atom for each structure's default instance.
(de instatom (symbol)
  (concat 'i: symbol))
 
; Special atom for each symbol.
(de symatom (symbol)
  (concat 's: symbol))
 
; Special atom for each block.
(de blockatom (symbol)
  (concat 'b: symbol))
 
; Special atom for each ordinal type.
(de ordatom (symbol)
  (concat 'o: symbol))
 
(defmacro putsymbolpname (name block)
  `(rplacx 2 ,block ,name))
 
(defmacro getsymbolpname (symbolitem)
  `(cxr 2 ,symbolitem))
 
(defmacro putpname (name blk)
  `(rplacx 5 ,blk ,name))
 
(defmacro getpname (blk)
  `(cxr 5 ,blk))
 
(defmacro putdef (defblock valblock)
  `(rplacx 0 ,valblock ,defblock))
 
(defmacro putisa (isa valblock)
  `(rplacx 4 ,valblock ,isa))
 
(defmacro getisa (valblock)
  `(cxr 4 ,valblock))
 
(defmacro putdefaultinst (valblock defblock)
  `(rplacx 3 ,defblock ,valblock))
 
(defmacro puthashalias (hashnum blk)
  `(rplacx 6 ,blk ,hashnum))
 
(defmacro gethashalias (blk)
  `(cxr 6 ,blk))
 
(defmacro puthashfocus (hashnum blk)
  `(rplacx 7 ,blk ,hashnum))
 
(defmacro gethashfocus (blk)
  `(cxr 7 ,blk))
 
(defmacro putexpansionlist (explist blk)
  `(rplacx 8 ,blk ,explist))
 
(defmacro getexpansionlist (blk)
  `(cxr 8 ,blk))
 
(defmacro putbasehooks (hooklist defblk)
  `(rplacx 9 ,defblk ,hooklist))
 
(defmacro getbasehooks (defblk)
  `(cxr 9 ,defblk))
 
(de addbasehook (conscell item)
  (let* ((itemdef (getdefinition item))
	 (oldhooks (getbasehooks itemdef)))
	(cond (oldhooks (nconc1 oldhooks conscell))
	      ( t (putbasehooks itemdef (ncons conscell))))))
 
(defmacro getslotname (slotnum blk)
  `(cxr (+ 8 (* 4 ,slotnum)) ,blk))
 
(defmacro putslotname (slotnum slotname blk)
  `(rplacx (+ 8 (* 4 ,slotnum)) ,blk ,slotname))

(defmacro addslotname (slotnum slotname blk)
  `(rplacx (+ 8 (* 4 ,slotnum)) ,blk
	   (cons ,slotname (cxr (+ 8 (* 4 ,slotnum)) ,blk))))
 
(defmacro putslottype (slotnum typenum blk)
  `(rplacx (+ 7 (* 4 ,slotnum)) ,blk ,typenum))
 
(defmacro getslottype (slotnum blk)
  `(cxr (+ 7 (* 4 ,slotnum)) ,blk))
 
(defmacro putppset (slotnum setname blk)
  `(rplacx (+ 9 (* 4 ,slotnum)) ,blk ,setname))
 
(defmacro getppset (slotnum blk)
  `(cxr (+ 9 (* 4 ,slotnum)) ,blk))
 
(defmacro initbothalists (inst)
  `(rplacx 2 ,inst (ncons nil)))

(defmacro putbothalists (alist inst)
  `(rplacx 2 ,inst ,alist))

(defmacro getbothalists (inst)
  `(cxr 2 ,inst))

(defmacro getalist (inst)
  `(cdr (cxr 2 ,inst)))

(defmacro putalist (alist inst)
  `(rplacd (cxr 2 ,inst) ,alist))
 
; This must return the new special conscell.
(defmacro addalist (var inst)
  `(let ((specialcell (cons ,var (punbound))))
	(putalist (cons specialcell (getalist ,inst)) ,inst)
	specialcell))
 
; The frozen variables are kept here instead of the regular assoc-list.
(defmacro getalistcp (inst)
  `(car (cxr 2 ,inst)))
 
(defmacro putalistcp (alist inst)
  `(rplaca (cxr 2 ,inst) ,alist))
 
(defmacro getabbrev (inst)
  `(cxr 3 ,inst))
 
(defmacro putabbrev (abbrev inst)
  `(rplacx 3 ,inst ,abbrev))
 
; Put zero as the (initial) hash and format info.
(defmacro clearhashandformat (slotnum defblock)
  `(rplacx (+ 6 (* 4 ,slotnum)) ,defblock 0))
 
(defmacro puthashandformat (slotnum hashnum defblock)
  `(rplacx (+ 6 (* 4 ,slotnum)) ,defblock ,hashnum))
 
(defmacro gethashandformat (slotnum defblock)
  `(cxr (+ 6 (* 4 ,slotnum)) ,defblock))
 
(defmacro puthashandenforce (slotnum hashnum blk)
  `(rplacx (+ 6 (* 4 ,slotnum)) ,blk
           (boole 7 (boole 1 (boole 10. 127. 0)
                           (cxr (+ 6 (* 4 ,slotnum)) ,blk))
                    (boole 1 127. ,hashnum))))
 
(defmacro puthashinfo (slotnum hashnum blk)
  `(rplacx (+ 6 (* 4 ,slotnum)) ,blk
           (boole 7 (boole 1 (boole 10. 63. 0)
                           (cxr (+ 6 (* 4 ,slotnum)) ,blk))
                    (boole 1 63. ,hashnum))))
 
(defmacro addhash* (hashnum)
  `(setq ,hashnum (boole 7 1 ,hashnum)))
 
(defmacro addhash** (hashnum)
  `(setq ,hashnum (boole 7 2 ,hashnum)))
 
(defmacro addhash: (hashnum)
  `(setq ,hashnum (boole 7 4 ,hashnum)))
 
(defmacro addhash:: (hashnum)
  `(setq ,hashnum (boole 7 8. ,hashnum)))
 
(defmacro addhash> (hashnum)
  `(setq ,hashnum (boole 7 16. ,hashnum)))
 
(defmacro addhash< (hashnum)
  `(setq ,hashnum (boole 7 32. ,hashnum)))
 
(defmacro addhash*** (hashnum)
  `(setq ,hashnum (boole 7 64. ,hashnum)))
 
(defmacro addenforce (hashnum)
  `(setq ,hashnum (boole 7 128. ,hashnum)))
 
(defmacro gethashinfo (slotnum blk)
  `(boole 1 63.
	  (cxr (+ 6 (* 4 ,slotnum)) ,blk)))

(defmacro gethash* (hashnum)
  `(\=& 1 (boole 1 1 ,hashnum)))
 
(defmacro gethash** (hashnum)
  `(\=& 2 (boole 1 2 ,hashnum)))
 
(defmacro gethash: (hashnum)
  `(\=& 4 (boole 1 4 ,hashnum)))
 
(defmacro gethash:: (hashnum)
  `(\=& 8. (boole 1 8. ,hashnum)))
 
(defmacro gethash> (hashnum)
  `(\=& 16. (boole 1 16. ,hashnum)))
 
(defmacro gethash< (hashnum)
  `(\=& 32. (boole 1 32. ,hashnum)))
 
(defmacro gethash*** (hashnum)
  `(\=& 64. (boole 1 64. ,hashnum)))
 
(defmacro getenforce (slotnum defblock)
  `(\=& 128. (boole 1 128. (cxr (+ 6 (* 4 ,slotnum)) ,defblock))))
 
; The format information is eventually intended for custom tailoring of
;    printing of structures but we've never gotten around to adding it.
;    The main idea is whether to print it if it contains the default
;    value, or whether to print to a limited depth, or whether to print
;    at all, etc.
(defmacro putformatinfo (slotnum hashnum blk)
  `(rplacx (+ 6 (* 4 ,slotnum)) ,blk
	   (boole 7
		  (boole 1 (boole 10. 192. 0)
			 (cxr (+ 6 (* 4 ,slotnum)) ,blk))
		  (boole 1 192. (lsh ,hashnum 6)))))
 
(defmacro getformatinfo (slotnum blk)
  `(lsh (boole 1
	       (boole 10. 192. 0)
	       (cxr (+ 6 (* 4 ,slotnum)) ,blk)) -6))
 
(defmacro putpred (slotnum value inst)
  `(rplacx (+ 2 (* 4 ,slotnum)) ,inst ,value))
 
(defmacro getpred (slotnum inst)
  `(cxr (+ 2 (* 4 ,slotnum)) ,inst))
 
(defmacro putslothooks (slotnum slothooklist inst)
  `(rplacx (+ 3 (* 4 ,slotnum)) ,inst ,slothooklist))
 
(defmacro getslothooks (slotnum inst)
  `(cxr (+ 3 (* 4 ,slotnum)) ,inst))
 
; Values of slots in PEARL structures are of one of four types.
; The type is stored as an atom in the "slotvaluetype"
;    and describes what type of value will be found in the "slotvalue".
; The possible types and what is put in "slotvalue" are:
;    CONSTANT A constant value   -- the value.
;    LOCAL    A local variable   -- the variable's alist conscell
;					(name . value).
;    ADJUNCT  A constant value plus an adjunct variable
;     	                          -- a conscell with CAR = the constant value
;     	                             and CDR = the adjvar's conscell
;					(name . value).
;    GLOBAL   A global variable  -- the (atom) name of the global variable.
;

(defmacro putslotvaluetype (slotnum type inst)
  `(rplacx (* 4 ,slotnum) ,inst ,type))

(defmacro getslotvaluetype (slotnum inst)
  `(cxr (* 4 ,slotnum) ,inst))

(defmacro putslotvalue (slotnum value inst)
  `(rplacx (1+ (* 4 ,slotnum)) ,inst ,value))

(defmacro getslotvalue (slotnum inst)
  `(cxr (1+ (* 4 ,slotnum)) ,inst))

(dm equivclass (none)
  ''*equivclass*)

(de equivclassp (potequivclass)
  (and (dtpr potequivclass)
       (eq (equivclass) (car potequivclass))))

; returns (punbound) for unified variables instead of the equiv cons cell.
(defmacro getvalofequivorvar (equivorvar)
  `(let ((val ,equivorvar))
        (cond ((equivclassp val) (punbound))
	      ( t val))))

(defmacro getvalue (slotnum inst)
  `(let ((value (getslotvalue ,slotnum ,inst)))
	(selectq (getslotvaluetype ,slotnum ,inst)
		 (CONSTANT  value)        ; A constant value.
		 (LOCAL     (getvalofequivorvar (cdr value))) ; A local var.
		 (ADJUNCT   (car value))  ; A constant plus adjvar.
		 (GLOBAL    (getvalofequivorvar (eval value))) ; A global var.
		 (otherwise (punbound)))))

; Same as getvalue, except that if the slot has an variable in it
;    the atom in "var" gets set to that value.
(defmacro getvarandvalue (slotnum inst var)
  `(let ((value (getslotvalue ,slotnum ,inst)))
	(selectq (getslotvaluetype ,slotnum ,inst)
		 (CONSTANT  (set ,var nil)
			    value)          ; A constant value.
		 (LOCAL     (set ,var value)
			    (getvalofequivorvar (cdr value))) ; A local var.
		 (ADJUNCT   (set ,var (cdr value))
			    (car value))    ; A constant plus adjvar.
		 (GLOBAL    (set ,var value)
			    (getvalofequivorvar (eval value))) ; A global var.
		 (otherwise (punbound)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  The next bunch of functions are for hashing and building data bases.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; For each data base, there are three parts (each a hunk):
;    the header which contains the name,
;                              whether it is active
;                              its parent and children and ...
;    the two parts of the actual data base:
;        DB1 for items hashed under one value.
;        DB2 for items hashed under two or more values.
; DB1 and DB2 each contain pointers to conscells whose cars are the
;    atom *db* and whose cdrs are the list of items in that bucket.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIRST, the functions to access and add to a hash bucket:

; Items hashed under only one integer are in DB1.
(defmacro gethash1 (num1 db1)
  `(cxr (\\ ,num1 *db1size*) ,db1))
 
; Add the item to the front of the appropriate hash bucket (AFTER the
;    special *db* conscell).
(defmacro puthash1 (num1 db1 item)
  `(let ((bucket (gethash1 ,num1 ,db1)))
	; Avoid exact duplicates.
	(or (memq ,item bucket)
	    (rplacd bucket (cons ,item (cdr bucket))))
	bucket))
 
; Items hashed under either two or more integers are in DB2.
(defmacro gethash2 (num1 num2 db2)
  `(cxr (\\ (+ ,num1 (* ,num2 1024.)) *db2size*)
	,db2))
 
; Add the item to the front of the appropriate hash bucket (AFTER the
;    special *db* conscell).
(defmacro puthash2 (num1 num2 db2 item)
  `(let ((bucket (gethash2 ,num1 ,num2 ,db2)))
	; Avoid exact duplicates.
	(or (memq ,item bucket)
	    (rplacd bucket (cons ,item (cdr bucket))))
	bucket))
 
(defmacro gethash3 (num1 num2 num3 db2)
  `(cxr (\\ (+ ,num1
	       (* ,num2 1024.)
	       (* ,num3 1048576.))  ; = 1024 * 1024
	    *db2size*)
	,db2))
 
; Add the item to the front of the appropriate hash bucket (AFTER the
;    special *db* conscell).
(defmacro puthash3 (num1 num2 num3 db2 item)
  `(let ((bucket (gethash3 ,num1 ,num2 ,num3 ,db2)))
	; Avoid exact duplicates.
	(or (memq ,item bucket)
	    (rplacd bucket (cons ,item (cdr bucket))))
	bucket))

(defmacro gethashmulti (num1 others db2)
  `(cxr (\\ (+ ,num1 
	       (apply (function +) 
		      (mapcar (function *)
			      ,others *multiproducts*)))
	    *db2size*)
	,db2))
 
; Add the item to the front of the appropriate hash bucket (AFTER the
;    special *db* conscell).
(defmacro puthashmulti (num1 others db2 item)
  `(let ((bucket (gethashmulti ,num1 ,others ,db2)))
	; Avoid exact duplicates.
	(or (memq ,item bucket)
	    (rplacd bucket (cons ,item (cdr bucket))))
	bucket))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now the header info.

(defmacro putdbname (name db)
  `(rplacx 0 ,db ,name))
 
(defmacro putdbchildren (childlist db)
  `(rplacx 2 ,db ,childlist))
 
(defmacro setdbactive (db)
  `(rplacx 3 ,db t))
 
(defmacro cleardbactive (db)
  `(rplacx 3 ,db nil))
 
(defmacro putdbparent (parent db)
  `(rplacx 4 ,db ,parent))
 
(defmacro putdb1 (db1 db)
  `(rplacx 5 ,db ,db1))
 
(defmacro putdb2 (db2 db)
  `(rplacx 6 ,db ,db2))
 
(defmacro getdbname (db)
  `(cxr 0 ,db))
 
(defmacro getdbchildren (db)
  `(cxr 2 ,db))
 
(defmacro getdbactive (db)
  `(cxr 3 ,db))
 
(defmacro getdbparent (db)
  `(cxr 4 ,db))
 
(defmacro getdb1 (db)
  `(cxr 5 ,db))
 
(defmacro getdb2 (db)
  `(cxr 6 ,db))
 
; The following predicates do the best we can to check for the type of
;    object by checking what we hope are reasonably unique arrangements
;    of values.  In the case of definitions, instances, databases and
;    symbols, a tag is put in the hunk saying what it is.  This is
;    assumed to be enough.

(de streamp (potstream)
  (and (dtpr potstream)
       (eq '*stream* (car potstream))))

(de databasep (potdb)
  (and (hunkp potdb)
       (let ((tag (gettypetag potdb)))
	    (or (eq tag '*pearldb*)
		(eq tag '*pearlinactivedb*)))))

(de blockp (potblock)
  (let* ((name (car potblock))
	 (blockname (blockatom name)))
	(and (boundp blockname)
	     (eq name
		 (car (eval blockname)))
	     (eq potblock
		 (eval blockname)))))

(de definitionp (potdef)
  (and (hunkp potdef)
       (eq '*pearldef* (gettypetag potdef))))

(de psymbolp (potsymbol)
  (and (hunkp potsymbol)
       (eq '*pearlsymbol* (gettypetag potsymbol))))

(de structurep (potstruct)
  (and (hunkp potstruct)
       (eq '*pearlinst* (gettypetag potstruct))))

(de symbolnamep (potname)
  (let ((symname (symatom potname)))
       (and (boundp symname)
	    (psymbolp (eval symname)))))

(de structurenamep (potname)
  (let ((defname (defatom potname)))
       (and (boundp defname)
	    (definitionp (eval defname)))))

; Determine the print name of an arbitrary object.
(de pname (item)
  (cond ((definitionp item)   (getpname item))
	((structurep item)    (getpname (getdefinition item)))
	((psymbolp item)      (getsymbolpname item))
	((databasep item)     (getdbname item))
	((atom item)          item)
	((streamp item)       (msg t "PNAME: streams do not have pnames: "
				   item t))
	( t (msg t "PNAME: " item " does not have a printname"))))
 
; For loop patterned after (do for ...) in UCI Lisp, except that an
;     initial value is required instead of RPT (and there is no DO). 
(defmacro for (val init final &rest body)
  `((lambda (,val pforlim)
	    (prog (pforval)
		  pforlab
		  (and (>& ,val pforlim)
		       (return pforval))
		  (setq pforval (progn .,body))
		  (setq ,val (1+ ,val))
		  (go pforlab)))
    ,init
    ,final))
 
; While loop patterned after (do while ...) in UCI Lisp.
(defmacro while (val &rest body)
  `(prog (pwhval)
	 pwhlab
	 (and (not ,val)
	      (return pwhval))
	 (setq pwhval (progn .,body))
	 (go pwhlab)))

; vi: set lisp:
EndOfFile
cat >  pearl/match.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; match.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for matching, comparing, and testing structures.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.
; Unification added by David Chin.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions which accomplish unification of two variables.

; Turns on unification (irrevocably).
(de useunification ()
  (setq *unifyunbounds* t)
  'UsingUnification)

; sets all variables in the var list of the equiv class (first arg) which are
; still bound to the equiv class to the new value (second arg).
(defmacro setequivclass (equiv value)
  `(mapc (funl (var)
	       (cond ((dtpr var)  ; a local var cell
		      ; If bound to equiv class, then save the old value
		      ;   and set the var to value.
		      (and (eq (cdr var) ,equiv)
			   (push (cons var (cdr var)) *equivsavestack*)
			   (rplacd var ,value)))
		     ( t ; otherwise a global var.
			 (and (eq (eval var) ,equiv)
			      (push (cons var (eval var)) *equivsavestack*)
			      (set var ,value)))))
	 (cdr ,equiv)))

; unifies two unbound variables (0, one or both may already be equiv classes).
(dm unifytwovars (none)
  '(progn (setq xval (cond ((dtpr xvar) (cdr xvar))
			   ( t (eval xvar))))
	  (setq yval (cond ((dtpr yvar) (cdr yvar))
			   ( t (eval yvar))))
	  (cond ((eq xvar yvar)
		 ; Same variable, so leave xvar and yvar alone.
		 (setq newval nil))
		; Both values are unbound so create a new equiv class.
		((and (eq xval (punbound))
		      (eq yval (punbound)))
		 (setq newval (cons (equivclass) (list xvar yvar))))
		; Same equiv class (not "unbound"), so leave xvar & yvar alone.
		((eq xval yval)
		 (setq newval nil))
		; Both are equiv classes, so merge into a new equiv class.
		((and (pboundp xval)
		      (pboundp yval))
		 (setq newval
		       (cons (equivclass)
			     (cond ((<& (length (cdr xval))
					(length (cdr yval)))
				    (append (cdr xval) (cdr yval)))
				   ( t (append (cdr yval) (cdr xval))))))
		 ; And change the equiv class for the other vars in the list.
		 (setequivclass xval newval)
		 (setequivclass yval newval))
		((punboundatomp xval) ; xvar is not an equiv class.
		 (cond ((memq xvar (cdr yval)) ; but used to be in yvar's.
			(setq newval yval))
		       ( t ; else build a new equiv class with yvar added.
			   (setq newval (cons (equivclass)
					      (cons xvar (cdr yval))))
			   (setequivclass yval newval))))
		( t ; otherwise yvar is not an equiv class.
		    (cond ((memq yvar (cdr xval)) ; but used to be in xvar's.
			   (setq newval xval))
			  ( t ; else build a new equiv class with xvar added.
			      (setq newval (cons (equivclass)
						 (cons yvar (cdr xval))))
			      (setequivclass xval newval)))))
	  ; Set the variables to a new equiv class created above.
	  (and newval
	       (progn
		; Save the old values in case match fails
		(push (cons xvar xval) *equivsavestack*)
		(push (cons yvar yval) *equivsavestack*)
		; And set variables (either local or global).
		(cond ((dtpr xvar) (rplacd xvar newval))
		      ( t (set xvar newval)))
		(cond ((dtpr yvar) (rplacd yvar newval))
		      ( t (set yvar newval)))))
	  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Low level macros for matching.

; Fast macro for minimum of two lengths.
(defmacro min& (n1 n2)
  `(let ((min ,n1)
	 (other ,n2))
	(and (>& min other)
	     (setq min other))
	min))

; Unbind all vars on the item's assoc list
(defmacro unbindvars (item)
  `(mapc (funl (cell) (rplacd cell (punbound))) (getalist ,item)))

; Set the GLOBAL or VAR variable to the value.
(defmacro varset (var val)
  `(let ((localvar ,var)
	 (localval ,val)
	 savevarval)
	(cond ((dtpr localvar)
	       (setq savevarval (cdr localvar))
	       (rplacd localvar localval))
	      ( t (push localvar *globalsavestack*)
		  (setq savevarval (eval localvar))
		  (set localvar localval)))
	(and *unifyunbounds*
	     (equivclassp savevarval)
	     (setequivclass savevarval localval))))

; Set the GLOBAL or VAR adjunct variable to the value.
(defmacro adjvarset (var val)
  `(let ((localvar ,var)
	 (localval ,val)
	 savevarval)
	(and localvar
	     (progn (cond ((dtpr localvar)
			   (setq savevarval (cdr localvar))
			   (rplacd localvar localval))
			  ( t (push localvar *globalsavestack*)
			      (setq savevarval (eval localvar))
			      (set localvar localval)))
		    (and *unifyunbounds*
			 (equivclassp savevarval)
			 (setequivclass savevarval localval))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros for matching individual values.

; Check whether VAL is consistent with the predicates in PREDLIST.
(defmacro consistentvalue (val predlist type item defblock)
  `(prog (restriction)
	 loop
	 (cond ((null ,predlist) (return t)) ; all predicates were true.
	       ; Otherwise, execute the next one.
	       ((cond ((reallitatom (setq restriction (pop ,predlist)))
		       ; The name of a function to be applied.
		       (apply* restriction (ncons ,val)))
		      ; An s-expression predicate -- fill in and execute.
		      ((dtpr restriction)
		       (eval (fillin1 restriction ,val ,item ,defblock)))
		      ; Otherwise, a value.
		      ( t
		       (selectq ,type
				(0 (or (let ((def (getdefinition ,val)))
					    (eq restriction def))
				       (disguisedas ,val restriction)))
				(1 (disguisedas ,val restriction))
				(2 (\=& restriction ,val))
				(3 (eq restriction ,val))
				(otherwise
				 ; A better way needed ?? Never done????
				 (eq restriction (car ,val))))))
		(go loop))
	       ; Otherwise this predicate failed, so we fail.
	       ( t (return nil)))))

; Check two values for "equality".
(defmacro equalvalue (xval yval type)
  `(selectq ,type
	    (0 (basicmatch ,xval ,yval))
	    (1 (eq ,xval ,yval))
	    (2 (\=& ,xval ,yval))
	    (3 (equal ,xval ,yval))
	    (otherwise
	     ; A better way needed!!!!!!!!!!!!!!!!!!!  something like:
	     ; (apply (function and)
	     ;        (mapcar (function equalvalue) ,xval ,yval (strip ,type)))
	     t)))

; Check to see if two slots whose number is passed are matchable,
; binding any variables and running any predicates.
; Assumes slotnum, item1, item2, def1, def2 already set and others declared
;    in main PROG.  The local PROG is necessary for slothooks processing.
(dm compatible (none)
  '(prog ()
	 ; *val and *var are both set by these calls.
	 ; *var are set to nil if no local, global, or adjunct variable.
	 (setq xval (getvarandvalue slotnum item1 'xvar))
	 (setq yval (getvarandvalue slotnum item2 'yvar))
	 ;
	 ; *ANY* => always match
	 (and (or (eq xvar *any*conscell*)
		  (eq yvar *any*conscell*))
	      (return t))
	 ;
	 ; If both are unbound, return *matchunboundsresult* (initially nil).
	 (setq xvalunbound (punboundatomp xval))
	 (setq yvalunbound (punboundatomp yval))
	 (setq bothunbound (and xvalunbound yvalunbound))
	 (and bothunbound
	      (or *unifyunbounds*
		  (return *matchunboundsresult*)))
	 ;
	 ; Get the slots' common type and individual predicates.
	 (setq slottype (getslottype slotnum def1))
	 (setq xpredlist (getpred slotnum item1))
	 (setq ypredlist (getpred slotnum item2))
	 (doslothooks2< '<match *runmatchhooks*)
	 ;
	 ; Otherwise we check to see if one of the slots can be
	 ;     bound to the other.
	 (cond (bothunbound ; Two unbound variables to be unified.
			    (unifytwovars)
			    (setq result t))
	       (xvalunbound ; Match x's variable against y's value.
		(and (setq result
			   (consistentvalue yval xpredlist slottype item2 def2))
		     (varset xvar yval)))
	       (yvalunbound ; Match y's variable against x's value.
		(and (setq result
			   (consistentvalue xval ypredlist slottype item1 def1))
		     (varset yvar xval)))
	       ( t  ; both are bound values -- check "equality".
		    (and (setq result (equalvalue xval yval slottype))
			 ; and set the adjunct variables (if any)
			 (progn (adjvarset xvar yval)
				(adjvarset yvar xval)))))
	 (doslothooks2> '>match *runmatchhooks*)
	 (return result)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Principle match functions.

; Match two structures slot by slot, WITHOUT unbinding variables first,
; but binding along the way.
(de basicmatch (item1 item2)
  (prog (newitem1 newitem2 result slottype xvar yvar xval yval def1 def2
		  xvalunbound yvalunbound length
		  newxval newyval xpredlist ypredlist xhooks yhooks
		  newval bothunbound)
	(setq def1 (getdefinition item1))
	(setq def2 (getdefinition item2))
	(setq length (getstructlength def1))
	(dobasehooks2< '<match *runmatchhooks*)
	(cond ((eq item1 item2) (setq result t)) ; Same structure -> t.
	      ; Not even related -> nil.
	      ((not (eq def1 def2)) (setq result nil))
	      ; No slots -> t.
	      ((\=& 0 length) (setq result t))
	      ; Otherwise, compare slot by slot.
	      ( t (setq result
			(for slotnum 1 length
			     (or (compatible)
				 (return nil))))))
	(dobasehooks2> '>match *runmatchhooks*)
	(return result)))

; Match two structures slot by slot, unbinding variables first.
(de standardmatch (item1 item2)
  (prog (newitem1 newitem2 result slottype xvar yvar xval yval def1 def2
		  xvalunbound yvalunbound length *globalsavestack*
		  newxval newyval xpredlist ypredlist xhooks yhooks
		  newval bothunbound *equivsavestack*)
	(unbindvars item1)
	(unbindvars item2)
	(setq def1 (getdefinition item1))
	(setq def2 (getdefinition item2))
	(setq length (getstructlength def1))
	(dobasehooks2< '<match *runmatchhooks*)
	(cond ((eq item1 item2) (setq result t)) ; Same structure -> t.
	      ; Not even related -> nil.
	      ((not (eq def1 def2)) (setq result nil))
	      ; No slots -> t.
	      ((\=& 0 length) (setq result t))
	      ; Otherwise, compare slot by slot.
	      ( t (setq result
			(for slotnum 1 length
			     (or (compatible)
				 (return nil))))))
	(dobasehooks2> '>match *runmatchhooks*)
	(or result 
	    ; Clean up the variables because of the failure.
	    (progn (unbindvars item1)
		   (unbindvars item2)
		   (and *globalsavestack*
			(mapc (funl (var)
				    (set var (punbound)))
			      *globalsavestack*))
		   ; *equivsavestack* is only non-nil when *unifyunbounds* is t.
		   (and *equivsavestack*
			(mapc (funl (pair)
				    (cond ((dtpr (car pair))
					   (rplacd (car pair) (cdr pair)))
					  ( t (set (car pair) (cdr pair)))))
			      *equivsavestack*))))
	(return result)))

(aliasdef 'match 'standardmatch)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions similar to above but for expanded structures.

; Check to see either defblock is an expansion of the other.
(defmacro relatedhier (defblock1 defblock2)
  `(or (eq ,defblock1 ,defblock2)
       (memq ,defblock2 (getexpansionlist ,defblock1))
       (memq ,defblock1 (getexpansionlist ,defblock2))))

; Check whether VAL is consistent with the predicates in PREDLIST.
(defmacro expconsistentvalue (val predlist type item defblock)
  `(prog (restriction)
	 loop
	 (cond ((null ,predlist) (return t)) ; all predicates were true.
	       ; Otherwise, execute the next one.
	       ((cond ((reallitatom (setq restriction (pop ,predlist)))
		       ; The name of a function to be applied.
		       (apply* restriction (ncons ,val)))
		      ; An s-expression predicate -- fill in and execute.
		      ((dtpr restriction)
		       (eval (fillin1 restriction ,val ,item ,defblock)))
		      ; Otherwise, a value.
		      ( t
		       (selectq ,type
				(0 (or (let ((def (getdefinition ,val)))
					    (relatedhier restriction def))
				       (disguisedas ,val restriction)))
				(1 (disguisedas ,val restriction))
				(2 (\=& restriction ,val))
				(3 (eq restriction ,val))
				(otherwise
				 ; A better way needed ?? Never done????
				 (eq restriction (car ,val))))))
		(go loop))
	       ; Otherwise this predicate failed, so we fail.
	       ( t (return nil)))))

; Check two values for "equality".
(defmacro expequalvalue (xval yval type)
  `(selectq ,type
	    (0 (basicexpandedmatch ,xval ,yval))
	    (1 (eq ,xval ,yval))
	    (2 (\=& ,xval ,yval))
	    (3 (equal ,xval ,yval))
	    (otherwise
	     ; A better way needed!!!!!!!!!!!!!!!!!!!  something like:
	     ; (apply (function and)
	     ;    (mapcar (function expequalvalue) ,xval ,yval (strip ,type)))
	     t)))

; Check to see if two slots whose number is passed are matchable,
; binding any variables and running any predicates.
; Assumes slotnum, item1, item2, def1, def2 already set and others declared
;    in main PROG.  The local PROG is necessary for slothooks processing.
(dm expcompatible (none)
  '(prog ()
	 ; *val and *var are both set by these calls.
	 ; *var are set to nil if no local, global, or adjunct variable.
	 (setq xval (getvarandvalue slotnum item1 'xvar))
	 (setq yval (getvarandvalue slotnum item2 'yvar))
	 ;
	 ; *ANY* => always match
	 (and (or (eq xvar *any*conscell*)
		  (eq yvar *any*conscell*))
	      (return t))
	 ;
	 ; If both are unbound, return *matchunboundsresult* (initially nil).
	 (setq xvalunbound (punboundatomp xval))
	 (setq yvalunbound (punboundatomp yval))
	 (setq bothunbound (and xvalunbound yvalunbound))
	 (and bothunbound
	      (or *unifyunbounds*
		  (return *matchunboundsresult*)))
	 ;
	 ; Get the slots' common type and individual predicates.
	 (setq slottype (getslottype slotnum def1))
	 (setq xpredlist (getpred slotnum item1))
	 (setq ypredlist (getpred slotnum item2))
	 (doslothooks2< '<match *runmatchhooks*)
	 ;
	 ; Otherwise we check to see if one of the slots can be
	 ;     bound to the other.
	 (cond (bothunbound ; Two unbound variables to be unified.
			    (unifytwovars)
			    (setq result t))
	       (xvalunbound ; Match x's variable against y's value.
		(and (setq result
			   (expconsistentvalue yval xpredlist slottype
					       item2 def2))
		     (varset xvar yval)))
	       (yvalunbound ; Match y's variable against x's value.
		(and (setq result
			   (expconsistentvalue xval ypredlist slottype
					       item1 def1))
		     (varset yvar xval)))
	       ( t  ; both are bound values -- check "equality".
		    (and (setq result (expequalvalue xval yval slottype))
			 ; and set the adjunct variables (if any)
			 (progn (adjvarset xvar yval)
				(adjvarset yvar xval)))))
	 (doslothooks2> '>match *runmatchhooks*)
	 (return result)))

; Match two structures slot by slot, WITHOUT unbinding variables first,
; but binding along the way.
(de basicexpandedmatch (item1 item2)
  (prog (newitem1 newitem2 result slottype xvar yvar xval yval def1 def2
		  xvalunbound yvalunbound length
		  newxval newyval xpredlist ypredlist xhooks yhooks
		  newval bothunbound)
	(setq def1 (getdefinition item1))
	(setq def2 (getdefinition item2))
	(setq length (min& (getstructlength def1)
			   (getstructlength def2)))
	(dobasehooks2< '<match *runmatchhooks*)
	(cond ((eq item1 item2) (setq result t)) ; Same structure -> t.
	      ; Not even related hierarchically -> nil.
	      ((not (relatedhier def1 def2)) (setq result nil))
	      ; No slots -> t.
	      ((\=& 0 length) (setq result t))
	      ; Otherwise, compare slot by slot.
	      ( t (setq result
			(for slotnum 1 length
			     (or (expcompatible)
				 (return nil))))))
	(dobasehooks2> '>match *runmatchhooks*)
	(return result)))

; Match two structures slot by slot, unbinding variables first.
(de standardexpandedmatch (item1 item2)
  (prog (newitem1 newitem2 result slottype xvar yvar xval yval def1 def2
		  xvalunbound yvalunbound length *globalsavestack*
		  newxval newyval xpredlist ypredlist xhooks yhooks
		  newval bothunbound *equivsavestack*)
	(unbindvars item1)
	(unbindvars item2)
	(setq def1 (getdefinition item1))
	(setq def2 (getdefinition item2))
	(setq length (min& (getstructlength def1)
			   (getstructlength def2)))
	(dobasehooks2< '<match *runmatchhooks*)
	(cond ((eq item1 item2) (setq result t)) ; Same structure -> t.
	      ; Not even related hierarchically -> nil.
	      ((not (relatedhier def1 def2)) (setq result nil))
	      ; No slots -> t.
	      ((\=& 0 length) (setq result t))
	      ; Otherwise, compare slot by slot.
	      ( t (setq result
			(for slotnum 1 length
			     (or (expcompatible)
				 (return nil))))))
	(dobasehooks2> '>match *runmatchhooks*)
	(or result 
	    ; Clean up the variables because of the failure.
	    (progn (unbindvars item1)
		   (unbindvars item2)
		   (and *globalsavestack*
			(mapc (funl (var)
				    (set var (punbound)))
			      *globalsavestack*))
		   ; *equivsavestack is only non-nil when *unifyunbounds* is t.
		   (and *equivsavestack*
			(mapc (funl (var)
				    (cond ((dtpr (car var))
					   (rplacd (car var) (cdr var)))
					  ( t (set (car var) (cdr var)))))
			      *equivsavestack*))
		   ))
	(return result)))

(aliasdef 'expandedmatch 'standardexpandedmatch)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for testing for equality and other comparisons.

; Check to see if two slots passed (with a type number) are EQUAL,
; NOT binding any variables OR checking any predicates.
(dm slotequal (none)
  '(prog ()
	 ; *val and *var are both set by these calls.
	 ; *var are set to nil if no local, global, or adjunct variable.
	 (setq xval (getvarandvalue slotnum item1 'xvar))
	 (setq yval (getvarandvalue slotnum item2 'yvar))
	 ;
	 ; If the slot of the first ITEM is unbound, fail
	 (and (punboundatomp xval)
	      (progn (msg t "Unbound variables not allowed in STREQUAL" t)
		     (pearlbreak)))
	 ; If the slot of the second ITEM is unbound, fail
	 (and (punboundatomp yval)
	      (progn (msg t "Unbound variables not allowed in STREQUAL" t)
		     (pearlbreak)))
	 ;
	 ; Get the slots' common type.
	 (setq slottype (getslottype slotnum def1))
	 (doslothooks2< '<strequal *runstrequalhooks*)
	 (setq result
	       (selectq slottype
			(0 (strequal xval yval))
			(1 (eq xval yval))
			(2 (\=& xval yval))
			(3 (equal xval yval))
			(otherwise
			 ; A better way needed!!!!!!!!!!!!!!!!!!!
			 (equal xval yval))))
	 (doslothooks2> '>strequal *runstrequalhooks*)
	 (return result)))

; Test two structures for "EQUAL"ity slot by slot, without unbinding
; variables first, and NOT binding along the way.
(de strequal (item1 item2)
  (prog (newitem1 newitem2 result slottype xvar yvar xval yval
		  def1 def2 length newxval newyval xhooks yhooks)
	(setq def1 (getdefinition item1))
	(setq def2 (getdefinition item2))
	(setq length (getstructlength def1))
	(dobasehooks2< '<strequal *runmatchhooks*)
	(cond ((eq item1 item2) (setq result t)) ; Same structure -> t.
	      ; Not even same type -> nil.
	      ((neq def1 def2) (setq result nil))
	      ; No slots -> t.
	      ((\=& 0 length) (setq result t))
	      ; Otherwise, compare slot by slot.
	      ( t (setq result
			(for slotnum 1 length
			     (or (slotequal)
				 (return nil))))))
	(dobasehooks2> '>strequal *runmatchhooks*)
	(return result)))

; Check to see if ITEM1 is an expansion of ITEM2.
(de isanexpanded (item1 item2)
  (let ((defblock1 (getdefinition item1))
	(defblock2 (getdefinition item2)))
       (or (eq defblock1 defblock2)
	   (memq defblock1 (getexpansionlist defblock2)))))

; Check to see if ITEM1 is (an expansion of) the base with name NAME.
(de isa (item1 name)
  (let ((defblock (getdefinition item1))
	(typedef (eval (defatom name))))
       (or (eq defblock typedef)
	   (memq defblock (getexpansionlist typedef)))))

; Test item to see if it's a nilstruct.
(de nullstruct (item)
  (eq (getdefinition item)
      (eval (defatom 'nilstruct))))

; Test item to see if it's a nilsym.
(de nullsym (item)
  (eq item
      (eval (symatom 'nilsym))))

(de memmatch (item list)
  (cond ((null list) nil)
	((not (dtpr list)) nil)
	((match item (car list)) list)
	( t (memmatch item (cdr list)))))

(de memstrequal (item list)
  (cond ((null list) nil)
	((not (dtpr list)) nil)
	((strequal item (car list)) list)
	( t (memstrequal item (cdr list)))))

; vi: set lisp:
EndOfFile
cat >  pearl/path.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; path.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for accessing and changing information associated with
;    slots of structures via a path.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; The PATH functions provide methods for adding and accessing information
;     in a structure.  The PATH macro takes as a first argument the function
;     to be performed and simply expands to the function.  The functions
;     available are:
;     1. PUTPATH -- replaces the value in the slot with one provided.
;     2. CLEARPATH -- replaces the value of the slot with the default.
;     3. ADDSETPATH -- adds the value provided to a SETOF slot (only one
;			    level of adding is currently available).
;     4. DELSETPATH -- deletes the value provided from a SETOF slot (note
;			    that this requires one to know the actual
;			    value to delete).
;     5. ADDPREDPATH -- adds a predicate (function, STRUCT, or hook) to
;			    the PREDLIST.
;     6. DELPREDPATH -- deletes a predicate from the PREDLIST.
;     7. GETPATH -- returns a pointer to the value in the slot.
;     8. GETPREDPATH -- returns the list of function and STRUCT
;				    predicates for the slot.
;     9. GETHOOKPATH -- returns the list of (dotted pair) hook
;				    functions for the slot.
;    10. APPLYPATH -- returns the result of APPLYing the function
;			      provided to the value for the slot.
;
; During a PATH operation, the global variable *PATHTOP* contains the
;    top level item which is being accessed and *PATHLOCAL* is the most
;    local item being accessed.  These are most handy for use by hooks
;    and predicates.

(defmacro path (fcn item pathlist &optional val)
  (selectq fcn
	   (put          `(putpath      ,item ,pathlist ,val))
	   (clear        `(clearpath    ,item ,pathlist))
	   (addset       `(addsetpath   ,item ,pathlist ,val))
	   (delset       `(delsetpath   ,item ,pathlist ,val))
	   (addpred      `(addpredpath  ,item ,pathlist ,val))
	   (delpred      `(delpredpath  ,item ,pathlist ,val))
	   (get          `(getpath      ,item ,pathlist))
	   (getpred      `(getpredpath  ,item ,pathlist))
	   (gethook      `(gethookpath  ,item ,pathlist))
	   (apply        `(applypath    ,item ,pathlist ,val))
	   (otherwise (msg t "PATH: Illegal function selector: " fcn
			   ". Rest of call was: "  item " " pathlist " " val t)
		      (pearlbreak))))

(de putpath (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(checkrunhandleslothooks1 '<put *runputpathhooks*)
	(selectq (getslotvaluetype slotnum item)
		 (CONSTANT (putslotvalue slotnum value item))
		 (ADJUNCT
		  (putslotvalue slotnum
				(cons value (cdr (getslotvalue slotnum item)))
				item))
		 ((LOCAL GLOBAL)
		  (putslotvaluetype slotnum 'CONSTANT item)
		  (putslotvalue slotnum value item)))
	(checkrunhandleslothooks1 '>put *runputpathhooks*)
	(return value)))
 
(de clearpath (item path)
  (prog (numitempair slotnum value result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(setq value (defaultfortype (getslottype slotnum (getdefinition item))))
	(checkrunhandleslothooks1 '<clear *runclearpathhooks*)
	(putslotvaluetype slotnum 'CONSTANT item)
	(putslotvalue slotnum value item)
	(checkrunhandleslothooks1 '>clear *runclearpathhooks*)
	(return value)))
 
(de addsetpath (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(checkrunhandleslothooks1 '<addset *runaddsetpathhooks*)
	(putslotvaluetype slotnum 'CONSTANT item)
	(putslotvalue slotnum (cons value (getvalue slotnum item)) item)
	(checkrunhandleslothooks1 '>addset *runaddsetpathhooks*)
	(return value)))
 
(de delsetpath (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(checkrunhandleslothooks1 '<delset *rundelsetpathhooks*)
	(putslotvaluetype slotnum 'CONSTANT item)
	(putslotvalue slotnum (delq value (getvalue slotnum item)) item)
	(checkrunhandleslothooks1 '>delset *rundelsetpathhooks*)
	(return value)))
 
(de addpredpath (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(checkrunhandleslothooks1 '<addpred *runaddpredpathhooks*)
	(putpred slotnum (cons value (getpred slotnum item)) item)
	(checkrunhandleslothooks1 '>addpred *runaddpredpathhooks*)
	(return value)))
 
(de delpredpath  (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(checkrunhandleslothooks1 '<delpred *rundelpredpathhooks*)
	(putpred slotnum (delete value (getpred slotnum item)) item)
	(checkrunhandleslothooks1 '>delpred *rundelpredpathhooks*)
	(return value)))
 
(de getpath (item path)
  (prog (numitempair slotnum value result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(setq value (punbound))
	(checkrunhandleslothooks1 '<get *rungetpathhooks*)
	(or (neq value (punbound))
	    (setq value (getvalue slotnum item)))
	(checkrunhandleslothooks1 '>get *rungetpathhooks*)
	(return value)))
 
(de getpredpath (item path)
  (prog (numitempair slotnum value result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cadr numitempair)))
	(setq value (punbound))
	(checkrunhandleslothooks1 '<getpred *rungetpredpathhooks*)
	(or (neq value (punbound))
	    (setq value (getpred slotnum item)))
	(checkrunhandleslothooks1 '>getpred *rungetpredpathhooks*)
	(return value)))
 
(de gethookpath (item path value)
  (prog (numitempair slotnum result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cadr numitempair)))
	(setq value (punbound))
	(checkrunhandleslothooks1 '<gethook *rungethookpathhooks*)
	(or (neq value (punbound))
	    (setq value (getslothooks slotnum item)))
	(checkrunhandleslothooks1 '>gethook *rungethookpathhooks*)
	(return value)))
 
(de applypath (fcn item path)
  (prog (numitempair slotnum value result)
	(setq *pathtop* item)
	(setq *currentpearlstructure* item)
	(and (null (setq numitempair (followpath item path)))
	     (return nil))
	(setq slotnum (car numitempair))
	(setq *pathlocal* (setq item (cdr numitempair)))
	(setq value (getvalue slotnum item))
	(checkrunhandleslothooks1 '<apply *runapplypathhooks*)
	(executehook1 fcn value item (getdefinition item))
	(checkrunhandleslothooks1 '>apply *runapplypathhooks*)
	(return value)))
 
; This does indirection.  If the path is longer and we come to a
;    symbol, we try to find something of the type with the name
;    that is next on the path and with the symbol in its first slot.
;    Unfortunately, this always uses the data base in *db*.
(defmacro findstructsymbolpair (defblock symbol)
  `(progn (and (setq bucket (gethash2 (getuniquenum ,defblock)
				      (getuniquenum ,symbol)
				      ; **** FIX to use different dbs (how?)
				      (getdb2 *db*)
				      ))
	       (while (and (setq potential (pop bucket))
			   (not (and (eq (getdefinition potential) ,defblock)
				     (eq (getvalue 1 potential)
					 ,symbol))))
		      potential))
	  potential))
 
; Follow the path down through the structures starting at item.
(de followpath (item path)
  (or (structurep item)
      (progn (msg t "PATH: only works on structures, not on " item
		  ". Requested path was: " path t)
	     (pearlbreak)))
  (let (slotnum type slotname bucket potential slotlocation)
       (and (atom path)
	    (setq path (ncons path)))
       (while (setq slotname (pop path))
	      (and (\=& 0
			(setq slotnum
			      (slotnametonumber slotname
						(getdefinition item))))
		   (progn (msg t "PATH: illegal slotname " slotname "requested "
			       "from " item ". Remaining path is: " path t)
			  (pearlbreak)))
	      (and (null path)
		   (return (cons slotnum item)))
	      ; If a symbol slot (and more path), do indirection.
	      (cond ((\=& 1
			  (setq type (getslottype slotnum
						  (getdefinition item))))
		     (and (null (setq item
				      (findstructsymbolpair
				       (eval (defatom (pop path)))
				       (getvalue slotnum item))))
			  (return nil)))
		    ((\=& 0 type) (setq item (getvalue slotnum item)))
		    (  t  (msg t "PATH: Unable to follow path.  "
			       "Bad slotname is " slotname t)
			  (pearlbreak))))))


; vi: set lisp:
EndOfFile
cat >  pearl/pearl.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; pearl.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file is the file that should be handed to Liszt for compiling.
;    It "includes" all of the files that need to be used to make
;    a complete PEARL object file.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; After compiling this file with the -r option,
;    run it,
; and then run the function
;       (savepearl) to save a version in the current directory
;       	    under the name "pearl"
;       or
;       (savepearl <pathandfilename>) to save a version under that name
; This will then give you a (very large) runnable version of
;    Franz plus PEARL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(eval-when (compile)
  ; To cut down on the number of garbage collects during compilation.
  (allocate 'list 800)
  (allocate 'symbol 200)
  (declare (special defmacro-for-compiling))
  (setq defmacro-for-compiling t))

(declare (macros t))
(declare (localf enforcetype buildvalue
		 insidescopy insidepatternize insidevarreplace
		 followpath convertpreds revassq
		 recursetoinsidestandardfetch gethashvalue insertbyfocus
		 removebyfocus
		 prefix addhistory read-in-startprl-file read-in-initprl-file))

(include ucisubset.l)
; Version numbers are in here.
(include franz.l)
(include lowlevel.l)
(include db.l)
(include vars.l)
(include symord.l)
(include hook.l)
(include create.l)
(include scopy.l)
(include path.l)
(include print.l)
(include hash.l)
(include match.l)
(include history.l)
(include toplevel.l)

; This is a version of the usual library file fix.l
;   with "print"s changed to "pearlfixprintfn".
; It should only be left out after changing the toplevel stuff to
;   not call the fixit debugger.
(include fix.l)

(include alias.l)
(include inits.l)

; vi: set lisp:
EndOfFile
cat >  pearl/pearlbase.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;; pearlbase.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file is the first half of PEARL for compiling in two steps.
;    After it is compiled, it can be loaded into a liszt that is
;    compiling pearlbulk.l
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(eval-when (compile)
  ; To cut down on the number of garbage collects during compilation.
  (allocate 'list 800)
  (allocate 'symbol 200)
  (declare (special defmacro-for-compiling))
  (setq defmacro-for-compiling t))

(declare (macros t))
(declare (localf enforcetype buildvalue
		 insidescopy insidepatternize insidevarreplace
		 followpath convertpreds revassq
		 recursetoinsidestandardfetch gethashvalue insertbyfocus
		 removebyfocus
		 prefix addhistory read-in-startprl-file read-in-initprl-file))

(include ucisubset.l)
; Version numbers are in here.
(include franz.l)
(include lowlevel.l)
(include db.l)
(include vars.l)
(include symord.l)
(include hook.l)


; vi: set lisp:
EndOfFile
cat >  pearl/pearlbulk.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;; pearlbulk.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file is the second half of PEARL for compiling in two pieces.
;    It loads "pearlbase.o" and then "includes" the rest of PEARL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(eval-when (compile)
  ; To cut down on the number of garbage collects during compilation.
  (allocate 'list 800)
  (allocate 'symbol 200)
  (allocate 'fixnum 10)
  (fasl 'pearlbase)
  (load 'franz.l)
  (declare (special defmacro-for-compiling))
  (setq defmacro-for-compiling t))

(declare (macros t))
(declare (localf enforcetype buildvalue
		 insidescopy insidepatternize insidevarreplace
		 followpath convertpreds revassq
		 recursetoinsidestandardfetch gethashvalue insertbyfocus
		 removebyfocus
		 prefix addhistory read-in-startprl-file read-in-initprl-file))

(include create.l)
(include scopy.l)
(include path.l)
(include print.l)
(include hash.l)
(include match.l)
(include history.l)
(include toplevel.l)

; This is a version of the usual library file fix.l
;   with "print"s changed to "pearlfixprintfn".
; It should only be left out after changing the toplevel stuff to
;   not call the fixit debugger.
(include fix.l)

(include alias.l)
(include inits.l)

; vi: set lisp:
EndOfFile
cat >  pearl/pearllib.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;; pearllib.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file loads the two halves of PEARL from /usr/lib/lisp when it
;    was compiled in two pieces on a machine with small memory
;    and/or tempfile space.  It is renamed "pearl.o" in /usr/lib/lisp.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(eval-when (load)
  (fasl '/usr/lib/lisp/pearlbase.o)
  (fasl '/usr/lib/lisp/pearlbulk.o))

; vi: set lisp:
EndOfFile
cat >  pearl/pearlsmall.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;; pearlsmall.l ;;;;;;;;;;;;;;;;;;;;;;;;;;
; This file loads the two halves of PEARL when it is compiled in
;    two pieces on a machine with small memory and/or tempfile space.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(eval-when (load)
  (fasl 'pearlbase.o)
  (fasl 'pearlbulk.o))

; vi: set lisp:
EndOfFile
cat >  pearl/print.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; print.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for converting from internal form to a printable form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Convert a predicate, which might be a structure, to printable form.
(de convertpreds (pred)
  (cond ((or (litatom pred)
	     (dtpr pred)
	     (numberp pred))
	 pred)
	((structurep pred) (allform pred))
	((definitionp pred) (getpname pred))
	( t pred)))
 
; Reverse assoc through a list of cons-cells -- look at the CDRs
;   for value and return the first cons-cell that matches.
(de revassq (value alist)
  (while alist  ; is not NIL
	 (and (eq value (cdar alist))
	      (return (car alist)))
	 (setq alist (cdr alist))))

; Convert an ordinal to printable form.
(defmacro ppsetform (slotval ppset)
  `(cond ((eq 'int ,ppset) ,slotval)
	 ( t (let ((assqlist (eval (ordatom ,ppset)))
		   assqresult)
		  (cond ((setq assqresult (revassq ,slotval assqlist))
			 (car assqresult))
			((\=& 0 ,slotval) '*zero-ordinal-value*)
			( t  (list ,ppset ,slotval)))))))

; Convert a stream to printable form.
(defmacro streamform (item)
  `(cond ((eq t (cadr ,item)) (list '*function-stream:*
				    (structureform (cddr ,item))))
	 ((or *fullprint*
	      (not *streamprintlength*))
	  (list '*stream:*
		(structureform (cadr ,item))
		(mapcan (funl (struct)
			      (cond ((eq '*db* struct) nil)
				    ( t (ncons (structureform struct)))))
			(cddr ,item))))
	 ( t
	  (list
	   '*stream:*
	   (structureform (cadr ,item))
	   (let
	    ((rest (cddr ,item))
	     (result (ncons nil))
	     next)
	    (cond ((dtpr (car rest))
		   ; stream built by expandedfetch.
		   (let ((itemnum 1)
			 bucket)
			(while (setq bucket (pop rest))
			       (mapc
				(funl (next)
				      (or (eq '*db* next)
					  (progn
					   (and (>& itemnum *streamprintlength*)
						(progn
						 (tconc result '|...|)
						 (return (car result))))
					   (tconc result (structureform next))
					   (setq itemnum (1+ itemnum))
					   )))
				bucket)
			       (or rest
				   (return (car result))))))
		  ( t (for itemnum 1 *streamprintlength*
			   (while (and (setq next (pop rest))
				       (eq '*db* next))
				  ) ; do nothing
			   (or next
			       (return (car result)))
			   (tconc result (structureform next)))))
	    (and rest
		 (tconc result '|...|))
	    (car result))))))
 
; Convert a symbol to printable form.
(defmacro symbolform (item)
  `(getsymbolpname ,item))

; Convert an equivalence class list to printable form.
(defmacro equivclassform (equiv)
  `(let ((equivclass ,equiv))
	(mapcan (funl (var)
		      (cond ((dtpr var) ; a local var
			     ; filter out variables which are no longer
			     ; members of the equivalence class
			     (and (eq (cdr var) equivclass)
				  (ncons (list '*var* (car var)))))
			    ( t ; otherwise a global var
				(and (eq (eval var) equivclass)
				     (ncons (list '*global* var))))))
		(cdr equivclass))))

; Convert a definition to printable form.
(defmacro defform (item)
  `(cons 'definition-of:
	 (structureform (getdefaultinst ,item))))

; Convert the constant portion of a slot
(defmacro slotconstform (item typenum ppset)
  `(selectq ,typenum
	    (0 (or (and *abbrevprint*
			(getabbrev ,item))
		   (structureform ,item)))
	    (1 (symbolform ,item))
	    (2 (ppsetform ,item ,ppset))
	    (3 (allform ,item))
	    (otherwise
	     (let ((newtypenum (- ,typenum 4.)))
		  (cond ((dtpr ,item)
			 (mapcar
			  (funl (singleitem)
				(listitemform singleitem newtypenum ,ppset))
			  ,item))
			; otherwise, in case value is somehow not a list,
			;    do your best.
			(t (allform ,item)))))))

; Makes a function out of slotconstform for mapping on a setof slot.
(de listitemform (item typenum ppset)
  (slotconstform item typenum ppset))

; Macro version of slotconstform for normal use on a slot's value.
(defmacro slotitemform (printval)
  `(let ((item ,printval)
	 (typenum (getslottype slotnum defblock))
	 (ppset (getppset slotnum defblock)))
	(slotconstform item typenum ppset)))

; Convert a slot from internal form to a list form.
(dm slotform (none)    ; but assumes SLOTNUM, ITEM, PRINTVAL and PRINTVAR.
  '(progn
    (setq printval (getslotvalue slotnum item))
    (selectq (getslotvaluetype slotnum item)
	     (CONSTANT  (slotitemform printval))
	     (LOCAL     (cond ((eq (punbound) (cdr printval))
			       (list '*var* (car printval)))
			      ((equivclassp (cdr printval))
			       (list (list '*var* (car printval))
				     ; Unfortunate kludge to get rid of \'s.
				     (ncons 'pearlequals)
				     (equivclassform (cdr printval))))
			      ( t (list (list '*var* (car printval))
					; Unfortunate kludge to get rid of \'s.
					(ncons 'pearlequals)
					(slotitemform (cdr printval))))))
	     (ADJUNCT   (list (slotitemform (car printval))
			      (ncons 'pearlequals)
			      (let ((var (cdr printval)))
				   (cond ((dtpr var)
					  (list '*var* (car var)))
					 ( t (list '*global* var))))))
	     (GLOBAL    (cond ((eq (punbound) (eval printval))
			       (list '*global* printval))
			      ((equivclassp (eval printval))
			       (list (list '*global* printval)
				     ; Unfortunate kludge to get rid of \'s.
				     (ncons 'pearlequals)
				     (equivclassform (eval printval))))
			      ( t (list (list '*global* printval)
					; Unfortunate kludge to get rid of \'s.
					(ncons 'pearlequals)
					(slotitemform (eval printval)))))))))

(de structureform (item)
  (let* ((curlist (ncons nil))
	 (defblock (getdefinition item))
	 (basehooks (getbasehooks defblock))
	 ppset
	 printvar
	 printval)
	(cond ((and *uniqueprint*
		    ; if there then return it.
		    (cdr (assq item *uniqueprintlist*))))
	      ( t (tconc curlist (getpname defblock))
		  (and *fullprint*
		       basehooks
		       (tconc curlist (cons 'if basehooks)))
		  (and *uniqueprint*
		       (push (cons item (car curlist))
			     *uniqueprintlist*))
		  (for slotnum 1 (getstructlength defblock)
		       (tconc curlist
			      (nconc (ncons (car
					     (getslotname slotnum defblock)))
				     (ncons (slotform))
				     (and *fullprint*
					  (mapcar (function convertpreds)
						  (getpred slotnum item)))
				     (and *fullprint*
					  (getslothooks slotnum item)))))
		  (car curlist)))))

; Convert any combination of PEARL and Lisp items (possibly from internal
; form) to a printable list structure.
(de allform (item)
  (cond ((hunkp item)
	 (selectq (gettypetag item)
		  (*pearlinst* (structureform item))
		  (*pearlsymbol* (symbolform item))
		  (*pearldef* (defform item))
		  (*pearldb*  (list 'database: (getdbname item)))
		  (*pearlinactivedb*  (list 'Inactive 'Database))
		  (otherwise item))) ; arbitrary hunk?.
	((streamp item) (streamform item))
	((equivclassp item) (equivclassform item))
	((atom item) item)
	((dtpr item) (cons (allform (car item))
			   (allform (cdr item))))
	; Else return item (arbitrary pieces of core?).
	( t item)))

; Convert a PEARL item in full detail and SPRINT the result.
(de fullform (item)
  (let ((*fullprint* t)
	(*abbrevprint* nil)
	(*uniqueprintlist* nil))
       (allform item)))

; Convert a PEARL item using abbreviations and SPRINT the result.
(de abbrevform (item)
  (let ((*abbrevprint* t)
	(*fullprint* nil)
	(*uniqueprintlist* nil))
       (allform item)))

; Normal function to convert a PEARL item and SPRINT the result.
(de valform (item)
  (let ((*fullprint* nil)
	(*abbrevprint* nil)
	(*uniqueprintlist* nil))
       (allform item)))

; Convert any PEARL item using whatever the current settings of 
;   *abbrevprint*, *fullprint* and *uniqueprint* are,
;   and SPRINT the result.
; BUT, don't bother if *quiet* is non-nil.
(de allprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (allform item) lmar rmar))
  '*invisible*)
 
(de structureprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (structureform item) lmar rmar))
  '*invisible*)
 
(de symbolprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (symbolform item) lmar rmar))
  '*invisible*)
 
(de streamprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (streamform item) lmar rmar))
  '*invisible*)
 
(de fullprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (fullform item) lmar rmar))
  '*invisible*)
 
(de valprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (valform item) lmar rmar))
  '*invisible*)
 
(de abbrevprint (item &optional (lmar 0) (rmar 0))
  (or *quiet*
      (sprint (abbrevform item) lmar rmar))
  '*invisible*)
 
; Run some commands but silence any printing it normally does.
(df quiet (command)
  (let ((*quiet* t))
       (eval `(progn ,@command))))

; Print out a data base, printing only buckets that have something in them.
(de printdb (&optional (db *db*))
  (let ((db1 (getdb1 db))
	(db2 (getdb2 db))
	bucket)
       (or (databasep db)
	   (progn (msg t "PRINTDB: Argument is not a database." t)
		  (pearlbreak)))
       (msg t "DB-Name: " (getdbname db))
       (msg t "Active: " (getdbactive db))
       (msg t "Children: " (mapcar (function pname) (getdbchildren db)))
       (msg t "Parent: " (pname (getdbparent db)))
       (msg t "DB1:")
       (and db1
	    (for slotnum 0 (1- *db1size*)
		 (and (setq bucket (remq '*db* (cxr slotnum db1)))
		      (progn (msg t "    " slotnum ": ")
			     (pearlprintfn bucket)))))
       
       (msg t "DB2:")
       (and db2
	    (for slotnum 0 (1- *db2size*)
		 (and (setq bucket (remq '*db* (cxr slotnum db2)))
		      (progn (msg t "    " slotnum ": ")
			     (pearlprintfn bucket)))))
       '*invisible*))

; Print complete information on the internal values stored in a structure
;    and its definition (or a definition and its default instance).
(de debugprint (item)
  (let (def name)
       (cond ((definitionp item)
	      (setq def item)
	      (setq item (getdefaultinst def)))
	     ( t  (setq def (getdefinition item))))
       (and (setq name (getabbrev item))
	    (msg t "******** " name " ********"))
       (msg t "Definition:")
       (msg t "   Unique\#: " (getuniquenum def))
       (msg "  Length: " (getstructlength def))
       (msg "  DefaultInst: " (getdefaultinst def))
       (msg t "   Isa: " (getisa def))
       (msg t "   Pname: " (getpname def))
       (msg "  HashAlias: " (gethashalias def))
       (msg "  ExpansionList: " (getexpansionlist def))
       (msg t "   BaseIfs: " (getbasehooks def))
       (msg t "Individual:")
       (msg "  Abbrev: " (getabbrev item))
       (msg t "   AList: " (getalist item))
       (msg "  AListcp: " (getalistcp item))
       (for slotnum 1 (getstructlength def)
	    (msg t t "***Slotnum " slotnum
		 " : " (getslotname slotnum def))
	    (msg t "Formatinfo: " (getformatinfo slotnum def))
	    (msg "  HashInfo: " (gethashinfo slotnum def))
	    (msg "  Enforce: " (getenforce slotnum def))
	    (msg "  Type: " (getslottype slotnum def))
	    (msg "  PPSet: " (getppset slotnum def))
	    (msg t "ValueType: " (getslotvaluetype slotnum item))
	    (msg "  Internal Value: " (getslotvalue slotnum item))
	    (msg t "Value: " (getvalue slotnum item))
	    (msg "  Preds: " (getpred slotnum item))
	    (msg "  SlotIfs: " (getslothooks slotnum item)))
       '*invisible*))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; the print functions for use with the top level, msg, and the
;    trace, break, etc. packages.

; standard trace print should use allform after turning off tracing.
(de pearltraceprintfn (*traceval*)
  ; Set the $tracemute flag to t so that tracing won't be done
  ; inside allform.
  (let ((\$tracemute t))
       (print (allform *traceval*))))

; standard showstack print should use allform.
(de pearlshowstackprintfn (*showstackval*)
  (print (allform *showstackval*)))

; standard break print should use allform.
(de pearlbreakprintfn (*breakval*)
  (print (allform *breakval*)))

; standard fix print should use allform.
(de pearlfixprintfn (*fixval*)
  (print (allform *fixval*)))

; msg should allform, unless *invisible*.
(de msgprintfn (*msgval*)
  (or (eq '*invisible* *msgval*)
      (patom (allform *msgval*))))

; printing in a trace-break should allprint.
(de pearltracebreakprintfn (*printval*)
  (allprint *printval* 3))

; standard print should allprint.
(de pearlprintfn (*printval*)
  (allprint *printval* 3))

; standard dskin print should use allform unless an atom.
(de dskprintfn (*dskval*)
  (cond ((atom *dskval*) (patom *dskval*))
	( t (print (allform  *dskval*)))))
 

; vi: set lisp:
EndOfFile
cat >  pearl/scopy.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; scopy.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for copying structures in various ways.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Internal slot processor of SCOPY.
(dm scopyslot (none)
  '(progn
    (setq slotvalue (getslotvalue slotnum oldvalblock))
    (selectq (setq valuetype (getslotvaluetype slotnum oldvalblock))
	     (CONSTANT (setq slotvalue (insidescopy slotvalue)))
	     (LOCAL (and (equivclassp (cdr slotvalue))
			 (progn
			  (setq oldvarcell (cdr slotvalue))
			  (setq slotvalue (cons (car slotvalue) (punbound)))))
		    (cond ((eq *any*conscell* slotvalue) nil)
			  ; Bound variable.
			  ((neq (cdr slotvalue) (punbound))
			   (setq valuetype 'CONSTANT)
			   (setq slotvalue (insidescopy (cdr slotvalue))))
			  ; Test for previously seen unbound variable.
			  ((setq newvarcell
				 (assq (car slotvalue)
				       (getalist *currenttopcopy*)))
			   (setq slotvalue newvarcell))
			  ; Otherwise it is a new unbound variable.
			  ( t (setq slotvalue
				    (addalist (car slotvalue)
					      *currenttopcopy*))
			      (and (equivclassp oldvarcell)
				   (progn
				    (rplacd slotvalue oldvarcell)
				    (rplacd oldvarcell
					    (cons slotvalue
						  (cdr oldvarcell))))))))
	     (ADJUNCT (setq oldvarcell (cdr slotvalue))
		      (setq slotvalue (insidescopy (car slotvalue)))
		      (cond ((eq *any*conscell* oldvarcell)
			     (setq slotvalue (cons slotvalue *any*conscell*)))
			    ((atom oldvarcell)
			     (setq slotvalue (cons slotvalue oldvarcell)))
			    ; Used to throw away bound adjunct variables.
			    ;((neq (cdr oldvarcell) (punbound))
			      ; (setq valuetype 'CONSTANT)
			      ; (setq slotvalue (insidescopy (car slotvalue)))
			      ; )
			    ; Test for previously seen variable.
			    ((setq newvarcell
				   (assq (car oldvarcell)
					 (getalist *currenttopcopy*)))
			     (setq slotvalue (cons slotvalue newvarcell)))
			    ; Otherwise it is a new variable.
			    ( t (setq newvarcell
				      (addalist (car oldvarcell)
						*currenttopcopy*))
				(setq slotvalue (cons slotvalue newvarcell)))))
	     (GLOBAL nil))
    (putslotvaluetype slotnum valuetype valblock)
    (putslotvalue     slotnum slotvalue valblock)
    (putpred      slotnum (copy (getpred      slotnum oldvalblock)) valblock)
    (putslothooks slotnum (copy (getslothooks slotnum oldvalblock)) valblock)))


; Internal item processor of SCOPY.
(de insidescopy (item)
  (let
   (defblock valblock length slotvalue valuetype oldvalblock
	     oldvarcell newvarcell abbrev)
   (cond ((null item) nil)
	 ((numberp item) item)                    ; Integer
	 ((dtpr item)                             ; Lisp or Setof
	  (mapcar (function insidescopy) item))
	 ((psymbolp item) item)                   ; Symbol
	 ((atom item) item)                       ; Lisp Atom
	 ; Otherwise, an instance of a structure
	 ((structurep item)
	  (cond ((setq valblock (cdr (assq item *scopieditems*))) valblock)
		( t (setq oldvalblock item)
		    (setq defblock (getdefinition oldvalblock))
		    (setq valblock
			  (allocval (setq length (getstructlength defblock))))
		    (puttypetag '*pearlinst* valblock)
		    (push (cons item valblock) *scopieditems*)
		    (cond (*toplevelp*
			   (setq *currenttopcopy* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
			  ( t (putbothalists *currenttopalists* valblock)))
		    
		    (putdef defblock valblock)
		    (and (setq abbrev (getabbrev oldvalblock))
			 ; Make new abbrev and store struct in abbrev.
			 (setq abbrev (eval `(newsym ,abbrev)))
			 (set abbrev valblock)
			 ; and abbrev in struct.
			 (putabbrev abbrev valblock))
		    (for slotnum 1 length
			 (scopyslot))
		    valblock))))))

; Copy a structure.  Bound variables are replaced by their values.
;   Unbound variables are installed as new local variables in the
;   copy, subject to overruling by the current open blocks.
(de scopy (item)
  (setq *scopieditems* nil)
  (setq *toplevelp* t)
  (insidescopy item))



; Internal slot processor of PATTERNIZE.
(dm patternizeslot (none)
  '(progn
    (setq slotvalue (getslotvalue slotnum oldvalblock))
    (selectq (setq valuetype (getslotvaluetype slotnum oldvalblock))
	     (CONSTANT (setq slotvalue (insidepatternize slotvalue)))
	     (LOCAL (cond ((eq *any*conscell* slotvalue) nil)
			  ; Bound variable.
			  ((and (neq (cdr slotvalue) (punbound))
				(not (equivclassp (cdr slotvalue))))
			   (setq valuetype 'CONSTANT)
			   (setq slotvalue (insidepatternize (cdr slotvalue))))
			  ; Otherwise it is an unbound variable to
			  ;   be replaced by ?*any*.
			  ( t (setq slotvalue *any*conscell*))))
	     (ADJUNCT (setq slotvalue (insidepatternize (car slotvalue)))
		      (setq valuetype 'CONSTANT))
	     (GLOBAL nil))
    (putslotvaluetype slotnum valuetype valblock)
    (putslotvalue     slotnum slotvalue valblock)
    (putpred      slotnum (copy (getpred      slotnum oldvalblock)) valblock)
    (putslothooks slotnum (copy (getslothooks slotnum oldvalblock)) valblock)))

; Internal item processor of PATTERNIZE.
(de insidepatternize (item)
  (let
   (defblock valblock length slotvalue valuetype oldvalblock abbrev)
   (cond ((null item) nil)
	 ((numberp item) item)                    ; Integer
	 ((dtpr item)                             ; Setof
	  (mapcar (function insidepatternize) item))
	 ((psymbolp item) item)                   ; Symbol
	 ((atom item) item)                       ; Lisp Atom
	 ; Otherwise, an instance of a structure
	 ((structurep item)
	  (cond ((setq valblock (cdr (assq item *scopieditems*))) valblock)
		( t (setq oldvalblock item)
		    (setq defblock (getdefinition oldvalblock))
		    (setq valblock
			  (allocval (setq length (getstructlength defblock))))
		    (puttypetag '*pearlinst* valblock)
		    (push (cons item valblock) *scopieditems*)
		    (cond (*toplevelp*
			   (setq *currenttopcopy* valblock)
			   (setq *currentpearlstructure* valblock)
			   (initbothalists valblock)
			   (setq *currenttopalists* (getbothalists valblock))
			   ; Include the current environment in 
			   ;    the variable assoc-list.
			   (and *blockstack*
				(putalist (cdar *blockstack*) valblock))
			   (setq *toplevelp* nil))
			  ( t (putbothalists *currenttopalists* valblock)))
		    
		    (putdef defblock valblock)
		    (and (setq abbrev (getabbrev oldvalblock))
			 ; Make new abbrev and store struct in abbrev.
			 (setq abbrev (eval `(newsym ,abbrev)))
			 (set abbrev valblock)
			 ; and abbrev in struct.
			 (putabbrev abbrev valblock))
		    (for slotnum 1 length
			 (patternizeslot))
		    valblock))))))

; Do an scopy but replace all local variables with ?*any*.
(de patternize (item)
  (setq *scopieditems* nil)
  (setq *toplevelp* t)
  (insidepatternize item))

; Internal environment Scopy.
; Do an scopy of <item> as if it were a recursive call within
;    an scopy of <outer>.
(de intscopy (item outer)
  (let
   (defblock valblock length slotvalue valuetype oldvalblock
	     newvarcell oldvarcell abbrev)
   (setq *scopieditems* nil)
   (cond ((null item) nil)
	 ((numberp item) item)                    ; Integer
	 ((dtpr item)                             ; Lisp or Setof
	  (mapcar (function insidescopy) item))
	 ((psymbolp item) item)                   ; Symbol
	 ((atom item) item)                       ; Lisp Atom
	 ; Otherwise, an instance of a structure
	 ((structurep item)
	  (setq oldvalblock item)
	  (setq defblock (getdefinition oldvalblock))
	  (setq valblock (allocval (setq length (getstructlength defblock))))
	  (puttypetag '*pearlinst* valblock)
	  (push (cons item valblock) *scopieditems*)
	  (initbothalists valblock)
	  (setq *currenttopcopy* outer)
	  (setq *currentpearlstructure* outer)
	  (setq *toplevelp* nil)
	  (putdef defblock valblock)
	  (and (setq abbrev (getabbrev oldvalblock))
	       ; Make new abbrev and store struct in abbrev.
	       (setq abbrev (eval `(newsym ,abbrev)))
	       (set abbrev valblock)
	       ; and abbrev in struct.
	       (putabbrev abbrev valblock))
	  (for slotnum 1 length
	       (scopyslot))
	  valblock))))

; Internal slot processor of VARREPLACE
(dm varreplaceslot (none)
  '(progn
    (setq slotvalue (getslotvalue slotnum item))
    (selectq (setq valuetype (getslotvaluetype slotnum item))
	     (CONSTANT (insidevarreplace slotvalue))
	     (LOCAL (cond ((eq *any*conscell* slotvalue) nil)
			  ; Bound variable, so replace with value.
			  ((and (neq (cdr slotvalue) (punbound))
				(not (equivclassp (cdr slotvalue))))
			   (putslotvaluetype slotnum 'CONSTANT item)
			   ; Should the value be varreplaced like this?
			   (putslotvalue slotnum
					 (insidevarreplace (cdr slotvalue))
					 item))
			  ; Otherwise an unbound variable.
			  ( t nil)))
	     (ADJUNCT (insidevarreplace (car slotvalue)))
	     (GLOBAL  (and (neq (setq slotvalue (eval slotvalue)) (punbound))
			   (not (equivclassp slotvalue))
			   (progn (putslotvaluetype slotnum 'CONSTANT item)
				  (putslotvalue slotnum
						(insidevarreplace slotvalue)
						item)))))))

; Internal item processor of VARREPLACE
(de insidevarreplace (item)
  (let
   (length slotvalue valuetype)
   (cond ((null item) nil)
	 ((numberp item) item)                    ; Integer
	 ((dtpr item)                             ; Lisp or Setof
	  (mapcar (function insidevarreplace) item))
	 ((psymbolp item) item)                   ; Symbol
	 ((atom item) item)                       ; Lisp Atom
	 ; Otherwise, an instance of a structure
	 ((structurep item)
	  (cond ((memq item *scopieditems*) item)
		( t (setq length (getstructlength (getdefinition item)))
		    (cond (*toplevelp*
			   (setq *currentpearlstructure* item)
			   (setq *toplevelp* nil)))
		    (push item *scopieditems*)
		    (for slotnum 1 length
			 (varreplaceslot))
		    item))))))

; Go through a structure replacing bound variables by their values.
(de varreplace (item)
  (setq *scopieditems* nil)
  (setq *toplevelp* t)
  (insidevarreplace item))


; Merge ITEM2 into ITEM1 by copying all bound slots of ITEM2 into
;    any unfrozen slots of ITEM1.
(de smerge (item1 item2)
  (let ((defblock1 (getdefinition item1))
	(defblock2 (getdefinition item2)))
       (and (neq defblock1 defblock2)
	    (not (memq defblock1 (getexpansionlist defblock2)))
	    (progn (msg t "SMERGE: Values not mergeable: " item2
			t "   and " item1)
		   (pearlbreak)))
       (prog (length oldvalue potential result newitem1 newitem2)
	     ; unbind all non-frozen vars first.
	     (mapc (funl (cell) (rplacd cell (punbound))) (getalist item1))
	     (setq length (getstructlength defblock2))
	     (setq result (punbound))
	     (dobasehooks2< '<smerge *runsmergehooks*)
	     (for slotnum 1 length
		  (setq potential (getvalue slotnum item2))
		  (setq oldvalue (getvalue slotnum item1))
		  (and (pboundp potential)
		       (not (pboundp oldvalue))
		       (progn (putslotvalue slotnum potential item1)
			      (putslotvaluetype slotnum 'CONSTANT item1))))
	     (setq result item1)
	     (dobasehooks2> '>smerge *runsmergehooks*)
	     (return result))))


; vi: set lisp:
EndOfFile
cat >  pearl/symord.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; symord.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for defining symbols and ordinal types.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Define one SYMBOL in a hunk for easy identification.
;   This will not work independently (for some reason).
(dm onesymbol (none)
  '(funl (symname)
	 (or (and (not (litatom symname))
		  (not (msg t "SYMBOL: Symbols can only be simple names, not:"
			    symname t)))
	     (and (eq symname 'nilsym)
		  (boundp (symatom 'nilsym))
		  (not (msg t "SYMBOL: Cannot redefine nilsym." t)))
	     (and (null symname)
		  (not (msg t "SYMBOL: Cannot name a symbol nil." t)))
	     (and (symbolnamep symname)
		  ; but okay to do.
		  (and *warn*
		       (msg t "SYMBOL: Warning: Redefining symbol: "
			    symname t)))
	     (let ((block (set (symatom symname) (makhunk 3))))
		  (putuniquenum (newnum) block)
		  (puttypetag '*pearlsymbol* block)
		  (putsymbolpname symname block)
		  block))))
 
; Define a bunch of SYMBOLS.
(df symbol (l)
  (mapcar (onesymbol) l))

; An EXPR which allows the defining of one SYMBOL.
(de symbole (symname)
  (cond ((not (litatom symname))
	 (msg t "SYMBOLE: symbols can only be simple names, not: "
	      symname t)
	 (pearlbreak))
	(  t  (apply* (onesymbol) (ncons symname)) symname)))
 
(de getsymbol (symname)
  (cond ((symbolnamep symname)
	 (eval (symatom symname)))
	(  t  (msg t "GETSYMBOL: " symname " is not the name of a symbol." t)
	      (pearlbreak))))
 
; (ordinal name (x y z)) or  (ordinal name (x 1 y 3 z 8)).
; Define a set of integer constants for readability in input and output.
; Also define o:name, name:max and name:min, and name:x, name:y and name:z.
(df ordinal (l)
  (let ((ordinalname (car l))
	(ordinalelements (cadr l))
	(alist (ncons nil))
	(count 0)
	(min 0)
	max
	name
	value)
       (push ordinalname *ordinalnames*)
       (set (ordatom ordinalname)
	    (cond ((not (numberp (cadr ordinalelements)))
		   ; generate numbers.
		   (while ordinalelements
			  (setq count (1+ count))
			  (tconc alist (cons (setq name (pop ordinalelements))
					     count))
			  (set (concat ordinalname ":" name) count))
		   (or (\=& 0 count)
		       (setq min 1))
		   (setq max count)
		   (car alist))
		  ; use numbers provided by user.
		  ( t (setq min (setq max (cadr ordinalelements)))
		      (while ordinalelements
			     (tconc alist
				    (cons (setq name (pop ordinalelements))
					  (setq value (pop ordinalelements))))
			     (set (concat ordinalname ":" name) value)
			     (and (<& value min)
				  (setq min value))
			     (and (>& value max)
				  (setq max value)))
		      (car alist))))
       (set (concat ordinalname ":min") min)
       (set (concat ordinalname ":max") max)
       (cons ordinalname (car alist))))
 

; vi: set lisp:
EndOfFile
cat >  pearl/toplevel.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; toplevel.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Franz and UCI Lisp top level functions 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering and John Foderaro.

;-------------------------------------------------------------------------
;  Top level functions for PEARL		Joe Faletti, December 1981
;      modified from
;  Top level function for franz			jkf, march 1980
;
; The following function contains the top-level read, eval, print 
; loop.  With the help of the usual error handling functions, 
; pearl-break-err-handler and  debug-err-handler,  pearl-top-level provides
; a reasonable environment for working with PEARL.  
; 

(defvar \$ldprint)

; Handle ^C with fixit.
(de pearl:int-serv (x)
  (fixit nil))

; Before Opus 38.31:
; (setq pearl-title (concat " plus PEARL " (status ctime)))
; Moved to franz.l:
; (setq pearl-title (concat " plus PEARL " (time-string)))

(de read-in-initprl-file ()
  (setq break-level-count 0    ; do this in case break
	debug-level-count 0)   ; occurs during readin
  (*catch '(break-catch top-level-catch)
	  (do ((dirs `("." ,(getenv 'HOME)) (cdr dirs))
	       ; prevent warnings (from setdbsize in particular).
	       (*warn* nil *warn*)
	       (\$ldprint nil \$ldprint))	; prevent messages
	      ((null dirs))
	      (cond ((do ((name '(".init.prl" "init.prl") (cdr name)))
			 ((null name))
			 (cond ((do ((ext '(".o" ".l" "") (cdr ext))
				     (file))
				    ((null ext))
				    (cond ((probef
					    (setq file (concat (car dirs)
							       "/"
							       (car name)
							       (car ext))))
					   (cond ((atom (errset (load file)))
						  (patom
						   "Error loading init.prl file ")
						  (print file)
						  (terpr)
						  (return 'error)))
					   (return t))))
				(return t))))
		     (return t))))))

(de read-in-startprl-file ()
  (setq break-level-count 0    ; do this in case break
	debug-level-count 0)   ; occurs during readin
  (*catch '(break-catch top-level-catch)
	  (do ((dirs `("." ,(getenv 'HOME)) (cdr dirs))
	       (\$ldprint nil \$ldprint))	; prevent messages
	      ((null dirs))
	      (cond ((do ((name '(".start.prl" "start.prl") (cdr name)))
			 ((null name))
			 (cond ((do ((ext '(".o" ".l" "") (cdr ext))
				     (file))
				    ((null ext))
				    (cond ((probef
					    (setq file (concat (car dirs)
							       "/"
							       (car name)
							       (car ext))))
					   (cond ((atom (errset (load file)))
						  (patom
						   "Error loading start.prl file ")
						  (print file)
						  (terpr)
						  (return 'error)))
					   (return t))))
				(return t))))
		     (return t))))))

; For the implementor who wishes to dump a PEARL.
(df savepearl (name)
  (sstatus ignoreeof nil)     ; to undo ~/.lisprc
  (setq franz-not-virgin nil)
  (aliasdef 'top-level 'pearl-top-level-init)
  (setq \$gcprint nil)
  (gc)			; garbage collect before dumping lisp
  (cond (name (eval (list 'dumplisp (car name))))
	( t (dumplisp pearl)))
  t)

; For the user who wishes to dump a PEARL that starts with .init.prl.
(de savefresh n
  (prog (name)
	;   (INITFN 'STARTUPPEARL)
	(setq franz-not-virgin nil)
	(aliasdef 'top-level 'pearl-top-level-init)
	(setq \$gcprint nil)
	(gc)			; garbage collect before dumping lisp
	(cond ((\=& n 1) (setq name (arg 1)))
	      ((\=& n 2) (setq name (concat (arg 1) '|/| (arg 2))))
	      ( t (setq name 'pearl)))
	(eval (list 'dumplisp name))
	(return t)))

; For the user who wishes to dump a PEARL that continues with the
;     read-eval-print loop.
(de savecontinue n
  (prog (name)
	;   (INITFN 'PEARL-REP-LOOP)
	(aliasdef 'top-level 'pearl-top-level)
	(setq \$gcprint nil)
	(gc)			; garbage collect before dumping lisp
	(cond ((\=& n 1) (setq name (arg 1)))
	      ((\=& n 2) (setq name (concat (arg 1) '|/| (arg 2))))
	      ( t (setq name 'pearl)))
	(eval (list 'dumplisp name))
	(return t)))

(de pearlreploop ()
  (prog (*pval*)
	*pearlloop*
	(terpri)
	(and *printhistorynumber*
	     (patom (1+ *historynumber*)))
	(patom *pearlprompt*)
	(setq *readlinechanged* nil)
	(cond ((eq (unbound)
		   (setq *pval*
			 (car (errset (eval (addhistory (read)))))))
	       (rplacx (\\ *historynumber* *historysize*)
		       *histval*
		       (unbound))
	       (prin 'unbound))
	      ( t (rplacx (\\ *historynumber* *historysize*)
			  *histval*
			  *pval*)
		  (pearlprintfn  *pval*)))
	(go *pearlloop*)))
 
(de pearl ()
  (read-in-initprl-file)
  (cond ((not (boundp '*db1size*))
	 (setdbsize 7.)))
  (cond ((not (boundp '*db*))
	 (builddb *maindb*)
	 (setq *db* *maindb*)))
  (cond ((not (boundp '*pearlprompt*))
	 (setq *pearlprompt* '|pearl> |))
	((null *pearlprompt*)
	 (setq *pearlprompt* '|-> |)))
  (cond ((not (boundp '*historysize*))
	 (setq *historysize* 64.)))
  (setq *historynumber* -1.)
  (setq *history* (makhunk *historysize*))
  (setq *histval* (makhunk *historysize*))
  (read-in-startprl-file)
  (terpri)
  (pearlreploop))
 
(de initpearl ()
  (cond ((not (boundp '*db1size*))
	 (setdbsize 7.)))
  (cond ((not (boundp '*db*))
	 (builddb *maindb*)
	 (setq *db* *maindb*))))

(de pearl-top-level-init ()
  (aliasdef 'reset 'franz-reset)
  (aliasdef 'top-level 'pearl-top-level)
  (signal 2 'pearl:int-serv)
  (*catch '(top-level-catch break-catch)
	  (cond ((or (not (boundp 'franz-not-virgin))
		     (null franz-not-virgin))
		 (setq franz-not-virgin t
		       + nil ++ nil +++ nil
		       * nil ** nil *** nil)
		 ; This is changed because fixit is included now.
		 ;	   (setq ER%tpl 'pearl-break-err-handler)
		 (setq ER%tpl 'fixit)
		 (setq ER%brk 'fixit)
		 (setq ER%err 'fixit)
		 
		 ; The rest of the code should be within this
		 ;     cond if autorunlisp existed
		 ;          (cond ((not (autorunlisp))))
		 ;
		 (patom (status version))
		 (cond ((boundp 'franz-minor-version-number)
			(patom franz-minor-version-number)))
		 (patom pearl-title)
		 (terpr)
		 (cond (*firststartup* (setq *firststartup* nil)
				       (read-in-initprl-file)))
		 (or *pearlprompt*
		     (setq *pearlprompt* '|-> |))
		 (and (not (\=& 64 *historysize*))
		      (setq *history* (makhunk *historysize*))
		      (setq *histval* (makhunk *historysize*)))
		 (read-in-startprl-file))))
  (reset))

(de pearl-top-level ()
  ; loop forever
  (do ((+*) (-) (retval))
      (nil)
      (setq retval
	    (*catch
	     '(top-level-catch break-catch)
	     ; begin or return to top level
	     (progn
	      (setq debug-level-count 0   break-level-count 0
		    evalhook nil	  funcallhook nil)
	      (cond (tpl-errlist (mapc 'eval tpl-errlist)))
	      (do ((^w nil nil))
		  (nil)
		  (cond (user-top-level (funcall user-top-level))
			( t ; Print prompt.
			    (and *printhistorynumber*
				 (patom (1+ *historynumber*)))
			    (patom *pearlprompt*)
			    (setq *readlinechanged* nil)
			    
			    (cond ((eq top-level-eof
				       ; read and add to history.
				       (setq - 
					     (car (errset
						   (addhistory
						    (read nil
							  top-level-eof))))))
				   (cond ((not (status isatty))
					  (exit)))
				   (cond ((null (status ignoreeof))
					  (terpr)
					  (print 'Goodbye)
					  (terpr)
					  (exit))
					 ( t (terpr)
					     (setq - ''EOF)))))
			    ; Eval and story result in history.
			    (setq +* (eval -))
			    (rplacx (\\ *historynumber* *historysize*)
				    *histval*
				    +*)
			    ; update list of old forms
			    (let ((val -))
				 (let ((o+ +) (o++ ++))
				      (setq +   val
					    ++  o+
					    +++ o++)))
			    ; update list of old values
			    (let ((val +*))
				 (let ((o* *) (o** **))
				      (setq *   val
					    **  o*
					    *** o**)))
			    ; Don't print *invisible*.
			    (and (neq '*invisible* +*)
				 (pearlprintfn +*))
			    (terpr))))
	      (terpr)
	      (patom "[Return to top level]")
	      (terpr)
	      (cond ((eq 'reset retval) (old-reset-function))))))))

; this is the break handler, it should be tied to 
; ER%tpl always.
; it is entered if there is an error which no one wants to handle.
; We loop forever, printing out our error level until someone
; types a ^D which goes to the next break level above us (or the 
; top-level if there are no break levels above us.)
; a (return n) will return that value to the error message
; which called us, if that is possible (that is if the error is
; continuable)
;
(def pearl-break-err-handler 
  (lexpr
   (n)
   ((lambda
     (message break-level-count retval rettype ^w piport)
     (cond ((>& n 0) 
	    (print 'error:)
	    (mapc '(lambda (a) (patom " ") (patom a) ) 
		  (cdddr (arg 1)))
	    (terpr)
	    (cond ((caddr (arg 1)) (setq rettype 'contuab))
		  ( t (setq rettype nil))))
	   ( t (setq rettype 'localcall)))
     
     (do nil (nil)
	 (cond ((dtpr 
		 (setq retval
		       (*catch
			'break-catch 
			(do ((form)) (nil)
			    (patom "<")
			    (patom break-level-count)
			    (patom ">: ")
			    (cond ((eq top-level-eof
				       (setq form (read nil top-level-eof)))
				   (cond ((null (status isatty))
					  (exit)))
				   (eval 1)	; force interrupt check
				   (return (1- break-level-count)))
				  ((and (dtpr form)
					(eq 'return (car form)))
				   (cond ((or (eq rettype 'contuab) 
					      (eq rettype 'localcall))
					  (return (ncons (eval (cadr form)))))
					 ( t (patom
					      "Can't continue from this error")
					     (terpr))))
				  ((and (dtpr form) (eq 'retbrk (car form)))
				   (cond ((numberp (setq form
							 (eval (cadr form))))
					  (return form))
					 ( t (return (1- break-level-count)))))
				  ( t (pearlbreakprintfn (eval form))
				      (terpr)))))))
		(return (cond ((eq rettype 'localcall) 
			       (car retval))
			      ( t retval))))
	       ((<& retval break-level-count)
		(setq tpl-errlist errlist)
		(*throw 'break-catch retval))
	       ( t (terpr)))))
    nil
    (1+ break-level-count)
    nil
    nil
    nil
    nil)))

(aliasdef 'break-err-handler 'pearl-break-err-handler)

; vi: set lisp:
EndOfFile
cat >  pearl/ucisubset.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ucisubset.l ;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for a subset of UCI Lisp that are either used by PEARL
;     or were needed by PEARL users at Berkeley.
; This was purposely designed to interfere as little as necessary
;     with Franz Lisp, so things like the standard UCI do macro
;     and the Charniak (et al) let macro are not provided.
; Includes what used to be sprint.l (at the end).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

(eval-when (compile)
  (declare (special defmacro-for-compiling *savedefs*))
  (setq defmacro-for-compiling t)
  (setq *savedefs* nil))

(declare (macros t))

(defvar poport)
(defvar pparm1 50)
(defvar pparm2 100)
(defvar lpar)
(defvar rpar)
(defvar form)
(defvar linel)
(defvar *outport* nil)
(defvar *fileopen*)
(defvar prettyprops '((comment . pp-comment)
		      (function . pp-function)
		      (value . pp-value)))

(declare (localf *patom1))

(defvar *file* nil)
(defvar *oldfunctiondefinition*)
(defvar *savedefs* t)

(defmacro funl (&rest rest)
  `(function (lambda .,rest)))

;
; ucilisp (de df dm) declare function macros.
;
; (DE name args body) -> declare exprs and lexprs.
;   If *savedefs* is t and function has previous definition,
;   save it under the property OLDDEF, and return '(name Redefined).
;   Otherwise, just do a defun and return name (as with defun).
;
(defun de macro (l)
  (cond (*savedefs*
	 `(progn 'compile
		 (setq *oldfunctiondefinition* (getd ',(cadr l)))
		 (defun .,(cdr l))
		 (and *file*
		      (putprop ',(cadr l) *file* 'sourcefile))
		 (cond (*oldfunctiondefinition*
			(putprop ',(cadr l) *oldfunctiondefinition* 'olddef)
			(list ',(cadr l) 'Redefined))
		       ( t ',(cadr l)))))
	( t `(defun .,(cdr l)))))
  
;
; (df name args body) -> declare fexprs.
;
(defun df macro (l) 
  (cond (*savedefs*
	 `(progn 'compile
		 (setq *oldfunctiondefinition* (getd ',(cadr l)))
		 (defun ,(cadr l) fexpr .,(cddr l))
		 (and *file*
		      (putprop ',(cadr l) *file* 'sourcefile))
		 (cond (*oldfunctiondefinition*
			(putprop ',(cadr l) *oldfunctiondefinition* 'olddef)
			(list ',(cadr l) 'Redefined))
		       ( t ',(cadr l)))))
	( t `(defun ,(cadr l) fexpr .,(cddr l)))))

;
; macro's are not compiled except under the same
;	conditions as in franz lisp.
;	(usually just do (declare (macros t))
;		to have macros also compiled).
;
;
; (dm name args body) -> declare macros. same as (defun name 'macro body)
;
(defun dm macro (l) 
  (cond (*savedefs*
	 `(progn 'compile
		 (setq *oldfunctiondefinition* (getd ',(cadr l)))
		 (defun ,(cadr l) macro .,(cddr l))
		 (and *file*
		      (putprop ',(cadr l) *file* 'sourcefile))
		 (cond (*oldfunctiondefinition*
			(putprop ',(cadr l) *oldfunctiondefinition* 'olddef)
			(list ',(cadr l) 'Redefined))
		       ( t ',(cadr l)))))
	( t `(defun ,(cadr l) macro .,(cddr l)))))

; UCI Lisp character macros are non-separating when occurring in 
;    the middle of atoms.
(eval-when (compile load eval)
  (add-syntax-class 'vucisplicemacro
		    '(csplicing-macro escape-when-first))
  (add-syntax-class 'vucireadmacro
		    '(cmacro escape-when-first)))

;
; ucilisp functions which declare character macros.
;
;
; dsm - declare splicing read macro.
;
(defun dsm macro (l) 
  (cond (*savedefs*
	 `(progn 'compile
		 (setq *oldfunctiondefinition*
		       (and (memq (getsyntax ',(cadr l))
				  '(vucireadmacro vucisplicemacro
						  vsplicing-macro vmacro))
			    (get ',(cadr l) readtable)))
		 (eval-when (compile load eval)
			    (setsyntax ',(cadr l) 'vucisplicemacro ',(caddr l)))
		 
		 (and *file*
		      (putprop ',(cadr l) *file* 'sourcefile))
		 (cond (*oldfunctiondefinition*
			(putprop ',(cadr l) *oldfunctiondefinition* 'oldmacro)
			(list ',(cadr l) 'Redefined))
		       ( t ',(cadr l)))))
	( t `(eval-when (compile load eval)
			(setsyntax ',(cadr l) 'vucisplicemacro ',(caddr l))))))

;
; drm - declare read macro.
;
(defun drm macro (l) 
  (cond (*savedefs*
	 `(progn 'compile
		 (setq *oldfunctiondefinition*
		       (and (memq (getsyntax ',(cadr l))
				  '(vucireadmacro vucisplicemacro
						  vsplicing-macro vmacro))
			    (get ',(cadr l) readtable)))
		 (eval-when (compile load eval)
			    (setsyntax ',(cadr l) 'vucireadmacro ',(caddr l)))
		 
		 (and *file*
		      (putprop ',(cadr l) *file* 'sourcefile))
		 (cond (*oldfunctiondefinition*
			(putprop ',(cadr l) *oldfunctiondefinition* 'oldmacro)
			(list ',(cadr l) 'Redefined))
		       ( t ',(cadr l)))))
	( t `(eval-when (compile load eval)
			(setsyntax ',(cadr l) 'vucireadmacro ',(caddr l))))))

;
; ucilisp selectq function. (written by jkf)
;
(defun selectq* macro (form)
  ((lambda (x)
	   `((lambda (,x)
		     (cond 
		      ,@(maplist 
			 (function
			  (lambda (ff)
				  (cond ((null (cdr ff))
					 `( t  ,(car ff)))
					((atom (caar ff))
					 `((eq ,x ',(caar ff))
					   . ,(cdar ff)))
					(t
					 `((memq ,x ',(caar ff))
					   . ,(cdar ff))))))
			 (cddr form))))
	     ,(cadr form)))
   (gensym 'z)))

(defun some macro (l)
  `((lambda (f a)
	    (prog ()
		  loop
		  (cond ((null a) (return nil))
			((funcall f (car a))
			 (return a))
			( t (setq a (cdr a))
			    (go loop)))))
    ,(cadr l)
    ,(caddr l)))

(defmacro subset (fun lis)
  `(mapcan (function (lambda (ele)
			     (cond ((funcall ,fun ele) (ncons ele)))))
	   ,lis))
  
(defun length (l)
  (prog (n)
	(setq n 0)
	loop
	(and (atom l) 
	     (return n))
	(setq l (cdr l))
	(setq n (1+ n))
	(go loop)))

(defmacro apply* (fcn args)
  `(prog (fcndef)
	 (return
	  (cond ((atom ,fcn)
		 (or (and (eq 'binary (type ,fcn))
			  (setq fcndef ,fcn))
		     (setq fcndef (getd ,fcn)))
		 (cond ((or (and (eq 'binary (type fcndef))
				 (eq 'macro (getdisc fcndef)))
			    (and (dtpr fcndef)
				 (eq 'macro (car fcndef))))
			(funcall ,fcn (cons ,fcn ,args)))
		       ( t (apply ,fcn ,args))))
		( t (apply ,fcn ,args))))))

(defmacro every (fcn args)
  `(prog (kkkk)
	 (setq kkkk ,args)
	 loop
	 (cond ((null kkkk)
		(return t))
	       ((apply* ,fcn (list (pop kkkk)))
		(go loop)))
	 (return nil)))

(defun timer fexpr (request)
  (let ((timein (ptime)) timeout result cpu garbage)
       (prog ()
	     loop
	     (setq result (eval (car request)))
	     (and (setq request (cdr request))
		  (go loop)))
       (setq timeout (ptime))
       (setq cpu (quotient (fix (times 1000
				       (quotient (difference (car timeout)
							     (car timein))
						 60.0)))
			   1000.0))
       (setq garbage (quotient (fix (times 1000
					   (quotient (difference (cadr timeout)
								 (cadr timein))
						     60.0)))
			       1000.0))
       (print (cons cpu garbage))
       (terpri)
       result))

(putd 'consp (getd 'dtpr))

(putd 'msgprintfn (getd 'patom))
  
;
; ucilisp msg function. (written by jkf)
;
(defmacro msg ( &rest body)
  `(progn ,@(mapcar 
	     (function
	      (lambda (form)
		      (cond ((eq form t) '(line-feed 1))
			    ((numberp form)
			     (cond ((>& form 0) 
				    `(msg-space ,form))
				   ( t `(line-feed ,(minus form)))))
			    ((atom form) `(msgprintfn ,form))
			    ((eq (car form) t) '(msgprintfn '\	))
			    ((eq (car form) 'e) 
			     `(msgprintfn ,(cadr form)))
			    ( t `(msgprintfn ,form)))))
	     body)
	  nil)) ; return nil!
  
;
; this NEED NOT be fixed to not use do.
;
(defmacro msg-space (n)
  (cond ((eq 1 n) '(patom '" "))
	( t `(do i ,n (1- i) (<& i 1) (patom '\ ))))) 

(defmacro line-feed (n)
  (cond ((eq 1 n) '(terpr))
	( t `(do i ,n (1- i) (<& i 1) (terpr)))))

; compatability functions: functions required by uci lisp but not
;	present in franz
;
; union uses the franz do loop (not the ucilisp one).

(defvar membfn 'member)

(defun union n
  (and (> n 0)
       (do ((res (ncons nil))
	    (i 1 (1+ i)))
	   ((eq i (1+ n)) (car res))
	   (mapc (function
		    (lambda (arg)
		       (or (apply* membfn (list arg (car res)))
			   (tconc res arg))))
		 (arg i)))))

(defun enter (v l)
  (cond ((apply* membfn (list v l)) l)
	( t (cons v l))))

(defun append2 (a b &aux (c (ncons nil)))
      (do ((a a (cdr a)))
	  ((null a))
	  (tconc c (car a)))
      (rplacd (cdr c) b)
      (car c))

(putd 'noduples (getd 'union))
(putd 'append* (getd 'append))
(putd '*append (getd 'append))
(putd '*dif (getd 'diff))
(putd '*eval (getd 'eval))
(putd '*great (getd 'greaterp))
(putd '*less (getd 'lessp))
(putd '*max (getd 'max))
(putd '*nconc (getd 'nconc))
(putd '*plus (getd 'plus))
(putd '*times (getd 'times))
(putd 'expandmacro (getd 'macroexpand))
(putd 'mapcl (getd 'mapcar))
(putd 'memb (getd 'member))

(dm clrbfi () 
 '(drain piport))

(defun save fexpr (l)
  (let ((fcnname (car l)))
       (putprop fcnname (getd fcnname) 'olddef)))

(defun unsave fexpr (l) 
  (let* ((name (car l))
	 (old (get name 'olddef)))
	(and old
	     (putprop name (getd name) 'olddef)
	     (putd name old))
	old))

(putd 'atcat (getd 'concat))

(putd 'gt (getd '>))
(putd 'lt (getd '<))

(defun le macro (x)
  `(not (> .,(cdr x))))

(defun ge macro (x)
  `(not (< .,(cdr x))))

(defun litatom macro (x)
  `(and (atom .,(cdr x))
	(not (numberp .,(cdr x)))))

(putd 'peekc (getd 'tyipeek))

;
;	unbound - (setq x (unbound)) will unbind x.
; "this [code] is sick" - jkf.
;
(defun unbound macro (l)
  `(fake -4))

(or (getd 'franzboundp)
  (putd 'franzboundp (getd 'boundp)))

(defun boundp (item)
  (cond ((arrayp item))
	((franzboundp item))))

(defvar *dskin* t)
(defvar piport)

;(eval-when (load eval compile)
;  (or (boundp '*dskin*)
;      (setq *dskin* t)))

(eval-when (load eval)
  (or (getd 'dskprintfn)
      (putd 'dskprintfn (getd 'patom))))

(defun dskin fexpr (l)
  (mapc 'dskin1 l)
  (terpri) t )

(defun dskin1 (*file*)
  (prog (port)
	(terpri)
	(patom '|>>>|)
	(cond ((null (setq port (car (errset (infile *file*) nil))))
	             (patom '|couldn't open file |)
		     (patom *file*))
	      ( t (patom *file*)
		  (patom '| |)
		  (dskin2 port)
		  (close port)))))

(defun dskin2 (port)
  (prog (expr value)
    loop
      (cond ((null (setq expr (read port))) nil)
	    ( t (cond ((memq (car expr) '(de df defmacro dm drm
					     dsm setq def defun))
		       (cond ((memq *dskin* '(name both))
			      (patom (cadr expr))
			      (patom '|: |))))
		      ((eq (car expr) 'create)
		       (cond ((memq *dskin* '(name both))
			      (patom (caddr expr))
			      (patom '|: |)))))
		(setq value (eval expr))
		(and (memq *dskin* '(t both))
		     (or (eq value '*invisible*)
			 (progn (dskprintfn value)
				(patom '| |))))
		(go loop)))))

(defun nequal (arg1 arg2)
  (not (equal arg1 arg2)))

(defun readl fexpr (l)
  (cond ((null l) (readl1 nil))
	( t (readl1 (eval (car l))))))

(putd 'lineread (getd 'readl))

(defun readl1 (flag)
  (cond ((not (and flag
		   (eq (tyipeek) 10)
		   (tyi)))
	 (prog (input)
	       (setq input (ncons nil))  ; initialize for tconc.
	       loop
	       (cond ((not (eq (tyipeek) 10))
		      (tconc input (read))
		      (go loop))
		     ( t ; the actual list is in the CAR.
			 (tyi)
			 (return (car input))))))))

(defun defv fexpr (l)
  (set (car l) (cadr l)))

(defun remprops (item proplist)
  (mapc (funl (prop)
	      (remprop item prop))
	proplist)
  nil)

(defun addprop (id value prop)
  (putprop id (enter value (get id prop)) prop))

(defun nconc1 (l elmt)
  (rplacd (last l) (cons elmt nil)))

(defun dremove (elmt l)
  (let (newl)
       (cond ((dtpr l)
	      (cond ((eq elmt (car l))
		     (setq newl (delq elmt l))
		     (rplaca l (car newl))
		     (rplacd l (cdr newl)))
		    ( t (delq elmt l))))
	     ( t l))))

(defun intersection (set1 set2)
  (prog (inter)
	(mapc (funl (elt) (putprop elt t '*inter*)) set1)
	(mapc (funl (elt) (and (get elt '*inter*)
			       (setq inter (cons elt inter))))
	      set2)
	(mapc (funl (elt) (remprop elt '*inter*)) set1)
	(return inter)))

(defun initsym1 expr (l)
  (prog (num)
	(cond ((dtpr l)
	       (setq num (cadr l))
	       (setq l (car l)))
	      ( t (setq num 0)))
	(putprop l num 'symctr)
	(return (concat l num))))

(defun initsym fexpr (l)
  (mapcar (function initsym1) l))

(defun newsym fexpr (l)
  (let ((name (car l)))
       (concat name
	       (putprop name
			(1+ (or (get name 'symctr)
				-1))
			'symctr))))

(defun oldsym fexpr (l)
  (let ((sym (car l)))
       (concat sym (get sym 'symctr))))

(defun allsym fexpr (l)
  (prog (num symctr syms)
	(cond ((dtpr (car l))
	       (setq num (cadar l))
	       (setq l (caar l)))
	      ( t (setq num 0)
		  (setq l (car l))))
	(or (setq symctr (get l 'symctr))
	    (return))
	loop
	(and (>& num symctr)
	     (return syms))
	(setq syms (cons (concat l symctr) syms))
	(setq symctr (1- symctr))
	(go loop)))

(defun remsym1 expr (l)
  (prog1 (funcall (function oldsym)
		  (cond ((dtpr (car l)) (car l))
			( t  l)))
	 (mapc (function remob) (apply (function allsym) l))
	 (cond ((dtpr (car l)) (putprop (caar l) (1- (cadar l)) 'symctr))
	       ( t (remprop (car l) 'symctr)))))

(defun remsym fexpr (l)
  (maplist (function remsym1) l))

(defun symstat fexpr (l)
  (mapcar (funl (k)
		(list k (get k 'symctr)))
	  l))

(defun suflist (itemlist num)
  (cond ((dtpr itemlist) (nth (1+ num) itemlist))))

;;;;;;;;;;;;;;;;;;;;;;; (formerly sprint.l) ;;;;;;;;;;;;;;;;;;;;;;;;
;  A few additions to the library file ucbpp.l, mostly to add
;  a UCI Lisp-like "sprint" including some modifications for
;     more flexible printmacros.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Moved to front and converted to defvar.
; (declare (special poport pparm1 pparm2 lpar rpar form linel))
; (declare (localf *patom1))
; (declare (special *outport* *fileopen* prettyprops))

; =======================================
; pretty printer top level routine pp
;
;
; calling form- (pp arg1 arg2 ... argn)
; the args may be names of functions, atoms with associated values
; or output descriptors.
; if argi is:
;    an atom - it is assumed to be a function name, if there is no
;	       function property associated with it,then it is assumed
;		to be an atom with a value
;    (P port)-  port is the output port where the results of the
;	        pretty printing will be sent.
;		poport is the default if no (P port) is given.
;    (F fname)- fname is  a file name to write the results in
;    (A atmname) - means, treat this as an atom with a value, dont
;		check if it is the name of a function.
;    (E exp)-   evaluate exp without printing anything
;    other -	pretty-print the expression as is - no longer an error
;
;    Also, rather than printing only a function defn or only a value, we will
;    let prettyprops decide which props to print.  Finally, prettyprops will
;    follow the CMULisp format where each element is either a property
;    or a dotted pair of the form (prop . fn) where in order to print the
;    given property we call (fn id val prop).  The special properties
;    function and value are used to denote those "properties" which
;    do not actually appear on the plist.
;
; [history of this code: originally came from Harvard Lisp, hacked to
; work under franz at ucb, hacked to work at cmu and finally rehacked
; to work without special cmu macros]
; THEN, hacked to use for PEARL.

; moved to front.
;(setq prettyprops '((comment . pp-comment)
;		    (function . pp-function)
;		    (value . pp-value)))

; printret is like print yet it returns the value printed, this is used
; by pp		
(def printret
  (macro (*l*)
	 `(progn (print ,@(cdr *l*)) ,(cadr *l*))))

(def pp
  (nlambda (*xlist*)
	(prog (*outport* *cur* *fileopen* *prl* *atm*)

	      (setq *outport* poport)			; default port
	      ; check if more to do, if not close output file if it is
	      ; open and leave


   toploop    (cond ((null (setq *cur* (car *xlist*)))
		     (condclosefile)
		     (terpr)
		     (return t)))

	      (cond ((dtpr *cur*)
		     (cond ((equal 'P (car *cur*))	; specifying a port
			    (condclosefile)		; close file if open
			    (setq *outport* (eval (cadr *cur*))))

			   ((equal 'F (car *cur*))	; specifying a file
			    (condclosefile)		; close file if open
			    (setq *outport* (outfile (cadr *cur*))
				  *fileopen* t))

						
			   ((equal 'E (car *cur*))
			    (eval (cadr *cur*)))

			   ( t (terpri *outport*)
			       (*prpr *cur*)))	;-DNC inserted
		     (go botloop)))


      (mapc (function
	       (lambda (prop)
		       (prog (printer)
			     (cond ((dtpr prop)
				    (setq printer (cdr prop))
				    (setq prop (car prop)))
				   ( t (setq printer 'pp-prop)))
			     (cond ((eq 'value prop)
				    (cond ((boundp *cur*)
					   (apply printer
						  (list *cur*
							(eval *cur*)
							'value)))))
				   ((eq 'function prop)
				    (cond ((and (getd *cur*)
						(not (bcdp (getd *cur*))))
					   (apply printer
						  (list *cur*
							(getd *cur*)
							'function)))))
				   ((get *cur* prop)
				    (apply printer
					   (list *cur*
						 (get *cur* prop)
						 prop)))))))
	    prettyprops)


 botloop      (setq *xlist* (cdr *xlist*))

	      (go toploop))))

; moved to front.
;(setq pparm1 50 pparm2 100)

;   -DNC These "prettyprinter parameters" are used to decide when we should
;	quit printing down the right margin and move back to the left -
;	Do it when the leftmargin > pparm1 and there are more than pparm2
;	more chars to print in the expression

; cmu prefers dv instead of setq

#+cmu
(def pp-value (lambda (i v p)
		      (terpri *outport*) (*prpr (list 'dv i v))))

#-cmu
(def pp-value (lambda (i v p)
		      (terpr *outport*) (*prpr `(setq ,i ',v))))
(def pp-function (lambda (i v p)
			 (terpri *outport*) (*prpr (list 'def i v))))
(def pp-prop (lambda (i v p)
		     (terpri *outport*) (*prpr (list 'defprop i v p))))

(def condclosefile 
  (lambda nil
	  (cond (*fileopen*
		 (terpr *outport*)
		 (close *outport*)
		 (setq *fileopen* nil)))))

;
; these routines are meant to be used by pp but since
; some people insist on using them we will set *outport* to nil
; as the default (moved to front).
;(setq *outport* nil)


(def *prpr 
  (lambda (x)
	  (cond ((not (boundp '*outport*)) (setq *outport* poport)))
	  (terpr *outport*)
	  (*prdf x 0 0)))

; This is the principle addition for PEARL.
; SPRINT simply calls *prdf after filling in any missing parameters.
(defun sprint (value &optional (lmar 0) (rmar 0))
  (cond ((not (boundp '*outport*)) (setq *outport* poport)))
  (*prdf value lmar rmar))

(defvar rmar)	; -DNC this used to be m - I've tried to
		; to fix up the pretty printer a bit.  It
		; used to mess up regularly on (a b .c) types
		; of lists.  Also printmacros have been added.



; Used to be $prdf but added a bit and changed to * to avoid
;   PEARL's history read macro $.
(def *prdf
  (lambda (l lmar rmar)
    (prog (pmac)
;
;			- DNC - Here we try to fix the tendency to print a
;			  thin column down the right margin by allowing it
;			  to move back to the left if necessary.
;
	  (cond ((and (>& lmar pparm1) (>& (flatc l (1+ pparm2)) pparm2))
		 (terpri *outport*)
		 (princ '"; <<<<< start back on the left <<<<<" *outport*)
		 (*prdf l 5 0)
		 (terpri *outport*)
		 (princ '"; >>>>> continue on the right >>>>>" *outport*)
		 (terpri *outport*)
		 (return nil)))
          (tab lmar *outport*)
     a    (cond ((and (dtpr l)
                      (atom (car l))
                      (setq pmac (get (car l) 'printmacro))
		      (cond ((stringp pmac)
			     ; Added for PEARL (and UCI Lisp compatibility).
			     ; a string printmacro means print this
			     ;   string and then the cadr of l if
			     ;   it's not nil, and only if l is
			     ;   a one- or two-element list.
			     (cond ((cddr l) ; more than two elements.
				    nil)
				   ((null (cdr l)) ; only one element.
				    (patom pmac)
				    t)
				   ( t (patom pmac)  ; two elements.
				       (patom (cadr l))
				       t)))
			    ( t (apply pmac (list l lmar rmar)))))
		 (return nil))
;
;				-DNC - a printmacro is a lambda (l lmar rmar)
;				attached to the atom.  If it returns nil then
;				we assume it did not apply and we continue.
;				Otherwise we assume it did the job.
;
                ((or (not (dtpr l))
;                    (*** at the moment we just punt hunks etc)
                     (and (atom (car l)) (atom (cdr l))))
                 (return (printret l *outport*)))
                ((<& (+ rmar (flatc l (chrct *outport*)))
                        (chrct *outport*))
;
;	This is just a heuristic - if print can fit it in then figure that
;	the printmacros won't hurt.  Note that despite the pretentions there
;	is no guarantee that everything will fit in before rmar - for example
;	atoms (and now even hunks) are just blindly printed.	- DNC
;
                 (printaccross l lmar rmar))
                ((and (*patom1 lpar)
                      (atom (car l))
                      (not (atom (cdr l)))
                      (not (atom (cddr l))))
                 (prog (c)
                       (printret (car l) *outport*)
                       (*patom1 '" ")
                       (setq c (nwritn *outport*))
                  a    (*prd1 (cdr l) c)
                       (cond
                        ((not (atom (cdr (setq l (cdr l)))))
                         (terpr *outport*)
                         (go a)))))
                (t
                 (prog (c)
                       (setq c (nwritn *outport*))
                  a    (*prd1 l c)
                       (cond
                        ((not (atom (setq l (cdr l))))
                         (terpr *outport*)
                         (go a))))))
     b    (*patom1 rpar))))

(def *prd1
  (lambda (l n)
    (prog nil
          (*prdf (car l)
                 n
                 (cond ((null (setq l (cdr l))) (|1+| rmar))
                       ((atom l) (setq n nil) (+ 4 rmar (pntlen l)))
                       ( t rmar)))
          (cond
           ((null n) (*patom1 '" . ") (return (printret l *outport*))))
;         (*** setting n is pretty disgusting)
;         (*** the last arg to *prdf is the space needed for the suffix)
;		;Note that this is still not really right - if the prefix
;		takes several lines one would like to use the old rmar 
;(		until the last line where the " . mumble)" goes.
	)))

; -DNC here's the printmacro for progs - it replaces some hackery that
; used to be in the guts of *prdf.

(def printprog
  (lambda (l lmar rmar)
    (prog (col)
          (cond ((cdr (last l)) (return nil)))
          (setq col (1+ lmar))
          (princ '|(| *outport*)
          (princ (car l) *outport*)
          (princ '| | *outport*)
          (print (cadr l) *outport*)
          (mapc '(lambda (x)
			 (cond ((atom x)
				(tab col *outport*)
				(print x *outport*))
                          ( t (*prdf x (+ lmar 6) rmar))))
		(cddr l))
          (princ '|)| *outport*)
          (return t))))

(putprop 'prog 'printprog 'printmacro)

; Here's the printmacro for def.  The original *prdf had some special code
; for lambda and nlambda.

(def printdef
  (lambda (l lmar rmar)
    (cond ((and (\=& 0 lmar)		; only if we're really printing a defn
                (\=& 0 rmar)
                (cadr l)
                (atom (cadr l))
                (caddr l)
                (null (cdddr l))
                (memq (caaddr l) '(lambda nlambda macro lexpr))
                (null (cdr (last (caddr l)))))
           (princ '|(| *outport*)
           (princ 'def *outport*)
           (princ '| | *outport*)
           (princ (cadr l) *outport*)
           (terpri *outport*)
           (princ '|  (| *outport*)
           (princ (caaddr l) *outport*)
           (princ '| | *outport*)
           (princ (cadaddr l) *outport*)
           (terpri *outport*)
           (mapc  '(lambda (x) (*prdf x 4 0)) (cddaddr l))
           (princ '|))| *outport*)
           t))))

(putprop 'def 'printdef 'printmacro)

; There's a version of this hacked into the printer (where it don't belong!)
; Note that it must NOT apply to things like (quote a b).

(def printquote
  (lambda (l lmar rmar)
    (cond ((or (null (cdr l)) (cddr l)) nil)
          ( t (princ '|'| *outport*) 
	      (*prdf (cadr l) (1+ lmar) rmar)
	      t))))

(putprop 'quote 'printquote 'printmacro)




(def printaccross
  (lambda (l lmar rmar)
    (prog nil
;         (*** this is needed to make sure the printmacros are executed)
          (princ '|(| *outport*)  ;)
     l:   (cond ((null l))
                ((atom l) (princ '|. | *outport*) (princ l *outport*))
                ( t (*prdf (car l) (nwritn *outport*) rmar)
		    (setq l (cdr l))
		    (cond (l (princ '| | *outport*)))
		    (go l:))))))



(def tab (lexpr (n)
  (prog (nn prt) (setq nn (arg 1))
		(cond ((>& n 1) (setq prt (arg 2))))
		(cond ((>& (nwritn prt) nn) (terpri prt)))
		(printblanks (- nn (nwritn prt)) prt))))

; ========================================
;
;	(charcnt port) 
; returns the number of characters left on the current line
; on the given port
;
; =======================================


(def charcnt
     (lambda (port) (- linel (nwritn port))))

(putd 'chrct (getd 'charcnt))

(def *patom1 (lambda (x) (patom x *outport*)))

; vi: set lisp:
EndOfFile
cat >  pearl/vars.l  << 'EndOfFile'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; vars.l ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions for declaring and creating pattern-matching variables
;    and blocks and for freezing and thawing them.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copyright (c) 1983 ,  The Regents of the University of California.
; All rights reserved.  
; Authors: Joseph Faletti and Michael Deering.

; Convert a question mark variable ?var to either (*global* var) if "var"
;    is in *globallist* or else make it local (*var* var).
(drm \?
  (lambda ()
	  (let ((nextchar (tyipeek))
		var)
	       (cond ((\=&  9. nextchar) '\?)
		     ((\=& 10. nextchar) '\?)
		     ((\=& 13. nextchar) '\?)
		     ((\=& 32. nextchar) '\?)
		     ((\=& 41. nextchar) '\?)
		     ( t (setq var (read))
			 (cond ((memq var *globallist*)
				(list '*global* var))
			       (  t  (list '*var* var))))))))
 
; VALUEOF and VARVALUE are EXPR and FEXPR versions of a function to
;     get the value of the variable VAR in the structure STRUCT.
(de valueof (var struct)
  (getvalofequivorvar
   (cdr (or (assq var (getalist struct))
	    (assq var (getalistcp struct))
	    (progn (msg t "VALUEOF: Variable " var
			" does not occur in structure:" struct t)
		   (pearlbreak))))))
 
;    This is a FEXPR version of valueof (above).
(df varvalue (l)     ; (VAR STRUCT)
  (let ((var (car l))
	(struct (eval (cadr l))))
       (getvalofequivorvar
	(cdr (or (assq var (getalist struct))
		 (assq var (getalistcp struct))
		 (progn (msg t "VARVALUE: Variable " var
			     " does not occur in structure:" struct t)
			(pearlbreak)))))))

; Set the given variable, in the given environment (if present) to
;    the value given.  If no environment given, look first at
;    *currentstructure*, then at *currentpearlstructure*, then at
;    *blockstack*, else complain.
(df setv (l)    ; (var 'val 'environment)
  (let*
   ((var (car l))
    (type (car var))
    (name (cadr var))
    (val (eval (cadr l)))
    (environment (eval (caddr l)))
    varcell
    oldvarval)
   (cond ((eq '*global* type)   ; global variable.
	  (setq oldvarval (eval name))
	  (set name val))
	 ((eq '*var* type)      ; local or block variable.
	  (cond (environment
		 ; optional 3rd argument given for environment.
		 (cond ((structurep environment)
			(setq varcell
			      (or (assq name (getalist environment))
				  (assq name (getalistcp environment))
				  (progn (msg t "SETV: No variable named: " name
					      " in structure: " t environment t)
					 (pearlbreak)))))
		       ((blockp environment)
			(setq varcell
			      (or (assq name environment)
				  (progn (msg t "SETV: No variable named: " name
					      " in block: " t environment t)
					 (pearlbreak)))))
		       ( t (msg t "SETV: Given environment is neither "
				"a block nor a structure: " t environment)
			   (pearlbreak))))
		; otherwise, try to find in standard environment.
		((setq varcell
		       (or (and (structurep *currentstructure*)
				(or (assq name (getalist *currentstructure*))
				    (assq name (getalistcp *currentstructure*))
				    ))
			   (and (structurep *currentpearlstructure*)
				(or (assq name
					  (getalist *currentpearlstructure*))
				    (assq name
					  (getalistcp *currentpearlstructure*))
				    ))
			   (and *blockstack*
				(assq name (cdar *blockstack*))))))
		( t ; Else if not there either, blow up.
		    (msg t "SETV: No variable in the current"
			 " environment named: " name t)
		    (pearlbreak)))
	  ; Successfully found the variable.
	  (and varcell
	       (setq oldvarval (cdr varcell))
	       (rplacd varcell val)))
	 ( t (msg t "SETV: " var " is not a variable." t)
	     (pearlbreak)))
   (and (equivclassp oldvarval)
	(mapc (funl (newvar) (cond ((dtpr newvar)	    ; a local var cell.
				    (and (eq (cdr newvar) oldvarval)
					 (rplacd newvar val)))
				   ( t ; otherwise a global var's name.
				       (and (eq (eval newvar) oldvarval)
					    (set newvar val)))))
	      (cdr oldvarval)))
   val))

; Get the value of a local variable.   Look in the same places as
;    SETV above but return nil if not found.
(df *var* (l)
  (let ((var (car l)))
       (getvalofequivorvar
	  (cdr (or (and (structurep *currentstructure*)
			(or (assq var (getalist *currentstructure*))
			    (assq var (getalistcp *currentstructure*))))
		   (and (structurep *currentpearlstructure*)
			(or (assq var (getalist *currentpearlstructure*))
			    (assq var
				  (getalistcp *currentpearlstructure*))))
		   (and *blockstack*
			(assq var (cdar *blockstack*))))))))

; Get the value of a global variable.
(df *global* (l)
  (getvalofequivorvar
     (eval (car l))))

; Declare a variable to be GLOBAL by entering it on the *GLOBALLIST*
;    and PEARL-unbinding it.
(df global (l)
  (let ((variable (car l)))
       (set variable (punbound))
       (push variable *globallist*)
       variable))
 
; PEARL-unbind a global variable. ("unbindvars" does the local variables
;    in an entire structure (see match.l)).
(df unbind (l)
  (let ((var (car l)))
       (cond ((memq var *globallist*)
	      (set var (punbound)))
	     ( t (set var (punbound))
		 (and *warn*
		      (msg t "UNBIND: Warning: " var
			   " is not a global variable but unbound it anyway."
			   t))))))

; Determine if the variable is GLOBAL, i.e., on the *GLOBALLIST*
(de globalp (variable)
  (memq variable *globallist*))
 
; (BLOCK <name> (<LIST OF VARIABLES>)) starts a (possibly embedded)
;    set of variables accessible to all structure CREATEd within
;    the block.   Terminated by a call to (ENDBLOCK <name>).
; The name is optional.  If used, then the block may be reaccessed
;    with b:<name>.
 
(df block (l)
  (let ((name (car l))
	varlist
	alist)
       (cond ((reallitatom name) (setq varlist (cadr l)))
	     ( t  (setq varlist name)
		  (setq name 'unnamedblock)))
       (setq alist
	     (nconc (ncons (cons nil (punbound)))  ; Cell for Frozen vars.
		    (mapcar (funl (varname) (cons varname (punbound)))
			    varlist)
		    (cond (*blockstack* (cdar *blockstack*))
			  ( t nil))))
       (and name
	    (set name alist))
       ; Create a special cons cell, point b:<name> at it and push it.
       (push (set (blockatom name)
		  (cons name alist))
	     *blockstack*)
       name))
 
; (ENDBLOCK <name>) ends the block with name <name>.
;    If <name> is * then close one block, regardless of name.
;    If <name> is nil then close one unnamed block only.
(df endblock (l)
  (let ((name (car l)))
       (and (null name)
	    (setq name 'unnamedblock))
       (cond ((not *blockstack*)
	      (msg t "ENDBLOCK: No blocks to end")
	      (msg ", not even named: " name t)
	      (pearlbreak))
	     ((or (eq name '*)
		  (eq name (caar *blockstack*)))
	      (prog1 (caar *blockstack*)
		     (setq *blockstack* (cdr *blockstack*))))
	     ( t (msg t "ENDBLOCK: Block to be ended, "
		      name " doesn't match innermost block, named: "
		      (caar *blockstack*) t)
		 (pearlbreak)))))

; (ENDANYBLOCKS <name>) ends all blocks back through the block
;    with name <name>.
; If <name> is * then end all blocks.
; If <name> is nil then end all blocks back through the
;    last unnamed block.
(df endanyblocks (l)
  (let ((name (car l))
	(block *blockstack*))
       (cond ((not *blockstack*)    nil)
	     ((eq name '*)       (setq *blockstack* nil))
	     ((null (while (and block
				(neq (caar block) name))
			   (setq block (cdr block))))
	      (msg t "ENDANYBLOCKS: No currently open block named "
		   name " to end blocks back to." t)
	      (pearlbreak))
	     ( t (setq *blockstack* (pop block))
		 (caar *blockstack*)))
       t))

; (ENDALLBLOCKS <name>) ends any open blocks, regardless of name.
(de endallblocks ()
  (setq *blockstack* nil)
  t)

; (SETBLOCK <blockname>) changes the current scope to that of
;      <blockname>, BUT doesn't allow ending former blocks!
(df setblock (l)
  (let ((blockname (car l)))
       (cond ((and (boundp (blockatom blockname))
		   (blockp (eval (blockatom blockname))))
	      (setq *blockstack* (eval (blockatom blockname))))
	     ( t (msg t "SETBLOCK: There is no block named: " blockname t)
		 (pearlbreak)))))
 
; Take all the bound variables off the STRUCT'S ALIST, and put them on
; the ALISTCP, preserving unique alist pairs.  Also take care of all the
; BLOCK alists.  WARNING: This code is tough so be careful with it!
(de freezebindings (struct)
  (let ((oldalist (getalist struct))     ; to be frozen.
	(unboundalist (ncons nil))       ; to still unbound variables.
	(boundalist (getalistcp struct)) ; already frozen.
	rest
	currentblock)
       ; While there are more variables to process, and we haven't reached
       ;     a block, add either to "unboundalist" or "boundalist".
       (while (and oldalist
		   (reallitatom (caar oldalist)))
	      (setq rest (cdr oldalist))
	      (cond ((eq (cdar oldalist) (punbound))
		     (tconc unboundalist (car oldalist)))
		    ( t (setq boundalist (rplacd oldalist boundalist))))
	      (setq oldalist rest))
       (and oldalist
	    (rplaca unboundalist
		    (nconc (car unboundalist)
			   oldalist))) ; pointer to the enclosing blocks.
       ; Store new lists.
       (putalist (car unboundalist) struct)
       (putalistcp boundalist struct)
       ; Process blocks one at a time.
       (while oldalist
	      (setq currentblock oldalist)
	      (setq oldalist (cdr oldalist))
	      (setq unboundalist (ncons nil))
	      (setq boundalist (caar currentblock))
	      (while (and oldalist
			  (reallitatom (caar oldalist)))
		     (setq rest (cdr oldalist))
		     (cond ((eq (cdar oldalist) (punbound))
			    (tconc unboundalist (car oldalist)))
			   ( t (setq boundalist (rplacd oldalist boundalist))))
		     (setq oldalist rest))
	      (and oldalist
		   (rplaca unboundalist
			   (nconc (car unboundalist)
				  oldalist))) ; pointer to the enclosing blocks.
	      ; store frozen vars.
	      (rplaca (car currentblock) boundalist)
	      (rplacd currentblock (car unboundalist)))
       t))
 
; Take all the bound variables off the STRUCT's ALIST, and put them on
;   the ALISTCP, preserving unique alist pairs.
(de freezestruct (struct)
  (let ((oldalist (getalist struct))
	(unboundalist (ncons nil))
	(boundalist (getalistcp struct))
	rest)
       (while (and oldalist                       ; is not NIL, and
		   (reallitatom (caar oldalist))) ; have not reached block
	      (setq rest (cdr oldalist))
	      (cond ((eq (cdar oldalist) (punbound))
		     (tconc unboundalist (car oldalist)))
		    ( t (setq boundalist (rplacd oldalist boundalist))))
	      (setq oldalist rest))
       (and oldalist
	    (rplaca unboundalist
		    (nconc (car unboundalist)
			   oldalist))) ; pointer to the enclosing blocks.
       (putalist (car unboundalist) struct)
       (putalistcp boundalist struct)
       t))
 
(df freezeblock (blockname)
  (let (block
	oldalist
	unboundalist
	boundalist
	rest)
       (cond ((and (boundp (blockatom (car blockname)))
		   (setq block (eval (blockatom (car blockname))))
		   (blockp block)))
	     ( t (msg t "FREEZEBLOCK: " blockname
		      " is not the name of a block." t)
		 (pearlbreak)))
       (setq oldalist (cddr block))
       (setq unboundalist (ncons nil))
       (setq boundalist (caadr block))
       (while (and oldalist
		   (reallitatom (caar oldalist)))
	      (setq rest (cdr oldalist))
	      (cond ((eq (cdar oldalist) (punbound))
		     (tconc unboundalist (car oldalist)))
		    ( t (setq boundalist (rplacd oldalist boundalist))))
	      (setq oldalist rest))
       (and oldalist
	    (rplaca unboundalist
		    (nconc (car unboundalist)
			   oldalist))) ; pointer to the enclosing blocks.
       (rplaca (cadr block) boundalist) ; store frozen vars.
       (rplacd (cdr block) (car unboundalist))
       t))
 
(dm findnextblockstart (none) ; But expects ALIST
  '(while (and alist
	       (reallitatom (caar alist)))
	  (setq alist (cdr alist))))
 
; This is for JUST THE STRUCT.
(de thawstruct (struct)
  (let ((alist (getalist struct)))
       (putalist (nconc (getalistcp struct) alist) struct)
       (putalistcp nil struct)
       t))
 
; Restore the Alist to include all values. (Undo FREEZEBINDINGS)
; This is done for ALL BLOCKs that STRUCT is a member of.
(de thawbindings (struct)
  (let ((alist (getalist struct)))
       (putalist (nconc (getalistcp struct) alist) struct)
       (putalistcp nil struct)
       (while (findnextblockstart)
	      (rplacd alist (nconc (caar alist) (cdr alist)))
	      (rplaca (car alist) nil))
       t))
 
; This is for JUST ONE BLOCK.
(df thawblock (blockname)
  (let (alist
	block)
       (cond ((and (boundp (blockatom (car blockname)))
		   (setq block (eval (blockatom (car blockname))))
		   (blockp block))
	      block)
	     ( t (msg t "THAWBLOCK: " blockname
		      " is not the name of a block." t)
		 (pearlbreak)))
       (setq alist (cddr block))
       (rplacd (cdr block) (nconc (caadr block) alist))
       (rplaca (cadr block) nil)
       t))


; vi: set lisp:
EndOfFile
cat >  lisplib/Makefile  << 'EndOfFile'
# $Header: Makefile,v 1.13 85/03/24 11:18:37 sklower Exp $
#	Makefile for /usr/lib/lisp
# this directory contains the lisp coded portion of the standard 
# lisp system and other useful lisp programs. 
# The command 'make all' insures that all source files are compiled
# The command 'make install' installs these files in the standard
# place (/usr/lib/lisp).  This is only useful of course if the current
# directory is not /usr/lib/lisp.
#
.SUFFIXES: .l.s.o

.l.s:
	${Liszt} -xaqS $*
.l.o:
	${Liszt} -xaq $*

#--- Default paths and programs:
LibDir = /usr/lib/lisp
CopyTo = /dev/null
Liszt = liszt


#--- ReqSrc: required source for building lisp system
#
ReqSrc = charmac.l common0.l common1.l common2.l common3.l toplevel.l \
	syntax.l  macros.l  vector.l array.l pp.l format.l version.l \
	tpl.l fcninfo.l


#--- OtherSrc: other lisp coded library files
OtherSrc = machacks.l loop.l ucifnc.l  ucido.l jkfmacs.l trace.l\
	record.l syscall.l \
	cmumacs.l cmufncs.l fix.l step.l cmufile.l cmutpl.l cmuedit.l \
	structini.l struct.l prof.l hash.l flavorm.l lmhacks.l

LocalSrc = describe.l flavors.l vanilla.l

ReqObj = charmac.o common0.o common1.o common2.o common3.o toplevel.o \
	syntax.o  macros.o  vector.o array.o pp.o format.o version.o \
	tpl.o fcninfo.o

OtherObj = machacks.o loop.o ucifnc.o  ucido.o jkfmacs.o trace.o\
	record.o syscall.o\
	cmumacs.o cmufncs.o fix.o step.o cmufile.o cmutpl.o cmuedit.o \
	struct.o prof.o hash.o flavorm.o lmhacks.o

LocalObj =  describe.o flavors.o vanilla.o

#--- AllSrc: all source files required for lisp system
#		LocalSrc isn't included!
#		Now it is! (SMH@MIT-EMS)

AllSrc = Makefile ReadMe buildlisp.l cmuenv.l fixit.ref \
	${ReqSrc} ${OtherSrc} autorun/vax autorun/unisoft \
	autorun/sun4.2 autorun/mc500 autorun/68k \
	$(LocalSrc)

AllObj = ${ReqObj} ${OtherObj}
    
# all: ${AllObj}

all: ${AllObj} ${LocalObj}

required: ${ReqObj}

DotSSrc = charmac.s common0.s common1.s\
	  common2.s common3.s toplevel.s syntax.s macros.s\
	  vector.s array.s pp.s format.s\
	  version.s tpl.s fcninfo.s

xtra:	${DotSSrc}

fromasm:
	for i in *.s; do echo $$i; ${LibDir}/as $$i; done
#	rm -f *.s


## defstruct should be compiled with a compiled version of itself.
## When a compiled form doesn't exist, structini.l can be used to
## build a struct.o which is close but not exactly what you want.
## Recompiling struct will use struct.o and create the correct struct.o
## 
struct-again:
	${Liszt} -xaq struct

## The three flavor files have dependencies (SMH@MIT-EMS):
flavors.o:	flavorm.o
vanilla.o:	flavors.o

## this will only work if you have an up to date version of ctags which
## understands lisp files.

tags:    ${AllSrc}
	ctags ${AllSrc}

sources: ${AllSrc}

xref:
	lxref ${AllSrc} > xref

echofiles:
	@echo ${ReqSrc} ${OtherSrc}

echorequired:
	@echo ${ReqSrc}

# updatemachine will vcp all objects and source to machine
# named with 'mach' on the command line

updatemachine: ${AllSrc} ${AllObj}
	-vcp -wfq /usr/ucb/lisp /usr/ucb/liszt ${mach}:.
	-vcp -wfq ${AllSrc} ${mach}:/usr/lib/lisp
	-vcp -wfq ${AllObj} ${mach}:/usr/lib/lisp

copysource: ${AllSrc}
	(tar cf - ${AllSrc} | (cd ${CopyTo} ; tar xf -))

copyobjects: ${AllObj}
	(tar cf - ${AllObj} | (cd ${CopyTo} ; tar xf -))

scriptcatall: ${AllSrc}
	@(X=`pwd` ; cd ${CdTo}; scriptcat $$X lisplib ${AllSrc})

scriptcatxtra:
	@(X=`pwd` ; cd ${CdTo}; scriptcat $$X lisplib ${DotSSrc})

as:
	@echo "Grabbing as from /bin"
	cp /bin/as as

nld:
	@echo "Grabbing nld from /bin"
	cp /bin/ld nld

cleanreq:
	-rm -f ${ReqObj}

cleanall:
	-rm -f ${AllObj}

cleanother:
	-rm -f ${OtherObj}

clean: 
	-rm -f *.o 
	-rm -f *.blat 
	-rm -f *.x
EndOfFile
cat >  lisplib/ReadMe  << 'EndOfFile'
	 ==== /usr/lib/lisp directory ====

  This directory contains a number of different kinds of files.  The meanings
of the file suffixes are:
	.l - lisp source		.o - compiled lisp	
	.x - lisp cross reference   	

    -- Contents --

Makefile:
    Input for make program.
    'make all' makes all object files
    'make required' makes only those object files needed to build the
	default lisp system

SCCS
    Directory for checkpointing source.  This directory is normally not
    distributed since it requires a special license to get the sccs
    software

as:
    Berkeley assembler. Probably a copy of /bin/as except in those places
    whose internal politics prevent the berkeley assembler from being the
    standard one.
    This assembler is called from liszt.

manual
    directory containing nroff output form of manual pages.
    used by the 'help' function in lisp.

nld
    berkeley loader.  Usually a copy of /bin/ld.  Used by 'cfasl'
    and 'ffasl' functions.

+++++ class A software +++++
--- supported and documented by people at Berkeley.

common0.l
    Lisp functions which must exist in order to read in the syntax
    and charmac files interpreted.  These are the lowest level files.

common1.l
    Most lisp coded lisp functions are in here.  
    * Loaded into the standard lisp.

common2.l
    Other lisp coded lisp functions.  contains the pretty printer.
    * Loaded into the standard lisp.

syntax.l
    Contains the setsyntax and getsyntax functions, as well as
    the defintions of Franz's syntax classes.
    * Loaded into the standard lisp.

charmac.l
    Contains the ever popular backquote macro and the sharp sign macro
    * Loaded into the standard lisp.

toplevel.l
    standard berkeley franz top level.  Contains top-level and break
    handlers as well as startup function for liszt -r and autoloads.
    * Loaded into the standard lisp.

trace.l
    Joseph Lister Trace package from Berkeley.
    Automatically loaded when a call to 'trace' is made.


+++++  class B +++++
--- contributed software.  Not supported by people at Berkeley but
documented in the Franz Lisp Manual. 
    
cmuenv.l
    a file which just loads the cmu files to create the complete cmu
    environment (macros, toplevel, file package, and editor).
    
cmuedit.l
    an interlisp like interactive editor. Documented in chapter 16.
    
cmufile.l
    a file package. This is documented in chapter 13
    
cmufncs.l
    functions required by the cmu macros and other run time packages.
    Some of these should move into the auxfns files

cmumacs.l
    compile time macros required for compiling other cmu files.  These
    are also useful at runtime.
    
cmutpl.l
    the cmu top level (containing a shell like history facility).
    Documented in chapter 13.
    


editor.l

fix.l
    fixit package from cmu.   It has been modified to allow it to compile
    with only the macros in cmumacs.  this is autoloaded when the 
    function (debug) is invoked.

+++++  class C
---  donated by individuals.  Not officially documented or supported.
---  some files may contain documentation at the beginning, others
---  may be documented in other lisp manuals

jkfmacs.l
    Some addition macros such as a nice 'If' macro and a msg macro for
    printing multiple values in one call.


machacks.l
    a list of macros for generating a maclisp environment.


step.l
    Step package from cmu (and from mit).  It has been modified for the
    new evalhook and funcallhook in Franz.  Will autoload when the 
    function step is referenced.

syscall.l
    A set of macros for doing syscall's.  very unix dependent at this point.

sysfunc.l
    file from cmu.  Probably should be removed and functions put elsewhere.
    
tackon
    program to put a 'fasl' type map onto an object file.
    use is: 'tackon map objectfile'


ucido.l
    do function from ucilisp.  should be in ucifnc but isn't due to 
    supposed compiler problems (which I don't believe still exist).

ucifnc.l
    set of macros and functions for generating a ucilisp environment.
    automatically loaded when -u is done.


+++++ Class D
----- files from the MacLisp/LispM world.  Not documented or supported
----- by Berkeley, however they may be integrated into our code.

loop.l
    a macro for writing loops

flavors.l
    an object creator/definer

struct.l 
    a macro for defining structures

structinit.l
    a file required to compile struct.l
EndOfFile
cat >  lisplib/buildlisp.l  << 'EndOfFile'
(int:setsyntax '\; 'splicing 'zapline)
;; buildlisp.l				-[Mon Aug 15 11:04:31 1983 by jkf]-
;; build the lisp system from the C kernel
;; the order of these files is very important.
;;
(setq rcs-buildlisp-
   "$Header: /usr/lib/lisp/RCS/buildlisp.l,v 1.2 83/08/15 22:16:06 jkf Exp $")

; variables to modify the way buildlisp works:
;   build:dir -- directory containing the object files to load
;	default: /usr/lib/lisp
;   build:map -- map file to write the fasl map into.
;	default: no map is written
;   build:load -- if t then only loading will be done, no fasl'ing
;   build:lisp-type -- may contain a site dependent name to help build
;		a personalized lisp
;   lisp-library-directory -- directory which will contain lisp library
;	this directory will be part of the default search path
;   lisp-object-directory -- directory which contains the lisp object file
;
(or (boundp 'build:dir) (setq build:dir '/usr/lib/lisp))
(or (boundp 'build:map) (setq build:map nil))
(or (boundp 'build:load) (setq build:load nil))
(or (boundp 'build:lisp-type) (setq build:lisp-type 'franz))
(or (boundp 'lisp-library-directory)
   (setq lisp-library-directory '/usr/lib/lisp))
(or (boundp 'lisp-object-directory)
   (setq lisp-object-directory '/usr/ucb))


(def build:load
   (lambda (x)
      (prog (name)
	 (setq name (concat build:dir "/" x))
	 (cond (build:map
		  (fasl-or-load name t build:map)
			; concatentate to map after first file loaded
			(cond ((null (status appendmap))
			       (sstatus appendmap t))))
		     (t (fasl-or-load name nil nil))))))

(def fasl-or-load
   (lambda (name provide-map map-name)
      (prog  (tempname)
      (cond ((and (null build:load)
		  (probef (setq tempname (concat name ".o"))))
	     (cond (provide-map (fasl tempname map-name))
		   (t (fasl name))))
	    ((probef (setq tempname (concat name ".l")))
	     (load tempname))
	    (t (patom "fasl-or-load: Can't find file: ")
	       (patom name)
	       (terpr)
	       (exit 1)  ; just go away fast so user will realize problem
	    )))))
	       
	      
(build:load 'common0)
(build:load 'syntax)
(build:load 'charmac)
(build:load 'macros)
(build:load 'common1)
(build:load 'common2)
(build:load 'common3)
(build:load 'vector)
(build:load 'array)
(build:load 'pp)

; only load format if it is compiled. This will save some time when
; building an interpreted lisp system
(cond ((probef (concat build:dir "/format.o"))
       (build:load 'format)))

(build:load 'version)

(and (not (eq build:lisp-type 'zlisp))
     (build:load 'tpl))

(build:load 'toplevel)

(cond ((eq build:lisp-type 'franz))
      ((eq build:lisp-type 'zlisp)
       (build:load 'zlisp))
      (t (patom "Invalid lisp type: ")
	 (patom build:lisp-type)
	 (terpr)
	 (exit 1)))

; kill definitions
(putd 'fasl-or-load  nil)
(putd 'build:load nil)
(allocate 'hunk3 2)	; make space for format to use
(new-vector 1024)
(new-vectori-long 512)
(gc)






EndOfFile
cat >  lisplib/cmuenv.l  << 'EndOfFile'
(setq rcs-cmuenv-
   "$Header: /usr/lib/lisp/cmuenv.l,v 1.1 83/01/29 18:33:54 jkf Exp $")

(load 'cmumacs)
(load 'cmufncs)
(load 'cmutpl)
(load 'cmufile)
EndOfFile
cat >  lisplib/fixit.ref  << 'EndOfFile'

u / u n / u f / u n f   go up, i.e. more recent (n frames) (of function f)
up / up n		go up to next (nth) non-system function
d / dn			go down, i.e. less recent (opposite of u and up)
ok / go			continue after an error or debug loop
redo / redo f		resume computation from current frame (or at fn f)
step			restart in single-step mode
return e		return from call with value of e (default is nil)
edit			edit the current stack frame
editf / editf f		edit nearest fn on stack (or edit fn f)
top / bot		go to top (bottom) of stack
p / pp			show current stack frame (pretty print)
where			give current stack position
help / h / ?		print this table -- /usr/lisp/doc/fixit.ref
help ...		get the help for ...
pop / ^d		exit one level of debug (reset)

bk / bk n / bk f / bk n f /     backtrace (to nth frame) (of fn f)
..f function names only         ..a include system functions
..v show variable bindings      ..e show expressions in full
..c go no deeper than here      *** combinations are allowed ***

EndOfFile
cat >  lisplib/charmac.l  << 'EndOfFile'
;;
;; charmac.l				-[Sat Jan 29 18:13:40 1983 by jkf]-
;;
;; character macros
;; this contains the definition of the backquote and sharpsign
;; character macros.  [the backquote macro also defines the comma macro]
;;

(setq rcs-charmac-
   "$Header: /usr/lib/lisp/charmac.l,v 1.1 83/01/29 18:33:29 jkf Exp $")


(declare (macros t))

(setq **backquote** 1)

(declare (special **backquote**  Backquote-comma Backquote-comma-at
		  Backquote-comma-dot))

(setq Backquote-comma (gensym)
   Backquote-comma-at (gensym)
   Backquote-comma-dot (gensym))

(def back-quote-ch-macro 
  (lambda nil 
	  (back=quotify  ((lambda (**backquote**) (read)) 
			  (1+ **backquote**)))))

(def back-quote-comma-macro
 (lambda nil
  ((lambda (**backquote**)
	   (cond ((zerop **backquote**)
		  (error "comma not inside a backquote."))
		 ((eq (tyipeek) 64)
		  (tyi)
		  (cons Backquote-comma-at (read)))
		 ((eq (tyipeek) 46)
		  (tyi)
		  (cons Backquote-comma-dot (read)))
		 (t (cons Backquote-comma (read)))))
   (1- **backquote**))))

(def back=quotify 
  (lambda (x)
	  ((lambda (a d aa ad dqp)
		   (cond ((atom x) (list 'quote x))
			 ((eq (car x) Backquote-comma) (cdr x))
			 ((or (atom (car x))
			      (not (or (eq (caar x) Backquote-comma-at)
				       (eq (caar x) Backquote-comma-dot))))
			  (setq a (back=quotify (car x)) d (back=quotify (cdr x))
				ad (atom d) aa (atom a)
				dqp (and (not ad) (eq (car d) 'quote)))
			  (cond ((and dqp (not (atom a)) (eq (car a) 'quote))
				 (list 'quote (cons (cadr a) (cadr d))))
				((and dqp (null (cadr d)))
				 (list 'list a))
				((and (not ad) (eq (car d) 'list))
				 (cons 'list (cons a (cdr d))))
				(t (list 'cons a d))))
			 ((eq (caar x) Backquote-comma-at)
			  (list 'append (cdar x) (back=quotify (cdr x))))
			 ((eq (caar x) Backquote-comma-dot)
			  (list 'nconc (cdar x)(back=quotify (cdr x))))
			 ))
	   nil nil nil nil nil)))


(setsyntax '\` 'macro 'back-quote-ch-macro)
(setsyntax '\, 'macro 'back-quote-comma-macro)


;------- sharpsign macro, used for conditional assembly

;#O <SEXP> or #o <SEXP> reads sexp with ibase bound to 8.
;#+<FEATURE> <SEXP> makes <SEXP> exist if (STATUS FEATURE <FEATURE>) is T
;#-<FEATURE> <SEXP> makes <SEXP> exist if (STATUS FEATURE <FEATURE>) is NIL
;#+(OR F1 F2 ...) <SEXP> makes <SEXP> exist of any one of F1,F2,... are in
;			 the (STATUS FEATURES) list.
;#+(AND F1 F2 ...) works similarly except all must be present in the list.
;#+(NOT <FEATURE>) is the same as #-<FEATURE>.
;#/CHAR returns the numerical character code of CHAR.
;#\SYMBOL gets the numerical character code of non-printing characters.
;#' is to FUNCTION as ' is to QUOTE.
;#.<SEXP> evaluates <SEXP> at read time and leaves the result.
;#,<SEXP> evaluates <SEXP> at load time.  Here it is the same as "#.".
;#t returns t, this means something in NIL, I am not sure what.


(declare (special sharpm-function-names franz-symbolic-character-names))
(setq sharpm-function-names nil)

(def new-sharp-sign-macro
   (lambda ()
      ((lambda (char entry)
	  (cond ((setq entry (assq char sharpm-function-names))
		 (funcall (cdr entry) char))
		(t (error "Unknown character after #:" (ascii char)))))
       (tyi) nil)))

(setsyntax '\# 'splicing 'new-sharp-sign-macro)

;--- defsharp  ::  define a sharp sign handler
; form is (defsharp key arglist body ...)
; where key is a number or a list of numbers (fixnum equivalents of chars)
; arglist is a list of one argument, which will be bound to the fixnum
; representation of the character typed.
; body is the function to be executed when #key is seen.  it should return
; either nil or (list x) where x is what will be spliced in.
;
(def defsharp
   (macro (arg)    ; arg is (defsharp number-or-list arglist function-body)
	  (prog (name)
	     (setq name (concat "Sharpm" (cond ((dtpr (cadr arg)) (caadr arg))
					       (t (cadr arg)))
				(gensym)))
	     (cond ((dtpr (cadr arg))
		    (return `(progn 'compile
				    ,@(mapcar
					 '(lambda (x)
					     (defsharp-expand x name))
					 (cadr arg))
				    (defun ,name ,(caddr arg) ,@(cdddr arg)))))
		   (t (return `(progn 'compile
				      ,(defsharp-expand (cadr arg) name)
				      (defun ,name ,(caddr arg) ,@(cdddr arg)))))))))

(eval-when (compile load eval)
   (defun defsharp-expand (code name)
	  (cond ((symbolp code) (setq code (car (aexploden code)))))
	  `((lambda (current)
	       (cond ((setq current (assq ,code sharpm-function-names))
		      (rplacd current ',name))
		     (t (setq sharpm-function-names
			      (cons '(,code . ,name)
				    sharpm-function-names)))))
	    nil)))


;; standard sharp sign functions:
(declare (special ibase))

(defsharp (o O) (x) ((lambda (ibase) (list (read))) 8.))  ;#o #O
(defsharp (x X) (x) (do ((res 0)			  ;#x #X (hex)
			 (this (tyi) (tyi))
			 (firstch t nil)
			 (factor 1))
			(nil)
			(cond ((not (or (> this 57.)	; #/0 <= this <= #/9
					(< this 48.)))
			       (setq res (+ (* res 16.) (- this 48.))))
			      ((not (or (> this 102.)   ; #/a <= this <= #/f
					(< this  97.)))
			       (setq res (+ (* res 16.) (- this (- 97 10)))))
			      ((not (or (> this 70.)
					(< this 65.)))
			       (setq res (+ (* res 16.) (- this (- 65 10)))))
			      ((and firstch (eq this 43.)))		; #/+
			      ((and firstch (eq this 45.))		; #/-
			       (setq factor (* -1 factor)))
			      (t (untyi this)
				 (return (list (* factor res)))))))
			    
			      

(defsharp + (x) ((lambda (frob)				; #+
		      (cond ((not (feature-present frob)) (read)))
		      nil)
		   (read)))
(defsharp - (x) ((lambda (frob)				; #-
		      (cond ((feature-present frob) (read)))
		      nil)
		   (read)))
(defsharp / (x) (list (tyi)))				;#/  fixum equiv
(defsharp ^ (x) (list (boole 1 31. (tyi))))		;#^  cntrl next char
(defsharp \' (x) (list (list 'function (read))))	;#'  function
(defsharp (\, \.) (x) (list (eval (read))))		;#, or #.
(defsharp \\ (x) ((lambda (frob char)			;#\
		      (setq char
			    (cdr (assq frob franz-symbolic-character-names)))
		      (or char (error '|Illegal character name in #\\| frob))
		      (list char))
		   (read) nil))
(defsharp (t T) (x) (list t))			;#t (for NIL)
(defsharp (M m  Q q  F f) (char)  ;M m Q q F f
   (cond ((not (feature-present
		  (cadr (assoc char '((77. maclisp) (109. maclisp)
				      (81. lispm) (113. lispm)
				      (70. franz) (102. franz))))))
	  (read)))
   nil)
		      

(defun feature-present (feature)
       (cond ((atom feature)
	      (memq feature (status features)))	;damn fsubrs
	     ((eq (car feature) 'not)
	      (not (feature-present (cadr feature))))
	     ((eq (car feature) 'and)
	      (do ((list (cdr feature) (cdr list)))
		  ((null list) t)
		  (cond ((not (feature-present (car list)))
			 (return nil)))))
	     ((eq (car feature) 'or)
	      (do ((list (cdr feature) (cdr list)))
		  ((null list) nil)
		  (cond ((feature-present (car list))
			 (return t)))))
	     (t (error '|Unknown form after #+ or #-| feature))))

(setq franz-symbolic-character-names
      '((eof . -1)  (backspace . 8.)(bs . 8.)
        (tab . 9.) (lf . 10.) (linefeed . 10.)
	(ff . 12.) (form . 12.) (return . 13.) (cr . 13.)
	(newline . 10.) (vt . 11.)
        (esc . 27.) (alt . 27.) 
	(space . 32.) (sp . 32.)
	(dq . 34.)     ; "
	(lpar . 40.) (rpar . 41.)
	(vert . 124.)  ; |
	(rubout . 127.)
	))

EndOfFile
cat >  lisplib/common0.l  << 'EndOfFile'
(setq rcs-common0-
   "$Header: common0.l,v 1.4 83/12/15 11:09:34 jkf Exp $")

;;
;;  common0.l				-[Mon Nov 21 14:06:20 1983 by jkf]-
;;
;;   Functions which are required to execute the low level lisp macros
;; and functions.
;;
;;   This is the first file of functions read in when building a lisp.
;; If this lisp is to run interpretedly, then we must not use anything
;; which hasn't be defined in the C lisp kernel, except ';' which is
;; defined as the comment character before reading this file.
;; We cannot use defmacro, the backquote or the # macro.
;;
;;   This file should be as short as possible since it must be written in
;; a rather primitive way.
;;

;--- declare : ignore whatever is given, this info is for the compiler
;
(def declare (nlambda (x) nil))

(declare (macros t))

;--- memq - arg : (probably a symbol)
;	  - lis : list
; returns part of lis beginning with arg if arg is in lis
;	
(def memq
  (lambda ($a$ $l$)
	  (do ((ll $l$ (cdr ll)))
	      ((null ll) nil)
	      (cond ((eq $a$ (car ll)) (return ll))))))

;--- def :: define a function
; This superceeds franz's definition.
; It does more error checking and it does lambda conversion
;
(def def
   (nlambda (l)
     ((lambda (name argl)
    	(cond ((and (symbolp (setq name (car l)))
		    (dtpr (cadr l))
		    (null (cddr l))
		    (memq (caadr l) '(lambda nlambda lexpr macro glambda)))
	       ; make sure lambda list is nil or a dtpr
	       (setq l (cadr l))  ; l points to (lambda (argl) ...)
	       (cond ((null (setq argl (cadr l))))	; nil check
		     ((dtpr (cadr l))			; dtpr
		      (cond ((and (eq (car l) 'lambda)
				  (or (memq '&aux argl)
				      (memq '&optional argl)
				      (memq '&rest argl)
				      (memq '&body argl)))
			     ; must lambda convert
			     (setq l (lambdacvt (cdr l))))))
		     (t (error "def: bad lambda list of form in " l)))
	       (putd name l)
	       name)
	      (t (error "def: bad form " l))))
      nil nil)))
			     

;--- defun
; maclisp style function defintion
;
(def defun
   (macro (l)
      (prog (name type arglist body specind specnam)
	 (setq name (cadr l) l (cddr l))
	 (cond ((dtpr name)
		(cond ((memq (cadr name) '(macro expr fexpr lexpr))
		       (setq l (cons (cadr name) l)
			     name (car name)))
		      (t (setq specnam (car name)
			       specind (cadr name)
			       name (concat (gensym) "::" specnam))))))
	 (cond ((null (car l)) (setq type 'lambda))
	       ((eq 'fexpr (car l)) (setq type 'nlambda l (cdr l)))
	       ((eq 'expr (car l))  (setq type 'lambda l (cdr l)))
	       ((eq 'macro (car l)) (setq type 'macro l (cdr l)))
	       ((atom (car l))
		(setq type 'lexpr
		      l (nconc (list (list (car l)))
			       (cdr l))))
	       (t (setq type 'lambda)))
	 (setq body (list 'def name (cons type l)))
	 (cond (specnam
		  (return (list 'progn ''compile
				body
				(list 'putprop
				      (list 'quote specnam)
				      (list 'getd
					    (list 'quote name))
				      (list 'quote specind)))))
	       (t (return body))))))


;--- error : print error message and cause an error
;  call is usually (error "string" value)
;
(def error
   ;; form: (error arg1 ...)
   ;; concat all args together, with spaces between them
   ;; and cause an error to be signaled
  (lexpr (n)
	 (do ((i n (1- i))
	      (mesg ""))
	     ((eq i 0) (err-with-message mesg))
	     (setq mesg (concat
			   (cond ((atom (arg i)) (arg i))
				 ((lessp (maknum (arg i)) (maknum nil))
				  ; this tests for the <UNBOUND> value
				  '<UNBOUND>)
				 (t (implode (exploden (arg i)))))
			   " " mesg)))))

(def err
   ;; (err value [junk])
   ;; This is here for maclisp compatibility.  junk should be nil,
   ;; but we don't verify.
   ;; The value is both to be printed and to be returned from the
   ;; errset.  'err-with-message' should be used for new code
   (lexpr (n)
	  (cond ((eq n 0)
		 (err-with-message "call to err"))
		((or (eq n 1) (eq n 2))
		 (err-with-message (arg 1) (arg 1)))
		(t (error "wrong number of args to err:" n)))))


;--- append : append two or more lists
; the result will be a copy of all but the last list
;
(declare (localf append2args))		

(def append
  (lexpr (nargs)
	 (cond ((eq nargs 2) (append2args (arg 1) (arg 2)))
	       ((zerop nargs) nil)
	       (t (do ((i (1- nargs) (1- i))
		       (res (arg nargs)))
		      ((zerop i) res)
		      (setq res (append2args (arg i) res)))))))

;--- append2args : append just two args
; a version of append which only works on 2 arguments
;
(def append2args 
  (lambda (x y)
	  (prog (l l*)
		(cond ((null x) (return y))
		      ((atom x) (error "Non-list to append:" x)))
		(setq l* (setq l (cons (car x) nil)))
	loop	(cond ((atom x) (error "Non-list to append:" x))
		      ((setq x (cdr x))
		       (setq l* (cdr (rplacd l* (cons (car x) nil))))
		       (go loop)))
		(rplacd l* y)
		(return l))))

;--- append1 : add object to end of list
; adds element y to then end of a copy of list x
;
(def append1 (lambda (x y) (append x (list y))))

;--- assoc - x : lispval
;	   - l : list
;	l is a list of lists. The list is examined and the first
;	sublist whose car equals x is returned.
;
(def assoc
  (lambda (val alist)
	  (do ((al alist (cdr al)))
	      ((null al) nil)
	      (cond ((null (car al)))
		    ((not (dtpr (car al)))
		     (error "bad arg to assoc" al))
		    ((equal val (caar al)) (return (car al)))))))

;--- rassq : like assq but look at the cdr instead of the car
;
(def rassq
   (lambda (form list)
      (cond ((null list) nil)
	    ((not (dtpr list))
	     (error "rassq: illegal second argument: " list))
	    (t (do ((ll list (cdr ll)))
		   ((null ll) nil)
		   (cond ((eq form (cdar ll)) (return (car ll)))))))))
;--- concatl - l : list of atoms
;	returns the list of atoms concatentated
;
(def concatl
 (lambda (x) (apply 'concat x)))

;--- length - l : list
;	returns the number of elements in the list.
;
(def length
   (lambda ($l$)
      (cond ((and $l$ (not (dtpr $l$)))
	     (error "length: non list argument: " $l$))
	    (t (cond ((null $l$) 0)
		     (t (do ((ll (cdr $l$)  (cdr ll))
			     (i 1 (1+ i)))
			    ((null ll) i))))))))

;--- memq - arg : (probably a symbol)
;	  - lis : list
; returns part of lis beginning with arg if arg is in lis
;	
(def memq
  (lambda ($a$ $l$)
	  (do ((ll $l$ (cdr ll)))
	      ((null ll) nil)
	      (cond ((eq $a$ (car ll)) (return ll))))))

;--- nconc - x1 x2 ...: lists
;	The cdr of the last cons cell of xi is set to xi+1.  This is the
;	structure modification version of append
;

(def nconc 
  (lexpr (nargs) 
	 (cond ((eq nargs '2) 
		(cond ((null (arg 1)) (arg 2))
		      (t (do ((tmp (arg 1) (cdr tmp)))
			     ((null (cdr tmp)) 
			      (rplacd tmp (arg 2))
			      (arg 1))))))
	       ((zerop nargs) nil)
	       (t (do ((i 1 nxt)
		       (nxt 2 (1+ nxt))
		       (res (cons nil (arg 1)))) 
		      ((eq i nargs) (cdr res))
		      (cond ((arg i) (rplacd (last (arg i)) (arg nxt)))
			    (t (rplacd (last res) (arg nxt)))))))))



(declare (localf nreverse1))	; quick fcn shared by nreverse and nreconc

;--- nreconc :: nreverse and nconc
; (nreconc list elemt) is equiv to (nconc (nreverse list) element)
;
(defun nreconc (list element)
  (cond ((null list) element)
	(t (nreverse1 list element))))

;--- nreverse - l : list
;	reverse the list in place
;

(defun nreverse (x)
  (cond ((null x) x)
	(t (nreverse1 x nil))))


;--- nreverse1
;  common local function to nreconc and nreverse.  [This can just be
; nreconc when I get local global functions allow in the compiler -jkf]
;
(defun nreverse1 (x ele)
  (prog (nxt)
  loop
	(setq nxt (cdr x))
	(rplacd x ele)
	(setq ele x)
	(cond (nxt (setq x nxt) (go loop)))
	(return x)))

;--- liszt-declare :: this is defined in the compiler
; we give it a null definition in the interpreter
;
(def liszt-declare (nlambda (x) nil))
EndOfFile
cat >  lisplib/common1.l  << 'EndOfFile'
(setq rcs-common1-
   "$Header: common1.l,v 1.9 84/01/06 14:21:46 sklower Exp $")

;;
;; common1.l				-[Sun Sep  4 14:04:15 1983 by jkf]-
;;
;;   common lisp functions.  These are the most common lisp functions
;; [which don't have to be defined in common0.l in order to support 
;;  the macros]
;;

(declare (macros t))		;; compile macros in this file

;--- Section 0 - variables
(declare (special Standard-Input Standard-Output Standard-Error
		  lisp-library-directory))

(or (boundp 'lisp-library-directory)
   (setq lisp-library-directory '/usr/lib/lisp))


;--- Section 0 - equivalences
; 
(defmacro make-equivalent (a b)
   `(progn (putd ',a (getd ',b))
	   (putprop ',a (get ',b 'fcn-info) 'fcn-info)))

(make-equivalent abs absval)
(make-equivalent add sum)
(make-equivalent bcdcall funcall)
(make-equivalent chrct charcnt)
(make-equivalent diff difference)
(make-equivalent numbp  numberp)
(make-equivalent remainder mod)
(make-equivalent terpri terpr)
(make-equivalent typep type)
(make-equivalent symeval eval)
(make-equivalent < lessp)
(make-equivalent <& lessp)	; fixnum version
(make-equivalent = equal)
(make-equivalent =& equal) 	; fixnum version
(make-equivalent > greaterp)
(make-equivalent >& greaterp) 	; fixnum version
(make-equivalent *dif difference)
(make-equivalent \\ mod) 
(make-equivalent \1+$ add1)
(make-equivalent \1-$ sub1)
(make-equivalent *$ times)
(make-equivalent /$ quotient)
(make-equivalent +$ add)
(make-equivalent -$ difference)

;--- Section I - functions and macros


;--- max - arg1 arg2 ... : sequence of numbe
;	returns the maximum
;
(def max
  (lexpr (nargs)
	 (do ((i nargs (1- i))
	      (max (arg 1)))
	     ((< i 2) max)
	     (cond ((greaterp (arg i) max) (setq max (arg i)))))))


;--- catch form [tag]  
;  catch is now a macro which translates to (*catch 'tag form)
;
(def catch
  (macro (l)
	 `(*catch ',(caddr l) ,(cadr l))))

;--- throw form [tag]
;  throw isnow a macro
;
(def throw
  (macro (l)
	 `(*throw ',(caddr l) ,(cadr l))))


      
;--- desetq
;	- pattern - pattern containing vrbl names
;	- expr 	  - expression to be evaluated
;
(defmacro desetq (&rest forms &aux newgen destrs)
  (do ((xx forms (cddr xx))
       (res)
       (patt)
       (expr))
      ((null xx) (cond ((null (cdr res)) (car res))
		       (t (cons 'progn (nreverse res)))))
      (setq patt (car xx) expr (cadr xx))
      (setq res 
	    (cons (cond ((atom patt) `(setq ,patt ,expr))	;trivial case
			(t (setq newgen (gensym)
				 destrs (de-compose patt '(r)))
			   `((lambda (,newgen)
				     ,@(mapcar '(lambda (frm)
							`(setq  ,(cdr frm) 
								(,(car frm) ,newgen)))
					       destrs)
				     ,newgen)
			     ,expr)))
		  res))))

;--- sassoc
;	- x : form
;	- y : assoc list
;	- fcn : function or lambda expression
; If (assoc x y) is non nil, then we apply the function fcn to nil.  
; This must be written as a macro if we expect to handle the case of
; a lambda expression as fcn in the compiler.  
;
(defmacro sassoc (x y fcn)
  (cond ((or (atom fcn) (not (eq 'quote (car fcn))))
	 `(or (assoc ,x ,y)
	      (funcall ,fcn)))
	(t `(or (assoc ,x ,y)
		(,(cadr fcn))))))

;--- sassq
;	- x : form
;	- y : assoc list
;	- fcn : function or lambda expression
; like sassoc above except it uses assq instead of assoc.
;
(defmacro sassq (x y fcn)
  (cond ((or (atom fcn) (not (eq 'quote (car fcn))))
	 `(or (assq ,x ,y)
	      (funcall ,fcn)))
	(t `(or (assq ,x ,y)
		(,(cadr fcn))))))

		    

;--- signp - test - unevaluated atom
;	   - value - evaluated value
; test can be l, le, e, n, ge or g   with the obvious meaning
; we return t if value compares to 0 by test

(defmacro signp (tst val)
  (setq tst  (cond ((eq 'l tst)  `(minusp signp-arg))
		   ((eq 'le tst) `(not (greaterp signp-arg 0)))
		   ((eq 'e tst)  `(zerop signp-arg))
		   ((eq 'n tst)  `(not (zerop signp-arg)))
		   ((eq 'ge tst) `(not (minusp signp-arg)))
		   ((eq 'g tst)  `(greaterp signp-arg 0))
		   (t (error "bad arg to signp " tst))))
  (cond ((atom val) `(and (numberp ,val) ,(subst val 'signp-arg tst)))
	(t `((lambda (signp-arg) (and (numberp signp-arg) ,tst))
	     ,val))))



;--- unwind-protect
;  The form of a call to unwind-protect is
;   (unwind-protect pform
;		    form1 form2 ...)
; and it works as follows:
;  pform is evaluated, if nothing unusual happens, form1 form2 etc are
;	then evaluated and unwind-protect returns the value of pform.
;  if while evaluating pform, a throw or error caught by an errset which
;   would cause control to pass through the unwind-protect, then
;   form1 form2 etc are evaluated and then the error or throw continues.
; Thus, no matter what happens, form1, form2 etc will be evaluated.
;
(defmacro unwind-protect (protected &rest conseq &aux (localv (gensym 'G)))
  `((lambda (,localv)
	    (setq ,localv (*catch 'ER%unwind-protect ,protected))
	    ,@conseq
	    (cond ((and (dtpr ,localv) (eq 'ER%unwind-protect (car ,localv)))
		   (I-throw-err (cdr ,localv)))
		  (t ,localv)))
    nil))


;----Section III -- Interrupt handlers 
; 

(def sys:fpeint-serv
   (lambda (x$) (error "Floating Exception ")))

(def sys:int-serv
   (lambda (dummy) (patom '"Interrupt:  ") (drain) (break)))


(signal 8 'sys:fpeint-serv)
(signal 2 'sys:int-serv)


;---- Section IV - interrupt handlers
;
(cond ((null (boundp '$gcprint))
       (setq $gcprint nil)))		; dont print gc stats by default

(cond ((null (boundp '$gccount$))
       (setq $gccount$ 0)))

;--- prtpagesused - [arg] : type of page allocated last time.
;	prints a summary of pages used for certain selected types
;	of pages.  If arg is given we put a star beside that type
;	of page.  This is normally called after a gc.
;
(def prtpagesused
  (lambda (space tottime gctime)
	  (patom "[")
	  (do ((curtypl (cond ((memq space '(list fixnum ))
			       '(list fixnum))
			      (t (cons space '(list fixnum))))
			(cdr curtypl))
	       (temp))
	      ((null curtypl) (print 'ut:)
	       (print (max 0 (quotient (times 100 (difference tottime gctime))
				       tottime)))
	       (patom "%]") (terpr))
	      (setq temp (car curtypl))
	      (cond ((greaterp (cadr (opval temp)) 0)
		     (cond ((eq space temp)
			    (patom '*)))
		     (patom temp)
		     (patom '":")
		     (print (cadr (opval temp)))
		     (patom '"{")
		     (print (fix (quotient 
				  (times 100.0
					 (car (opval temp)))
				  (* (cadr (opval temp))
					 (caddr (opval temp))))))
		     (patom '"%}")
		     (patom '"; "))))))

(declare (special gcafter-panic-mode $gccount$ $gc_midlim $gc_minalloc 
		  $gc_pct $gc_lowlim $gcprint ptimeatlastgc))

(setq gcafter-panic-mode nil)
(setq $gc_minalloc 10)
(setq $gc_lowlim 60)
(setq $gc_midlim 85)
(setq $gc_pct    .10)
(setq ptimeatlastgc (ptime))

;--- gcafter - [s] : type of item which ran out forcing garbage collection.
;	This is called after each gc.
; the form of an opval element is  (number_of_items_in_use
;				    number_of_pages_allocated
;				    number_of_items_per_page)
;
;
(def gcafter 
  (nlambda (s)
	   (prog (x pct amt-to-allocate thisptime diffptime difftottime
		    diffgctime)
		 (cond ((null s) (return)))  
		 (cond ((null (boundp '$gccount$)) (setq $gccount$ 0)))
		 (setq $gccount$ (1+ $gccount$))
		 (setq x (opval (car s)))
		 (setq thisptime (ptime)
		       difftottime (max  (difference (car thisptime)
						     (car ptimeatlastgc))
					 1)
		       diffgctime (difference (cadr thisptime)
					      (cadr ptimeatlastgc))
		       ptimeatlastgc thisptime)
		 ; pct is the percentage of space used
		 (setq pct (quotient (times 100 (car x))
				     (max 1 (times (cadr x) (caddr x)))))
		 (setq amt-to-allocate
		       (cond (gcafter-panic-mode 
			      (cond ((greaterp pct 95) 
				     (patom "[Storage space totally exhausted]")
				     (terpr)
				     (error "Space exhausted when allocating "
					    (car s)))
				    (t 0)))
			     ((greaterp pct $gc_midlim)
			      (max $gc_minalloc (fix (times $gc_pct (cadr x)))))
			     ((greaterp pct $gc_lowlim)
			      $gc_minalloc)
			     ((lessp (cadr x) 100)
			      $gc_minalloc)
			     (t 0)))
		 (cond ((and (null gcafter-panic-mode) (greaterp amt-to-allocate
								 0))
			(cond ((atom (errset (allocate (car s) amt-to-allocate)))
			       (cond ($gcprint 
					(patom "[Now in storage allocation panic mode]")
					(terpr)))
			       (setq gcafter-panic-mode t)))))

		 (cond ($gcprint (prtpagesused (car s) difftottime diffgctime)
				 (comment (cond ((and (getd 'gcstat)
					     (eq $gcprint '$all))
					(print (gcstat))
					(terpr)))))))))

;----Section V - the functions
; 


;--- bigp - x : lispval
;	returns t if x is a bignum
;
(def bigp (lambda (arg) (equal (type arg) 'bignum)))

;--- comment - any
; 	ignores the rest of the things in the list
(def comment
  (nlambda (x) 'comment))


;--- copy - l : list (will work if atom but will have no effect)
;	makes a copy of the list.
; will also copy vector and vectori's, if their property list
; doesn't have the 'unique' flag
;
(def copy
   (lambda (l)
      (cond ((dtpr l) (cons (copy (car l)) (copy (cdr l))))
	    ((vectorp l)
	     (if (vget l 'unique)
		then l
		else (let ((size (vsize l)))
			(do ((newv (new-vector size))
			     (i 0 (1+ i)))
			    ((not (<& i size))
			     (vsetprop newv (copy (vprop l)))
			     newv)
			    (vset newv i (copy (vref l i)))))))
	    ((vectorip l)
	     (if (vget l 'unique)
		then l
		else (let ((size (vsize-byte l)))
			(do ((newv (new-vectori-byte size))
			     (i 0 (1+ i)))
			    ((not (<& i size))
			     (vsetprop newv (copy (vprop l)))
			     newv)
			    (vseti-byte newv i (vrefi-byte l i))))))
	    (t l))))


;--- copysymbol - sym : symbol to copy
;		- flag : t or nil
;  generates an uninterned symbol with the same name as sym.  If flag is t
; then the value, function binding and property list of sym are placed
; in the uninterned symbol.
;
(def copysymbol 
  (lambda (sym flag)
	  ((lambda (newsym)
		   (cond (flag (cond ((boundp sym) (set newsym (eval sym))))
			       (putd newsym (getd sym))
			       (setplist newsym (plist sym))))

		   newsym)
	   (uconcat sym))))


;--- cvttointlisp -- convert reader syntax to conform to interlisp
;
(def cvttointlisp
  (lambda nil
	  (setsyntax '\% 'vescape)		; escape character
	  (setsyntax '\\ 'vcharacter)		; normal character
	  (setsyntax '\` 'vcharacter)		; normal character
	  (setsyntax '\, 'vcharacter)		; normal character
	  (sstatus uctolc t)			; one case
	  ))


;--- cvttomaclisp - converts the readtable to a maclisp character syntax
;
(def cvttomaclisp
  (lambda nil
	  (setsyntax '\/ 'vescape)		; escape
	  (setsyntax '\\ 'vcharacter)		; normal char
	  (setsyntax '\[ 'vcharacter)		; normal char
	  (setsyntax '\] 'vcharacter)		; normal char
	  (sstatus uctolc t)))

(declare (special readtable))
;--- cvttoucilisp - converts the readtable to a ucilisp character syntax
;
(def cvttoucilisp
  (lambda nil
	  (sstatus uctolc t)		; upper case to lower case
  					; change backquote character.
					; to ` and ! and !@ from ` , and ,@
  					; undo comma.
	(setsyntax '\! 'splicing (get '\, readtable))
	(setsyntax '\, 'vcharacter)
	  	; 
  		; ~ as comment character, not ; and / instead of \ for escape
  	(setsyntax '\~ 'splicing 'zapline)
	(setsyntax '\; 'vcharacter)
	(setsyntax '\/ 'vescape)
	(setsyntax '\\   'vcharacter)))


;--- cvttofranzlisp - converts the readtable to the standard franz readtable
; this just does the obvious conversions, assuming that the user was
; in the maclisp syntax before.
(def cvttofranzlisp
   (lambda nil
      (setsyntax '\/ 'vcharacter)
      (setsyntax '\\ 'vescape)
      (setsyntax '\[ 'vleft-bracket)
      (setsyntax '\] 'vright-bracket)
      (sstatus uctolc nil)))

;--- defprop - like putprop except args are not evaled
;
(def defprop 
    (nlambda (argl)
	(putprop (car argl) (cadr argl) (caddr argl) )))

;--- delete
;	- val - lispval
;	- lst - list
;	- n   - Optional arg, number of occurances to delete
; removes up to n occurances of val from the top level of lst.
; if n is not given, all occurances will be removed.
;
(def delete
  (lexpr (nargs)
	 (prog (val lst cur ret nmb)
	       (cond ((= nargs 2)
		      (setq nmb -1))
		     ((= nargs 3) 
		      (setq nmb (arg 3)))
		     (t (error " wrong number of args to delete "
			       (cons 'delete (listify nargs)))))
	       (setq val (arg 1) lst (arg 2))
	       (cond ((and (atom lst) (not (null lst))) 	
		      (error " non-list arg to delete " 
			       (cons 'delete (listify nargs)))))
	       (setq cur (cons nil lst)
		     ret cur)
	   loop
	       (cond ((or (atom lst) (zerop nmb))
		      (return (cdr ret)))
		     ((equal val (car lst))
		      (rplacd cur (cdr lst))
		      (setq nmb (1- nmb)))
		     (t (setq cur (cdr cur))))
	       (setq lst (cdr lst))
	       (go loop))))

;--- delq 
;  same as delete except eq is used for testing.
;
(def delq
  (lexpr (nargs)
	 (prog (val lst cur ret nmb)
	       (cond ((= nargs 2)
		      (setq nmb -1))
		     ((= nargs 3) 
		      (setq nmb (arg 3)))
		     (t (error " wrong number of args to delq "
			       (cons 'delq (listify nargs)))))
	       (setq val (arg 1) lst (arg 2))
	       (cond ((and (atom lst) (not (null lst))) 	
		      (error " non-list arg to delq " 
			       (cons 'delq (listify nargs)))))
	       (setq cur (cons nil lst)
		     ret cur)
	   loop
	       (cond ((or (atom lst) (zerop nmb))
		      (return (cdr ret)))
		     ((eq val (car lst))
		      (rplacd cur (cdr lst))
		      (setq nmb (1- nmb)))
		     (t (setq cur (cdr cur))))
	       (setq lst (cdr lst))
	       (go loop))))

;--- evenp : num   -  return 
;
;
(def evenp
  (lambda (n)
	  (cond ((not (zerop (boole 4 1 n))) t))))

;--- ex [name] : unevaluated name of file to edit.
;	the ex editor is forked to edit the given file, if no
;	name is given the previous name is used
;
(def ex (nlambda (x) (exvi 'ex x nil)))

(declare (special edit_file))

(def exvi 
  (lambda (cmd x doload) 
	   (prog (handy handyport bigname)
		 (cond ((null x) (setq x (list edit_file)))
		       (t (setq edit_file (car x))))		 
		 (setq bigname (concat (car x) ".l"))
		 (cond ((setq handyport (car (errset (infile bigname) nil)))
			(close handyport)
			(setq handy bigname))
		       (t (setq handy (car x))))
		 (setq handy (concat cmd " '+set lisp' " handy))
		 (setq handy (list 'process handy))
		 (eval handy)
		 (cond (doload (load edit_file))))))

;--- exec - arg1 [arg2 [arg3 ...] ] unevaluated atoms
;	A string of all the args concatenated together seperated by 
;	blanks is forked as a process.
;
(def exec
 (nlambda (list)
     (do ((xx list (cdr xx))
	  (res "" (concat res " " (car xx))))
	 ((null xx) (*process res)))))

;--- exl - [name] : unevaluated name of file to edit and load.
;	If name is not given the last file edited will be used.
;	After the file is edited it will be `load'ed into lisp.
;
(def exl (nlambda (x) (exvi 'ex x t)))

;----- explode functions -------
; These functions, explode , explodec and exploden, implement the 
; maclisp explode functions completely.
; They have a similar structure and are written with efficiency, not
; beauty in mind (and as a result they are quite ugly)
; The basic idea in all of them is to keep a pointer to the last
; thing added to the list, and rplacd the last cons cell of it each time.
;
;--- explode - arg : lispval
;	explode returns a list of characters which print would use to
; print out arg.  Slashification is included.
;
(def explode
  (lambda (arg)
	  (cond ((atom arg) (aexplode arg))
		((vectorp arg)
		 (aexplode (concat "vector[" (vsize arg) "]")))
		((vectorip arg)
		 (aexplode (concat "vectori[" (vsize-byte arg) "]")))
		(t (do ((ll (cdr arg) (cdr ll))
			(sofar (setq arg (cons '|(| (explode (car arg)))))
			(xx))
		       ((cond ((null ll) (rplacd (last sofar) (ncons '|)| )) 
			       t)
			      ((atom ll) (rplacd (last sofar)
						 `(| | |.| | | ,@(explode ll) 
						     ,@(ncons '|)|)))
			       t))
			arg)
		       (setq xx (last sofar)
			     sofar (cons '| | (explode (car ll))))
		       (rplacd xx sofar))))))

;--- explodec - arg : lispval
; returns the list of character which would be use to print arg assuming that
; patom were used to print all atoms.
; that is, no slashification would be used.
;
(def explodec
  (lambda (arg)
	  (cond ((atom arg) (aexplodec arg))
		((vectorp arg)
		 (aexplodec (concat "vector[" (vsize arg) "]")))
		((vectorip arg)
		 (aexplodec (concat "vectori[" (vsize-byte arg) "]")))
		(t (do ((ll (cdr arg) (cdr ll))
			(sofar (setq arg (cons '|(| (explodec (car arg)))))
			(xx))
		       ((cond ((null ll) (rplacd (last sofar) (ncons '|)| )) 
			       t)
			      ((atom ll) (rplacd (last sofar)
						 `(| | |.| | | ,@(explodec ll) 
						     ,@(ncons '|)|)))
			       t))
			arg)
		       (setq xx (last sofar)
			     sofar (cons '| | (explodec (car ll))))
		       (rplacd xx sofar))))))

;--- exploden - arg : lispval
;	returns a list just like explodec, except we return fixnums instead
; of characters.
;
(def exploden
  (lambda (arg)
	  (cond ((atom arg) (aexploden arg))
		((vectorp arg)
		 (aexploden (concat "vector[" (vsize arg) "]")))
		((vectorip arg)
		 (aexploden (concat "vectori[" (vsize-byte arg) "]")))
		(t (do ((ll (cdr arg) (cdr ll))
			(sofar (setq arg (cons 40. (exploden (car arg)))))
			(xx))
		       ((cond ((null ll) (rplacd (last sofar) (ncons 41.)) 
			       t)
			      ((atom ll) (rplacd (last sofar)
						 `(32. 46. 32. ,@(exploden ll) 
						     ,@(ncons 41.)))
			       t))
			arg)
		       (setq xx (last sofar)
			     sofar (cons 32. (exploden (car ll))))
		       (rplacd xx sofar))))))

;-- expt  - x
;	  - y
;
;	   y
; returns x
;
(defun expt (x y)
  (cond ((equal x 1) x)
	((zerop x) x)   ; Maclisp does this 
	((lessp y 0) (quotient 1.0 (expt x (times -1 y))))
	((floatp y) 
	 (exp (times y (log x)))) ; bomb out for (-3)^4 or (-3)^4.0 or 0^y.
	((bigp y)
	 (error "expt: Can't compute number to a bignum power" y))
	(t ; y is integer, y>= 0
	   (prog (res)
		 (setq res 1)
		 loop
		 (cond ((equal y 0) (return res))
		       ((oddp y)(setq res (times  res x) y (1- y)))
		       (t (setq x (times x x) y (/ y 2))))
		 (go loop)))))



;--- ffasl :: fasl in a fortran file
;  arg #
;   1	- fnam : file name
;   2	- entry : entry point name
;   3	- fcn  : entry name
;   4   - disc : optional discipline
;   5   - lib  ; optional library specifier
;
(defun ffasl (fnam entry fcn &optional (disc 'subroutine) (lib " "))
  (cfasl fnam entry fcn disc (concat lib " -lI77 -lF77 -lm")))


;
; filepos function (maclisp compatibility)
;
(defun filepos n
  (cond ((zerop n) nil)
	((onep n)
	 (fseek (arg 1) 0 1))
	((equal n 2)
	 (fseek (arg 1) (arg 2) 0))))

;--- fixp - l : lispval
;	returns t if l is a fixnum or bignum
;
(defun fixp (x) (or (equal (type x) 'fixnum)
		    (equal (type x) 'bignum)))



;--- flatsize - l : lispval
;	     the second arg should be:
;	      - n : limit for what we care about
;	     but we dont care about this at present, since we have
;	     to explode the whole thing anyway.
;	returns the number of characters which print would
;	use to print l
;
(defun flatsize n
  (length (explode (arg 1))))


;--- floatp - l : lispval
;	returns t if l is a flonum
;
(defun floatp (x) (equal 'flonum (type x)))


;--- getchar,getcharn   - x : atom
;	     		- n : fixnum
; returns the n'th character of x's pname (the first corresponds to n=1)
; if n is negative then it counts from the end of the pname
; if n is out of bounds, nil is returned

(def getchar
  (lambda (x n)
	  (concat (substring x n 1))))


(def getcharn
  (lambda (x n)
	  (substringn x n 0)))


(def getl 
  (lambda (atm lis)
	  (do ((ll (cond ((atom atm) (plist atm))
			 (t (cdr atm)))
		   (cddr ll)))
	      ((null ll) nil)
	      (cond ((memq (car ll) lis) (return ll))))))


;--- help
; retrive selected portions of the Franz Lisp manual.
; There are four types of help offered:
; (help) prints a description of the other three options
; (help tc) prints a table of contents.
; (help n) {where n is a number or b or c} prints the whole chapter.
; (help fcn) prints info on function fcn
;
; An index to the functions is kept in the documentation directory.
; The index has entries like (append ch2.r).  
; When asked to print info on a function, it locates the chapter
; using the index then asks more to locate the definition.
;
(declare (localf locatefunction))

(defun help fexpr (lis)
  (cond ((null lis) 
 (patom "type (help fnc) for info on function fnc")(terpr)
 (patom "type (help n) to see chapter n")(terpr)
 (patom "type (help tc) for a table of contents")(terpr))
	(t (do ((ll lis (cdr ll))
		(fcn))
	       ((null ll))
	       (cond ((not (atom (setq fcn (car ll))))
		      (patom "Bad option to help ")(print fcn)(terpr))
		     ((and (stringp fcn) (setq fcn (concat fcn)) nil))
		     ((eq fcn 'tc)
		      (patom "Table of contents")(terpr)
 (patom "1 - intro; 2 - data structure; 3 - arithmetic; 4 - special")(terpr)
 (patom "5 - i/o; 6 - system; 7 - reader; 8 - functions; 9 - arrays")(terpr)
 (patom "10 - exceptions; 11 - trace package; 12 - Liszt;")(terpr)
 (patom "14 - step package; 15 - fixit package") (terpr)
 (patom "b - special symbols; c - gc & debugging & top level ")(terpr))
		     ((or (and (numberp fcn) (lessp fcn 16) (greaterp fcn -1))
			  (memq fcn '(b c)))
		      (apply 'process 
			 (ncons (concat "/usr/ucb/ul "
					lisp-library-directory
					"/manual/ch"
				       fcn ".r | /usr/ucb/more -f" ))))
		     ((locatefunction fcn))
		     (t (patom "Unknown function: ")(print fcn)(terpr)))))))

(declare (special readtable))

(defun locatefunction (fc)
  (let (x inf )
       (cond ((null (get 'append 'helplocation)) 
	      (patom "[Reading help index]")(drain)
	      (setq inf (infile (concat lisp-library-directory
					"/manual/helpindex")))
	      (do ((readtable (makereadtable t))
		   (x (read inf) (read inf)))
		  ((null x) (close inf) (terpr))
		  (cond ((null (cddr x))
			 (putprop (car x) (cadr x) 'helplocation))
			(t (putprop (concat (car x) " " (cadr x))
				    (caddr x)
				    'helplocation))))))
       (cond ((setq x (get fc 'helplocation))
	      (apply 'process (ncons (concat "/usr/ucb/ul "
					     lisp-library-directory
					     "/manual/"
					     x 
					     " | /usr/ucb/more -f \"+/(" 
					     fc 
					     "\"")))
	      t))))

;
; (hunk 'g_arg1 [...'g_argn])
;
; This function makes a hunk. The hunk is preinitialized to the
; arguments present. The size of the hunk is determined by the
; number of arguments present.
;

(defun hunk n
  (prog (size)
	(setq size -1)
	(cond ((> n 128) (error "hunk: size is too big" n))
	      ((eq n 1) (setq size 0))
	      ((eq n 0) (return nil))	; hunk of zero length
	      (t (setq size (1- (haulong (1- n))))))
	(setq size (*makhunk size))
	(do
	 ((argnum 0 (1+ argnum)))
	 ((eq argnum n))
	 (*rplacx argnum size (arg (1+ argnum))))
	(return size)))


;--- last - l : list
;	returns the last cons cell of the list, NOT the last element
;
(def last 
  (lambda (a)
	  (do ((ll a (cdr ll)))
	      ((null (cdr ll))  ll))))

;---- load 
; load will either load (read-eval)  or fasl in the file.
; it is affected by these global flags
;  tilde-expansion :: expand filenames preceeded by ~ just like
;	csh does (we do the expansion here so each i/o function we call
;	doesn't have to do it).
;  load-most-recent :: if there is a choice between a .o and a .l file,
;	load the youngest one
;
(declare (localf load-a-file))
(declare (special gcdisable load-most-recent tilde-expansion))

(or (boundp 'load-most-recent) (setq load-most-recent nil))
(or (boundp 'tilde-expansion) (setq tilde-expansion t))

(defun load (filename &rest fasl-args)
  (cond ((not (or (symbolp filename) (stringp filename))) 
	 (error "load: illegal filename " filename)))
  (let ( load-only fasl-only no-ext len search-path name pred shortname explf
	 faslfile loadfile)

       
       (cond (tilde-expansion (setq filename (tilde-expand filename))))
		
       ; determine the length of the filename, ignoring the possible
       ; list of directories.  set explf to the reversed exploded filename
       (setq len (do ((xx (setq explf (nreverse (exploden filename))) (cdr xx))
		      (i 0 (1+ i)))
		     ((null xx) i)
		     (cond ((eq #// (car xx)) (return i)))))

       (cond ((> len 2)
	      (cond ((eq (cadr explf) #/.)
		     (cond ((eq (car explf) #/o)
			    (setq fasl-only t))
			   ((eq (car explf) #/l)
			    (setq load-only t))
			   (t (setq no-ext t))))
		    (t (setq no-ext t))))
	     (t (setq no-ext t)))

       ; a short name is less or equal 12 characters.  If a name is not
       ; short, then load will not try to append .l or .o
       (cond ((or (< len 13) (status feature long-filenames))
	      (setq shortname t)))

       (cond ((and (> len 0) (eq (getchar filename 1) '/))
	      (setq search-path '(||)))
	     (t (setq search-path (status load-search-path))))
       (do ((xx search-path (cdr xx)))
	   ((null xx) (error "load: file not found " filename))
	   (setq pred (cond ((memq (car xx) '(|| |.|)) '||)
			    (t (concat (car xx) "/"))))
	   (cond (no-ext
		  (cond ((and shortname
			      load-most-recent
			      (probef
				 (setq faslfile (concat pred filename ".o")))
			      (probef
				 (setq loadfile (concat pred filename ".l"))))
			 ; both an object and a source file exist.
			 ; load the last modified one (fasl wins in ties)
			 (let ((faslstat (filestat faslfile))
			       (loadstat (filestat loadfile)))
			    (cond ((< (filestat:mtime faslstat)
				      (filestat:mtime loadstat))
				   (return (load-a-file loadfile)))
				  (t (return
					(fasl-a-file faslfile
						     (car fasl-args)
						     (cadr fasl-args)))))))
			((and shortname
			      (probef (setq name
					    (concat pred filename ".o"))))
			 (return (fasl-a-file name (car fasl-args)
					      (cadr fasl-args))))
			((and shortname
			      (probef (setq name
					    (concat pred filename ".l"))))
			 (return (load-a-file name)))
			((probef (setq name (concat pred filename)))
			 (cond (fasl-args (return
					     (fasl-a-file name
							  (car fasl-args)
							  (cadr fasl-args))))
			       (t (return (load-a-file name)))))))
		 (fasl-only
		  (cond ((probef (setq name (concat  pred  filename)))
			 (return (fasl-a-file name (car fasl-args)
					      (cadr fasl-args))))))
		 (load-only
		  (cond ((probef (setq name (concat pred filename)))
			 (return (load-a-file name)))))))))

;--- tilde-expand :: given a ~filename, expand it
;
(defun tilde-expand (name)
   (cond ((or (symbolp name) (stringp name))
	  (cond ((eq (getcharn name 1) #/~)
		 (let ((form (exploden name)))
		    (do ((xx (cdr form) (cdr xx))
			 (res)
			 (val))
			((or (null xx) (eq (car xx) #//))
			 ;; if this is the current user, just get value
			 ;; from environment variable HOME
			 (cond ((or (null res)
				    (equal (setq res (implode (nreverse res)))
					   (getenv 'USER)))
				(setq val (getenv 'HOME)))
			       (t (setq val (username-to-dir res))))
			 (cond ((null val)
				(error "tilde-expand: unknown user " res))
			       (t (concat val (implode xx)))))
			(setq res (cons (car xx) res)))))
		(t name)))
	 (t (error "tilde-expand: illegal argument " name))))

      

;--- fasl-a-file
; The arguments are just like those to fasl.  This fasl's a file
; and if the translink's are set, it does the minimum work necessary to rebind
; the links (so that the new functions just fasl'ed in will be used).
; 
(defun fasl-a-file (name map warnflag)
   (let ((translinkarg (status translink)))
      (prog1
	 (fasl name map warnflag)
	 (cond ((and translinkarg (setq translinkarg (status translink)))
		; if translink was set before and is still set
		(cond ((eq translinkarg t)
		       (sstatus translink nil)  ; clear all links
		       (sstatus translink t))	; set to make links
		      (t ; must be 'on'
			 (sstatus translink on) ; recompute all links
			 ))))))) 

(declare (special $ldprint))	; print message before loading
(declare (special prinlevel prinlength))

(defun load-a-file (fname)
   (cond ($ldprint (patom "[load ")(patom fname)(patom "]")(terpr)))
   (let ((translinkarg (status translink)))
      (prog1
	 (let ((Piport (infile fname))
	       ; (gcdisable t)	; too dangerous: removed for now
	       ; don't gc when loading, it slows things down
	       (eof (list nil)))
	    (do ((form (errset (read Piport eof)) (errset (read Piport eof)))
		 (lastform "<no form read successfully>"))
		((eq eof (car form)) (close Piport) t)
		(cond ((null form)
		       (error "load aborted due to read error after form "
			      lastform))
		      (t (setq lastform (car form))
			 (eval (car form))))))
	 (cond ((and translinkarg (setq translinkarg (status translink)))
		; if translink was set before and is still set
		(cond ((eq translinkarg t)
		       (sstatus translink nil)  ; clear all links
		       (sstatus translink t))	; set to make links
		      (t ; must be 'on'
			 (sstatus translink on) ; recompute all links
			 )))))))

(funcall 'sstatus (list 'load-search-path (list '|.| lisp-library-directory)))
;--- include - read in the file name given, the name not evaluated
;
(def include (nlambda (l) (load (car l))))

;--- includef - read in the file name given and eval the first arg
;
(def includef (lambda (l) (load l)))


;--- list-to-bignum
;  convert a list of fixnums to a bignum.
; there is a function bignum-to-list but it is written in C
;
;(author: kls)
;
(def list-to-bignum
 (lambda (x) (cond (x (scons (car x) (list-to-bignum (cdr x))))
		   (t nil))))



;--- macroexpand - form 
;	expands out all macros it can
;
(def macroexpand
  (lambda (form)
    (prog nil
  top (cond ((atom form) (return form))
	    ((atom (car form))
	     (return
	      (let ((nam (car form)) def disc)
		   (setq def (getd nam))
		   (setq disc (cond ((bcdp def) (getdisc def))
				    ((arrayp def) 'array)
				    ((dtpr def) (car def))))
		   (cond ((and (null def)
			       (get nam 'macro-autoload))
			  (setq disc 'macro)))
		   (cond ((memq disc '(array lambda lexpr nil))
			  (cons nam (mapcar 'macroexpand (cdr form))))
			 ((eq disc 'macro)
			  (setq form (apply nam form))
			  (go top))
			 ((eq nam 'prog)
			  (cons nam
				(cons (cadr form)
				      (mapcar 'macroexpand (cddr form)))))
			 (t form)))))
	    (t (return (cons (macroexpand (car form))
			     (mapcar 'macroexpand (cdr form)))))))))




;
; (makhunk 'n)
;
; This function is similar to hunk, except that:
;
; n can be a fixnum, which specifies the length of the hunk.
;	The hunk is preinitialized to nil's
; n can be a list which is used to preinitialize the hunk.
;
(defun makhunk (n)
  (prog (size Hunk)
	(setq size -1)
	(cond ((numberp n)
;
; If n is a number then build a nil hunk of the right size
;
	       (cond ((greaterp n 128) (error "makhunk: size is too big" n))
		     ((= n 1) (setq size 0))
		     (t (setq size (1- (haulong (1- n))))))
	       (cond ((minusp size) (return nil)))
	       (setq Hunk (*makhunk size))
	       (do ((i 0 (1+ i)))
		   ((=& i n))
		   (*rplacx i Hunk nil))
	       (return Hunk))
;
; If it isn't a number, then try hunk on it
;
	      (t (return (apply 'hunk n))))))

;--- member - VAL : lispval
;	    - LIS : list
;	returns that portion of LIS beginning with the first occurance
;	of VAL  if  VAL is found at the top level of list LIS.
;	uses equal for comparisons.
;
(def member 
  (lambda ($a$ $l$)
	  (do ((ll $l$ (cdr ll)))
	      ((null ll) nil)
	      (cond ((equal $a$ (car ll)) (return ll))))))

;--- memq - arg : (probably a symbol)
;	  - lis : list
; returns part of lis beginning with arg if arg is in lis
;	
; [ defintion moved to top of file to allow backquote macro to work ]

;--- min - arg1 ... numbers 
;
; 	returns minimum of n numbers. 
;

(def min
  (lexpr (nargs)
	 (do ((i nargs (1- i))
	      (min (arg 1)))
	     ((lessp i 2) min)
	     (cond ((lessp (arg i) min) (setq min (arg i)))))))


;
(def oddp
  (lambda (n)
	  (cond ((not (zerop (boole 1 1 n))) t))))

;--- plusp : x - number
; returns t iff x is greater than zero

(def plusp
  (lambda (x)
	  (greaterp x 0)))


;--- princ : l - any s-expression
;	    [p] - port to write to
; prints using patom for atoms (unslashified)
;
(def princ
  (lexpr (n)
	 (prog (port val)
	       (cond ((eq n 2) (setq port (arg 2))))
	       (cond ((dtpr (setq val (arg 1)))
		      (cond ((and (eq 'quote (car val))
				  (dtpr (cdr val))
				  (null (cddr val)))
			     (patom "'" port)
			     (princ (cadr val) port))
			    (t 
			     (patom "(" port)
			     (do ((xx val))
				 ((null xx) (patom ")" port))
				 (princ (car xx) port)
				 (cond ((null (setq xx (cdr xx))))
				       ((not (dtpr xx))
					(patom " . " port)
					(princ xx port)
					(setq xx nil))
				       (t (patom " " port)))))))
		     (t (patom val port)))
	       (return t))))

;--- prog1 : return the first value computed in a list of forms
;
(def prog1
  (lexpr (n)
	 (arg 1)))

;--- reverse : l - list
;	returns the list reversed using cons to create new list cells.
;
(def reverse 
  (lambda (x)
	  (cond ((null x) nil)
		(t (do ((cur (cons (car x) nil) 
			     (cons (car res) cur))
			(res (cdr x) (cdr res)))
		       ((null res) cur))))))


;--- shell - invoke a new c shell
;
(def shell 
  (lambda nil 
	  ((lambda (shellname)
		   (cond ((lessp (flatc shellname) 1) (setq shellname 'csh)))
		   (apply 'process (ncons shellname)))
	   (getenv 'SHELL))))



; S L O A D  stuff
;
(defvar $sldprint t)
(declare (special sload-print))
(setq sload-print nil)

(defmacro sl-print (&rest args)
   `(cond ((and sload-print
		(getd sload-print))
	   (funcall sload-print . ,args))
	  (t (print . ,args))))

;--- sload : fn - file name (must include the .l)
;	loads in the file printing each result as it is seen
;
(defun sload (&rest files)
   (mapc '(lambda (fn)
	     (prog (por eof argnum result)
		(cond ((setq por (infile fn))
		       (and $sldprint
			    (progn (princ "[sload ")
				   (princ fn)
				   (princ "]")
				   (terpr))))
		      (t (patom "bad file name: ")
			 (patom fn)
			 (terpr)
			 (return nil)))
		(setq eof (gensym))
		(do ((input (read por eof) (read por eof)))
		    ((eq eof input) (close por))
		    (and $sldprint
			 (cond ((and (dtpr input)
				     (setq argnum
					   (get (car input) 'sloadprintarg)))
				(print (nth argnum input)))
			       (t (print input))))
		    (setq result (eval input))
		    (and (eq 'value $sldprint)
			 (progn (princ ": ")
				(sl-print result)))
		    (and $sldprint
			 (terpr)))
		(return t)))
	 files))

(defprop def 1 sloadprintarg)
(defprop defun 1 sloadprintarg)

(defprop setq 1 sloadprintarg)
(defprop declare 1 sloadprintarg)





;---- bubble merge sort 
; it recursively splits the list to sort until the list is small.  At that
; point it uses a bubble sort.  Finally the sorted lists are merged.

(declare (special sort-function))

;--- sort :: sort a lisp list
; args: lst - list of items
;       fcn - function to compare two items.
; returns: the list with such that for each pair of adjacent elements,
;	   either the elements are equal, or fcn applied to the two 
; 	   args returns a non nil value.
;
(defun sort (lst fcn)
  (setq sort-function (cond (fcn)   ; store function name in global cell
			    (t 'alphalessp)))
  ; (setq sort-compares 0)		; count number of comparisons
  (sortmerge lst (length lst)))


;--- sortmerge :: utility routine to sort
; args: lst - list of items to sort
;	nitems - a rough idea of how many items are in the list
;
; result - sorted list (see the result of sort above)
;
(defun sortmerge (lst nitems)
  (prog (tmp tmp2)
	(cond ((greaterp nitems 7)
	       ; do a split and merge
	       (setq tmp (splitlist lst (setq tmp2 (quotient nitems 2))))
	       (return (mergelists (sortmerge (car tmp) tmp2)
			      (sortmerge (cdr tmp) tmp2))))
	      (t ; do a bubble sort
		 (do ((l lst (cdr l))
		      (fin))
		     ((null l))
		     (do ((ll lst (cdr ll)))
			 ((eq fin (cdr ll)) (setq fin ll))
			 ;(setq sort-compares (1+ sort-compares))
			 (cond ((not (funcall sort-function (car ll) (cadr ll)))
				(rplaca ll (prog1 (cadr ll)
						 (rplaca (cdr ll)
							 (car ll))))))))
		 (return lst)))))

;--- splitlist :: utility routine to split a list
; args : lst - list to split
;        spliton - number of items to put in the first list
;
; returns: a cons cell whose car is the first part of the list
;	   and whose cdr is the second part.
;
(defun splitlist (lst spliton)
  (prog (second)
	(do ((i spliton (sub1 i))
	     (l lst))
	    ((or (null (cdr l)) (zerop i))
	     (setq second (cdr l))
	     (rplacd l nil))
	    (setq l (cdr l)))
	(return (cons lst second))))


;--- mergelists ::utility routine to merge two lists based on predicate function
; args: ls1 - lisp list
; 	ls2 - lisp list
;	sort-function (global) - compares items of the lists
;
; returns: a sorted list containing the elements of the two lists.
; 
(defun mergelists  (ls1 ls2)
  (prog (result current)
	; initialize
	(setq current (setq result (cons nil nil)))
loop	(cond ((null ls1)
	       (rplacd current ls2)
	       (return (cdr result)))
	      ((null ls2)
	       (rplacd current ls1)
	       (return (cdr result)))
	      ((funcall sort-function (car ls1) (car ls2))
	       ;(setq sort-compares (1+ sort-compares))
	       (rplacd current ls1)
	       (setq current ls1
		     ls1 (cdr ls1)))
	      (t ;(setq sort-compares (1+ sort-compares))
		 (rplacd current ls2)
		 (setq current ls2
		       ls2 (cdr ls2))))
	(go loop)))

;--- end bubble merge sort
(declare (localf exchange2))

(defun sortcar (a fun)
   (prog (n)
       (if (null fun) then (setq fun 'alphalessp))
       (cond ((null a) (return nil)) ;no elements
	     (t (setq n (length a))
		(do i 1 (1+ i) (greaterp i n) (sortcarhelp a fun))
		(return a)))))

(defun sortcarhelp (a fun)
  (cond ((null (cdr a)) a)
        ((funcall fun (caadr a) (caar a))  
	 (exchange2 a)
	 (sortcarhelp (cdr a) fun))
	(t (sortcarhelp (cdr a) fun))))


(defun exchange2 (a)
  (prog (temp)
	(setq temp (cadr a))
	(rplaca (cdr a) (car a))
	(rplaca a temp)))

;--- sublis: alst - assoc list ((a . val) (b . val2) ...)
;	     exp  - s-expression
; for each atom in exp which corresponds to a key in alst, the associated
; value from alst is substituted.  The substitution is done by adding
; list cells, no struture mangling is done.  Only the minimum number
; of list cells will be created.
;
(def sublis
  (lambda (alst exp)
     (let (tmp)
	  (cond ((atom exp) 
		 (cond ((setq tmp (assoc exp alst))
			(cdr tmp))
		       (t exp)))
		((setq tmp (sublishelp alst exp))
		 (car tmp))
		(t exp)))))

;--- sublishelp : alst - assoc list
;		  exp  - s-expression
; this function helps sublis work.  it is different from sublis in that
; it return nil if no change need be made to exp, or returns a list of
; one element which is the changed exp.
;
(def sublishelp
  (lambda (alst exp)
     (let (carp cdrp)
	  (cond ((atom exp)
		 (cond ((setq carp (assoc exp alst))
			(list (cdr carp)))
		       (t nil)))
		(t (setq carp (sublishelp alst (car exp))
			 cdrp (sublishelp alst (cdr exp)))
		   (cond ((not (or carp cdrp)) nil)		; no change
			 ((and carp (not cdrp))			; car change
			  (list (cons (car carp) (cdr exp))))	
			 ((and (not carp) cdrp)			; cdr change
			  (list (cons (car exp) (car cdrp))))	
			 (t					; both change 
			  (list (cons (car carp) (car cdrp))))))))))


;--- subst : new - sexp
;	     old - sexp
;	     pat - sexp
; substitutes in patrn all occurrences equal to old with new and returns the
; result
; MUST be put in the manual

(declare (special new old))

(def subst 
  (lambda (new old pat)
	  (cond ((symbolp old) (substeq pat))
		(t (substequal pat)))))

;use this function for substituting for symbols
(def substeq
  (lambda (pat)
	  (cond ((eq old pat) new)
		((atom pat) pat)
		(t (cons (substeq (car pat))(substeq (cdr pat)))))))

(def substequal
  (lambda (pat)
	  (cond ((equal old pat) new)
		((atom pat) pat)
		(t (cons (substequal (car pat))
			 ; in interlisp, the next line would be
			 ;(substeq (cdr pat))
			 ; for maclisp compatibility, we do this.
			 (substequal (cdr pat)))))))

(declare (unspecial new old))
;--- vi: arg is unevaluated name of function to run vi on
;
(def vi (nlambda (x) (exvi 'vi x nil)))

;--- vil : arg is unevaluated, edits file and then loads it
;
(def vil (nlambda (x) (exvi 'vi x t)))

;--- *quo : returns integer part of x/y
; x and y must be fixnums.
;
(putd '*quo (getd 'quotient))

;--- xcons : a - sexp
;	     b - sexp
; returns (b . a)   that is, it is an exchanged cons
;
(def xcons  (lambda (a b) (cons b a)))






;--- mode lines, must be last lines of the file
; vi: set lisp :
;
EndOfFile
cat >  lisplib/common2.l  << 'EndOfFile'
(setq rcs-common2-
   "$Header: common2.l,v 1.10 84/02/29 19:32:00 jkf Exp $")

;;
;; common2.l				-[Fri Feb  3 07:42:40 1984 by jkf]-
;;
;; lesser used functions
;;


(declare (macros t))

;--- process functions
; these functions permit the user to start up processes and either
; to either wait for their completion or to continue processing,
; communicating with them through a pipe.
;
; the main function, *process, is written in C.  These functions
; handle the common cases
;
;--- *process-send  :: start a process and return port to write to
;
(defun *process-send (command)
   (cadr (*process command nil t)))

;--- *process-receive :: start a process and return port to read from
;
(defun *process-receive (command)
   (car (*process command t)))

;--- process :: the old nlambda version of process
;  this function is kept around for compatibility
; use: (process command [frompipe [topipe]])
;  if the from and to pipes aren't given, run it and wait
;
(defun process fexpr (args)
   (declare (*args 1 3))
   (let ((command (car args))
	 (fromport (cadr args))
	 (toport (caddr args)))
      (cond ((null (cdr args)) (*process command))  ; call and wait
	    (t (let ((res (*process command fromport toport)))
		  (cond (fromport (set fromport (cadr res))))
		  (cond (toport (set toport (car res))))
		  ; return pid
		  (caddr res))))))


;--- msg : print a message consisting of strings and values
; arguments are:
;   N	    - print a newline
;   (N foo) - print foo newlines (foo is evaluated)
;   B       - print a blank
;   (B foo) - print foo blanks (foo is evaluated)
;   (P foo) - print following args to port foo (foo is evaluated)
;   (C foo) - go to column foo (foo is evaluated)
;   (T n)   - print n tabs
;   D	    - drain
;   other   - evaluate a princ the result (remember strings eval to themselves)

(defmacro msg (&rest msglist)
  (do ((ll msglist (cdr ll))
       (result)
       (cur nil nil)
       (curport nil)
       (current))
      ((null ll) `(progn ,@(nreverse result)))
      (setq current (car ll))
      (If (dtpr current)
	  then (If (eq (car current) 'N)
		   then (setq cur `(msg-tyo-char 10 ,(cadr current)))
		elseif (eq (car current) 'B)
		  then (setq cur `(msg-tyo-char 32 ,(cadr current)))
		elseif (eq (car current) 'T)
		  then (setq cur `(msg-tyo-char #\tab ,(cadr current)))
		elseif (eq (car current) 'P)
		   then (setq curport (cadr current))
		elseif (eq (car current) 'C)
		   then (setq cur `(tab (1- ,(cadr current))))
		else (setq cur `(msg-print ,current)))
       elseif (eq current 'N)
	  then (setq cur (list 'terpr))		; (can't use backquote
       elseif (eq current 'B)			; since must have new
      	  then (setq cur (list 'tyo 32))	; dtpr cell at end)
       elseif (eq current 'D)
	  then (setq cur '(drain))
       else (setq cur `(msg-print ,current)))
      (If cur 
	  then (setq result (cons (If curport then (nconc cur (ncons curport))
			                      else cur)
				  result)))))




(defun msg-tyo-char (ch n &optional (port nil))
  (do ((i n (1- i)))
      ((< i 1))
      (cond ((eq ch 10) (terpr port))
	    (t (tyo ch port)))))

(defun msg-print (item &optional (port nil))
   (patom item port))

;--- printblanks :: print out a stream of blanks to the given port
; (printblanks 'x_numberofblanks 'p_port)
;
(def printblanks
   (lambda (n prt)
      (let ((easy (memq n '( 0  ""
			     1  " "
			     2  "  "
			     3  "   "
			     4  "    "
			     5  "     "
			     6  "      "
			     7  "       "
			     8  "        "))))
	 (cond (easy (patom (cadr easy) prt))
	       (t (do ((i n (1- i)))
		      ((<& i 1))
		      (patom " " prt)))))))





; --- linelength [numb]
;
; sets the linelength (actually just varib linel) to the
; number given: numb
; if numb is not given, the current line length is returned
; 

(declare (special linel))

(setq linel 80)

(def linelength
     (nlambda (form)
	      (cond ((null form) linel )
		    ((numberp (car form)) (setq linel (car form)))
		    (t linel))))

; ========================================
;
;	(charcnt port) 
; returns the number of characters left on the current line
; on the given port
;
; =======================================


(def charcnt
     (lambda (port) (- linel (nwritn port))))

;--- nthcdr :: do n cdrs of the list and return the result
;
; 
(defun nthcdr (index list)
   (cond ((fixp index)
	  (cond ((<& index 0)
		 (cons nil list))
		((=& index 0)
		 list)
		(t (nthcdr (1- index) (cdr list)))))
	 (t (error "Non fixnum first argument to nthcdr " index))))

;--- nthcdr (cmacro) :: version of nthcdr for use by the compiler
;
(defcmacro nthcdr (index list)
   (if (and (fixp index) (=& index 0))
      then list	; (nthcdr 0 expr) => expr
      else (let ((val (assq index '((1  . cdr)
				    (2  . cddr)
				    (3  . cdddr)
				    (4  . cddddr)
				    (5  . cdddddr)
				    (6  . cddddddr)))))
	      (cond (val `(,(cdr val) ,list))	; (nthcdr 1-6 list)
		    (t `(nthcdr ,index ,list)))))) ; other cases


;--- nth :: return nth element of the list
; cdr index times and then car to get the element.
; thus the first element is 0
;
(defun nth (index list)
   (car (nthcdr index list)))

;--- nth (cmacro) :: compiler macro to do the same thing
;
(defcmacro nth (index list)
   `(car (nthcdr ,index ,list)))

   


;;==============================
;  (assqr val alist)
; acts much like assq, it looks for val in the cdr of elements of
; the alist and returns the element if found.
; fix this when the compiler works
(eval-when nil (def assqr 
    (lambda (val alist)
	(do ((al alist (cdr al)))
	    ((null al) nil)
	    (cond ((eq val (cdar al)) (return (car al))))))))


; ====================
; (listp 'x) is t if x is a non-atom or nil
; ====================
(def listp (lambda (val) (or (dtpr val) (null val))))



;--- memcar - VAL : lispval
;	    - LIS : list
;	returns t if VAL found as the car of a top level element.
;temporarily turn this off till the compiler can handle it.
(eval-when nil (def memcar 
  (lambda (a l)
	  (do ((ll l (cdr ll)))
	      ((null ll) nil)
	      (cond ((equal (caar ll) a) (return (cdar ll))))))))

; =================================
;
;	(memcdr 'val 'listl)
;
; the list listl is searched for a list
; with cdr equal to val. if found, the
; car of that list is returned.
; ==================================
;fix this when compiler works ok
(eval-when nil (def memcdr 
  (lambda (a l)
	  (do ((ll l (cdr ll)))
	      ((null ll) nil)
	      (cond ((equal (cdar ll) a) (return (caar l))))))))


;this looks like funcall, so we will just use it
'(def apply* 
  (nlambda ($x$)
	(eval (cons (eval (car $x$)) (cdr $x$)))))

(putd 'apply* (getd 'funcall))

(defun remq (item list &optional (cnt -1))	;no tail recursion sucks.
   (let ((head nil)
	 (tail nil))
      (do ((l list (cdr l))
	   (newcell))
	  ((null l) head)
	  (cond ((or (not (eq (car l) item))
		     (=& 0 cnt))
		 (setq newcell (list (car l)))
		 (cond ((null head) (setq head newcell))
		       (t (rplacd tail newcell)))
		 (setq tail newcell))
		(t (setq cnt (1- cnt)))))))

(defun tab n
   (prog (nn prt over)
      (setq nn (arg 1))
      (cond ((>& n 1) (setq prt (arg 2))))
      (cond ((>& (setq over (nwritn prt)) nn)
	     (terpri prt)
	     (setq over 0)))
      (printblanks (- nn over) prt)))

;--- charcnt :: returns the number of characters left on the current line
; 	p - port
;(local function)
(def charcnt
     (lambda (port) (- linel (nwritn port))))

;(local function)
;
(declare (special $outport$))
(def $patom1 (lambda (x) (patom x $outport$)))

;;; --- cmu  functions ---
(def attach
   (lambda (x y)
	   (cond ((dtpr y) (rplacd y (cons (car y) (cdr y))) (rplaca y x))
		 (t (error "An atom can't be attached to " y)))))
(def Cnth
   (lambda (x n)
	   (cond ((> 1 n) (cons nil x))
		 (t
		    (prog nil
		     lp   (cond ((or (atom x) (eq n 1)) (return x)))
			  (setq x (cdr x))
			  (setq n (1- n))
			  (go lp))))))




(def dsubst
   (lambda (x y z)
	   (prog (b)
		 (cond ((eq y (setq b z)) (return (copy x))))
		 lp
		 (cond ((atom z) (return b))
		       ((cond ((symbolp y) (eq y (car z))) (t (equal y (car z))))
			(rplaca z (copy x)))
		       (t (dsubst x y (car z))))
		 (cond ((and y (eq y (cdr z))) (rplacd z (copy x)) (return b)))
		 (setq z (cdr z))
		 (go lp))))

(putd 'eqstr (getd 'equal))

(defun insert (x l comparefn nodups)
      (cond ((null l) (list x))
            ((atom l) (error "an atom, can't be inserted into" l))
            ((and nodups (member x l)) l)
	    (t (cond
                ((null comparefn) (setq comparefn (function alphalessp))))
               (prog (l1 n n1 y)
                     (setq l1 l)
                     (setq n (length l))
                a    (setq n1 (/ (add1 n) 2))
                     (setq y (Cnth l1 n1))
                     (cond ((< n 3)
                            (cond ((funcall comparefn x (car y))
                                   (cond
                                    ((not (equal x (car y)))
                                     (rplacd y (cons (car y) (cdr y)))
                                     (rplaca y x))))
                                  ((eq n 1) (rplacd y (cons x (cdr y))))
                                  ((funcall comparefn x (cadr y))
                                   (cond
                                    ((not (equal x (cadr y)))
                                     (rplacd (cdr y)
                                             (cons (cadr y) (cddr y)))
                                     (rplaca (cdr y) x))))
                                  (t (rplacd (cdr y) (cons x (cddr y))))))
                           ((funcall comparefn x (car y))
                            (cond
                             ((not (equal x (car y)))
                              (setq n (sub1 n1))
                              (go a))))
                           (t (setq l1 (cdr y)) (setq n (- n n1)) (go a))))
               l)))




(def kwote (lambda (x) (list 'quote x)))

(def lconc
     (lambda 
      (ptr x)
      (prog (xx)
            (return
             (cond ((atom x) ptr)
                   (t (setq xx (last x))
                      (cond ((atom ptr) (cons x xx))
                            ((dtpr (cdr ptr))
                             (rplacd (cdr ptr) x)
                             (rplacd ptr xx))
                            (t (rplaca (rplacd ptr xx) x)))))))))
(def ldiff
     (lambda (x y)
      (cond ((eq x y) nil)
            ((null y) x)
            (t
             (prog (v z)
                   (setq z (setq v (ncons (car x))))
              loop (setq x (cdr x))
                   (cond ((eq x y) (return z))
                         ((null x) (error "not a tail - ldiff")))
                   (setq v (cdr (rplacd v (ncons (car x)))))
                   (go loop))))))

(def lsubst
     (lambda (x y z)
      (cond ((null z) nil)
            ((atom z) (cond ((eq y z) x) (t z)))
            ((equal y (car z)) (nconc (copy x) (lsubst x y (cdr z))))
            (t (cons (lsubst x y (car z)) (lsubst x y (cdr z)))))))

(def merge
   (lambda (a b %%cfn)
      (declare (special %%cfn))
      (cond ((null %%cfn) (setq %%cfn (function alphalessp))))
      (merge1 a b)))

(def merge1
   (lambda (a b)
      (declare (special %%cfn))
      (cond ((null a) b)
	    ((null b) a)
	    (t
	       (prog (val end)
		  (setq val
			(setq end
			      (cond ((funcall %%cfn (car a) (car b))
				     (prog1 a (setq a (cdr a))))
				    (t (prog1 b (setq b (cdr b)))))))
		  loop (cond ((null a) (rplacd end b) (return val))
			     ((null b) (rplacd end a) (return val))
			     ((funcall %%cfn (car a) (car b))
			      (rplacd end a)
			      (setq a (cdr a)))
			     (t (rplacd end b) (setq b (cdr b))))
		  (setq end (cdr end))
		  (go loop))))))

(defmacro neq (a b) `(not (eq ,a ,b)))

(putd 'nthchar (getd 'getchar))
;(def nthchar
;     (lambda (x n)
;      (cond ((plusp n) (car (Cnth (explodec x) n)))
;            ((minusp n) (car (Cnth (reverse (explodec x)) (minus n))))
;            ((zerop n) nil))))

(defmacro quote! (&rest a) (quote!-expr-mac a))

(eval-when (compile eval load)
   
(defun quote!-expr-mac (form)
   (cond ((null form) nil)
	 ((atom form) `',form)
	 ((eq (car form) '!)
	  `(cons ,(cadr form) ,(quote!-expr-mac (cddr form))))
	 ((eq (car form) '!!)
	  (cond ((cddr form) `(append ,(cadr form)
				       ,(quote!-expr-mac (cddr form))))
		(t (cadr form))))
	 (t `(cons ,(quote!-expr-mac (car form))
		    ,(quote!-expr-mac (cdr form))))))

)

(defun remove (item list &optional (cnt -1))
  (let ((head '())
	(tail nil))
    (do ((l list (cdr l))
	 (newcell))
	((null l) head)
      (cond ((or (not (equal (car l) item))
		 (zerop cnt))
	     (setq newcell (list (car l)))
	     (cond ((null head) (setq head newcell))
		   (t (rplacd tail newcell)))
	     (setq tail newcell))
	    (t (setq cnt (1- cnt)))))))

(def subpair
     (lambda (old new expr)
      (cond (old (subpr expr old (or new '(nil)))) (t expr))))

(def subpr
   (lambda (expr l1 l2)
	   (prog (d a)
		 (cond ((atom expr) (go lp))
		       ((setq d (cdr expr)) (setq d (subpr d l1 l2))))
		 (setq a (subpr (car expr) l1 l2))
		 (return
		    (cond ((or (neq a (car expr))
			       (neq d (cdr expr))) (cons a d))
			  (t expr)))
		 lp   (cond ((null l1) (return expr))
			    (l2 (cond ((eq expr (car l1))
				       (return (car l2)))))
			    (t (cond ((eq expr (caar l1))
				      (return (cdar l1))))))
		 (setq l1 (cdr l1))
		 (and l2 (setq l2 (or (cdr l2) '(nil))))
		 (go lp))))
(def tailp
   (lambda (x y)
	   (and x
		(prog nil
		      lp   (cond ((atom y) (return nil)) ((eq x y) (return x)))
                 (setq y (cdr y))
                 (go lp)))))

(def tconc
     (lambda (p x)
      (cond ((atom p) (cons (setq x (ncons x)) x))
            ((dtpr (cdr p)) (rplacd p (cdr (rplacd (cdr p) (ncons x)))))
            (t (rplaca p (cdr (rplacd p (ncons x))))))))

;--- int:vector-range-error
; this is called from compiled code if a vector reference is made
; which is out of bounds.  it should print an error message and
; never return
(defun int:vector-range-error (vec index)
   (error "vector index out of range detected in compiled code "
	  (list vec index)))

;--- int:wrong-number-of-args-error :: pass wna error message to user
; this is called from compiled code (through wnaerr in the C interpreter)
; when it has been detected that the wrong number of arguments have
; been passed.  The state of the arguments are:
;	args 1 to (- n 3) are the acutal arguments
;	arg (- n 2) is the name of the function called
;	arg (- n 1) is the minimum number of arguments allowed
; 	arg n is the maximum number of arguments allowed
;		(or -1 if there is no maximum)
(defun int:wrong-number-of-args-error n
   (let ((max (arg n))
	 (min (arg (1- n)))
	 (name (arg (- n 2))))
      (do ((i (- n 3) (1- i))
	   (x)
	   (args))
	  ((<& i 1)
	   ; cases
	   ;  exact number
	   ;  min and max
	   ;  only a min
	   (if (=& min max)
	      then (setq x
		    (format nil
		     "`~a' expects ~r argument~p but was given ~@d:"
		     name min min (length args)))
	    elseif (=& max -1)
	      then (setq x
		    (format nil
		     "`~a' expects at least ~r argument~p but was given ~@d:"
		      name min min (length args)))
	      else (setq x
		    (format nil
		     "`~a' expects between ~r and ~r arguments but was given ~@d:"
		     name min max (length args))))
		   
	   (error x args))
	  (push (arg i) args))))   
;--- functions to retrieve parts of the vector returned by
;    filestat
;
(eval-when (compile eval)
   (defmacro filestat-chk (name index)
	     `(defun ,name (arg)
		      (cond ((vectorp arg)
			     (vref arg ,index))
			    (t (error (concat ',name '|: bad arg |) arg))))))
(filestat-chk filestat:mode	0)
(filestat-chk filestat:type	1)
(filestat-chk filestat:nlink	2)
(filestat-chk filestat:uid 	3)
(filestat-chk filestat:gid	4)
(filestat-chk filestat:size	5)
(filestat-chk filestat:atime	6)
(filestat-chk filestat:mtime	7)
(filestat-chk filestat:ctime	8)
(filestat-chk filestat:dev	9)
(filestat-chk filestat:rdev	10)
(filestat-chk filestat:ino	11)

;; lisp coded showstack and baktrace.
;;

(declare (special showstack-prinlevel showstack-prinlength
		  showstack-printer prinlevel prinlength))

(or (boundp 'showstack-prinlevel) (setq showstack-prinlevel 3))
(or (boundp 'showstack-prinlength) (setq showstack-prinlength 4))
(or (boundp 'showstack-printer)	(setq showstack-printer 'print))
(or (getd 'old-showstack) (putd 'old-showstack (getd  'showstack)))
(or (getd 'old-baktrace) (putd 'old-baktrace (getd  'baktrace)))

;--- showstack :: do a stack backtrace.
; arguments (unevaluated) are
;	t  - print trace expressions too (normally they are not printed)
;	N  - for some fixnum N, only print N levels.
;	len N - set prinlength to N
;	lev N - set prinlevel to N
;
(defun showstack fexpr (args)
   (showstack-baktrace args t))

(defun baktrace fexpr (args)
   (showstack-baktrace args nil))

(defun showstack-baktrace (args showstackp)
   (let ((print-trace nil)
	 (levels-to-print -1)
	 (prinlevel showstack-prinlevel)
	 (prinlength showstack-prinlength)
	 (res nil)
	 (newres nil)
	 (oldval nil)
	 (stk nil))
      ;; scan arguments
      (do ((xx args (cdr xx)))
	  ((null xx))
	  (cond ((eq t (car xx)) (setq print-trace t))
		((fixp (car xx)) (setq levels-to-print (car xx)))
		((eq 'lev (car xx))
		 (setq xx (cdr xx) prinlevel (car xx)))
		((eq 'len (car xx))
		 (setq xx (cdr xx) prinlength (car xx)))))
      ;; print the levels
      (do ((levs levels-to-print)
	   (firsttime t nil))
	  ((or (equal 0 stk)
	       (zerop levs))
	   (terpr))
	  (setq res (int:showstack stk))
	  (cond ((null res) (terpr) (return nil)))
	  (setq stk (cdr res)
		res (car res))
	  (cond ((or print-trace (not (trace-funp res)))
		 (cond ((and oldval showstackp)
			(setq newres (subst-eq '<**> oldval res)))
		       (t (setq newres res)))
		 (cond (showstackp (funcall showstack-printer newres) (terpr))
		       (t (baktraceprint newres firsttime)))
		 (setq levs (1- levs))
		 (setq oldval res))))))

(defun baktraceprint (form firsttime)
   (cond ((not firsttime) (patom " -- ")))
   (cond ((> (nwritn) 65) (terpr)))
   (cond ((atom form) (print form))
	 (t (let ((prinlevel 1)
		  (prinlength 2))
	       (cond ((dtpr form) (print (car form)))
		     (t (print form)))))))


;--- trace-funp  :: see if this is a trace function call
; return t if this call is a result of tracing a function, or of calling
; showstack
;
(defun trace-funp (expr)
   (or (and (symbolp expr)
	    (memq expr '(T-eval  T-apply T-setq
				 eval int:showstack showstack-baktrace)))
       (and (dtpr expr)
	    (cond ((symbolp (car expr))
		   (memq (car expr) '(trace-break T-cond T-eval T-setq
						  T-apply)))
		  ((dtpr (car expr))
		   (and (eq 'lambda (caar expr))
			(eq 'T-arglst (caadar expr))))))))

;--- subst-eq  :: replace parts eq to new with old
; make new list structure
;
(defun subst-eq (new old list)
   (cond ((eq old list)
	  new)
	 ((and (dtpr list)
	       (subst-eqp old list))
	  (cond ((eq old (car list))
		 (cons new (subst-eq new old (cdr list))))
		((dtpr (car list))
		 (cons (subst-eq new old (car list))
		       (subst-eq new old (cdr list))))
		(t (cons (car list)
			 (subst-eq new old (cdr list))))))
	 (t list)))

(defun subst-eqp (old list)
   (cond ((eq old list) t)
	 ((dtpr list)
	  (or (subst-eqp old (car list))
	      (subst-eqp old (cdr list))))
	 (t nil)))



;;; environment macros

(defmacro environment (&rest args)
   (do ((xx args (cddr xx))
	(when)(action)(res))
       ((null xx)
	`(progn 'compile
		,@(nreverse res)))
       (setq when (car xx)
	     action (cadr xx))
       (if (atom when)
	  then (setq when (ncons when)))
       (if (and (dtpr action)
		(symbolp (car action)))
	  then (setq action (cons (concat "environment-" (car action))
				  (cdr action))))
       (push `(eval-when ,when ,action) res)))
       

(defun environment-files fexpr (names)
   (mapc '(lambda (filename)
	     (if (not (get filename 'version)) then (load filename)))
	 names))

(defun environment-syntax fexpr (names)
   (mapc '(lambda (class)
	     (caseq class
		 (maclisp (cvttomaclisp))
		 (intlisp (cvttointlisp))
		 (ucilisp (cvttoucilisp))
		 ((franz franzlisp) (cvttofranzlisp))
		 (t (error "unknown syntax conversion type " class))))
	 names))

;--- standard environments
(defmacro environment-maclisp (&rest args)
   `(environment (compile load eval) (files machacks)
		 (compile eval) (syntax maclisp)
		 ,@args))


(defmacro environment-lmlisp (&rest args)
   `(environment (compile load eval) (files machacks lmhacks)
		 (compile eval) (syntax maclisp)
		 ,@args))

;;;--- i/o functions redefined.
; The common I/O functions are redefined here to do tilde expansion
; if the tilde-expansion symbol is non nil
(declare (special tilde-expansion))
   
;First, define the current <name> as int:<name>
;
(cond ((null (getd 'int:infile))
       (putd 'int:infile (getd 'infile))
       (putd 'int:outfile (getd 'outfile))
       (putd 'int:fileopen (getd 'fileopen))
       (putd 'int:cfasl (getd 'cfasl))
       (putd 'int:fasl (getd 'fasl))))

;Second, define the new functions:

(defun infile (filename)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "infile: non symbol or string filename " filename)))
   (cond (tilde-expansion (setq filename (tilde-expand filename))))
   (int:infile filename))

(defun outfile (filename &optional args)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "outfile: non symbol or string filename " filename)))
   (cond (tilde-expansion (setq filename (tilde-expand filename))))
   (int:outfile filename args))

;--- fileopen :: open a file with a non-standard stdio file
;  [this should probably be flushed because it depends on stdio,
;   which we may not use in the future]
(defun fileopen (filename mode)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "fileopen: non symbol or string filename " filename)))
   (cond (tilde-expansion (setq filename (tilde-expand filename))))
   (int:fileopen filename mode))

(defun fasl (filename &rest args)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "fasl: non symbol or string filename " filename)))
   (cond (tilde-expansion (setq filename (tilde-expand filename))))
   (lexpr-funcall 'int:fasl filename args))

(defun cfasl (filename &rest args)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "cfasl: non symbol or string filename " filename)))
   (cond (tilde-expansion (setq filename (tilde-expand filename))))
   (lexpr-funcall 'int:cfasl filename args))


;--- probef :: test if a file exists
;
(defun probef (filename)
   (cond ((not (or (symbolp filename) (stringp filename)))
	  (error "probef: non symbol or string filename " filename)))
   (sys:access filename 0))



(declare (special user-name-to-dir-cache))
(or (boundp 'user-name-to-dir-cache) (setq user-name-to-dir-cache nil))

;--- username-to-dir
; given a user name, return the home directory name
;
(defun username-to-dir (name)
   (cond ((symbolp name) (setq name (get_pname name)))
	 ((stringp name))
	 (t (error "username-to-dir: Illegal name " name)))
   (let ((val (assoc name user-name-to-dir-cache)))
      (cond ((null val)
	     (setq val (sys:getpwnam name))
	     (cond (val (push (cons name val) user-name-to-dir-cache))))
	    (t (setq val (cdr val))))
      (cond (val (sys:getpwnam-dir val)))))
		    
;--- username-to-dir-flush-cache :: clear all memory of where users are
; it is important to call this function upon startup to clear all
; knowledge of pathnames since this object file could have been copied
; from another machine
;
(defun username-to-dir-flush-cache ()
   (setq user-name-to-dir-cache nil))

;--- lisp interface to int:franz-call
;
(eval-when (compile eval)
   (setq fc_getpwnam 1   fc_access 2  fc_chdir 3  fc_unlink 4
	 fc_time   5     fc_chmod  6  fc_getpid 7 fc_stat  8
	 fc_gethostname 9 fc_link 10  fc_sleep 11 fc_nice 12))

;--- sys:getpwnam
; (sys:getpwnam 'st_username)
; rets vector: (t_name x_uid x_gid t_dir)
;
(defun sys:getpwnam (name)
   (cond ((or (symbolp name) (stringp name))
	  (int:franz-call #.fc_getpwnam name))
	 (t (error "sys:getpwnam : illegal name " name))))

; return dir portion
;
(defun sys:getpwnam-dir (vec) (vref vec 3))

(defun sys:access (name class)
   (cond ((and (or (symbolp name) (stringp name))
	       (fixp class))
	  (cond (tilde-expansion (setq name (tilde-expand name))))
	  (zerop (int:franz-call #.fc_access name class)))
	 (t (error "sys:access : illegal name or class " name class))))

(defun chdir (dir)
   (cond ((or (symbolp dir) (stringp dir))
	  (cond (tilde-expansion (setq dir (tilde-expand dir))))
	  (cond ((zerop (int:franz-call #.fc_chdir dir)))
		(t (error "cd: can't chdir to " dir))))
	 (t (error "chdir: illegal argument " dir))))

;--- sys:unlink :: unlink (remove) a file
;
(defun sys:unlink (name)
   (cond ((or (symbolp name) (stringp name))
	  (cond (tilde-expansion (setq name (tilde-expand name))))
	  (cond ((zerop (int:franz-call #.fc_unlink name)))
		(t (error "sys:unlink : unlink failed of " name))))
	 (t (error "sys:unlink : illegal argument " name))))

;--- sys:link :: make (hard) link to file
;
(defun sys:link (oldname newname)
   (cond ((or (symbolp oldname) (stringp oldname))
	  (cond (tilde-expansion (setq oldname (tilde-expand oldname))))
	  (cond ((or (symbolp newname) (stringp newname))
		 (cond (tilde-expansion (setq newname 
						(tilde-expand newname))))
		 (cond ((zerop (int:franz-call #.fc_link oldname newname)))
		       (t (error "sys:link : unlink failed of "
				 oldname newname))))
		(t (error "sys:unlink : illegal argument " newname))))
	 (t (error "sys:unlink : illegal argument " oldname))))

;--- sys:time :: return 'absolute' time in seconds
;
(defun sys:time ()
   (int:franz-call #.fc_time))

;--- sys:chmod :: change mode of file
; return t iff it succeeded.
;
(defun sys:chmod (name mode)
   (cond ((and (or (stringp name) (symbolp name))
	       (fixp mode))
	  (cond (tilde-expansion (setq name (tilde-expand name))))
	  (cond ((zerop (int:franz-call #.fc_chmod name mode)))
		(t (error "sys:chmod : chmod failed of " name))))
	 (t (error "sys:chmod : illegal argument(s): " name mode))))
   
(defun sys:getpid ()
   (int:franz-call #.fc_getpid))

(defun filestat (name)
   (let (ret)
      (cond ((or (symbolp name) (stringp name))
	     (cond (tilde-expansion (setq name (tilde-expand name))))
	     (cond ((null (setq ret (int:franz-call #.fc_stat name)))
		    (error "filestat : file doesn't exist " name))
		   (t ret)))
	    (t (error "filestat : illegal argument " name)))))

;--- sys:gethostname :: retrieve the current host name as a string
;
(defun sys:gethostname ()
   (int:franz-call #.fc_gethostname))

(defun sleep (seconds)
   ;; (sleep 'x_seconds)
   ;; pause for the given number of seconds
   (cond ((fixp seconds) (int:franz-call #.fc_sleep seconds))
	 (t (error "sleep: non-fixnum argument " seconds))))

(defun sys:nice (delta-priority)
   ;; modify the priority by the given amount
   (cond ((fixp delta-priority) (int:franz-call #.fc_nice delta-priority))
	 (t (error "sys:nice: non-fixnum argument " delta-priority))))
EndOfFile
cat >  lisplib/common3.l  << 'EndOfFile'
(setq rcs-common2-
   "$Header: common3.l,v 1.4 84/02/29 23:23:35 layer Exp $")

;;
;; common3.l				-[Sat Sep 10 10:51:18 1983 by jkf]-
;;
;;

(declare (macros t))

(defun litatom macro (x)
  `(and (atom . ,(cdr x))
	(not (numberp . ,(cdr x)))))

; This function really should compile optimally in-line
;
(defun nequal (arg1 arg2)
  (not (equal arg1 arg2)))

(defun lineread (&rest args)
   (let (flag port)
      (mapc (function		; get the options
	       (lambda (x)
		  (cond ((portp x) (setq port x))
			((setq flag x)))))
	    args)
      (cond ((not (and flag	; flag for empty line
		       (eq (tyipeek port) #\lf)
		       (tyi port)))
	     (prog (input)
		(setq input (ncons nil))  ; initialize for tconc.
		(tconc input (read port))	; do read to make sure
						; an s-expression gets read
		loop
		(cond ((not (eq (tyipeek port) #\lf))
		       (tconc input (read port))
		       (go loop))
		      ( t ; the actual list is in the CAR.
			(tyi port)
			(return (car input)))))))))

(defun defv fexpr (l)
  (set (car l) (cadr l)))


(defun initsym (&rest l)
   (mapcar (function initsym1) l))

(defun initsym1 expr (l)
   (prog (num)
      (cond ((dtpr l)
	     (setq num (cadr l))
	     (setq l (car l)))
	    ( t (setq num 0)))
      (putprop l num 'symctr)
      (return (concat l num))))

(defun newsym (name)
   (concat name
	   (putprop name
		    (1+ (or (get name 'symctr)
			    -1))
		    'symctr)))

(defun oldsym (sym)
   (cond ((get sym 'symctr) (concat sym (get sym 'symctr)))
	 ( t sym)))

(defun allsym (name)
   (prog (num symctr syms)
      (cond ((dtpr name)
	     (setq num (cadr name))
	     (setq name (car name)))
	    ( t (setq num 0)))
      (or (setq symctr (get name 'symctr))
	  (return))
      loop
      (and (>& num symctr)
	   (return syms))
      (setq syms (cons (concat name symctr) syms))
      (setq symctr (1- symctr))
      (go loop)))

(defun remsym (&rest l)
   (mapcar (function remsym1) l))

(defun remsym1 expr (l)
   (prog1 (oldsym (cond ((dtpr l) (car l))
			( t l)))
	  (mapc (function remob) (allsym l))
	  (cond ((dtpr l)
		 (putprop (car l) (1- (cadr l)) 'symctr))
		( t (remprop l 'symctr)))))

(defun symstat (&rest l)
   (mapcar (function (lambda (k)
			(list k (get k 'symctr))))
	   l))

;; from peter@renoir
(defun wide-print-list (given-list &optional (left-margin (nwritn)))
  ;	given a (presumably long) list, print it as wide as possible.
  (declare (special lpar rpar))
  (let ((max-width 78))
       (tab left-margin)
       (cond ((not (listp given-list))
	      (patom given-list))
	     ((null given-list)
	      (patom nil))
	     (t
	      (patom lpar)
	      (do ((left given-list (cdr left))
		   (need-space-p nil t))
		  ((null left) nil)
		  (cond (need-space-p
			 (patom " ")))
		  (let* ((element (car left))
			 (length (flatc element))
			 (used (nwritn))
			 (available (- max-width used)))
			(cond ((>= length available)
			       (tab (1+ left-margin))))
			(cond ((listp element)
			       (wide-print-list element))
			      (t
			       (patom element)))))
	      (patom rpar)))))
EndOfFile
cat >  lisplib/toplevel.l  << 'EndOfFile'
(setq rcs-toplevel-
   "$Header: toplevel.l,v 1.6 83/11/18 08:47:24 jkf Exp $")

;;
;; toplevel.l				-[Sun Oct 30 08:14:49 1983 by jkf]-
;;
;;  toplevel read eval print loop
;;


; special atoms:
(declare (special debug-level-count break-level-count
		  errlist tpl-errlist user-top-level
		  franz-not-virgin piport ER%tpl ER%all
		  $ldprint evalhook funcallhook
		  franz-minor-version-number
		  top-level-init
		  top-level-prompt top-level-read
		  top-level-eval top-level-print
		  top-level-eof * ** *** + ++ +++ ^w)
         (localf autorunlisp cvtsearchpathtolist)
	 (macros t))

(setq top-level-eof (gensym 'Q)
      tpl-errlist nil
      errlist nil
      user-top-level nil
      top-level-init nil
      top-level-prompt nil
      top-level-read  nil
      top-level-eval nil
      top-level-print nil)

;--- initialization, prompt, read, eval, and print functions are
; user-selectable by just assigning another value to top-level-init,
; top-level-prompt, top-level-read, top-level-eval, and top-level-print.
;
(defmacro top-init nil
   '(cond ((and top-level-init
		(getd top-level-init))
	   (funcall top-level-init))
	  (t (cond ((not (autorunlisp))
		    (patom (status version))
		    ; franz-minor-version-number defined in version.l
		    (cond ((boundp 'franz-minor-version-number)
			   (patom franz-minor-version-number)))
		    (terpr)
		    (read-in-lisprc-file))))))
     
(defmacro top-prompt nil
   `(cond ((and top-level-prompt
		(getd top-level-prompt))
	   (funcall top-level-prompt))
	  (t (patom "-> "))))

(defmacro top-read (&rest args)
   `(cond ((and top-level-read
		(getd top-level-read))
	   (funcall top-level-read ,@args))
	  (t (read ,@args))))

(defmacro top-eval (&rest args)
   `(cond ((and top-level-eval
		(getd top-level-eval))
	   (funcall top-level-eval ,@args))
	  (t (eval ,@args))))

(defmacro top-print (&rest args)
   `(cond ((and top-level-print
		(getd top-level-print))
	   (funcall top-level-print ,@args))
	  (t (print ,@args))))

;------------------------------------------------------
;  Top level function for franz			jkf, march 1980
;
; The following function contains the top-level read, eval, print 
; loop.  With the help of the error handling functions, 
; break-err-handler and  debug-err-handler,  franz-top-level provides
; a reasonable enviroment for working with franz lisp.  
; 

(def franz-top-level
  (lambda nil
     (putd 'reset (getd 'franz-reset))
     (username-to-dir-flush-cache)	 ; clear tilde expansion knowledge
      (cond ((or (not (boundp 'franz-not-virgin))
		 (null franz-not-virgin))
	     (setq franz-not-virgin t
		   + nil ++ nil +++ nil
		   * nil ** nil *** nil)
	     (setq ER%tpl 'break-err-handler)
	     (top-init)))
     
     ; loop forever
     (do ((+*) (-) (retval))
	 (nil)
	 (setq retval
	  (*catch 
	  '(top-level-catch break-catch)
	   ; begin or return to top level
	   (progn
             (setq debug-level-count 0   break-level-count 0
		   evalhook nil	  funcallhook nil)
             (cond (tpl-errlist (mapc 'eval tpl-errlist)))
	     (do ((^w nil nil))
		 (nil)
		 (cond (user-top-level (funcall user-top-level))
		       (t (top-prompt)
			  (cond ((eq top-level-eof
				     (setq - 
					   (car (errset (top-read nil 
							      top-level-eof)))))
				 (cond ((not (status isatty))
					(exit)))
				 (cond ((null (status ignoreeof))
					(terpr)
					(print 'Goodbye)
					(terpr)
					(exit))
				       (t (terpr)
					  (setq - ''EOF)))))
			  (setq +* (top-eval -))
			  ; update list of old forms
			  (let ((val -))
			       (let ((o+ +) (o++ ++))
				    (setq +   val
					  ++  o+
					  +++ o++)))
			  ; update list of old values
			  (let ((val +*))
			       (let ((o* *) (o** **))
				    (setq *   val
					  **  o*
					  *** o**)))
			  (top-print +*)
			  (terpr)))))))
	 (terpr)
	 (patom "[Return to top level]")
	 (terpr)
	 (cond ((eq 'reset retval) (old-reset-function))))))





; debug-err-handler is the clb of ER%all when we are doing debugging
; and we want to catch all errors.
; It is just a read eval print loop with errset.
; the only way to leave is: 
;   (reset) just back to top level
;   (return x) return the value to the error checker. 
;		if nil is returned then we will continue as if the error
;		didn't occur. Otherwise if the returned value is a list,
;		then if the error is continuable, the car of that list
;		will be returned to recontinue computation.
;   ^D	continue as if this handler wasn't called.
; the form of errmsgs is:
;  (error_type unique_id continuable message_string other_args ...)
;
(def debug-err-handler
   (lexpr (n)
	  ((lambda (message debug-level-count retval ^w piport)
	      (cond ((greaterp n 0)
		     (print 'Error:)
		     (mapc '(lambda (a) (patom " ") (patom a) )
			   (cdddr (arg 1)))
		     (terpr)))
	      (setq ER%all 'debug-err-handler)
	      (do ((retval)) (nil)
		  (cond ((dtpr
			    (setq retval
				  (errset
				     (do ((form)) (nil)
					 (patom "D<")
					 (patom debug-level-count)
					 (patom ">: ")
					 (cond ((eq top-level-eof
						    (setq form
							  (top-read nil
								top-level-eof)))
						(cond ((null (status isatty))
						       (exit)))
						(return nil))
					       ((and (dtpr form)
						     (eq 'return
							 (car form)))
						(return (eval (cadr form))))
					       (t (setq form (top-eval form))
						  (top-print form)
						  (terpr)))))))
			 (return (car retval))))))
	   nil
	   (add1 debug-level-count)
	   nil
	   nil
	   nil)))

; this is the break handler, it should be tied to 
; ER%tpl always.
; it is entered if there is an error which no one wants to handle.
; We loop forever, printing out our error level until someone
; types a ^D which goes to the next break level above us (or the 
; top-level if there are no break levels above us.
; a (return n) will return that value to the error message
; which called us, if that is possible (that is if the error is
; continuable)
;
(def break-err-handler
   (lexpr (n)
     ((lambda (message break-level-count retval rettype ^w piport)
	 (cond ((greaterp n 0)
		(print 'Error:)
		(mapc '(lambda (a) (patom " ") (patom a) )
		      (cdddr (arg 1)))
		(terpr)
		(cond ((caddr (arg 1)) (setq rettype 'contuab))
		      (t (setq rettype nil))))
	       (t (setq rettype 'localcall)))

	 (do nil (nil)
	     (cond ((dtpr
		       (setq retval
			     (*catch 'break-catch
				 (do ((form)) (nil)
				     (patom "<")
				     (patom break-level-count)
				     (patom ">: ")
				     (cond ((eq top-level-eof
						(setq form
						      (top-read
							 nil
							 top-level-eof)))
					    (cond ((null (status isatty))
						   (exit)))
					    (eval 1)	; force interrupt check
					    (return (sub1 break-level-count)))
					   ((and (dtpr form)
						 (eq 'return (car form)))
					    (cond ((or (eq rettype 'contuab)
						       (eq rettype 'localcall))
						   (return (ncons (top-eval (cadr form)))))
						  (t (patom "Can't continue from this error")
						     (terpr))))
					   ((and (dtpr form) (eq 'retbrk (car form)))
					    (cond ((numberp (setq form (top-eval (cadr form))))
						   (return form))
						  (t (return (sub1 break-level-count)))))
					   (t (setq form (top-eval form))
					      (top-print form)
					      (terpr)))))))
		    (return (cond ((eq rettype 'localcall)
				   (car retval))
				  (t retval))))
		   ((lessp retval break-level-count)
		    (setq tpl-errlist errlist)
		    (*throw 'break-catch retval))
		   (t (terpr)))))
      nil
      (add1 break-level-count)
      nil
      nil
      nil
      nil)))

(defvar debug-error-handler 'debug-err-handler) ; name of function to get
						; control on ER%all error
(def debugging 
  (lambda (val)
	  (cond (val (setq ER%all debug-error-handler)
		     (sstatus translink nil)
		     (*rset t))
		(t (setq ER%all nil)))))


; the problem with this definition for break is that we are
; forced to put an errset around the break-err-handler. This means
; that we will never get break errors, since all errors will be
; caught by our errset (better ours than one higher up though).
; perhaps the solution is to automatically turn debugmode on.
;
(defmacro break (message &optional (pred t))
  `(*break ,pred ',message))

(def *break
  (lambda (pred message)
     (let ((^w nil))
	  (cond ((not (boundp 'break-level-count)) (setq break-level-count 1)))
	  (cond (pred (terpr)
		      (patom "Break ")
		      (patom message)
		      (terpr)
		      (do ((form))
			  (nil)
			  (cond ((dtpr (setq form (errset (break-err-handler))))
				 (return (car form))))))))))


; this reset function is designed to work with the franz-top-level.
; When franz-top-level begins, it makes franz-reset be reset. 
; when a reset occurs now, we set the global variable tpl-errlist to 
; the current value of errlist and throw to top level.  At top level,
; then tpl-errlist will be evaluated.
;
(def franz-reset
  (lambda nil
	  (setq tpl-errlist errlist)
	  (errset (*throw 'top-level-catch 'reset)
		  nil)
	  (old-reset-function)))


(declare (special $ldprint))

;--- read-in-lisprc-file
; search for a lisp init file.  Look first in . then in $HOME
; look first for .o , then .l and then "",
; look for file bodies .lisprc and then lisprc
; 
(def read-in-lisprc-file
   (lambda nil
      (setq break-level-count 0	; do this in case break
	    debug-level-count 0)   ; occurs during readin
      (*catch '(break-catch top-level-catch)
	      (do ((dirs `("." ,(getenv 'HOME)) (cdr dirs))
		   ($ldprint nil $ldprint))	; prevent messages
		  ((null dirs))
		  (cond ((do ((name '(".lisprc" "lisprc") (cdr name)))
			     ((null name))
			     (cond ((do ((ext '(".o" ".l" "") (cdr ext))
					 (file))
					((null ext))
					(cond ((probef
						  (setq file
							(concat (car dirs)
								"/"
								(car name)
								(car ext))))
					       (cond ((atom (errset (load file)))
						      (patom
							 "Error loading lisp init file ")
						      (print file)
						      (terpr)
						      (return 'error)))
					       (return t))))
				    (return t))))
			 (return t)))))))

(putd 'top-level (getd 'franz-top-level))

; if this is the first time this file has been read in, then 
; make franz-reset be the reset function, but remember the original
; reset function as old-reset-function.  We need the old reset function
; if we are going to allow the user to change top-levels, for in 
; order to do that we really have to jump all the way up to the top.
(cond ((null (getd 'old-reset-function))
       (putd 'old-reset-function (getd 'reset))))


;---- autoloader functions

(def undef-func-handler
  (lambda (args)
    (prog (funcnam file)
	  (setq funcnam (caddddr args))
	  (cond ((symbolp funcnam) 
		 (cond ((setq file (or (get funcnam 'autoload)
				       (get funcnam 'macro-autoload)))
			(cond ($ldprint
			       (patom "[autoload ") (patom file)
			       (patom "]")(terpr)))
			(load file))
		       (t (return nil)))
		 (cond ((getd funcnam) (return (ncons funcnam)))
		       (t (patom "Autoload file " ) (print file)
			  (patom " does not contain function ")
			  (print funcnam)
			  (terpr)
			  (return nil))))))))

(setq ER%undef 'undef-func-handler)

(declare (special $ldprint))
;--- autorunlisp :: check if this lisp is supposed to run a program right
; away.
;
(defun autorunlisp nil
  (cond ((and (> (argv -1) 2) (equal (argv 1) '-f))
	 (let ((progname (argv 2))
	       ($ldprint nil)
	       (searchlist nil))	; don't give fasl messages
	      (setq searchlist (cvtsearchpathtolist (getenv 'PATH)))
	      ; give two args to load to insure that a fasl is done.
	      (cond ((null 
		      (errset (load-autorunobject progname searchlist)))
		     (exit 0))
		    (t t))))))


(defun cvtsearchpathtolist (path)
  (do ((x (explodec path) (cdr x))
       (names nil)
       (cur nil))
      ((null x) 
       (nreverse names))
      (cond ((or (eq ': (car x)) 
		 (and (null (cdr x)) (setq cur (cons (car x) cur))))
	     (cond (cur (setq names (cons (implode (nreverse cur))
					  names))
			(setq cur nil))
		   (t (setq names (cons '|.| names)))))
	    (t (setq cur (cons (car x) cur))))))

(defun load-autorunobject (name search)
  (cond ((memq (getchar name 1) '(/ |.|))
	 (cond ((probef name) (fasl name))
	       (t (error "From lisp autorun: can't find file to load"))))
	(t (do ((xx search (cdr xx))
		(fullname))
	       ((null xx) (error "Can't find file to execute "))
	       (cond ((probef (setq fullname (concat (car xx) "/" name)))
		      (return (fasl-a-file fullname nil nil))))))))

;--- command-line-args :: return a list of the command line arguments
; The list does not include the name of the program being executed (argv 0).
; It also doesn't include the autorun flag and arg.
;
(defun command-line-args ()
   (do ((res nil (cons (argv i) res))
	(i (1- (argv -1)) (1- i)))
       ((<& i 1)
	(if (and (eq '-f (car res))
		 (cdr res))
	   then (cddr res)
	   else res))))

(defun debug fexpr (args)
  (load 'fix)	; load in fix package
  (eval (cons 'debug args)))	; enter debug through eval

;-- default autoloader properties

(putprop 'trace (concat lisp-library-directory "/trace") 'autoload)
(putprop 'untrace (concat lisp-library-directory "/trace") 'autoload)

(putprop 'step (concat lisp-library-directory "/step") 'autoload)
(putprop 'editf (concat lisp-library-directory "/cmuedit") 'autoload)
(putprop 'editv (concat lisp-library-directory "/cmuedit") 'autoload)
(putprop 'editp (concat lisp-library-directory "/cmuedit") 'autoload)
(putprop 'edite (concat lisp-library-directory "/cmuedit") 'autoload)

(putprop 'defstruct (concat lisp-library-directory "/struct") 'macro-autoload)
(putprop 'defstruct-expand-ref-macro
	 (concat lisp-library-directory "/struct") 'autoload)
(putprop 'defstruct-expand-cons-macro
	 (concat lisp-library-directory "/struct") 'autoload)
(putprop 'defstruct-expand-alter-macro
         (concat lisp-library-directory "/struct") 'autoload)

(putprop 'loop      (concat lisp-library-directory "/loop")   'macro-autoload)
(putprop 'defflavor
	 (concat lisp-library-directory "/flavors") 'macro-autoload)
(putprop 'defflavor1
	 (concat lisp-library-directory "/flavors") 'autoload)

(putprop 'format (concat lisp-library-directory "/format") 'autoload)
(putprop 'ferror (concat lisp-library-directory "/format") 'autoload)

(putprop 'make-hash-table
	 (concat lisp-library-directory "/hash") 'autoload)
(putprop 'make-equal-hash-table
	 (concat lisp-library-directory "/hash") 'autoload)

(putprop 'describe (concat lisp-library-directory "/describe") 'autoload)

(putprop 'cgol (concat lisp-library-directory "/cgol/cgoll")   'autoload)
(putprop 'cgolprint (concat lisp-library-directory "/cgol/cgp")   'autoload)

; probably should be in franz so we don't have to autoload
(putprop 'displace  (concat lisp-library-directory "/machacks")   'autoload)

(putprop 'defrecord (concat lisp-library-directory "/record") 'macro-autoload)
(putprop 'record-pkg-construct
   (concat lisp-library-directory "/record") 'autoload)
(putprop 'record-pkg-access
   (concat lisp-library-directory "/record") 'autoload)
(putprop 'record-pkg-illegal-access
   (concat lisp-library-directory "/record") 'autoload)
EndOfFile
cat >  lisplib/syntax.l  << 'EndOfFile'
(setq rcs-syntax-
   "$Header: /usr/lib/lisp/syntax.l,v 1.1 83/01/29 18:40:24 jkf Exp $")

;;
;; syntax.l				-[Sat Jan 29 18:28:58 1983 by jkf]-
;;
;; contains the user callable setsyntax function
;;


;--- setsyntax :: new version of setsyntax
;  this version allows symbolic syntax codes.
;
(declare
   (special syntax:symbolic-to-old-fixnum ;; for upward compatibility
	    				; use this to map from old
					; fixnums to symbolic names
	    syntax:symbolic-bits-to-fixnum ;; bit definitions of symbolic
	    				   ;bits.  see h/chars.h
	    syntax:code-to-bits  	;; used at runtime to
	    				; interpret symbolic names
	    readtable			;; current readtable
   ))


(def setsyntax
   (lexpr (n)
	  (cond ((not (or (equal n 2) (equal n 3)))
		 (error "setsyntax: 2 or 3 args required, not " n)))
	  ; determine the correct code
	  (prog (given ch number)
	     (setq given (arg 2)
		   ch    (arg 1))
	     (cond ((and (not (numberp ch))
			 (not (symbolp ch)))
		    (error "setsyntax: first arg must be a number or symbol: "
			   ch)))
	     (cond ((numberp given)
		    ; using the old fixnum values (we suppose)
		    (cond ((setq number
				 (rassq given syntax:symbolic-to-old-fixnum))
			   (setq given (car number))) ; use symbolic name
			  (t (error "setsyntax: fixnum code is not defined: "
				    given)))))
	     (cond ((symbolp given)
		    ; convert from common names to our symbolic names
		    (cond ((eq 'macro given)
			   (setq given 'vmacro))
			  ((eq 'splicing given)
			   (setq given 'vsplicing-macro)))
		    ; now see if the symbolic name is defined
		    (cond ((setq number (assq given syntax:code-to-bits))
			   (setq number (cdr number)))
			  (t (error "setsyntax: unknown symbolic code: "
				    given))))
		   (t (error "setsyntax: second arg not symbol or fixnum: "
			     given)))
	     ; now call the low level code to set the value.
	     (int:setsyntax (arg 1) number)		;;; change to *
	     ; the final argument is placed on the property list of the
	     ; first argument, with the indicator being the current readtable,
	     ; thus you can have more than one macro function for each
	     ; character for each readtable.
	     (cond ((equal n 3)
		    (cond ((numberp ch) (setq ch (ascii ch))))   ; need symbol
		    (putprop ch (arg 3) readtable))))
   t))
	     

(def getsyntax
   (lambda (ch)
      (let ((res (int:getsyntax ch))   ; this will be modified too
	    (symb))
	 (cond ((setq symb (rassq res syntax:code-to-bits))
		(car symb))
	       (t (error "getsyntax: no symbolic code corresponds to: "
			 res))))))


;--- add-syntax-class : add a new symbolic syntax class
; name is the name which we will use to refer to it.
; bits are a list of symbolic bit names for it.
; modifies global variable: syntax:code-to-bits
;
(def add-syntax-class
   (lambda (name bits)
      (cond ((not (symbolp name))
	     (error "add-syntax-class: illegal name: " name)))
      (cond ((not (dtpr bits))
	     (error "add-syntax-class: illegal bits: " bits)))
      (do ((xx bits (cdr xx))
	   (this 0)
	   (num 0))
	  ((null xx)
	   (cond ((setq this (assq name syntax:code-to-bits))
		  (rplacd this num))	; replace old value
		 (t (setq syntax:code-to-bits (cons (cons name num)
						    syntax:code-to-bits)))))
	  (cond ((setq this (assq (car xx) syntax:symbolic-bits-to-fixnum))
		 ;(format t "num:~d, oth:~a, comb:~d~%"
			; num (cdr this) (apply 'boole `(7 ,num ,(cdr this))))
		 (setq num (boole 7 num (cdr this)))
		 ;(format t "res: ~d~%" num)
		 )   ; logical or
		(t (error "illegal syntax code " (car xx)))))
      name))

(setq syntax:symbolic-to-old-fixnum
       '((vnumber . 0) (vsign . 1) (vcharacter . 2)
	 (vsingle-character-symbol . 66.)
	 (vleft-paren . 195.) (vright-paren . 196.)
	 (vperiod . 133.)
	 (vleft-bracket . 198.) (vright-bracket . 199.) (veof . 200.)
	 (vsingle-quote . 201.) (vsymbol-delimiter . 138.)
	 (vstring-delimiter . 137.)
	 (villegal . 203.) (vseparator . 204.)
	 (vsplicing-macro . 205.) (vmacro . 206.)
	 (vescape . 143.))
   syntax:symbolic-bits-to-fixnum 
       '(; character classes
	   (cnumber . 0) (csign . 1) (ccharacter . 2)
	   (cleft-paren . 3)
	   (cright-paren . 4) (cperiod . 5) (cleft-bracket . 6)
	   (cright-bracket . 7)
	   (csingle-quote . 9.) (csymbol-delimiter . 10.) (cillegal . 11.)
	   (cseparator . 12.) (csplicing-macro . 13.)
	   (cmacro . 14.) (cescape . 15.) (csingle-character-symbol . 16.)
	   (cstring-delimiter . 17.)
	   (csingle-macro . 18.) (csingle-splicing-macro . 19.)
	   (cinfix-macro . 20.)
	   (csingle-infix-macro . 21.)
	  ; escape bits
	   (escape-when-unique . 64.)
	   (escape-when-first . 128.)
	   (escape-always . 192.)
	  ; separator
	   (separator . 32.))
   syntax:code-to-bits nil)
       
(add-syntax-class 'vnumber  	'(cnumber))
(add-syntax-class 'vsign 	'(csign))
(add-syntax-class 'vcharacter 	'(ccharacter))
(add-syntax-class 'vleft-paren 	'(cleft-paren escape-always separator))
(add-syntax-class 'vright-paren	'(cright-paren escape-always separator))
(add-syntax-class 'vperiod 	'(cperiod escape-when-unique))
(add-syntax-class 'vleft-bracket '(cleft-bracket escape-always separator))
(add-syntax-class 'vright-bracket '(cright-bracket escape-always separator))
(add-syntax-class 'vsingle-quote '(csingle-quote escape-always separator))
(add-syntax-class 'vsymbol-delimiter 	'(csymbol-delimiter escape-always))
(add-syntax-class 'villegal 	'(cillegal escape-always separator))
(add-syntax-class 'vseparator 	'(cseparator escape-always separator))
(add-syntax-class 'vsplicing-macro '(csplicing-macro escape-always separator))
(add-syntax-class 'vmacro 	'(cmacro escape-always separator))
(add-syntax-class 'vescape 	'(cescape escape-always))
(add-syntax-class 'vsingle-character-symbol
   		  '(csingle-character-symbol separator))
(add-syntax-class 'vstring-delimiter	'(cstring-delimiter escape-always))
(add-syntax-class 'vsingle-macro '(csingle-macro escape-when-unique))
(add-syntax-class 'vsingle-splicing-macro
     		 '(csingle-splicing-macro escape-when-unique))
(add-syntax-class 'vinfix-macro '(cinfix-macro escape-always separator))
(add-syntax-class 'vsingle-infix-macro
                  '(csingle-infix-macro escape-when-unique))


EndOfFile
cat >  lisplib/macros.l  << 'EndOfFile'
(setq rcs-macros-
   "$Header: macros.l,v 1.6 83/11/09 07:09:42 jkf Exp $")

;; macros.l				-[Wed Nov  9 07:09:26 1983 by jkf]-
;;
;;  The file contains the common macros for Franz lisp.
;; contents:
;;	defmacro
;;	setf
;;	defsetf
;;	push
;;	pop
;;	let
;;	let*
;;	caseq
;;	listify
;;	include-if
;;	includef-if
;;	defvar


(declare (macros t))

;; defmacro
(declare (special defmacrooptlist protect-list protect-evform))

;--- defmacro - name - name of macro being defined
;	      - pattrn - formal arguments plus other fun stuff
;	      - body   - body of the macro
; This is an intellegent macro creator.  The pattern may contain
; symbols which are formal paramters, lists which show how the
; actual paramters will appear in the args, and these key words
;  &rest name  - the rest of the args (or nil if there are no other args)
;		 is bound to name
;  &optional name - bind the next arg to name if it exists, otherwise
;		    bind it to nil
;  &optional (name init) - bind the next arg to name if it exists, otherwise
;		    bind it to init evaluted. (the evaluation is done left
;		    to right for optional forms)
;  &optional (name init given) - bind the next arg to name and given to t
;		    if the arg exists, else bind name to the value of
;		    init and given to nil.
;  &aux name
;  &aux (name init)
;
; Method of operation:
;  the list returned from defmcrosrc has the form ((cxxr name) ...)
;	where cxxr is the loc of the macro arg and name is it formal name
;  defmcrooptlist has the form ((initv cxxr name) ...)
; which is use for &optional args with an initial value.
;  here cxxr looks like cdd..dr which will test of the arg exists.
;
; the variable defmacro-for-compiling determines if the defmacro forms
; will be compiled. If it is t, then we return (progn 'compile (def xx..))
; to insure that it is compiled
;
(declare (special defmacro-for-compiling))
(cond ((null (boundp 'defmacro-for-compiling))   ; insure it has a value
       (setq defmacro-for-compiling nil)))

(def defmacro
  (macro (args)
    ((lambda 
       (tmp tmp2 defmacrooptlist body protect-evform protect-list gutz)
       (setq tmp (defmcrosrch (caddr args) '(d r) nil)
	     body
	     `(def ,(cadr args)
		   (macro (defmacroarg)
		     ((lambda ,(mapcar 'cdr tmp)
			      ,@(mapcar 
				   '(lambda (arg)
				      `(cond ((setq ,(caddr arg)
						    (,(cadr arg) 
						      defmacroarg))
					      ,@(cond ((setq tmp2 (cadddr arg))
						       `((setq ,tmp2 t))))
					      (setq ,(caddr arg)
						    (car ,(caddr arg))))
					     (t (setq ,(caddr arg)
						      ,(car arg)))))
					defmacrooptlist)
			      ,@(cond (protect-evform 
				       (setq gutz 
					     (eval `((lambda ,(mapcar 'cdr tmp)
							     ,@(cdddr args))
						     ,@(mapcar
							'(lambda (x) `',(cdr x))
							tmp))))
				       (ncons 
					`(cond (,protect-evform
						      (copy
							 `((lambda ,',(mapcar 'cdr tmp)
							      ,',gutz)
							   ,,@(mapcar 'cdr tmp))))
					       (t ,@(cdddr args)))))
				      (t (cdddr args))))
		      ,@(mapcar '(lambda (arg) 
					 (cond ((dtpr (car arg))
						(caar arg))
					       ((car arg)
						`(,(car arg) defmacroarg))))
			       tmp)))))
      (cond (defmacro-for-compiling `(progn 'compile ,body))
	    (t body)))

     nil nil nil nil nil nil nil)))

(def defmcrosrch
  (lambda (pat form sofar)
	  (cond ((null pat) sofar)
		((atom pat) (cons (cons (concatl `(c ,@form)) pat)
				  sofar))
		((memq (car pat) '(&rest &body))
		 (append (defmcrosrch (cadr pat) form nil)
		 	 (defmcrosrch (cddr pat) form sofar)))
		((eq (car pat) '&optional)
		 (defmcrooption (cdr pat) form sofar))
		((eq (car pat) '&protect)
		 (setq protect-list (cond ((atom (cadr pat))
					   (ncons (cadr pat)))
					  (t (cadr pat)))
		       protect-evform (cons 'or (mapcar '(lambda (x)
								 `(dtpr ,x))
							protect-list)))
		 (defmcrosrch (cddr pat) form sofar))
		((eq (car pat) '&aux)
		 (mapcar '(lambda (frm)
				  (cond ((atom frm) `((nil) . ,frm))
					(t `((,(cadr frm)) . ,(car frm)))))
			 (cdr pat)))
		(t (append (defmcrosrch (car pat) (cons 'a form) nil)
			   (defmcrosrch (cdr pat) (cons 'd form) sofar))))))

(def defmcrooption
  (lambda (pat form sofar)
    ((lambda (tmp tmp2)
	  (cond ((null pat) sofar)
		((memq (car pat) '(&rest &body))
		 (defmcrosrch (cadr pat) form sofar))
		(t (cond ((atom (car pat))
			  (setq tmp (car pat)))
			 (t (setq tmp (caar pat))
			    (setq defmacrooptlist 
				  `((,(cadar pat) 
				        ,(concatl `(c ,@form))
				        ,tmp
				        ,(setq tmp2 (caddar pat)))
				    . ,defmacrooptlist))))
		   (defmcrooption 
			(cdr pat) 
			(cons 'd form) 
			`( (,(concatl `(ca ,@form)) . ,tmp)
			   ,@(cond (tmp2 `((nil . ,tmp2))))
			  . ,sofar)))))
     nil nil)))


;--- lambdacvt	:: new lambda converter.
;
; - input is  a lambda body beginning with the argument list.
;
; vrbls   :: list of (name n) where n is the arg number for name
; optlist :: list of (name n defval pred) where optional variable name is
;	     (arg n) [if it exists], initval is the value if it doesn't
;	     exist,  pred is set to non nil if the arg exists
; auxlist :: list of (name initial-value) for auxillary variables. (&aux)
; restform :: (name n) where args n to #args should be consed and assigned
;		to name.
;
;; strategy:
;  Until the compiler can compiler lexprs better, we try to avoid creating
; a lexpr.  A lexpr is only required if &optional or &rest forms
; appear.
;   Formal parameters which come after &aux are bound and evaluated in a let*
; surrounding the body.  The parameter after a &rest is put in the let*
; too, with an init form which is a complex do loop.  The parameters
; after &optional are put in the lambda expression just below the lexpr.
;
(defun lambdacvt (exp)
   (prog (vrbls optlist auxlist restform vbl fl-type optcode mainvar
	  minargs maxargs)
      (do ((reallist (car exp) (cdr reallist))
	   (count 1 (1+ count)))
	  ((null reallist))
	  (setq vbl (car reallist))
	  (cond ((memq vbl '(&rest &body))
		 (setq fl-type '&rest count (1- count)))
		((eq '&aux vbl)
		 (setq fl-type '&aux count (1- count)))
		((eq '&optional vbl)
		 (setq fl-type '&optional count (1- count)))
		((null fl-type)		 ; just a variable
		 (setq vrbls (cons (list vbl count) vrbls)))
		((eq fl-type '&rest)
		 (cond (restform (error "Too many &rest parameters " vbl)))
		 (setq restform (list vbl count)))
		((eq fl-type '&aux)
		 (cond ((atom vbl)
			(setq auxlist (cons (list vbl nil) auxlist)))
		       (t (setq auxlist (cons (list (car vbl) (cadr vbl))
					      auxlist)))))
		((eq fl-type '&optional)
		 (cond ((atom vbl)
			(setq optlist
			      (cons (list vbl count) optlist)))
		       (t (setq optlist
				(cons (cons (car vbl)
					    (cons count
						  (cdr vbl)))
				      optlist)))))))

      ;; arguments are collected in reverse order, but set them straight
      (setq vrbls (nreverse vrbls)
	    optlist (nreverse optlist)
	    auxlist (nreverse auxlist)
	    minargs (length vrbls)
	    maxargs (cond (restform nil)
			  (t (+ (length optlist) minargs))))

      ;; we must covert to a lexpr if there are &optional or &rest forms
      (cond ((or optlist restform) (setq mainvar (gensym))))
      
      ; generate optionals code
      (cond (optlist
	       (setq optcode
		     (mapcar '(lambda (x)
				 `(cond ((> ,(cadr x) ,mainvar)
					 (setq ,(car x) ,(caddr x)))
					(t (setq ,(car x)
						  (arg ,(cadr x)))
					   ,(cond ((cdddr x)
						   `(setq ,(cadddr x) t))))))
			     optlist))))

      ;; do the rest forms
      (cond (restform
	       (let ((dumind (gensym))
		     (dumcol (gensym)))
		  (setq restform
			`((,(car restform)
			    (do ((,dumind ,mainvar (1- ,dumind))
				 (,dumcol nil (cons (arg ,dumind) ,dumcol)))
				((< ,dumind ,(cadr restform)) ,dumcol))))))))
      
      ;; calculate body
      (let (body)
	 (setq body (cond ((or auxlist restform)
			     `((let* ,(append restform auxlist)
				  ,@(cdr exp))))
			  (t (cdr exp))))
	 (cond ((null mainvar)		; no &optional or &rest
		(return `(lambda ,(mapcar 'car vrbls)
			    (declare (*args ,minargs ,maxargs))
			    ,@body)))
	       (t (return
		     `(lexpr (,mainvar)
			 (declare (*args ,minargs ,maxargs))
			 ((lambda
			     ,(nconc
				 (mapcar 'car vrbls)
				 (mapcan '(lambda (x) 	; may be two vrbls
					     (cons (car x)
						   (cond ((cdddr x) ;pred?
							  (ncons
							     (cadddr x))))))
					 optlist))
			     ,@optcode ,@body)
			  ,@(nconc (mapcar '(lambda (x) `(arg ,(cadr x)))
					   vrbls)
				   (mapcan '(lambda (x)
					       (cond ((cdddr x)
						      (list nil nil))
						     (t (list nil))))
					   optlist))))))))))

;--- defcmacro :: like defmacro but result ends up under cmacro ind
;
(def defcmacro
   (macro (args)
	(let ((name (concat (cadr args) "::cmacro:" (gensym))))
	   `(eval-when (compile load eval)
		    (defmacro ,name ,@(cddr args))
		    (putprop ',(cadr args) (getd ',name) 'cmacro)
		    (remob ',name)))))

;;; --- setf macro
;
;(setf (cadr x) 3) --> (rplaca (cdr x) 3)

(defmacro setf (expr val &rest rest)
	  (cond ((atom expr)
		 (or (symbolp expr)
		     (error '|-- setf can't handle this.| expr))
		 `(setq ,expr ,val))
		(t
		 (do ((y)
		      (tmp))
		     (nil)
		     (and (dtpr (car expr))
			  (setq tmp
				(setf-record-package-access-check expr val))
			  (return tmp))
		     (or (symbolp (car expr))
			 (error '|-- setf can't handle this.| expr))
		     (and (setq y (get (car expr) 'setf-expand))
			  (return (apply y `(,expr ,val ,@rest))))
		     (or (setf-check-cad+r (car expr))
			 (and
			    (or (setq y (get (car expr) 'cmacro))
				(setq y (getd (car expr))))
			    (or (and (dtpr y)
				     (eq (car y) 'macro))
				(and (bcdp y)
				     (eq (getdisc y) 'macro)))
			    (setq expr (apply y expr)))
			 (error '|-- setf can't handle this.| expr))))))

(defun setf-check-cad+r (name)
   ;; invert all c{ad}+r combinations
   (if (eq (getcharn name 1) #/c)
      then (let ((letters (nreverse (cdr (exploden name)))))
	      (if (eq (car letters) #/r)
		 then (do ((xx (cdr letters) (cdr xx)))
			  ((null xx)
			   ;; form is c{ad}+r, setf form is
			   ;; (rplac<first a or d> (c<rest of a's + d's>r x))
			   (setq letters (nreverse letters))
			   (eval
			      `(defsetf ,name (e v)
				  (list
				     ',(concat "rplac" (ascii (car letters)))
				      (list
					 ',(implode `(#/c ,@(cdr letters)))
					 (cadr e))
				      v)))
			   t)
			  (if (not (memq (car xx) '(#/a #/d)))
			      then (return nil)))))))

(defun setf-record-package-access-check (form val)
   ;; When the record package is given the 'access-check' flag,
   ;; the access macros it generates have this form:
   ;; ((lambda (defrecord-acma)
   ;;    (cond (...)
   ;;          (t (access-form))))
   ;;   res)
   ;; To invert this, we make a copy of the form and replace the
   ;; access-form with (setf (access-form) val)
   ;;
   ;; we return nil if the form passed isn't a recognized form
   ;;
   (cond ((and (dtpr form)
	       (dtpr (car form))
	       (eq 'lambda (car (car form)))
	       (dtpr (cadr (car form)))
	       (eq (car (cadr (car form)))
		   'defrecord-acma))
	  ((lambda (newform acc)
	      ; newform is a copy of the given form, so we can
	      ; clobber it
	      ; locate the second clause of the cond
	      (setq acc (cadr 	;; right the 't'
			  (caddr  ;; second cond clause
			    (caddr  ;; cond is third thing in lambda
			       (car newform)))))
	      (rplaca (cdaddaddar newform) (list 'setf acc val))
	      newform)
	   (copy form) nil))
	 (t nil)))
		      
(defmacro defsetf (name vars &rest body)
	  `(eval-when 
	    (compile load eval)
	    (defun (,name setf-expand) ,vars . ,body)))

;--- other setf's for car's and cdr's are generated automatically
;
(defsetf car (e v) `(rplaca ,(cadr e) ,v))
(defsetf caar (e v) `(rplaca (car ,(cadr e)) ,v))
(defsetf cadr (e v) `(rplaca (cdr ,(cadr e)) ,v))
(defsetf cdr (e v) `(rplacd ,(cadr e) ,v))
(defsetf cdar (e v) `(rplacd (car ,(cadr e)) ,v))
(defsetf cddr (e v) `(rplacd (cdr ,(cadr e)) ,v))
(defsetf cxr (e v) `(rplacx ,(cadr e) ,(caddr e) ,v))

(defsetf vref (e v) `(vset ,(cadr e) ,(caddr e) ,v))
(defsetf vrefi-byte (e v) `(vseti-byte ,(cadr e) ,(caddr e) ,v))
(defsetf vrefi-word (e v) `(vseti-word ,(cadr e) ,(caddr e) ,v))
(defsetf vrefi-long (e v) `(vseti-long ,(cadr e) ,(caddr e) ,v))

(defsetf nth (e v) `(rplaca (nthcdr ,(cadr e) ,(caddr e)) ,v))
(defsetf nthelem (e v) `(rplaca (nthcdr (1- ,(cadr e)) ,(caddr e)) ,v))
(defsetf nthcdr (e v) `(rplacd (nthcdr (1- ,(cadr e)) ,(caddr e)) ,v))

(defsetf arraycall (e v) `(store ,e ,v))
(defsetf get (e v) `(putprop ,(cadr e) ,v ,(caddr e)))

(defsetf plist (e v) `(setplist ,(cadr e) ,v))

(defsetf symeval (e v) `(set ,(cadr e) ,v))

(defsetf arg (e v) `(setarg ,(cadr e) ,v))

(defsetf args (e v) `(args ,(cadr e) ,v))


(defmacro push (object list) `(setf ,list (cons ,object ,list)))

; this relies on the fact that setf returns the value stored.
(defmacro pop (list &optional (into nil into-p))
  (cond (into-p `(prog1 (setf ,into (car ,list))
                        (setf ,list (cdr ,list))))
        (t `(prog1 (car ,list)
                   (setf ,list (cdr ,list))))))

; let for franz (with destructuring)
;--- let
;	- binds - binding forms
;	- . body - forms to execute
; the binding forms may have these forms
;   a	local variable a, initially nil
;  (a x)  local variable a, x is evaled and a gets its value initially
;  ((a . (b . c)) x)   three local variables, a,b and c which are given
;			values corresponding to the location in the value
;		        of x.  Any structure is allowed here. 
;
(defmacro let (binds &rest body &aux vrbls vals destrs newgen)
  (mapc '(lambda (form)
		(cond ((atom form)
		       (setq vrbls (cons form vrbls)
			     vals  (cons nil vals)))
		      ((atom (car form))
		       (setq vrbls (cons (car form) vrbls)
			     vals  (cons (cadr form) vals)))
		      (t (setq newgen (gensym)
			       destrs `((,newgen ,@(de-compose (car form) '(r)))
					,@destrs)
			       vrbls  (cons newgen vrbls)
			       vals   (cons (cadr form) vals)))))
       binds)

  (mapc '(lambda (frm)
		(do ((ll (cdr frm) (cdr ll)))
		    ((null ll))
		    (setq vrbls (cons (cdar ll) vrbls)
			  vals  (cons nil vals))))
       destrs)

  (setq vals (nreverse vals)
	vrbls (nreverse vrbls)
	destrs (nreverse destrs))
  `((lambda ,vrbls
	    ,@(mapcan '(lambda (frm)
			       (mapcar '(lambda (vrb)
						`(setq ,(cdr vrb) (,(car vrb)
								  ,(car frm))))
				       (cdr frm)))
		      destrs)
	    ,@body)
    ,@vals))

;--- de-compose
;		form - pattern to de-compose
;		sofar - the sequence of cxxr's needed to get to this part
;			of the pattern
;  de-compose returns a list of this form
;
;	((cxxr . a) (cyyr . b) ... )
; which tells how to get to the value for a and b ..etc..
;
(def de-compose 
  (lambda (form sofar)
	  (cond ((null form ) nil)
		((atom form) (ncons (cons (apply 'concat (cons 'c sofar))
					  form)))
		(t (nconc (de-compose (car form) (cons 'a sofar))
			  (de-compose (cdr form) (cons 'd sofar)))))))

;--- caseq
; use is 
;    (caseq expr
;	    (match1 do1)
;	    (match2 do2)
;	    (t  doifallelsefails))
; the matchi can be atoms in which case an 'eq' test is done, or they
; can be lists in which case a 'memq' test is done.
;

(defmacro caseq (switch &body clauses &aux var code)
   (setq var (cond ((symbolp switch) switch) ((gensym 'Z))))
   (setq code
	 `(cond . ,(mapcar '(lambda (clause)
			       (cons
				  (let ((test (car clause)))
				     (cond ((eq test t) t)
					   ((dtpr test)
					    `(memq ,var ',test))
					   (t `(eq ,var ',test))))
				  (cdr clause)))
			   clauses)))
   (cond ((symbolp switch) code)
	 (`((lambda (,var) ,code) ,switch))))

;--- selectq :: just like caseq
; except 'otherwise' is recogized as equivalent to 't' as a key
;
(defmacro selectq (key . forms)
	  (setq forms
		(mapcar '(lambda (form) (if (eq (car form) 'otherwise)
					     (cons t (cdr form)) form))
			forms))
	  `(caseq ,key . ,forms))

;--- let*
;	- binds  - binding forms (like let)
;	- body   - forms to eval (like let)
; this is the same as let, except forms are done in a left to right manner
; in fact, all we do is generate nested lets
;
(defmacro let* (binds &rest body)
  (do ((ll (reverse binds) (cdr ll)))
      ((null ll) (car body))
      (setq body `((let (,(car ll)) ,@body)))))


		   
;--- listify : n  - integer
;	returns a list of the first n args to the enclosing lexpr if
; n is positive, else returns the last -n args to the lexpr if n is
; negative.
; returns nil if n is 0
;
(def listify 
  (macro (lis)
	 `(let ((n ,(cadr lis)))
	       (cond ((eq n 0) nil)
		     ((minusp n)
		      (do ((i (arg nil)  (1- i))
			   (result nil (cons (arg i) result)))
			  ((<& i (+ (arg nil) n  1)) result) ))
		     (t (do ((i n  (1- i))
			     (result nil (cons (arg i) result)))
			    ((<& i 1) result) ))))))

;--- include-if
; form: (include-if <predicate> <filename>)
;  will return (include <filename>) if <predicate> is non-nil
;  This is useful at the beginning of a file to conditionally
;  include a file based on whether it has already been included.
;
(defmacro include-if (pred filename)
   (cond ((eval pred) `(include ,filename))))

;--- includef-if
; form: (includef-if <predicate> '<filename>)
;  like the above except it includef's the file.
;
(defmacro includef-if (pred filenameexpr)
   (cond ((eval pred) `(includef ,filenameexpr))))

;--- if :: macro for doing conditionalization
;
;  This macro is compatible with both the crufty mit-version and
; the keyword version at ucb.
;
;  simple summary:
;   non-keyword use:
;	(if a b) ==> (cond (a b))
;	(if a b c d e ...) ==> (cond (a b) (t c d e ...))
;   with keywords:
;	(if a then b) ==> (cond (a b))
;	(if a thenret) ==> (cond (a))
;	(if a then b c d e) ==> (cond (a b c d e))
;	(if a then b c  else d) ==> (cond (a b c) (t d))
;	(if a then b c  elseif d  thenret  else g)
;		==> (cond (a b c) (d) (t g))
;
;   
;
;
; In the syntax description below,
;    optional parts are surrounded by [ and ],
;    + means one or more instances.
;    | means 'or'
;    <expr> is an lisp expression which isn't a keyword
;       The keywords are:  then, thenret, else, elseif.
;    <pred> is also a lisp expression which isn't a keyword.
; 
; <if-stmt> ::=  <simple-if-stmt>
; 	       | <keyword-if-stmt>
; 
; <simple-if-stmt> ::=  (if <pred> <expr>)
; 		      | (if <pred> <expr> <expr>)
; 
; <keyword-if-stmt> ::= (if <pred> <then-clause> [ <else-clause> ] )
; 
; <then-clause> ::=  then <expr>+
; 		   | thenret
; 
; <else-clause> ::=  else <expr>+
; 		   | elseif <pred> <then-clause> [ <else-clause> ]
;

(declare (special if-keyword-list))

(eval-when (compile load eval)
   (setq if-keyword-list '(then thenret elseif else)))

;--- if
;
;  the keyword if expression is parsed using a simple four state
; automaton.  The expression is parsed in reverse.
; States:
;	init - have parsed a complete predicate,  then clause
;	col  - have collected at least one non keyword in col
;	then - have just seen a then, looking for a predicate
;	compl - have just seen a predicate after an then, looking
;		for elseif or if (i.e. end of forms).
;
(defmacro if (&rest args)
   (let ((len (length args)))
      ;; first eliminate the non-keyword if macro cases
      (cond ((<& len 2)
	     (error "if: not enough arguments " args))
	    ((and (=& len 2)
		  (not (memq (cadr args) if-keyword-list)))
	     `(cond (,(car args) ,(cadr args))))
	    ; clause if there are not keywords (and len > 2)
	    ((do ((xx args (cdr xx)))
		 ((null xx) t)
		 (cond ((memq (car xx) if-keyword-list)
			(return nil))))
	     `(cond (,(car args) ,(cadr args))
		    (t ,@(cddr args))))
	    
	    ;; must be an instance of a keyword if macro
	    
	    (t (do ((xx (reverse args) (cdr xx))
		    (state 'init)
		    (elseseen nil)
		    (totalcol nil)
		    (col nil))
		   ((null xx)
		    (cond ((eq state 'compl)
			   `(cond ,@totalcol))
			  (t (error "if: illegal form " args))))
		   (cond ((eq state 'init)
			  (cond ((memq (car xx) if-keyword-list)
				 (cond ((eq (car xx) 'thenret)
					(setq col nil
					      state 'then))
				       (t (error "if: bad keyword "
						 (car xx) args))))
				(t (setq state 'col
					 col nil)
				   (push (car xx) col))))
			 ((eq state 'col)
			  (cond ((memq (car xx) if-keyword-list)
				 (cond ((eq (car xx) 'else)
					(cond (elseseen
						 (error
						    "if: multiples elses "
						    args)))
					(setq elseseen t)
					(setq state 'init)
					(push `(t ,@col) totalcol))
				       ((eq (car xx) 'then)
					(setq state 'then))
				       (t (error "if: bad keyword "
						 (car xx) args))))
				(t (push (car xx) col))))
			 ((eq state 'then)
			  (cond ((memq (car xx) if-keyword-list)
				 (error "if: keyword at the wrong place "
					(car xx) args))
				(t (setq state 'compl)
				   (push `(,(car xx) ,@col) totalcol))))
			 ((eq state 'compl)
			  (cond ((not (eq (car xx) 'elseif))
				 (error "if: missing elseif clause " args)))
			  (setq state 'init))))))))

;--- If :: the same as 'if' but defined for those programs that still
;	use it.
;
(putd 'If (getd 'if))

;--- defvar :: a macro for declaring a variable special
;  a variable declared special with defvar will be special when the
; file containing the variable is compiled and also when the file
; containing the defvar is loaded in.  Furthermore, you can specify
; an default value for the variable. It will be set to that value
; iff it is unbound
;
(defmacro defvar (variable &optional (initial-value nil iv-p) documentation)
  (if iv-p
     then `(progn 'compile
		   (eval-when (eval compile load)
			  (eval '(liszt-declare (special ,variable))))
		   (or (boundp ',variable) (setq ,variable ,initial-value)))
     else `(eval-when (eval compile load)
		  (eval '(liszt-declare (special ,variable))))))




(defmacro list* (&rest forms)
	  (cond ((null forms) nil)
		((null (cdr forms)) (car forms))
		(t (construct-list* forms))))

(eval-when (load compile eval)
   (defun construct-list* (forms)
	  (setq forms (reverse forms))
	  (do ((forms (cddr forms) (cdr forms))
	       (return-form `(cons ,(cadr forms) ,(car forms))
			     `(cons ,(car forms) ,return-form)))
	      ((null forms) return-form))))

;; (<= a b) --> (not (> a b))
;; (<= a b c) --> (not (or (> a b) (> b c)))
;; funny arglist to check for correct number of arguments.


(defmacro <= (arg1 arg2 &rest rest &aux result)
  (setq rest (list* arg1 arg2 rest))
  (do l rest (cdr l) (null (cdr l))
      (push `(> ,(car l) ,(cadr l)) result))
  (cond ((null (cdr result)) `(not ,(car result)))
	(t `(not (or . ,(nreverse result))))))

(defmacro <=& (x y)
   `(not (>& ,x ,y)))

;; (>= a b) --> (not (< a b))
;; (>= a b c) --> (not (or (< a b) (< b c)))
;; funny arglist to check for correct number of arguments.

(defmacro >= (arg1 arg2 &rest rest &aux result)
  (setq rest (list* arg1 arg2 rest))
  (do l rest (cdr l) (null (cdr l))
      (push `(< ,(car l) ,(cadr l)) result))
  (cond ((null (cdr result)) `(not ,(car result)))
	(t `(not (or . ,(nreverse result))))))


(defmacro >=& (x y)
   `(not (<& ,x ,y)))
EndOfFile
cat >  lisplib/vector.l  << 'EndOfFile'
(setq rcs-vector-
   "$Header: vector.l 1.5 83/07/30 15:35:51 layer Exp $")

;; vector handling functions	-[Sun Jun 19 15:09:14 1983 by jkf]-
;; [also contains closure functions]
;;
;; preliminary.  this is subject to change at any moment.
;; Don't use the functions in this file!!	--jkf
;;
;; contains functions:
;;  vector{,i-byte,i-word,i-long}   : create and initialize
;;  vref{,i-byte,i-word,i-long}	 : reference
;;  vset{,i-byte,i-word,i-long}	 : set
;;  vsize	-- must write
;;  vsize-word
;;  vsize-byte 
;;
;; references external functions
;;  new-vector{,i-byte,i-word,i-long
;;
;; references internal functions:
;;  int:vref 'vect 'index 'class
;;  int:vset 'vect 'index 'value 'class
;;  int:vsize 'vect

;--- vector
;  call is (vector elmt0 elmt1 ... elmtn)
; creates an n-1 size vector and initializes
;
(defmacro vector-macro (create class)
   `(let ((vec (,create n)))
      (do ((from n to)
	   (to (1- n) (1- to)))
	  ((< to 0))
	  (int:vset vec to (arg from) ,class))
      vec))

(defun vector n (vector-macro new-vector 3))
(defun vectori-byte n (vector-macro new-vectori-byte 0))
(defun vectori-word n (vector-macro new-vectori-word 1))
(defun vectori-long n (vector-macro new-vectori-long 2))

;--- vref
; refernces an element of a vector
;   (vref 'vect 'index)
;
(defmacro vref-macro (vector index predicate limit class)
   `(cond ((not (,predicate ,vector))
	  ,(cond ((eq predicate 'vector)
		  `(error "vref: non vector argument " ,vector))
		 (t `(error "vref: non vectori argument " ,vector))))
	 ((not (fixp ,index))
	  (error "vref: non fixnum index " ,index))
	 ((or (< ,index 0) (not (< ,index ,limit)))
	  (error "vref: index out of range " ,index ,vector))
	 (t (int:vref ,vector ,index ,class))))

(defun vref (vect ind)
   (vref-macro vect ind vectorp (vsize vect) 3))

(defun vrefi-byte (vect ind)
   (vref-macro vect ind vectorip (vsize-byte vect) 0))
(defun vrefi-word (vect ind)
   (vref-macro vect ind vectorip (vsize-word vect) 1))
(defun vrefi-long (vect ind)
   (vref-macro vect ind vectorip (vsize vect) 2))


;--- vset
; use:
;	(vset 'vector 'index 'value)
;
(defmacro vset-macro (vector index value predicate limit class)
   `(cond ((not (,predicate ,vector))
	  ,(cond ((eq predicate 'vector)
		  `(error "vset: non vector argument " ,vector))
		 (t `(error "vset: non vectori argument " ,vector))))
	 ((not (fixp ,index))
	  (error "vset: non fixnum index " ,index))
	 ((or (<& ,index 0) (not (<& ,index ,limit)))
	  (error "vset: index out of range " ,index ,vector))
	 (t (int:vset ,vector ,index ,value ,class))))

(defun vset (vect ind val)
   (vset-macro vect ind val vectorp (vsize vect) 3))

(defun vseti-byte (vect ind val)
   (vset-macro vect ind val vectorip (vsize-byte vect) 0))

(defun vseti-word (vect ind val)
   (vset-macro vect ind val vectorip (vsize-word vect) 1))

(defun vseti-long (vect ind val)
   (vset-macro vect ind val vectorip  (vsize vect) 2))


;;; vector sizes

;--- vsize :: size of vector viewed as vector of longwords
;
(defun vsize (vector)
   (if (or (vectorp vector) (vectorip vector))
      then (int:vsize vector 2)
      else (error "vsize: non vector argument " vector)))

(defun vsize-word (vectori)
   (if (vectorip vectori)
      then (int:vsize vectori 1)
      else (error "vsize-word: non vectori argument " vectori)))

(defun vsize-byte (vectori)
   (if (vectorip vectori)
      then (int:vsize vectori 0)
      else (error "vsize-byte: non vectori argument " vectori)))

;; vector property list functions
;;
(defun vget (vector ind)
   (let ((x (vprop vector)))
      (if (dtpr x)
	 then (get x ind))))

;--- vputprop :: store value, indicator pair on property list
; if a non-dtpr is already there,  make it the car of the list
;
(defun vputprop (vector value ind)
   (let ((x (vprop vector)))
      (if (not (dtpr x))	
	 then (setq x (ncons x))
	      (vsetprop vector x))
      (putprop x value ind)))

	     
;; closures
;
;- closures are implemented in terms of vectors so we'll store the
; code here for now
;  a closure is a vector with leader field eq to 'closure'
; the 0th element of a closure vector is the functional form
; to funcall
; then the elements go in triplets
;			1 is the symbol name
;			    either
;	2 is nil 			2 is a pointer to a vector
;	3 is the saved value		3 is a fixnum index into the vector
;	 ^				   ^
;	 |---- the simple case		   |-- when we are sharing a value
;					       slot, this points to the
;					       value slot
;
; the size of the vector tells the number of variables.
;

;--- closure :: make a closure
; form (closure 'l_vars 'g_fcn)
; l_vars is a list of symbols
; g_fcn is a functional form, either a symbol or a lambda expression
; alist is a list of what has been already stored so far.
;   it will always be non nil, so we can nconc to it to return values.
;
(defun make-fclosure-with-alist (vars fcn alist)
   (cond ((not (or (null vars) (dtpr vars)))
	  (error "fclosure: vars list has a bad form " vars)))
   
   (let ((vect (new-vector (1+ (length vars)) nil 'fclosure)))
      (do ((xx vars (cdr xx))
	   (val)
	   (sym)
	   (i 1 (1+ i)))
	  ((null xx)
	   (setf (vref vect 0) fcn)	; store the function to call
	   vect)
	  (setq sym (car xx))
	  (cond ((not (symbolp sym))
		 (error "fclosure: non symbol in var list " sym)))

	  ; don't allow the variable nil to be closed over
	  (cond ((null sym)
		 (error "fclosure: you can't close over nil " vars)))

	  ; if the fclosure variable has already been given slot, use
	  ; it, else make a new one
	  (cond ((null (setq val (assq sym alist)))
		   ; if the variable is bound use it's current value,
		   ; else use nil
		   (cond ((setq val (boundp sym))
			  (setq val (cdr val))))
		   ; generate a new closure variable object
		   (setq val (cons sym (cons val (copyint* 0))))
		   ; remember this value for later fclosures
		   (nconc alist (list val))))
	  (setf (vref vect i) val))))
   


;--- fclosure :: generate a simple fclosure
; 
(defun fclosure (vars func)
   (make-fclosure-with-alist vars func (list nil)))

(defun fclosure-list n
   (cond ((not (evenp n))
	  (error "fclosure-alist: not given an even number of arguments: "
		 (listify n))))
   (do ((i 1 (+ i 2))
	(alist (list nil))
	(res))
       ((> i n) (nreverse res))
       (push (make-fclosure-with-alist (arg i) (arg (1+ i)) alist) res)))

(defun fclosurep (fclosure)
   (and (vectorp fclosure)
	(eq 'fclosure (vprop fclosure))))
(defun fclosure-alist (fclosure)
   (cond ((fclosurep fclosure)
	  (do ((xx 1 (1+ xx))
	       (lim  (vsize fclosure))
	       (val)
	       (res))
	      ((not (< xx lim))
	       res)
	      (setq val (vref fclosure xx))
	      (push (cons (car val) (cadr val)) res)))
	 (t (error "fclosure-alist: non fclosure argument: " fclosure))))



(defun fclosure-function (fclosure)
   (and (fclosurep fclosure)
	(vref fclosure 0)))

(defun vector-dump (vect)
   (let (size)
      (msg "size = " (setq size (vsize vect)) ", prop= " (vprop vect) N)
      (do ((ii 0 (1+ ii)))
	  ((not (< ii size)))
	  (msg ii ": " (vref vect ii) N ))))
   
	
;--- symeval-in-fclosure :: determine the value of a symbol
;   with respect to an fclosure.
;
(defun symeval-in-fclosure (fclosure symbol)
  (cond ((not (fclosurep fclosure))
	 (error "set-in-fclosure: non fclosure first argument: " fclosure))
	(t (do ((xx 1 (1+ xx))
		(val)
		(lim (vsize fclosure)))
	       ((not (< xx lim))
		(error "symeval-in-fclosure: variable not found" symbol))
	       (setq val (vref fclosure xx))
	       (cond ((eq symbol (car val))
		      (return (int:fclosure-stack-stuff val))))))))

;--- set-in-fclosure :: set the value of a symbol in an fclosure
;
(defun set-in-fclosure (fclosure symbol value)
  (cond ((not (fclosurep fclosure))
	 (error "set-in-fclosure: non fclosure first argument: " fclosure))
	(t (do ((xx 1 (1+ xx))
		(val)
		(lim (vsize fclosure)))
	       ((not (< xx lim))
		(error "set-in-fclosure: variable not found" symbol))
	       (setq val (vref fclosure xx))
	       (cond ((eq symbol (car val))
		      (return (int:fclosure-stack-stuff val value))))))))

(defmacro let-fclosed (vars function)
  `(let ,vars (fclosure ',(mapcar #'(lambda (x) (if (atom x) x (car x))) vars)
			,function)))
		

EndOfFile
cat >  lisplib/array.l  << 'EndOfFile'
;;
;; array.l				-[Tue Jul  5 23:51:48 1983 by layer]-
;;
;; maclisp compatible array package.  This implements maclisp
;; compatible arrays.
;;
;; features of the new package:
;; Most array will be notype arrays.  This is because they are the most 
;; efficient in Franz.  What used to be fixnum and flonums arrays are
;; now fixnum-block and flonum-block arrays.
;; The array access functions are more specialized and much faster now.
;; The array access functions have different semantics.  Now they are
;; responsible for both accessing and storing in an array.
;; When an access function is asked to access a value, it will be given
;; the subscripts already evaluated and the array object.  These will
;; be stacked, so the array access function should be a lexpr to read them.
;; When an access function is asked to store a value that value will be
;; the first argument, the subscripts will follow and finally there will
;; be the array object.  
;; It is up to the access function to determine if it is being asked to
;; store or retrieve a value, and this determination will probably
;; be made by looking at the number of arguments.


(setq rcs-array-
   "$Header: array.l 1.5 83/07/05 23:51:58 layer Exp $")

(declare (special gcdisable)
   (macros t))

(def array
  (macro ($lis$)
	 `(*array ',(cadr $lis$) ',(caddr $lis$) ,@(cdddr $lis$))))

(def *array
  (lexpr (nargs)
	   (prog (name type rtype dims size tname numdims)

		 (cond ((lessp (setq numdims (- nargs 2)) 1)
			(error "no bounds to array declaration ")))

		 (setq name  (arg 1)
		       type  (arg 2)
		       rtype (cond ((memq type '(t nil fixnum flonum))
				    'value)
				   ((eq type 'fixnum-block)
				    'fixnum)
				   ((eq type 'flonum-block)
				    'flonum)
				   (t (error "array: bad type: " type)))
		       dims  (do ((i nargs (1- i))
				  (res nil (cons (arg i) res)))
				 ((eq i 2) res))

		       size  (apply 'times dims))

		 (cond ((null type) (setq type 'unmarked_array)))

		 ; we disable gc during the next calculation since
		 ; the data returned from small-segment is unprotected
		 ; and a gc would cause its data to be put on the 
		 ; free list.
		 (let ((gcdisable t))
		      (setq tname
			    (marray (small-segment rtype size)
				    (cond ((eq rtype 'value)
					   (cond ((eq numdims 1) 
						  (getd 'arrac-oneD))
						 ((eq numdims 2) 
						  (getd 'arrac-twoD))
						 (t (getd 'arrac-nD))))
					  (t (getd 'arrac-nD)))
				    (cons type dims)
				    size
				    (sizeof rtype))))
		 ; if type is fixnum or flonum
		 ; we must intialize to 0 or 0.0
		 (cond ((or (and (eq 'fixnum type)
				 (setq rtype 0))
			    (and (eq 'flonum type)
				 (setq rtype 0.0))
			    (and (or (status feature 68k)
				     (status feature for-68k))
				 (progn (setq rtype nil) t)))
			(do ((i size))
			    ((zerop i))
			    (set (arrayref tname (setq i (1- i))) rtype))))

		 (cond (name (putd name tname)))
		 (return tname))))

(defmacro arraycall (type array &rest indexes)
  `(funcall ,array ,@indexes))

;--- array-type :: return type of array
;
(defun array-type (arr)
   (cond ((not (arrayp arr)) (error "array-type: non array passed " arr))
	 (t (car (getaux arr)))))

; this is used by the old array scheme.  Keep this around until
; everything is recompiled

(defun ev-arraycall (type array indexes)
  (apply array indexes))


;;;---- array access functions.

; we first define a macro to evaluate a value cell.  In compiled code cdr
; is the fastest way to do this, in interpreted code the type checker 
; would not let us use cdr so we have to use eval.
(eval-when (compile)
  (defmacro value-eval (x) `(cdr ,x))  ; one level of indirection
  (defmacro simple-arrayref (arr ind) `(offset-cxr ,ind (getdata ,arr))))

(eval-when (eval)
  (defun value-eval (x) (eval x))
  (defun simple-arrayref (arr ind) (arrayref arr ind)))

;- one dimensional
(defun arrac-oneD n
  (cond ((eq n 2) (value-eval (simple-arrayref (arg 2) (arg 1))))
	((eq n 3) (set (simple-arrayref (arg 3) (arg 2)) (arg 1)))
	(t (error " wrong number of subscripts to array: " (arg n)))))

(defun arrac-twoD n
  (let ((aux (getaux (arg n))))
       (cond ((eq n 3)
	      (value-eval (simple-arrayref
			     (arg n)
			     (+ (* (arg 1) (caddr aux)) (arg 2)))))
	     ((eq n 4)
	      (set (simple-arrayref (arg n)
				    (+ (* (arg 2) (caddr aux)) (arg 3))) 
		   (arg 1)))
	     (t (error " wrong number of subscripts to array: " (arg n))))))

;-- n dimensional array access function.  
(defun arrac-nD n
  (let ((aux (getaux (arg n)))
	firstsub subs
	store
	(index 0))

       (setq subs (length (cdr aux)))
       (cond ((eq n (1+ subs))
	      (setq firstsub 1))
	     ((eq n (+ 2 subs))
	      (setq firstsub 2 store t))
	     (t (error "wrong number of subscripts to array: " (arg n))))

       (setq index (arg firstsub))
       (do ((bounds (cddr aux) (cdr bounds))
	    (i firstsub))
	   ((null bounds))
	   (setq index (+ (* index (car bounds)) (arg (setq i (1+ i))))))

       (setq subs (arrayref (arg n) index))	; get cell requested
       (cond ((memq (car aux) '(fixnum-block flonum-block))
	      (cond (store (replace subs (arg 1)))
		    (t (cpy1 subs))))
	     (t (cond (store (set subs (arg 1)))
		      (t (value-eval subs)))))))


(defmacro store ( (arrname . indexes) value)
 (do ((fnd))
     (nil)
   (cond ((eq 'funcall arrname)
	  (return `(funcall ,(car indexes) ,value . ,(cdr indexes))))
	 ((eq 'apply arrname)
	  (return `(apply ,(car indexes) (cons ,value ,@(cdr indexes)))))
	 ((eq 'arraycall arrname)
	  (return `(funcall ,(cadr indexes) ,value ,@(cddr indexes))))
	 ((arrayp arrname)
	  (return `(funcall ',arrname ,value ,@indexes))))
   (setq fnd (getd arrname))
   (cond ((or (and (dtpr fnd) (eq 'macro (car fnd)))
	      (and (bcdp fnd) (eq 'macro (getdisc fnd))))
	  (setq fnd (apply arrname (cons arrname indexes)))
	  (setq arrname (car fnd)
		indexes (cdr fnd)))
	 (t (return `(,arrname ,value . ,indexes))))))

;-- storeintern  -  there may be residual calls to storeintern from 
; old code, we handle it here.  this routine can be eliminated when
; code is recompiled

(defun storeintern (arrnam value indexes)
  (apply arrnam (cons value indexes)))

;--- small segment storage allocators.

; this function allocates segments of storage and attempt to use the whole
; block instead of throwing away what isnt used
;

(declare (special gcdisable))

(defun small-segment (type n)
  (prog (lastseg retv elementsize itemsperpage-1 gcdisable tmp)
	(setq gcdisable t) 	; its not a good idea to gc while we are
				; handling pointers to things segment returns.
	(desetq (elementsize . itemsperpage-1) (get 'segment-sizes type))
	(cond ((null elementsize) (error "small-segment: bad type " type)))
	(setq lastseg (get 'segment-types type))
	(cond ((and lastseg (not (lessp (car lastseg) n))))
	      (t ; must allocate a block of storage, want to the least number of
		 ; pages which includes n elements
		 ; there are elementsize elements per page, and 
		 ; itemsperpage-1 is the number of elements on a page minus 1 
		 (setq retv (boole 4 
				   (+ n itemsperpage-1) 
				   itemsperpage-1))  ; 4 is x & ~y
		 (setq lastseg (cons retv (maknum (segment type retv))))))
	(setq retv (cdr lastseg))
	(rplaca lastseg (- (car lastseg) n))
	(rplacd lastseg (+ (cdr lastseg) (* elementsize n)))
	(cond ((greaterp (car lastseg) 0)
	       (putprop 'segment-types lastseg type)
	       (cond ((null (setq tmp (get 'segment-arrays type)))
		      (putprop 'segment-arrays 
			       (setq tmp (marray nil nil nil nil nil))
			       type)))
	       (putdata tmp (fake (cdr lastseg)))
	       (putlength tmp (car lastseg))
	       (putdelta tmp elementsize))
	      (t  ; remove all counters since we no longer have any space
		  ; left and we can't have a zero length array
		  (remprop 'segment-types type)
		  (remprop 'segment-arrays type)))
	(return (fake retv))))

; data base for small-segment
(putprop 'segment-sizes '( 4 . 127) 'value)
(putprop 'segment-sizes '( 4 . 127) 'fixnum)
(putprop 'segment-sizes '( 8 . 63)  'flonum)


(def arraydims (lambda (arg) (cond ((symbolp arg) (getaux (getd arg)))
				   ((arrayp arg) (getaux arg))
				   (t (break '"non array arg to arraydims")))))

; fill array from list or array

(def fillarray
  (lambda (arr lis)
	  (prog (maxv typept)
		(cond ((symbolp arr) (setq arr (getd arr))))

		(cond ((symbolp lis)
		       (setq lis (getd lis))
		       (return (fillarrayarray arr lis)))

		      ((arrayp lis) (return (fillarrayarray arr lis))))

		(setq maxv (1- (getlength arr))
		      typept (cond ((memq (car (getaux arr))
					  '(t fixnum flonum unmarked_array))
				    t)
				   (t nil)))
		(do ((ls lis)
		     (i 0 (1+ i)))
		    ((>& i maxv))

		    (cond (typept (set (arrayref arr i) (car ls)))
			  (t (replace (arrayref arr i) (car ls))))

		    (cond ((cdr ls) (setq ls (cdr ls))))))))

(def fillarrayarray
  (lambda (arrto arrfrom)
	  (prog (maxv)
		(setq maxv (1- (min (getlength arrto)
				      (getlength arrfrom))))
		(do ((i 0 (1+ i)))
		    ((>& i maxv))
		    (replace (arrayref arrto i) (arrayref arrfrom i))))))

(def listarray
  (lexpr (n)
	 (prog (arr size typ ret newv)
	       (setq arr (arg 1))
	       (cond ((arrayp arr))
		     ((and (symbolp arr) (arrayp (setq arr (getd arr)))))
		     (t (error "Non array to listarray " arr)))
	       (setq size (cond ((eq n 2) (arg 2))
				(t (apply '* (cdr (arraydims arr))))))
	       (setq typ (car (getaux arr)))
	       (cond ((memq typ '(t fixnum flonum unmarked_array))
		      (setq typ t))
		     (t (setq typ nil)))
	       (do ((i (1- size) (1- i)))
		   ((lessp i 0))
		   (setq newv (arrayref arr i))
		   (setq ret (cons (cond (typ (eval newv))
					 (t (cpy1 newv)))
				   ret)))
	       (return ret))))
EndOfFile
cat >  lisplib/pp.l  << 'EndOfFile'
(setq rcs-pp-
   "$Header: /usr/lib/lisp/RCS/pp.l,v 1.2 83/08/15 22:27:54 jkf Exp $")

;;
;; pp.l					-[Mon Aug 15 10:52:13 1983 by jkf]-
;;
;; pretty printer for franz lisp
;;

(declare (macros t))

(declare (special poport pparm1 pparm2 lpar rpar form linel))
; (declare (localf $patom1 $prd1 $prdf charcnt condclosefile))

; =======================================
; pretty printer top level routine pp
;
;
; calling form- (pp arg1 arg2 ... argn)
; the args may be names of functions, atoms with associated values
; or output descriptors.
; if argi is:
;    an atom - it is assumed to be a function name, if there is no
;	       function property associated with it,then it is assumed
;		to be an atom with a value
;    (P port)-  port is the output port where the results of the
;	        pretty printing will be sent.
;		poport is the default if no (P port) is given.
;    (F fname)- fname is  a file name to write the results in
;    (A atmname) - means, treat this as an atom with a value, dont
;		check if it is the name of a function.
;    (E exp)-   evaluate exp without printing anything
;    other -	pretty-print the expression as is - no longer an error
;
;    Also, rather than printing only a function defn or only a value, we will
;    let prettyprops decide which props to print.  Finally, prettyprops will
;    follow the CMULisp format where each element is either a property
;    or a dotted pair of the form (prop . fn) where in order to print the
;    given property we call (fn id val prop).  The special properties
;    function and value are used to denote those "properties" which
;    do not actually appear on the plist.
;
; [history of this code: originally came from Harvard Lisp, hacked to
; work under franz at ucb, hacked to work at cmu and finally rehacked
; to work without special cmu macros]

(declare (special $outport$ $fileopen$ prettyprops))

(setq prettyprops '((comment . pp-comment)
		    (function . pp-function)
		    (value . pp-value)))

; printret is like print yet it returns the value printed, this is used
; by pp		
(def printret
  (macro ($l$)
	 `(progn (print ,@(cdr $l$)) ,(cadr $l$))))

(def pp
  (nlambda ($xlist$)
	(prog ($gcprint $outport$ $cur$ $fileopen$ $prl$ $atm$)

	      (setq $gcprint nil)			; don't print
							; gc messages in pp.

	      (setq $outport$ poport)			; default port
	      ; check if more to do, if not close output file if it is
	      ; open and leave


   toploop    (cond ((null (setq $cur$ (car $xlist$)))
		     (condclosefile)
		     (terpr)
		     (return t)))

	      (cond ((dtpr $cur$)
		     (cond ((equal 'P (car $cur$))	; specifying a port
			    (condclosefile)		; close file if open
			    (setq $outport$ (eval (cadr $cur$))))

			   ((equal 'F (car $cur$))	; specifying a file
			    (condclosefile)		; close file if open
			    (setq $outport$ (outfile (cadr $cur$))
				  $fileopen$ t))

						
			   ((equal 'E (car $cur$))
			    (eval (cadr $cur$)))

			   (t (pp-form $cur$ $outport$)))	;-DNC inserted
		     (go botloop)))


      (mapc (function
	     (lambda (prop)
		     (prog (printer)
			   (cond ((dtpr prop)
				  (setq printer (cdr prop))
				  (setq prop (car prop)))
				 (t (setq printer 'pp-prop)))
			   (cond ((eq 'value prop)
				  (and (boundp $cur$)
				       (apply printer
					      (list $cur$
						    (eval $cur$)
						    'value))
				       (terpr $outport$)))
				 ((eq 'function prop)
				  (and (getd $cur$)
				       (cond ((not (bcdp (getd $cur$)))
					      (apply printer
						     (list $cur$
							   (getd $cur$)
							   'function)))
					     ; restore message about
					     ; bcd since otherwise you
					     ; just get nothing and
					     ; people were complaining.
					     ; - dhl.
					     #-cmu
					     (t
					      (msg N 
						   "pp: function " 
						   (or $cur$)
						   " is machine coded (bcd) "))
					     )
				       (terpri $outport$)))
				 ((get $cur$ prop)
				  (apply printer
					 (list $cur$
					       (get $cur$ prop)
					       prop))
				  (terpri $outport$))))))
	    prettyprops)


 botloop      (setq $xlist$ (cdr $xlist$))

	      (go toploop))))

(setq pparm1 50 pparm2 100)

;   -DNC These "prettyprinter parameters" are used to decide when we should
;	quit printing down the right margin and move back to the left -
;	Do it when the leftmargin > pparm1 and there are more than pparm2
;	more chars to print in the expression

; cmu prefers dv instead of setq

#+cmu
(def pp-value (lambda (i v p)
		      (terpri $outport$)
		      (pp-form (list 'dv i v) $outport$)))

#-cmu
(def pp-value (lambda (i v p)
		      ;;(terpr $outport$) ;; pp-form does an initial terpr.
		      ;;			we don't need two.
		      (pp-form `(setq ,i ',v) $outport$)))

(def pp-function (lambda (i v p)
			 #+cmu (terpri $outport$)
			 ;;
			 ;; add test for traced functions and don't
			 ;; print the trace mess, just the original
			 ;; function.  - dhl.
			 ;;
			 ;; this test might belong in the main pp
			 ;; loop but fits in easily here. - dhl
			 ;;
			 (cond ((and (dtpr v)
				     (dtpr (cadr v))
				     (memq (caadr v)
					   '(T-nargs T-arglist))
				     (cond ((bcdp (get i 'trace-orig-fcn))
					    #-cmu
					    (msg N 
						 "pp: function " 
						 (or i) 
						 " is machine coded (bcd) ")
					    t)
					   (t (pp-form 
					       (list 'def i 
						     (get i 'trace-orig-fcn))
					       $outport$)
					      t))))
			       ; this function need to return t, but
			       ; pp-form returns nil sometimes.
			       (t (pp-form (list 'def i v) $outport$)
				  t))))

(def pp-prop (lambda (i v p)
		     #+cmu (terpri $outport$)
		     (pp-form (list 'defprop i v p) $outport$)))

(def condclosefile 
  (lambda nil
	  (cond ($fileopen$
		 (terpr $outport$)
		 (close $outport$)
		 (setq $fileopen$ nil)))))

;
; these routines are meant to be used by pp but since
; some people insist on using them we will set $outport$ to nil
; as the default
(setq $outport$ nil)



(defun pp-form (value &optional ($outport$ poport oport-p) (lmar 0))
 ($prdf value lmar 0))

; this is for compatability with old code, will remove soon -- jkf
(def $prpr (lambda (x) (pp-form x $outport$)))



(declare (special rmar))	; -DNC this used to be m - I've tried to
				; to fix up the pretty printer a bit.  It
				; used to mess up regularly on (a b .c) types
				; of lists.  Also printmacros have been added.

(def $prdf
  (lambda (l lmar rmar)
    (prog nil
;
;			- DNC - Here we try to fix the tendency to print a
;			  thin column down the right margin by allowing it
;			  to move back to the left if necessary.
;
	  (cond ((and (>& lmar pparm1) (>& (flatc l (1+ pparm2)) pparm2))
		 (terpri $outport$)
		 (patom "; <<<<< start back on the left <<<<<" $outport$)
		 ($prdf l 5 0)
		 (terpri $outport$)
		 (patom "; >>>>> continue on the right >>>>>" $outport$)
		 (terpri $outport$)
		 (return nil)))
          (tab lmar $outport$)
     a    (cond ((and (dtpr l)
		      (atom (car l))
		      (or (and (get (car l) 'printmacro)
			       (funcall (get (car l) 'printmacro)
					l lmar rmar))
			  (and (get (car l) 'printmacrochar)
			       (printmacrochar (get (car l) 'printmacrochar)
					       l lmar rmar))))
		 (return nil))
;
;				-DNC - a printmacro is a lambda (l lmar rmar)
;				attached to the atom.  If it returns nil then
;				we assume it did not apply and we continue.
;				Otherwise we assume it did the job.
;
                ((or (not (dtpr l))
;                    (*** at the moment we just punt hunks etc)
                     (and (atom (car l)) (atom (cdr l))))
                 (return (printret l $outport$)))
                ((<& (+ rmar (flatc l (charcnt $outport$)))
		    (charcnt $outport$))
		 ;
		 ;	This is just a heuristic - if print can fit it in then figure that
;	the printmacros won't hurt.  Note that despite the pretentions there
;	is no guarantee that everything will fit in before rmar - for example
;	atoms (and now even hunks) are just blindly printed.	- DNC
;
                 (printaccross l lmar rmar))
                ((and ($patom1 lpar)
                      (atom (car l))
                      (not (atom (cdr l)))
                      (not (atom (cddr l))))
                 (prog (c)
                       (printret (car l) $outport$)
                       ($patom1 '" ")
                       (setq c (nwritn $outport$))
                  a    ($prd1 (cdr l) c)
                       (cond
                        ((not (atom (cdr (setq l (cdr l)))))
                         (terpr $outport$)
                         (go a)))))
                (t
                 (prog (c)
                       (setq c (nwritn $outport$))
                  a    ($prd1 l c)
                       (cond
                        ((not (atom (setq l (cdr l))))
                         (terpr $outport$)
                         (go a))))))
     b    ($patom1 rpar))))

(def $prd1
  (lambda (l n)
    (prog nil
          ($prdf (car l)
                 n
                 (cond ((null (setq l (cdr l))) (|1+| rmar))
                       ((atom l) (setq n nil) (plus 4 rmar (pntlen l)))
                       (t rmar)))
          (cond
           ((null n) ($patom1 '" . ") (return (printret l $outport$))))
;         (*** setting n is pretty disgusting)
;         (*** the last arg to $prdf is the space needed for the suffix)
;		;Note that this is still not really right - if the prefix
;		takes several lines one would like to use the old rmar 
;		until the last line where the " . mumble)" goes.
	)))

; -DNC here's the printmacro for progs - it replaces some hackery that
; used to be in the guts of $prdf.

(def printprog
  (lambda (l lmar rmar)
    (prog (col)
          (cond ((cdr (last l)) (return nil)))
          (setq col (add1 lmar))
          (princ '|(| $outport$)
          (princ (car l) $outport$)
          (princ '| | $outport$)
          (print (cadr l) $outport$)
          (mapc '(lambda (x)
			 (cond ((atom x)
				(tab col $outport$)
				(print x $outport$))
                          (t ($prdf x (+ lmar 6) rmar))))
		(cddr l))
          (princ '|)| $outport$)
          (return t))))

(putprop 'prog 'printprog 'printmacro)

;;
;;	simpler version which
;;	should look nice for lambda's also.(inside mapcar's) -dhl
;;
(defun print-lambda (l lmar rmar)
  (prog (col)
	(cond ((cdr (last l)) (return nil)))
	(setq col (add1 lmar))
	(princ '|(| $outport$)
	       (princ (car l) $outport$)
	       (princ '| | $outport$)
	       (print (cadr l) $outport$)
	       (let ((c (cond ((eq (car l) 'lambda)
			       8)
			      (t 9))))
		    (mapc '(lambda (x)
				   ($prdf x (+ lmar c) rmar))
			  (cddr l)))
	       (princ '|)| $outport$)
	(terpr $outport$)
	(tab lmar $outport$)
	(return t)))

(putprop 'lambda 'print-lambda 'printmacro)
(putprop 'nlambda 'print-lambda 'printmacro)

; Here's the printmacro for def.  The original $prdf had some special code
; for lambda and nlambda.

(def printdef
  (lambda (l lmar rmar)
    (cond ((and (zerop lmar)		; only if we're really printing a defn
                (zerop rmar)
                (cadr l)
                (atom (cadr l))
                (dtpr (caddr l))
                (null (cdddr l))
                (memq (caaddr l) '(lambda nlambda macro lexpr))
                (null (cdr (last (caddr l)))))
           (princ '|(| $outport$)
           (princ 'def $outport$)
           (princ '| | $outport$)
           (princ (cadr l) $outport$)
           (terpri $outport$)
           (princ '|  (| $outport$)
           (princ (caaddr l) $outport$)
           (princ '| | $outport$)
           (princ (cadaddr l) $outport$)
           (terpri $outport$)
           (mapc  '(lambda (x) ($prdf x 4 0)) (cddaddr l))
           (princ '|))| $outport$)
           t))))

(putprop 'def 'printdef 'printmacro)

; There's a version of this hacked into the printer (where it don't belong!)
; Note that it must NOT apply to things like (quote a b).

;
; adding printmacrochar so that it can be used by other read macros
; which create things of the form (tag lisp-expr) like quote does,
; I know this is restrictive but it is helpful in the frl source. - dhl.
;
;

(def printmacrochar
  (lambda (macrochar l lmar rmar)
    (cond ((or (null (cdr l)) (cddr l)) nil)
          (t (princ macrochar $outport$) 
             ($prdf (cadr l) (add1 lmar) rmar)
             t))))

(putprop 'quote '|'| 'printmacrochar)

(def printaccross
  (lambda (l lmar rmar)
    (prog nil
;         (*** this is needed to make sure the printmacros are executed)
          (princ '|(| $outport$)
     l:   (cond ((null l))
                ((atom l) (princ '|. | $outport$) (princ l $outport$))
                (t ($prdf (car l) (nwritn $outport$) rmar)
                   (setq l (cdr l))
                   (cond (l (princ '| | $outport$)))
                   (go l:))))))

EndOfFile
cat >  lisplib/format.l  << 'EndOfFile'
(setq rcs-format-
   "$Header")

;;
;;  format.l				-[Fri Mar  4 12:20:16 1983 by jkf]-
;;
;;   This is a function for printing or creating nicely formatted strings.
;; This file is a modified version of the format program which runs in
;; the mit lisps.  When converting to franz, compatibility was the
;; major goal, thus we still use the \ character as a string delimiter
;; within a command string, even though it must be doubled in Franz.
;;
;; The file contains the user callable functions:
;;   format	- lexpr for doing formated printed output or creating
;;		  strings
;;   defformat  - macro for adding a format directive
;;

; FORMAT prints several arguments according to a control argument.
; The control argument is either a string or a list of strings and lists.
; The strings and lists are interpreted consecutively.
; Strings are for the most part just printed, except that the character ~
; starts an escape sequence which directs other actions.
; A ~ escape sequence has an (optional) numeric parameter followed by a
; mode character.
; These escape actions can use up one or more of the non-control arguments.
; A list in the control-argument list is also interpreted as an escape.
; Its first element is the mode, a symbol which may be any length,
; and its remaining elements are parameters.  The list (D 5) is equivalent
; to the ~ escape "~5D";  similarly, each ~ escape has an equivalent list.
; However, there are list escapes which have no ~ equivalent.

; Any undefined list escape is simply evaluated.

;These are the escape modes which are defined:
; ~nD Takes any number and prints as a decimal integer.  If no arg,
;     print without leading spaces.  If arg and it fits in, put in leading
;     spaces; if it doesnt fit just print it.  If second arg, use that
;     (or first char of STRING of it if not a number) instead of space
;     as a pad char.
; ~nF Floating point
; ~nE Exponential notation
; ~nO Like D but octal
; ~nA Character string.  If there is an n then pad the string with spaces 
;     on the right to make it n long.  If it doesn't fit, ignore n.
; ~n,m,minpad,padcharA  Pad on the right to occupy at least
;     n columns, or if longer than that to begin with, pad to occupy
;     n+p*m columns for some nonnegative integer p.
;     at least minpad pad characters are produced in any case
;     (default if not supplied = 0).
;     padchar is used for padding purposes (default if not supplied = space).
;      if padchar is not a number, the first character in STRING of it is used.

;     A mode can actually be used to PRINC anything, not just a string.
; ~S  Prin1 an object.  Just like ~A (including parameters) but uses PRIN1.
; ~C  One character, in any acceptable form.
;      Control and meta bits print as alpha, beta, epsilon.
; ~n* Ignore the next n args.  n defaults to 1.
; ~n% Insert n newlines.  n defaults to 1.
; ~n| Insert n formfeeds.  n defaults to 1.
; ~nX Insert n spaces.  n defaults to 1.
; ~n~ Insert n tildes.  n defaults to 1.
; ~&  Perform the :FRESH-LINE operation on the stream.
; ~n,mT  Tab to column n+pm, for p an integer >= 0.
; ~Q  Apply the next arg to no arguments.
; (Q ...) Apply the next arg to the (unevaluated) parameters following the Q.
; ~P  Insert an "s", unless its argument is a 1
; ~nG  Goto the nth argument (zero based).  The next command will get that
;      argument, etc.
; ~E and ~F are not implemented.  ~T is not implemented.

; (FORMAT <stream> <control arg> <args>)
; If <stream> is NIL, cons up and return a symbol.
; If <stream> is T, use STANDARD-OUTPUT (saves typing).

;; defformat:
;;  to add a format handler, the defformat macro is used.
;; the form is (defformat code args type . body)
;;   where
;;   code is the code this will handle.  the code can be a multi
;;    character symbol, however it will have to be called with \\code\\.
;;   args is either a one or two symbol list, depending on type
;;   type is either: none, one, or many.
;;    none means that type handler will not use any argument (it may use
;;      use parameters however)
;;    one means that it takes exactly one argument
;;    many means that it may take from zero to ?? arguments.
;;   body is the body of the function.  Its return value is only important
;;    in the case of 'many' handlers since these handlers must return the
;;    list of the arguments they didn't use.
;;
;;  'none' handlers get passes a hunk which contains the parameters provide
;;	for this format directive.
;;  'one' handlers are passed the argument and the parameters.
;;  'many' handlers are passed the list of remaining arguments and the
;;	parameters. they return the arguments they don't use.

;to do:
;  3) make sure the semantics follows the lisp machine defs
;  6) do exponential (~e) floating point formats correctly.
;  7) move ferror elsewhere (near error would be a good place).
;  8) document it.
;  11) fix ~a to left justify if given correct flag
;  13) make sure that multi character directives are lower cased
;  14) make the 'x parameter work correctly
;  15) fix the english printer (wrt stream arg) and add ordinal


;;; Kludges to make MacLISP like some of the LISPM functions

(declare (special Format-Standard-Output roman-old 
		  format-params-supplied format format-handlers
		  format-sharpsign-vars))

(setq format-sharpsign-vars 'franz-symbolic-character-names)

;; format-params-supplied : numbers of parameters to format parameter
;; roman-old when t, the roman printer will print IIII instead of IV

(or (boundp 'roman-old) (setq roman-old nil))

(declare (setq defmacro-for-compiling nil defmacro-displace-call nil ))
  (defmacro nsubstring (&rest w) `(format\:nsubstring ,.w))
  (defmacro string-search-char (&rest w) `(format\:string-search-char ,.w))
  (defmacro ar-1 (ar ind) `(cxr ,ind ,ar))
  (defmacro as-1 (val ar ind) `(rplacx ,ind ,ar ,val))
  (defmacro >= (x y) `(not (< ,x ,y)))
  (defmacro <= (x y) `(not (> ,x ,y)))
  (defmacro neq (x y) `(not (= ,x ,y)))
  (defmacro pop (stack) `(prog1 (car ,stack) (setq ,stack (cdr ,stack))))
(declare (setq defmacro-for-compiling 't defmacro-displace-call 't))


(declare
 (special ctl-string		 ;The control string.
	  ctl-length		 ;string-length of ctl-string.
	  ctl-index		 ;Our current index into the control string.
				 ; Used by the conditional command. (NYI)
	  atsign-flag		 ;Modifier
	  colon-flag		 ;Modifier
	  format-temporary-area	 ;For temporary consing
	  format-arglist	 ;The original arg list, for ~G.
	  arglist-index		 ;How far we are in the current arglist
	  float-format		 ; format used when printing floats
	  poport		; franz's standard output
	  ))

(defun format (stream ctl-string &rest args)
  (let (format-string Format-Standard-Output
	(format-arglist args)
	(arglist-index 0))
    (setq stream (cond ((eq stream 't) poport )
		       ((null stream)
			(setq format-string 't)
			(list nil))
		       (t stream)))
    (setq Format-Standard-Output stream)
    (cond ((symbolp ctl-string)
	   (setq ctl-string (get_pname ctl-string))))
    (cond ((stringp ctl-string)
	   (format-ctl-string args ctl-string))
	  (t (do ((ctl-string ctl-string (cdr ctl-string)))
	       ((null ctl-string))
	       (setq args
		     (cond ((symbolp (car ctl-string))
			    (format-ctl-string args (car ctl-string)))
			   (t (format-ctl-list args (car ctl-string))))))))
    (and format-string
	 (setq format-string (maknam (nreverse (cdr stream)))))
    format-string))

(defun format-ctl-list (args ctl-list)
       (format-ctl-op (car ctl-list) args (cdr ctl-list)))

(defun format-ctl-string (args ctl-string)
    (declare (fixnum ctl-index ctl-length))
    (do   ((ctl-index 0) (ch) (tem) (str) (sym)
	   (ctl-length (flatc ctl-string)))
	  ((>= ctl-index ctl-length) args)
	(setq tem (cond ((string-search-char #/~ ctl-string ctl-index))
			(t ctl-length)))
	(cond ((neq tem ctl-index)		;Put out some literal string
	       (setq str (nsubstring ctl-string ctl-index tem))
	       (format:patom str)
	       (and (>= (setq ctl-index tem) ctl-length)
		    (return args))))
	;; (ar-1 ch ctl-index) is a tilde.
	(do ((atsign-flag nil)	;Modifier
	     (colon-flag nil)	;Modifier
	     (params (makhunk 10))
	     (param-leader -1)
			        ;PARAMS contains the list of numeric parameters
	     (param-flag nil)	;If T, a parameter has been started in PARAM
	     (param))		;PARAM is the parameter currently
				; being constructed
	    ((>= (setq ctl-index (1+ ctl-index)) ctl-length))
	  (setq ch (getcharn ctl-string (1+ ctl-index)))
	  (cond ((and (>= ch #/0) (<= ch #/9))		 	 ; 
		 (setq param (+ (* (or param 0) 10.) (- ch #/0)) ; 
		     param-flag t))
		((= ch #/@)					 ;ascii @
		 (setq atsign-flag t))
		((= ch #/:)					 ;ascii :
		 (setq colon-flag t))
		((or (= ch #/v) (= ch #/V))			;ascii v, v
		 (as-1 (pop args) params
		       (setq param-leader (1+ param-leader)))
		 (setq arglist-index (1+ arglist-index))
		 (setq param nil param-flag nil))
		((= ch #/#)
		 (as-1 (length args) params
		       (setq param-leader (1+ param-leader))))
		((= ch #/,)
		   ;comma, begin another parameter, ascii ,
		 (and param-flag (as-1 param params (setq param-leader
							  (1+ param-leader))))
		 (setq param nil param-flag t))
		  ;omitted arguments made manifest by the
		  ;presence of a comma come through as nil
		(t		;must be a command character
		    ;upper case to lower 
		  (and (>= ch #/A) (<= ch #/Z) (setq ch (+ ch (- #/a #/A))))
		  (setq ctl-index (1+ ctl-index)) ;advance past command char
		  (and param-flag (as-1 param params (setq param-leader
							   (1+ param-leader))))
		  (setq param-flag nil param nil tem nil)
		   ;str gets a string which is the name of the operation to do
		  (setq
		    str (cond ((= ch #/\ )			 ;ascii \
			       (let ((i (string-search-char
					   #/\
					   ctl-string
					   (1+ ctl-index))))
				  (and (null i)
				       (ferror nil
					  '|Unmatched \\ in control string.|))
				  (prog1 ; don't uppercase! we are a two
				     ; case system
				     (setq tem
					   (nsubstring ctl-string
						       (1+ ctl-index)
						       i))
				     (setq ctl-index i))))
			      ; makes ~<newline> work!  ;SMH@EMS
			      ((= ch #\newline) (concat "ch" ch))  ;SMH@EMS
			      (t (ascii ch))))
		   ;; SYM gets the symbol corresponding to STR
		  (cond ((setq sym str)
			 (setq format-params-supplied param-leader)
			 (setq args (format-ctl-op sym args params)))
			(t (ferror nil '|~C is an unknown FORMAT op in \"~A\"|
				   tem ctl-string)))
		  (return nil))))))

;Perform a single formatted output operation on specified args.
;Return the remaining args not used up by the operation.
(defun format-ctl-op (op args params &aux tem)
   (cond ((stringp op) (setq op (concat op))))  ; make into a symbol
   (cond ((setq tem (assq op format-handlers))
	  (cond ((eq 'one (cadr tem))
		 (or args
		     (ferror nil "arg required for ~a, but no more args" op))
		 (funcall (caddr tem) (car args) params)
		 (setq arglist-index (1+ arglist-index))
		 (cdr args))
		((eq 'none (cadr tem))
		 (funcall (caddr tem) params)
		 args)
		((eq 'many (cadr tem))
		 (funcall (caddr tem) args params))
		(t (ferror nil "Illegal format handler: ~s" tem))))
	 (t (ferror nil '|\"~S\" is not defined as a FORMAT command.| op)
	    args)))

(setq format-handlers nil)
;; Format handlers
;;
(defmacro defformat (name arglist type &rest body)
   (let (newname)
      ;; allow the name to be the fixnum rep of a character too.
      (cond ((fixp name) (setq name (concat "ch" name))))
      
      (cond ((not (memq type '(none one many)))
	     (ferror nil "The format type, \"~a\" is not: none, one or many"
		     type)))
      (cond ((or (not (symbolp name))
		 (not (dtpr arglist)))
	     (ferror nil "Bad form for name and/or arglist: ~a ~a"
		     name arglist)))
      (cond ((memq type '(one many))
	     (cond ((not (= (length arglist) 2))
		    (ferror nil "There should be 2 arguments to ~a" name))))
	    (t (cond ((not (= (length arglist) 1))
		      (ferror nil "There should be 1 argument to ~a" name)))))
      (setq newname (concat name ":format-handler"))
      `(progn 'compile
	      (defun ,newname ,arglist ,@body)
	      (let ((handler (assq ',name format-handlers)))
		 (cond (handler (rplaca (cddr handler) ',newname))
		       (t (setq format-handlers (cons (list ',name
							    ',type
							    ',newname)
						      format-handlers))))))))



(defformat d (arg params) one
   (let ((width (cxr 0 params))
	 (padchar (cxr 1 params)))
    (cond ((and colon-flag (< arg 4000.) (> arg 0))
	   (roman-step arg 0))
	  (atsign-flag (english-print arg 'cardinal))
	  ((let ((base 10.) (*nopoint t))
	     (cond ((null padchar) (setq padchar 32.))
		   ((not (numberp padchar))
		    (setq padchar (getcharn padchar 1))))
	     (and width (format-ctl-justify width (flatc arg) padchar))
	     (format:patom arg))))))

(defformat f (arg params) one
   (cond ((not (floatp arg)) (format:patom arg))
	 (t (let ((float-format "%.16g")
		  (prec (cxr 0 params)))
	       (cond ((and prec (fixp prec) (> prec 0) (< prec 16))
		      (setq float-format (concat "%" prec "g"))))
	       (format:patom arg)))))

; r format
; no params and flags: print as cardinal (four)
; no params and colon: print as ordinal  (fourth)
; no params and atsign: print as roman (IV)
; no params and colon and atsign: print as old roman (IIII)
; params:  radix,mincol[0],padchar[<space>]
;		print in radix with at least mincol columns, padded on left
;		with padchar
;
(defformat r (arg params) one
   (format:anyradix-printer arg params nil))

; o format - like ~8r, but params are like ~d.
;
(defformat o (arg params) one
   (format:anyradix-printer arg params 8.))

(defun format:anyradix-printer (arg params radix)
   ; this is called by ~r and ~o.  for ~r, the mincol parameter starts at
   ; cxr 1, for ~o the mincol parameter starts at cxr 0.  We compute
   ; paramstart as either 0 or 1
   ; radix is given as third argument iff this is ~o
   (let ((paramstart (cond (radix 0)
			   (t 1))))
      (cond ((null radix) (setq radix (cxr 0 params))))
      (cond ((null radix)	; if not to any given base
	     (cond ((and (null colon-flag) (null atsign-flag))
		    (english-print arg 'cardinal))
		   ((and colon-flag (null atsign-flag))
		    (english-print arg 'ordinal))
		   ((and (null colon-flag) atsign-flag)
		    (roman-step arg 0))
		   ((and colon-flag atsign-flag)
		    (let ((roman-old t))
		       (roman-step arg 0)))))
	    (t (let ((mincol (cxr paramstart params))
		     (padchr (or (cxr (+ 1 paramstart) params) #\space))
		     (res))
		  (cond (mincol 	;; if mincol specified
			   (let ((Format-Standard-Output (list nil)))
			      (format-binpr arg radix)
			      (setq res (cdr Format-Standard-Output)))
			   (format-ctl-justify mincol (length res) padchr)
			   (mapc 'format:tyo (nreverse res)))
			(t (format-binpr arg radix))))))))
	       

(defun format-binpr (x base)
   (cond ((equal x 0)(format:patom 0))
	 ((or (> base 36.) (< base 2))
	  (ferror nil "\"~s\" is not a base between 2 and 36" base))
	 ((lessp x 0)
	  (format:patom '-)
	  (format-binpr1 (minus x) base))
	 (t (format-binpr1 x base)))
   x)



(defun format-binpr1 (x base)
   (cond ((equal x 0))
	 (t (format-binpr1 (quotient x base) base)
	    (format-prc (remainder x base)))))

(defun format-prc (x)
   (cond ((< x 10.) (format:patom x))
	 (t (format:tyo (plus (- #/a 10.) x)))))
			; works for 10.=A, 35.=Z.

;; must get the width stuff to work!!
(defun format-ctl-octal (arg params)
   (let ((width (cxr 0 params)) (padchar (cxr 1 params)))
      (let ((base 8))
	 (cond ((null padchar)
		(setq padchar 32.))
	       ((not (numberp padchar))
		(setq padchar (getcharn padchar 1))))
	 (and width (format-ctl-justify width (flatc arg) padchar))
	 (format:patom arg))))

(defformat a (arg params) one
   (format-ctl-ascii arg params nil))

(defun format-ctl-ascii (arg params prin1p)
    (let ((edge (cxr 0 params))
	  (period (cxr 1 params))
          (min (cxr 2 params))
	  (padchar (cxr 3 params)))
	 (cond ((null padchar)
		(setq padchar #\space))
	       ((not (numberp padchar))
		(setq padchar (getcharn padchar 1))))
         (cond (prin1p (format:print arg))
               (t (format:patom arg)))
	 (cond ((not (null edge))
		(let ((width (cond (prin1p (flatsize arg)) ((flatc arg)))))
		  (cond ((not (null min))
			 (format-ctl-repeat-char min padchar)
			 (setq width (+ width min))))
		  (cond (period
			 (format-ctl-repeat-char
			  (- (+ edge (* (\\ (+ (- (max edge width) edge 1)
					       period)
					    period)
					period))
			     width)
			  padchar))
			(t (format-ctl-justify edge width padchar))))))))

(defformat s (arg params) one
    (format-ctl-ascii arg params t))

(defformat c (arg params) one
   (cond ((or (not (fixp arg))
	      (< arg 0)
	      (> arg 127))
	  (ferror nil "~s is not a legal character value" arg)))
   (cond ((and (not colon-flag) (not atsign-flag))
	  ; just print out the character after converting to ascii
	  (format:patom (ascii arg)))
	 (t ; it may have an extended name, check for that first
	    (let (name)
	       (cond ((setq name (car
				    (rassq arg (symeval format-sharpsign-vars))))
		      ; it has an extended name.
		      ; if : flag, then print in human readable
		      (cond (colon-flag (format:patom name))
			    (atsign-flag (format:patom "#\\")
					 (format:patom name))))
		     ((< arg #\space)
		      ; convert from control to upper case
		      (setq arg (+ arg #/@))
		      (cond (colon-flag (format:patom "^")
					(format:patom (ascii arg)))
			    (atsign-flag (format:patom "#^")
					 (format:patom (ascii arg)))))
		     (t (cond (colon-flag (format:patom (ascii arg)))
			      (atsign-flag (format:patom "#/")
					   (format:patom (ascii arg))))))))))

(defformat p (args params) many
  (let (arg)
    (cond (colon-flag
	   (setq arg (nth (1- arglist-index) format-arglist)))
	  ((null args)
	   (ferror () "Argument required for p, but no more arguments"))
	  (t (setq arg (pop args)
		   arglist-index (1+ arglist-index))))
    (if (= arg 1)
	(if atsign-flag (format:tyo #/y))
	(cond (atsign-flag
	       (format:tyo #/i)
	       (format:tyo #/e)
	       (format:tyo #/s))
	      (t (format:tyo #/s))))
    args))

(defformat *  (args params) many
  (let ((count (or (cxr 0 params) 1)))
    (if colon-flag (setq count (minus count)))
    (setq arglist-index (+ arglist-index count))
;;  (nthcdr count format-arglist)		;; ??? SMH@EMS
    (nthcdr arglist-index format-arglist)))	;; SMH@EMS

(defformat g (arg params) many
       (let ((count (or (cxr 0 params) 1)))
	    (nthcdr count format-arglist)))

(defformat % (params) none
       (declare (fixnum i))
       (let ((count (or (cxr 0 params) 1)))
	    (do i 0 (1+ i) (= i count)
		(format:terpr))))

;  ~ at the end of the line
;  no params: ignore newline and following whitespace
;  @ flag: leave the newline in the string but ignore whitespace
;  : flag: ignore newline but leave the whitespace
;  :@ flags: leave both newline and whitespace
;
(defformat #\newline (params) none
   (cond (atsign-flag
	    (format:tyo #\newline)))
   (cond ((not colon-flag)
	  (setq ctl-index (1+ ctl-index))
	  (do ()
	      ((>= ctl-index ctl-length))
	      (cond ((memq (getcharn ctl-string ctl-index)
			   '(#\space #\tab))
		     (setq ctl-index (1+ ctl-index)))
		    (t (setq ctl-index (1- ctl-index))
		       (return)))))))

		 
(defformat & (params) none
    (format:fresh-line))

(defformat x (params) none
   (format-ctl-repeat-char (cxr 0 params) #\space))

(defformat \| (params) none
   (format-ctl-repeat-char (cxr 0 params) #\ff))
   
(defformat ~ (params) none
   (format-ctl-repeat-char (cxr 0 params) #/~))

(defun format-ctl-repeat-char (count char)
    (declare (fixnum i))
    (cond ((null count) (setq count 1)))
    (do i 0 (1+ i) (=& i count)
	(format:tyo char)))

;; Several commands have a SIZE long object which they must print
;; in a WIDTH wide field.  If WIDTH is specified and is greater than
;; the SIZE of the thing to be printed, this put out the right
;; number of  CHARs to fill the field.  You can call this before
;; or after printing the thing, to get leading or trailing padding.
(defun format-ctl-justify (width size &optional (char #\space))
    (and width (> width size) (format-ctl-repeat-char (- width size) char)))

(defformat q (arg params) one
   ;; convert params given to a list
   (do ((ii format-params-supplied (1- ii))
	(params-given nil))
       ((< ii 0) (apply arg params-given))
       (setq params-given (cons (cxr ii params) params-given))))

;; Fixed nested ~[ ~] parser to handle ~:[ ~] and ~@:[ ~] as well.  SMH@EMS
(defun case-scan (goal &optional (lim ctl-length) (times 1))
  (declare (fixnum cnt lim times ctl-index))
  (*catch 'case-scan
    (do ((cnt 0 (1+ cnt)))
	((>= cnt times) t)
      (do ((ch))
	  ((>= ctl-index lim)
	   (*throw 'case-scan nil))
	(setq ch (getcharn ctl-string (1+ ctl-index))
	      ctl-index (1+ ctl-index))
	(cond ((= ch #/~)
	       (setq ch (getcharn ctl-string (1+ ctl-index))
		     ctl-index (1+ ctl-index))
	       (cond ((= ch goal)
		      (return t))
		     ((or (= ch #/[)		;; SMH@EMS
			  (and (or (= ch #/:) (= ch #/@))
			       (= (getcharn ctl-string
					    (setq ctl-index (1+ ctl-index)))
				  #/[)))	;; #/] fakeout emacs
		      (case-scan #/] lim)))))))))

; [ format
;  the case selector is the first parameter given, and if no  parameter
;  is given, then it is the next argument
;
(defformat \[ (args params) many
   (let ((start ctl-index)
	 (num (cond ((> format-params-supplied -1)
		     (cxr 0 params))
		    (t (cond ((null args)
			      (error "the [ format requires an argument")))
		       (prog1 (car args)
			      (setq args (cdr args))
			      (setq arglist-index (1+ arglist-index)))))))
      (and colon-flag (setq num (cond (num 1) (t 0))))
      (and (null num)
	   (ferror nil
	       "The FORMAT \"[\" command must be given a numeric parameter"))
      (cond ((>= num 0)
	     (or (case-scan #/])
		 (ferror nil "Unbalanced conditional in FORMAT control string"))
	     (let ((i ctl-index))
		(setq ctl-index start)
		(case-scan #/; i num))))
      args))

(defformat \] (params) none nil)

(defformat \; (params) none
   (case-scan #/]))

;; FIXTHIS:
;; The following doesn't bind format-arglist and arglist-index properly.
;; Added return-* stuff, also fixing above(?).  SMH@EMS
(defformat \{ (args params) many
  (let ((loop-times (or (cxr 0 params) -1))
	(loop-string)
	(at-least-once nil)
	(return-args)			;; SMH@EMS
	(return-format-arglist)		;; SMH@EMS
	(return-arglist-index))		;; SMH@EMS
    (do ((i (format\:string-search-char #/~ ctl-string ctl-index)
	    (format\:string-search-char #/~ ctl-string (1+ i))))
        ((or (null i) (= (1+ i) ctl-length))
	 (ferror () "No matching \"}\" for \"{\" in format"))
      (cond ((= #/} (getcharn ctl-string (+ 2 i)))
	     (setq loop-string
		   (format\:nsubstring ctl-string ctl-index i)
		   ctl-index (+ 2 i))
	     (return t))
	    ((and (= #/: (getcharn ctl-string (+ 2 i)))
		  (= #/} (getcharn ctl-string (+ 3 i))))
	     (setq loop-string
		   (format\:nsubstring ctl-string ctl-index i)
		   ctl-index (+ 3 i)
		   at-least-once t)
	     (return t))))
    (if (= 0 (flatc loop-string))
	(setq loop-string (pop args)
	      arglist-index (1+ arglist-index)))
    (if (null atsign-flag)
	(setq return-args (cdr args)			;; SMH@EMS
	      return-arglist-index arglist-index	;; SMH@EMS
	      arglist-index 0				;; SMH@EMS
	      return-format-arglist format-arglist	;; SMH@EMS
	      format-arglist (car args)			;; SMH@EMS
	      args format-arglist))
    (*catch '(loop-stop loop-abort)
      (do ((i loop-times (1- i)))
	  ((and (null at-least-once)
		(or (null args) (= i 0))))
	(setq at-least-once nil)
	(cond ((null colon-flag)
	       (setq args (format-ctl-string args loop-string)))
	      (t (*catch 'loop-stop
		    (format-ctl-string (car args) loop-string))
		 (setq args (cdr args)
		       arglist-index (1+ arglist-index))))))
    (cond (return-arglist-index					;; SMH@EMS
	   (setq args return-args				;; SMH@EMS
		 arglist-index (1+ return-arglist-index)	;; SMH@EMS
		 format-arglist return-format-arglist)))	;; SMH@EMS
    args))

(defformat \} (params) none nil)

(defformat \^ (args params) many
  (let ((terminate nil))
    (cond ((null (cxr 0 params))
	   (setq terminate (null args)))
	  ((null (cxr 1 params))
	   (setq terminate (zerop (cxr 0 params))))
	  ((null (cxr 2 params))
	   (setq terminate (equal (cxr 1 params) (cxr 0 params))))
	  (t (setq terminate (and (< (cxr 0 params) (cxr 1 params))
				  (< (cxr 1 params) (cxr 2 params))))))
    (if terminate
	(if colon-flag (*throw 'loop-abort t) (*throw 'loop-stop t))
	args))) 


(declare (special english-small english-medium english-large))

(defun make-list-array (list)
   (let ((a (makhunk (length list))))
      (do ((i 0 (1+ i))
	   (ll list (cdr ll)))
	  ((null ll))
	  (rplacx i a (car ll)))
      a))

(setq english-small
   (make-list-array '(|one| |two| |three| |four| |five| |six|
			    |seven| |eight| |nine| |ten| |eleven| |twelve|
			    |thirteen| |fourteen| |fifteen| |sixteen|
			    |seventeen| |eighteen| |nineteen|)))

(setq english-medium
   (make-list-array '(|twenty| |thirty| |forty| |fifty| |sixty| |seventy|
			       |eighty| |ninty|)))

(setq english-large
   (make-list-array '(|thousand| |million| |billion| |trillion| |quadrillion|
				 |quintillion|)))


(defun english-print (n type)
       (declare (fixnum i n limit))
       (cond ((zerop n)
	      (cond ((eq type 'cardinal) (format:patom "zero"))
		    (t (format:patom "zeroth"))))
	     ((< n 0)
	      (format:patom '|minus|)
	      (format:tyo #\space)
	      (english-print (minus n) type))
	     (t
	      (do ((n n)
                   (p)
		   (flag)
		   (limit 1000000.
			  (quotient limit 1000.))
		   (i 1 (1- i)))
		  ((< i 0)
		   (cond ((> n 0)
			  (and flag (format:tyo #\space))
			  (english-print-thousand n))))
		  (cond ((not (< n limit))
			 (setq p (quotient n limit)
			       n (remainder n limit))
			 (cond (flag (format:tyo #\space))
			       (t (setq flag t)))
			 (english-print-thousand p)
			 (format:tyo #\space)
			 (format:patom (ar-1 english-large i))))))))

(defun english-print-thousand (n)
       (declare (fixnum i n limit))
       (let ((n (remainder n 100.))
	     (h (quotient n 100.)))
	    (cond ((> h 0)
		   (format:patom (ar-1 english-small (1- h)))
		   (format:tyo #\space)
		   (format:patom '|hundred|)
		   (and (> n 0) (format:tyo #\space))))
	    (cond ((= n 0))
		  ((< n 20.)
		   (format:patom (ar-1 english-small (1- n))))
		  (t
		   (format:patom (ar-1 english-medium
						   (- (quotient n 10.) 2)))
		   (cond ((zerop (setq h (remainder n 10.))))
			 (t
			  (format:tyo #/-) ;ascii -
			  (format:patom (ar-1 english-small (1- h)))))))))

(defun roman-step (x n)
    (cond ((> x 9.)
	   (roman-step (quotient x 10.) (1+ n))
	   (setq x (remainder  x 10.))))
    (cond ((and (= x 9) (not roman-old))
	   (roman-char 0 n)
	   (roman-char 0 (1+ n)))
	  ((= x 5)
	   (roman-char 1 n))
	  ((and (= x 4) (not roman-old))
	   (roman-char 0 n)
	   (roman-char 1 n))
	  (t (cond ((> x 5)
		    (roman-char 1 n)
		    (setq x (- x 5))))
	     (do i 0 (1+ i) (>= i x)
	       (roman-char 0 n)))))

(defun roman-char (i x)
    (format:tyo (car (nthcdr (+ i x x) '(#/I #/V #/X #/L #/C #/D #/M)))
	   		 ;  i   v   x   l   c   d   m
))

;;; Kludges to make MacLISP like some of the LISPM functions


(defun format:tyo (char)
   (cond ((dtpr Format-Standard-Output)
	  (rplacd Format-Standard-Output
		  (cons char (cdr Format-Standard-Output))))
	 (t (tyo char Format-Standard-Output))))

(defun format:patom (arg)
   (format:printorpatom arg nil))

(defun format:print (arg)
   (format:printorpatom arg t))

(defun format:printorpatom (argument slashify)
   (cond ((dtpr Format-Standard-Output)
	  (rplacd Format-Standard-Output
		  (nreconc (cond (slashify
					 (mapcar '(lambda (x)
						     (getcharn x 1))
					         (explode argument)))
					((exploden argument)))
				  (cdr Format-Standard-Output))))
	 (t (cond (slashify (print argument Format-Standard-Output))
		  (t (patom argument Format-Standard-Output))))))

(defun format:terpr nil
   (cond ((dtpr Format-Standard-Output)
	  (rplacd Format-Standard-Output
		  (cons #\newline (cdr Format-Standard-Output))))
	 (t (terpr Format-Standard-Output))))

(defun format:fresh-line nil
   (cond ((dtpr Format-Standard-Output)
	  (cond ((and (cdr Format-Standard-Output)
		      (not (= (cadr Format-Standard-Output) #\newline)))
		 (rplacd Format-Standard-Output
			 (cons #\newline (cdr Format-Standard-Output))))))
	 (t (and (not (= 0 (nwritn Format-Standard-Output)))
		 (terpr Format-Standard-Output)))))
   
	  


(defun format\:string-search-char (char str start-pos)
       (declare (fixnum i start-pos str-len))
       (do ((i start-pos (1+ i))
	    (str-len (flatc str)))
	   ((>& i str-len) nil)
	   (and (=& char (getcharn str (1+ i))) (return i))))

(defun format\:nsubstring (str from to)
       (declare (fixnum i from to))
       (substring str (+ 1 from) (- to from)))  ;substring is 1 based

(defun ferror (&rest args)
   (let (str)
      ; if the first arg to ferror is a string we assume that it is the
      ; format control string, otherwise we assume that it is a port
      ; specification, and we ignore it since we want to build a string.
      (if (stringp (car args))
	 then (setq str (lexpr-funcall 'format nil args))
	 else (setq str (lexpr-funcall 'format nil (cdr args))))
      (error str)))


(defun format-test nil
   (format t "Start test, newline:~%freshline:~&")
   (format t "decimal:~d, width=5:~5d~%" 10 10)
   (format t "decimal pad with period:~10,vd~%" #/.  12)
   (format t "char normal:~c, as # would read:~@c, human read:~:c~%"
	   #\space #\space #\space)
   (format t "cardinal:~r, roman new:~@r, roman-old:~:@r~
   		<same line I hope>~@
		new line but at beginning~:
   same line, but spaced out~:@
   	new line and over two tabs~%" 4 4 4))

(putprop 'format t 'version)
EndOfFile
cat >  lisplib/version.l  << 'EndOfFile'
;; version.l
;;			-[ Wed May 22 09:30:58 PDT 1985 by sklower]-
;;
;; This file is edited after every modification is made to the
;; lisp system.
;; Variables defined:
;;   this-lisp-version-built: a symbols whose pname is the date when
;;	the lisp system was build.  People who care about such things
;;	can have their .lisprc file print it out at startup
;;   franz-minor-version-number.  This is printed after the opus number
;;	upon startup.  It is incremented after each fix or feature addition
;;

(setq this-lisp-version-built (status ctime)
      franz-minor-version-number ".92")
EndOfFile
cat >  lisplib/tpl.l  << 'EndOfFile'
(setq rcs-tpl-
   "$Header: tpl.l,v 1.6 84/02/29 19:31:09 jkf Exp $")

;				-[Thu Feb 16 07:49:26 1984 by jkf]-
;

; to do
; ?state : display  status translink, *rset, displace-macros.
;		current error, prinlevel and prinlength
;	   add a way of modifying the values
; ?bk [n] : do a baktrace (default 10 frames from bottom)
; ?zo [n] : add an optional number of frames to zoom
; ?retf : return value from 'current' frame
; ?retry : retry expr in 'current' frame (required mod to lisp).
;
; the frame re-eval question is not asked when it should.
; interact with tracebreaks correctly
;
; add stepper.
; get 'debugging' to work ok.

;--- state
;
(declare (special tpl-debug-on tpl-step-on
		  tpl-top-framelist tpl-bot-framelist
		  tpl-eval-flush tpl-trace-flush
		  tpl-prinlength tpl-prinlevel
		  prinlevel prinlength top-level-print
		  tpl-commands tpl-break-level
		  tpl-spec-char
		  tpl-last-loaded
		  tpl-level
		  tpl-fcn-in-eval
		  tpl-contuab
		  ER%tpl ER%all given-history res-history
		  tpl-stack-bad tpl-stack-ok
		  tpl-history-count
		  tpl-history-show
		  tpl-dontshow-tpl
		  tpl-step-enable	;; if stepping is on
		  tpl-step-print	;; if should print step forms
		  tpl-step-triggers	;; list of fcns to enable step
		  tpl-step-countdown	;; if positive, then don't break
		  tpl-step-reclevel	;; recursion level
		  evalhook funcallhook
		  *rset % piport ^w
		  debug-error-handler
		  displace-macros
		  ))

(putd 'tpl-eval (getd 'eval))
(putd 'tpl-funcall (getd 'funcall))
(putd 'tpl-evalhook (getd 'evalhook))
(putd 'tpl-funcallhook (getd 'funcallhook))


;--- macros which should be in the system
;
(defmacro evalframe-type (evf) `(car ,evf))
(defmacro evalframe-pdl (evf)  `(cadr ,evf))
(defmacro evalframe-expr (evf) `(caddr ,evf))
(defmacro evalframe-bind (evf) `(cadddr ,evf))
(defmacro evalframe-np (evf)   `(caddddr ,evf))
(defmacro evalframe-lbot (evf) `(cadddddr ,evf))


;; messages are passed between break levels by means of catch and
;; throw:
(defmacro tpl-throw (value) `(*throw 'tpl-break-catch ,value))
(defmacro tpl-catch (form) `(*catch 'tpl-break-catch ,form))

; A tpl-catch is placed around the prompting and evaluation of forms.
; if something abnormal happens in the evaluation, a tpl-throw is done
; which then tells the break look that something special should be
; done.
;
; messages:
;   contbreak  -  this tells the break level to print out the message
;		  it prints when it is entered (such as the error message).
;		  [see poplevel message]. 
;   poplevel   -  tells the break level to jump up to the next higher
;		  break level and continue there.  It sends  contbreak
;		  message to that break level so that it will remind the
;		  user what the state is. [see cmd: ?pop ]
;   reset      -  This tells the break level to send a reset to the next
;		  higher break level.  Thus a reset is done by successive
;		  small pops.  This isn't totally necessary, but it is
;		  clean.
;  (retbreak v) - return from the break level, returning the value v.
;		  If this an error break, then we return (list v) since
;		  that is required to indicate that an error has been
;		  handled.
;  (retry v)	- instead of asking for a new value, retry the given one.
;  popretry     - take the expression that caused the current break and
;		  send a (retry expr) message to the break level above us
;		  so that it can be tried again.

(setq tpl-eval-flush nil  tpl-trace-flush nil
   tpl-prinlevel 3 tpl-prinlength 4
   tpl-spec-char #/?)

(or (boundp 'tpl-last-loaded) (setq tpl-last-loaded nil))

(defun tpl nil
   (let ((debug-error-handler 'tpl-err-all-fcn))
      (setq ER%tpl 'tpl-err-tpl-fcn)
      (putd '*break (getd 'tpl-*break))
      (setq given-history nil
	    res-history   nil
	    tpl-debug-on  nil
	    tpl-step-on   nil
	    tpl-top-framelist nil
	    tpl-bot-framelist nil
	    tpl-stack-bad t
	    tpl-stack-ok nil
	    tpl-fcn-in-eval nil
	    tpl-level nil
	    tpl-history-count 0
	    tpl-break-level -1
	    tpl-dontshow-tpl t
	    tpl-history-show 10
	    tpl-step-enable nil
	    tpl-step-countdown 0
	    tpl-step-reclevel 0)
      (do ((retv))
	  (nil)
	  (setq retv
		(tpl-catch
		   (tpl-break-function nil))))))


;--- do-one-transaction
;  do a single read-eval-print transaction
;  If eof-form is given, then we provide a prompt and read the input,
;   otherwise given is what we use, but we print the prompt and the
;   given input before evaling it again.
; (given must be in the form (sys|user ..)
;
(defun do-one-transaction (given prompt eof-form)
   (let (retv)
      (patom prompt)
      (If eof-form
	 then (setq given
		    (car (errset (ntpl-read nil eof-form))))
	      (If (eq eof-form given)
		 then (If (status isatty)
			 then (msg "EOF" N)
			      (setq given '(sys  <eof>))
			 else (exit)))
	 else (tpl-history-form-print given)
	      (terpr))
      (add-to-given-history given)
      (If (eq 'user (car given))
	 then (setq tpl-stack-bad t)
	      (setq retv
		    (if tpl-step-enable
		       then (tpl-evalhook (cdr given)
					  'tpl-do-evalhook
					  'tpl-do-funcallhook)
		       else (tpl-eval (cdr given))))
	      (setq tpl-stack-bad t)
	 else (setq retv (process-fcn (cdr given)))
	      (setq tpl-stack-bad (not tpl-stack-ok)))
      (add-to-res-history retv)
      (ntpl-print retv)
      (terpr)
      ))
		     

;; reader
; if sees a rpar as the first non space char, it just reads all chars
; return (sys . form)  where form is a list, e.g
;			)foo bar baz rets (sys foo bar baz)
;  or
;  (user . form)
; note: if nothing is typed, (sys) is returned
;
(defun ntpl-read (port eof-form)
   (let (ch)
      ; skip all spaces
      (do ()
	  ((and (not (eq (setq ch (tyipeek port)) #\space))
		(not (eq ch #\newline))))
	  (setq ch (tyi)))
      (If (eq ch #\eof)
	 then eof-form
	 else (setq ch (tyi port))
	      (If (eq ch tpl-spec-char)
		 then (do ((xx (list #\lpar) (cons (tyi) xx)))
			  ((or (eq #\eof (car xx))
			       (eq #\newline  (car xx)))
			   (cons 'sys
				 (car (errset
					 (readlist
					    (nreverse
					       (cons #\rpar (cdr xx)))))))))
		 else (untyi ch)
		      (cons 'user (read port eof-form))))))

;--- tpl-history-form-print :: the inverse of tpl-read
; this takes the history form of an expression and prints it out
; just as the user would have typed it.
;
(defun tpl-history-form-print (form)
   (If (eq 'user (car form))
      then (print (cdr form))
      else (patom "?")
	   (mapc '(lambda (x) (print x) (patom " ")) (cdr form))))

(defun ntpl-print (form)
   (cond ((and top-level-print
		(getd top-level-print))
	   (funcall top-level-print form))
	  (t (print form))))

(setq tpl-commands
   '( ((help h) tpl-command-help
       " [cmd] - print general or specific info "
       " '?help' - print a short description of all commands "
       " '?help cmd' - print extended information on the given command ")
      ( ? tpl-command-redo
	" [args] - redo last or previous command "
	" '??' - redo last user command "
	" '?? n' - (for n>0) redo command #n (as printed by ?history)"
	" '?? -n' - (for n>0) redo n'th previous command (?? -1 == ??)"
	" '?? symb' - redo last with car == symb"
	" '?? symb *' - redo last with car == symb*")
      ( (his history) tpl-command-history
	" [r] - print history list "
	" ?history, ?his - print list of commands previously executed"
	" '?his r' - print results too")
      ( (re reset) tpl-command-reset
	" - pop up to the top level"
	" '?re, ?reset', pop up to the top level ")
      ( tr tpl-command-trace
	" [fn ..] - trace"
	" '?tr' - print list of traced functions"
	" '?tr fn ...' - trace given functions, can be fn or (fn cmd ...)"
	"	where cmds are trace commands")
      ( step tpl-command-step
	" [t] [funa funb ...] step always or when specific function hit"
	" '?step t' - step starting right away "
	" '?step funa funb' - step when either funa or funb to be called ")
      ( soff tpl-command-stepoff
	" - turn off stepping "
	" '?soff' - turn off stepping ")
      ( sc tpl-command-sc
	" [n] - continue stepping [don't break for n steps] "
	" '?sc' -  do one step then break "
	" '?sc n' - step for n steps before breaking "
	"	    if n is a non integer (e.g. inf) then "
	"	    step forever without breaking ")
      ( state tpl-command-state
	" [vals] - print or change state "
	" 'state' - print current state in short form "
	" 'state l' - print state in long form"
	" 'state sym val ... ...' - set values of state "
	"	symbols are those given in 'state  l' list")
      ( prt tpl-command-prt
	" - pop up a level and retry the command which caused this break"
	" ?prt - do a ?pop followed by a retry of the command which"
	"	caused this break to be entered")
      ( ld  tpl-command-load
	" [file ...] - load given or last files"
	" 'ld'  - loads the last files loaded with ?ld"
	" 'ld file ...' - loads the given files")
      ( debug tpl-command-debug
	" [off] - toggle debug state "
	" 'debug' Turns on debugging.  When debug is on then"
	"	enough information is kept around for viewing"
	"	and quering evaluation stack"
	" 'debug off' - Turns off debuging" )
      ( fast tpl-command-fast
	" - set switches for fastest execution "
	" '?fast - turn off ?debug mode (i.e. (*rset nil)), set the "
	"	translink table to 'on', and set displace-macros to t."
	" 	This will cause franz to run as fast as possible "
	"	(but will result in loss of debugging information ")
      ( pop tpl-command-pop
	" - pop up to previous break level"
	" 'pop' - if not at top level, pop up to the break level"
	"	above this one")
      ( ret tpl-command-ret
	" [val] - return value from this break loop "
	" 'ret [val]' if this is a break look due to a break command "
	"	or a continuable error, evaluate val (default nil)"
	"	and return it to the function that found an error,"
	" 	allowing it to continue")
      
      ( zo tpl-command-zoom
	" - view a portion of evaluation stack"
	" 'zo' - show a portion above and below the 'current' stack"
	"	frame.  Use )up and )dn or alter current stack frame")
      ( dn tpl-command-down
	" [n] - go down stack frames "
	" 'dn' - move the current stack frame down one.  Down refers to"
	"	older stack frames"
	" 'dn n' - n is a fixnum telling how many stack frames to go down"
	" 'dn n z' - after going down, do a zoom"
	" After dn is done, a limited zoom will be done")
      ( up tpl-command-up
	" [n] - go up stack frames "
	" 'up' - move the current stack frame up one.  Up refers to"
	"	younger stack frames"
	" 'up n' - n is a fixnum telling how many stack frames to go up")
      ( ev tpl-command-ev
	" symbol - eval the given symbol wrt the current frame "
	" 'ev symbol' - determine the value of the given symbol"
	"	after restoring the bindings to the way they were"
	"	when the current frame was current.  see ?zo,?up,?dn")
      ( pp tpl-command-pp
	" - pretty print the current frame "
	" 'pp' - pretty print the current frame (see ?zo, ?up, ?dn)")
      ( <eof> tpl-command-pop
	" - pop one break level up "
	" '^D' - if connect to tty, pops up one break level,"
	"        otherwise, exits doesn't exit unless  "))
   )
	       
;--- process-fcn :: do a user command
;
(defun process-fcn (form)
   (let ((sel (car form)))
      (setq tpl-stack-ok nil)
      (do ((xx tpl-commands (cdr xx))
	   (this))
	  ((null xx)
	   (msg "Illegal command, type ?help for list of commands" N))
	  (If (or (and (symbolp (setq this (caar xx)))
		       (eq sel this))
		  (and (dtpr this)
		       (memq sel this)))
	      then (return (tpl-funcall (cadar xx) form))))))
			    
	      
   
;--- tpl commands
;

;--- tpl-command-help
(defun tpl-command-help (x)
   (setq tpl-stack-ok t)
   (If (cdr x)
      then (do ((xx tpl-commands (cdr xx))
		(sel (cadr x))
		(this))
	       ((null xx)
		(msg "I don't know that command" N))
	       ; look for command in tpl-commands list
	       (If (or (and (symbolp (setq this (caar xx)))
		       (eq sel this))
		  (and (dtpr this)
		       (memq sel this)))
		  then (return (do ((yy (cdddar xx) (cdr yy)))
				   ((null yy))
				   ; print all extended documentation
				   (patom (car yy))
				   (terpr)))))
      else ; print short info on all commands
	   (mapc #'(lambda (x)
		      (let ((sel (car x)))
			 ; first print selector or selectors
			 (If (dtpr sel)
			    then (patom (car sel))
				 (mapc #'(lambda (y) (patom ",") (patom y))
					(cdr sel))
			    else (patom sel))
			 ; next print documentation
			 (patom (caddr x))
			 (terpr)))
		  tpl-commands))
   nil)

(defun tpl-command-load (args)
   (setq args (cdr args))
   (If args
      then (setq tpl-last-loaded args)
	   (mapc 'load args)
    elseif tpl-last-loaded
      then (mapc 'load tpl-last-loaded)
      else (msg "Nothing to load" N)))

	      
(defun tpl-command-trace (args)
   (setq args (cdr args))
   (apply 'trace args))

	 
   
;--- tpl-command-state
;
(defun tpl-command-state (x)
   (msg " State:  debug " tpl-debug-on ", step " tpl-step-enable N)
   (msg "	  *rset " *rset ", (status translink) " (status translink) N)
   (msg "  variables: tpl-prinlength " tpl-prinlength N)
   (msg " 	      tpl-prinlevel  " tpl-prinlevel N))

;--- tpl-command-debug
;
(defun tpl-command-debug (x)
   (If (memq 'off (cdr x))
      then (*rset nil)
	   (msg "Debug is off" N)
	   (setq tpl-debug-on nil)
      else (*rset t)
	   (sstatus translink nil)
	   (msg "Debug is on" N)
	   (setq tpl-debug-on t)))

;--- tpl-command-fast
;
(defun tpl-command-fast (x)
   (*rset nil)
   (setq tpl-debug-on nil)
   (sstatus translink on)
   (setq displace-macros t))

;--- tpl-command-zoom
;
(defun tpl-command-zoom (x)
   (tpl-update-stack)
   (setq tpl-stack-ok t)
   (tpl-zoom))

(defun tpl-command-down (args)
   ;; go down the evaluation stack and zoom
   ;; down means towards older frames
   (setq tpl-stack-ok t)
   (let ((count 1))
      (If (and (fixp (cadr args)) (> (cadr args) 0))
	 then (setq count (cadr args)))
      (do ((xx count (1- xx)))
	  ((= 0 xx))
	  (If tpl-bot-framelist
	     then (setq tpl-top-framelist (cons (car tpl-bot-framelist)
						tpl-top-framelist)
			tpl-bot-framelist (cdr tpl-bot-framelist))))
      (tpl-command-zoom nil)))

(defun tpl-command-up (args)
   ;; go up the stack and zoom
   ;; up is towards more recent stuff
   ;;
   (setq tpl-stack-ok t)
   (let ((count 1))
      (If (and (fixp (cadr args)) (> (cadr args) 0))
	 then (setq count (cadr args)))
      (do ((xx count (1- xx)))
	  ((= 0 xx))
	  (If tpl-top-framelist
	     then (setq tpl-bot-framelist (cons (car tpl-top-framelist)
						tpl-bot-framelist)
			tpl-top-framelist (cdr tpl-top-framelist))))
      (tpl-command-zoom nil)))

(defun tpl-command-ev (args)
   ;; ?ev foo
   ;; determine the value of variable foo with respect to the current
   ;; evaluation frame.
   ;;
   (let ((sym (cadr args)))
      (If (not (symbolp sym))
	 then (msg "ev must be given a symbol" N)
       elseif (null tpl-bot-framelist)
	 then (msg "there is no evaluation stack, is debug on?")
	 else (prog1 (car
			(errset
			   (eval sym
				 (evalframe-bind (car tpl-bot-framelist)))))
		     (setq tpl-stack-ok t)))))


(defun tpl-command-pp (args)
   (pp-form (evalframe-expr (car tpl-bot-framelist)))
   (terpr)
   nil)

;;-- history list maintainers
;
; history lists are just lists of forms
; one for the given, and one for the returned
;
(defun most-recent-given () (car given-history))

(defun add-to-given-history (form)
   (setq given-history (cons form given-history))
   (setq res-history   (cons nil  res-history))
   (If (not (eq (car form) 'history))
       then (setq tpl-history-count (1+ tpl-history-count))))

(defun add-to-res-history (form)
   (setq res-history (cons form (cdr res-history)))
   (setq % form))

   
;--- evalframe generation
;

(defun tpl-update-stack nil
   (If tpl-stack-bad
      then (If (tpl-yorn "Should I re-calc the stack(y/n):")
	      then (tpl-gentrace)
	      else (msg "[not re-calc'ed]" N)
		   (setq tpl-stack-bad nil))))

;--- tpl-gentrace
; this is called before an function which references the
; frame list.  it needn't be called unless one knows that
; the frame status has changed
;
(defun tpl-gentrace ()
   (let ((templist (tpl-getframelist)))
      ; templist contains the frame from bottom (oldest) to top

      (setq templist (nreverse templist)) ; now youngest to oldest

      
      ; determine a new framelist and put it on the bottom list
      ; the top list is empty.  the first thing in the
      ; bottom framelist is the 'current' frame.

      ; go though frames, based on flags, flush trace calls
      ; or eval calls
      (do ((xx templist (cdr xx))
	   (remember (If tpl-dontshow-tpl then nil else t))
	   (forget-this nil nil)
	   (res)
	   (exp)
	   (flushpoint))
	  ((null xx) (setq tpl-bot-framelist (nreverse res)))
	  (setq exp (evalframe-expr (car xx)))
	  (If (dtpr exp)
	     then (If (and tpl-dontshow-tpl
			   (memq (car exp) '(tpl-eval tpl-funcall
						      tpl-evalhook
						      tpl-funcallhook)))
		     then (setq remember nil)))
	  (If (dtpr exp)
	     then (If (and tpl-dontshow-tpl (memq (car exp)
						 '(tpl-err-tpl-fcn
						     tpl-funcall-evalhook
						     tpl-do-funcallhook)))
		      then (setq forget-this t)))
	  (If (and remember (not forget-this))
	      then (setq res (cons (car xx) res)))
	  (If (dtpr exp)
	     then (If (and tpl-dontshow-tpl
			   (eq (car exp) 'tpl-break-function))
		     then (setq remember t))))

      (setq tpl-top-framelist nil)))

(defun tpl-getframelist nil
   (let ((frames)
	 temp)
      (If *rset
	 then ; Getting the first few frames is tricky because
	      ; the frames disappear quickly.
	      (setq temp (evalframe nil))	; call to setq
	      (setq temp (evalframe (evalframe-pdl temp)))
	      (do ((xx (list (evalframe (evalframe-pdl temp)))
		       (cons (evalframe (evalframe-pdl (car xx))) xx)))
		  ((null (car xx))
		   (cdr xx))))))

	       
(defun tpl-printframelist (printdown  vals count)
   (If (null vals)
      then (If printdown
	      then (msg "*** bottom ***" N)
	      else (msg "*** top ***" N))
    elseif (= 0 count)
      then (msg "... " (length vals) " more ..." N)
    else (If (not printdown)
	    then (tpl-printframelist printdown (cdr vals) (1- count)))
	 (let ((prinlevel tpl-prinlevel)
	       (prinlength tpl-prinlength))
	    ; tag apply type forms with 'a:'
	    (if (eq 'apply (evalframe-type (car vals)))
	       then (msg "a:"))
	    (print (evalframe-expr (car vals)))
	    (terpr))
	 (If printdown
	    then (tpl-printframelist printdown (cdr vals) (1- count)))))


(defun tpl-zoom nil
   (tpl-printframelist nil tpl-top-framelist 4)
   (msg "// current \\\\" N)
   (tpl-printframelist t   tpl-bot-framelist 4))

		  

(defmacro errdesc-class (err) `(car ,err))
(defmacro errdesc-id    (err) `(cadr ,err))
(defmacro errdesc-contp (err) `(caddr ,err))
(defmacro errdesc-descr (err) `(cdddr ,err))

;--- error handler
;

(defun tpl-break-function (reason)
   (do ((tpl-fcn-in-eval (most-recent-given))
	(tpl-level reason)
	(tpl-continuab)
	(tpl-break-level (1+ tpl-break-level))
	;(tpl-step-enable)
	(prompt)
	(do-retry nil nil)
	(retry-value)
	(retv 'contbreak)
	(piport nil)
	(eof-form (ncons nil)))
       (nil)
       (If (eq retv 'contbreak)
	  then
	       (If (memq (car reason) '(error derror))
		  then (if (eq (car reason) 'error)
			  then (msg "Error: ")
			  else (msg "DError: "))
		       (patom (car (errdesc-descr (cdr reason))))
		       (mapc #'(lambda (x) (patom " ") (print x))
			      (cdr (errdesc-descr (cdr reason))))
		       (terpr)
		       (msg "Form: " (cdr tpl-fcn-in-eval))
		elseif (eq 'break (car reason))
		  then (msg "Break: ")
		       (patom (cadr reason))
		       (mapc #'(lambda (x) (patom " ") (print x))
			      (cddr reason)))
	       (terpr)
	       (setq tpl-contuab (or (memq (car reason) '(break derror step))
				     (errdesc-contp (cdr reason))))
	       (setq prompt (If reason
			       then (concat (if (eq (car reason) 'derror)
					       then "d"
					     elseif (eq (car reason) 'step)
					       then "s"
					       else "")
					    (If tpl-contuab then "c" else "")
					    "{"
					    tpl-break-level
					    "} ")
			       else "=> "))
	elseif (eq retv 'reset)
	  then (tpl-throw 'reset)
	elseif (eq retv 'poplevel)
	  then (tpl-throw 'contbreak)
	elseif (eq retv 'popretry)
	  then (tpl-throw `(retry ,tpl-fcn-in-eval))
	elseif (dtpr retv)
	  then (If (eq 'retbreak (car retv))
		  then (If (eq 'error (car reason))
			  then (return (cdr retv))	; return from error
			  else (return (cadr retv)))
		  else (If (eq 'retry (car retv))
			  then (setq do-retry t
				     retry-value (cadr retv)))))
       (setq retv
	     (tpl-catch
		     (do ()
			 (nil)
			 (If (null do-retry)
			    then (do-one-transaction nil prompt eof-form)
			    else (do-one-transaction retry-value prompt nil))
			 (setq do-retry nil)
			 nil)))))

;--- tpl-err-tpl-fcn
; attached to ER%tpl, the error will return to top level
; generic error handler
;
(defun tpl-err-tpl-fcn (err)
   (let ((^w nil))
      (tpl-break-function (cons 'error err))))

;--- tpl-err-all-fcn
; attached to ER%all if (debugging t) is done.
;
(defun tpl-err-all-fcn (err)
   (let ((^w nil))
      (setq ER%all 'tpl-err-all-fcn)
      (tpl-break-function (cons 'derror err))))
   
;-- tpl-command-pop
; pop a break level
; 
(defun tpl-command-pop (x)
   (If (= 0 tpl-break-level)
      then (msg "Already at top level " N)
      else (tpl-throw 'poplevel)))

       
	   
(defun tpl-command-ret (x)
   (If tpl-contuab
      then (tpl-throw (list 'retbreak (eval (cadr x))))
      else (msg "Can't return at this point" N)))

;--- tpl-command-redo
; see documentatio above for a list of the various things this accepts
;
(defun tpl-command-redo (x)
   (setq x (cdr x))
   (If (null x)
      then (tpl-redo-by-count 1)
    elseif (fixp (car x))
      then (If (< (car x) 0)
	      then (tpl-redo-by-count (- (car x)))
	      else (If (not (< (car x) tpl-history-count))
		      then (msg "There aren't that many commands " N)
		      else (tpl-redo-by-count (- tpl-history-count (car x)))))
      else (tpl-redo-by-car x)))


;--- tpl-redo-by-car :: locate command to do by the car of the command
;
(defun tpl-redo-by-car (x)
   (let ((command (car x))
	 (substringp (If (eq (cadr x) '*) thenret)))
      (If substringp
	 then (If (not (symbolp command))
		 then (msg "must give a symbol before *" N)
		 else (let* ((string (get_pname command))
			     (len (pntlen string)))
			 (do ((xx (tpl-next-user-in-history given-history)
				  (tpl-next-user-in-history (cdr xx)))
			      (pos))
			     ((null xx)
			      (msg "Can't find a match" N))
			     (If (and (dtpr (cdar xx))
				      (symbolp (setq pos (cadar xx))))
				then (If (equal (substring pos 1 len)
						string)
					then (tpl-throw
						     `(retry ,(car xx))))))))
	 else (do ((xx (tpl-next-user-in-history given-history)
		       (tpl-next-user-in-history (cdr xx)))
		   (pos))
		  ((null xx)
		   (msg "Can't find a match" N))
		  (If (and (dtpr (cdar xx))
			   (symbolp (setq pos (cadar xx))))
		     then (If (eq pos command)
			     then (tpl-throw
					  `(retry ,(car xx)))))))))
			     
;--- tpl-redo-by-count :: redo n'th previous input
; n>=0.  if n=0, then redo last.
;
(defun tpl-redo-by-count (n)
   (do ((xx  n (1- xx))
	(list (tpl-next-user-in-history given-history)
	      (tpl-next-user-in-history (cdr list))))
       ((or (not (> xx 0)) (null list))
	(If (null list)
	   then (msg "There aren't that many commands " N)
	   else (tpl-throw `(retry ,(car list)))))))


'(defun tpl-next-user-in-history (hlist)
   (do ((histlist hlist (cdr histlist)))
       ((or (null histlist)
	    (eq 'user (caar histlist)))
	histlist)))

(defun tpl-next-user-in-history (hlist)
   hlist)

;--- tpl-command-prt
; pop and retry command which failed this time
;
(defun tpl-command-prt (x)
   (tpl-throw 'popretry))


;--- tpl-command-history
;
(defun tpl-command-history (x)
   (let (show-res)
      (If (memq 'r (cdr x))
	 then (setq show-res t))
      (tpl-command-his-rec tpl-history-show tpl-history-count show-res
			   given-history res-history)))

(defun tpl-command-his-rec (count current show-res hlist rhlist)
   (If (and hlist (> count 0))
      then (tpl-command-his-rec (1- count) (1- current) show-res
				(cdr hlist) (cdr rhlist)))
   (If hlist
      then
	   (let ((prinlevel tpl-prinlevel)
		 (prinlength tpl-prinlength))
	      (msg current ": ") (tpl-history-form-print (car hlist))
	      (terpr)
	      (If show-res
		 then (msg "% " current ": " (car rhlist) N)))))


(defun tpl-command-reset (x)
   (tpl-throw 'reset))

(defun tpl-yorn (message)
   (drain piport)
   (msg message)
   (let ((ch (tyi)))
      (drain piport)
      (eq #/y ch)))

       
;--- tpl-*break :: handle breaks
;  when tpl starts, this is put on *break's function cell
;
(defun tpl-*break (pred message)
   (let ((^w nil))
      (cond (pred (tpl-break-function (list 'break message))))))



;; stepping code
(defun tpl-command-step (args)
   (setq tpl-step-enable t
	 tpl-step-print nil
	 tpl-step-triggers nil
	 tpl-step-countdown 0)
   (if (memq t args)
      then (setq tpl-step-print t)
      else (setq tpl-step-triggers args))
   (*rset t)
   (setq evalhook nil funcallhook nil)
   (sstatus translink nil)
   (sstatus evalhook t))


(defun tpl-command-stepoff (args)
   ;; we don't turn off status evalhook because then an
   ;; evalhook would cause an error (this probably should be fixed)
   (sstatus evalhook nil)
   (setq tpl-step-enable nil
	 tpl-step-print nil))

(defun tpl-command-sc (args)
   ;; continue after step
   (if (cdr args)
      then (if (fixp (cadr args))
	      then (setq tpl-step-countdown (cadr args))
	      else (setq tpl-step-countdown 100000)))
   (tpl-throw `(retbreak ,tpl-step-enable)))

(defun tpl-do-evalhook (arg)
   ;; arg is the form to eval
   (tpl-funcall-evalhook arg 'eval))

(defun tpl-do-funcallhook (&rest args)
   ;; this is called with n args.
   ;; args 0 to n-2 are the actual arguments.
   ;; arg n-1 is the function to call (notice that it comes at the end)
   ; the list in 'args' is a fresh list, we can clobber it
   (let (name)
      ; strip the last cons cells from the args list
      ; there will be at least one element in the list,
      ; namely the function being called
      (if (cdr args)
	 then ; case of at least one argument
	      (do ((xx args (cdr xx)))
		  ((null (cddr xx))
		   (setq name (cadr xx))
		   (setf (cdr xx) nil)))
	 else ; case of zero arguments
	      (setq name (car args) args nil))
      
      (tpl-funcall-evalhook (cons name args) 'funcall)))


(defun tpl-funcall-evalhook (fform type)
   ;; function called after an evalhook or funclalhook is triggered
   ;; The form is an s-expression to be evaluated
   ;; The type is either 'eval' or 'funcall',
   ;;   eval meaning that the form is something to be eval'ed
   ;;   funcall meaning that the car of the form is the function to
   ;;	 be applied to the list which is the cdr [actually the cdr
   ;;	 is spread out on the stack and a 'funcall' is done, but this
   ;;	 is what apply does anyway.
   ;; Upon entry we optionally print, optionally break, optionally continue
   ;;	  stepping, and then optionally print the value
   ;; We print if tpl-step-print is t
   ;; We break if tpl-step-print is t and tpl-step-countdown is <= 0
   ;; We continue stepping if tpl-step-enable is t
   ;; We print the result if we continued stepping.
   ;; 
   ;; note: if it were possible to call evalhook and funcallhook if
   ;; (status evalhook) were nil, then we could make ?soff turn off
   ;; (status evalhook), making things run faster [as it is now, stepping
   ;; continues until we reach top-level again.  We just don't print
   ;; things out]
   ;;
   (let ((tpl-step-reclevel (1+ tpl-step-reclevel)))
      (if (and (not tpl-step-print)
	       (dtpr fform)
	       (memq (car fform) tpl-step-triggers))
	 then (setq tpl-step-print t))
      (if tpl-step-print
	 then (tpl-step-printform tpl-step-reclevel type fform)
	      (if (<& tpl-step-countdown 1)
		 then (setq tpl-step-enable (tpl-break-function '(step)))
		 else (setq tpl-step-countdown (1- tpl-step-countdown))))
      (if tpl-step-enable
	 then (let ((newval))
		 (setq newval (if (eq type 'eval)
				 then (tpl-evalhook fform
						    'tpl-do-evalhook
						    'tpl-do-funcallhook)
				 else (tpl-funcallhook fform
						       'tpl-do-funcallhook
						       'tpl-do-evalhook)))
		 (if tpl-step-print
		    then (tpl-step-printform tpl-step-reclevel 'r newval))
		 newval)
	 else (if (eq type 'eval)
		 then (tpl-evalhook fform nil nil)
		 else (tpl-funcallhook fform nil nil)))))
      

(defun tpl-step-printform (indent key form)
   (printblanks indent nil)
   (let ((prinlevel 4) (prinlength 4))
      (msg (if (eq key 'r)
	      then '"=="
	    elseif (eq key 'funcall)
	      then 'f:
	    elseif (eq key 'eval)
	      then 'e:
	      else key)
	   form N)))

; in order to use this: (setq user-top-level 'tpl)

	   
(putprop 'tpl t 'version)
EndOfFile
cat >  lisplib/fcninfo.l  << 'EndOfFile'
(setq rcs-fcninfo- "$Header: fcninfo.l,v 1.2 84/01/29 23:39:00 layer Exp $")

;;
;; fcninfo.l				-[Sun Jan 29 23:38:10 1984 by layer]-
;;
;; This is normally not loaded into a lisp system but is loaded into
;; the compiler.  
;; number of arguments information for C coded functions
;; not included: evalframe evalhook wait exece
;; stopped in sysat.c after *invmod
;
;; the information is stored in such as way as to minimize the
;; amount of space required to store the informaion.


(eval-when (compile eval)
   (setq cdescrip " defined in C-coded kernel"))

(defmacro decl-fcn-info (tag fcns)
   `(let ((fcninfo ',tag))
       ,@(mapcar '(lambda (fcn) `(putprop ',fcn fcninfo 'fcn-info)) fcns)))
(defmacro zero (&rest args)
   `(decl-fcn-info ((0 . 0) ,cdescrip) ,args))	
(defmacro zero-to-one (&rest args)
   `(decl-fcn-info ((0 . 1) ,cdescrip) ,args))
(defmacro zero-to-two (&rest args)
   `(decl-fcn-info ((0 . 2) ,cdescrip) ,args))
(defmacro zero-to-inf (&rest args)
   `(decl-fcn-info (nil ,cdescrip) ,args))
(defmacro one (&rest args)
   `(decl-fcn-info ((1 . 1) ,cdescrip) ,args))
(defmacro one-to-two (&rest args)
   `(decl-fcn-info ((1 . 2) ,cdescrip) ,args))
(defmacro one-to-three (&rest args)
   `(decl-fcn-info ((1 . 3) ,cdescrip) ,args))
(defmacro one-to-inf (&rest args)
   `(decl-fcn-info ((1 . nil) ,cdescrip) ,args))
(defmacro two (&rest args)
   `(decl-fcn-info ((2 . 2) ,cdescrip) ,args))
(defmacro two-to-inf (&rest args)
   `(decl-fcn-info ((1 . nil) ,cdescrip) ,args))
(defmacro three (&rest args)
   `(decl-fcn-info ((3 . 3) ,cdescrip) ,args))
(defmacro three-to-five (&rest args)
   `(decl-fcn-info ((3 . 5) ,cdescrip) ,args))
(defmacro three-to-inf (&rest args)
   `(decl-fcn-info ((3 . nil) ,cdescrip) ,args))
(defmacro four (&rest args)
   `(decl-fcn-info ((4 . 4) ,cdescrip) ,args))
(defmacro five (&rest args)
   `(decl-fcn-info ((5 . 5) ,cdescrip) ,args))


(zero baktrace fork oblist ptime reset resetio zapline)
(zero-to-one arg close drain dumplisp exit
   gensym monitor nwritn random return terpr time-string tyipeek)
(zero-to-two err ratom read readc tyi)
(zero-to-inf + - * / and concat cond
   difference greaterp lessp list or plus product prog quotient setq
   sum times unconcat)
(one  1+ 1- absval add1
   aexplode aexplodec aexploden argv
   arrayp ascii asin acos atom bcdp
   bignum-to-list boundp car cdr chdir cos
   dtpr exp fact fake fix float frexp function get_pname getaccess getaux
   getd getdata getdelta
   getentry getenv getdisc getlength go haulong infile log 
   implode intern maknam maknum makunbound minus minusp
   not ncons null numberp onep plist pntlen portp ptr 
   quote readlist remob *rset sin sizeof stringp sub1 sqrt symbolp
   truename type valuep zerop)
(one-to-two errset flatc outfile patom print status tyo untyi)
(one-to-three fasl load process)
(one-to-inf funcall progv)
(two  allocate alphalessp
   arrayref assq atan bignum-leftshift *catch cons
   Divide eq equal freturn
   get haipart *invmod lsh
   mfunction mod *mod nthelem putaux putd
   putdata putdelta putdisc putlength
   remprop replace rot rplaca rplacd segment set setarg setplist scons
   signal sstatus sticky-bignum-leftshift *throw
   vref vrefi-byte vrefi-word vrefi-long)
   
(two-to-inf  apply def mapc mapcan mapcar mapcon maplist prog2)
(three putprop)
(three-to-five cfasl)
(three-to-inf boole)
(four Emuldiv)
(five marray)

EndOfFile
cat >  lisplib/machacks.l  << 'EndOfFile'
(setq rcs-machacks-
   "$Header: machacks.l 1.5 83/07/05 00:04:09 jkf Exp $")

;; (c) copywrite 1982, University of California, Berkeley
;; (c) copywrite 1982, Massachusetts Insititute of Technology

;; This file was originally written at the University of California,
;; Berkeley.  Some portions were modified and additions made were made at
;; MIT.

;; machacks - maclisp compatibility package.
;; when this file is fasl'ed into a lisp, it will change the syntax to
;; maclisp's syntax and will define functions know to the standard maclisp.
;; it is also used to bootstrap vaxima compilation.
;
; this file will be fasled whenever the -m switch is set for compilation.
;

(declare (macros t))

(def coutput
  (lambda (msg)
	  (print msg)	; should go to unfasl port
	  (terpr)))

;--- displace 
; this is useful after a macro has been expanded and you want to save the
; interpreter the trouble of expanding the macro again.  
; [this is really only useful for interpretation]
(defun displace (old-form new-form)
       (cond ((atom old-form)
	      (error '|not able to displace this form| old-form))
	     ((atom new-form)
	      (rplaca old-form 'progn)
	      (rplacd old-form (list new-form)))
	     (t (rplaca old-form (car new-form))
		(rplacd old-form (cdr new-form)))))



;--- fboundp  :: check if a symbol has a function binding
;
(defmacro fboundp (form &protect (form)) `(and (symbolp ,form) (getd ,form)))




(defmacro list* (&rest forms)
	  (cond ((null forms) nil)
		((null (cdr forms)) (car forms))
		(t (construct-list* forms))))

(eval-when (load compile eval)
   (defun construct-list* (forms)
	  (setq forms (reverse forms))
	  (do ((forms (cddr forms) (cdr forms))
	       (return-form `(cons ,(cadr forms) ,(car forms))
			     `(cons ,(car forms) ,return-form)))
	      ((null forms) return-form))))

(defmacro ttf (&rest l) `(list* . , l))


;; lexpr-funcall is a cross between apply and funcall.  the last arguments
;; is a list of the rest of the arguments
;; this is now in Franz Opus 38.35
;; (defmacro lexpr-funcall (func &rest args)
;;    `(apply ,func (list* ,@args)))

; contents of the file libmax;macros  all of these functions are
; (by default) in maclisp
;; (if x p q1 q2 ...) --> (cond (x p) (t q1 q2 ...))
;; it is important that (if nil <form>) returns nil as macsyma code depends
;; upon this in places.  see also ifn in libmax;maxmac.
; in Franz Lisp, opus 38.36 and on
;(defmacro if (predicate then &rest else)
;	  (cond ((null else) `(cond (,predicate ,then)))
;		(t `(cond (,predicate ,then) (t . ,else)))))

;; let, let*, list* are now a part of multics lisp.  nobody should miss
;; the code commented out below.
;; (let ((a 3) (b) c) stuff) --> ((lambda (a b c) stuff) 3 nil nil)
;; (let* ((a 3) (b 4)) stuff) --> ((lambda (a) ((lambda (b) stuff) 4)) 3)

;; (push x s) --> (setq s (cons x s))
; in franz
;(defmacro push (object list) `(setf ,list (cons ,object ,list)))

;; (pop s) -->   (prog1 (car s) (setf s (cdr s)))
;; (pop s v) --> (prog1 (setf v (car s)) (setf s (cdr s)))
;; this relies on the fact that setf returns the value stored.

;(defmacro pop (list &optional (into nil into-p))
;  (cond (into-p `(prog1 (setf ,into (car ,list))
;                        (setf ,list (cdr ,list))))
;        (t `(prog1 (car ,list)
;                   (setf ,list (cdr ,list))))))

;; (for i m n . body) will evaluate body with i bound to m,m+1,...,n-1
;; sequentially.  (for i 0 n . body) --> (dotimes (i n) . body)

(defmacro for (var start stop . body)
          `(do ,var ,start (1+ ,var) (= ,var ,stop) ,@body))

; these were grabbed from lspsrc;umlmac.5
(defmacro when (p . c) `(cond (,p . ,c)))
(defmacro unless (p . c) `(cond ((not ,p) . ,c)))


(defmacro if-for-maclisp-else-lispm (&rest ll) (car ll))

(defmacro logand (&rest forms) `(boole 1 . ,forms))
(defmacro logior (&rest forms) `(boole 7 . ,forms))
(defmacro logxor (&rest forms) `(boole 6 . ,forms))
(defmacro lognot (n) `(boole 10. ,n -1))
(defmacro bit-test (&rest forms) `(not (zerop (boole 1 . ,forms))))
(defmacro bit-set (x y) `(boole 7 ,x ,y))
(defmacro bit-clear (x y) `(boole 2 ,x ,y))

;; (<= a b) --> (not (> a b))
;; (<= a b c) --> (not (or (> a b) (> b c)))
;; funny arglist to check for correct number of arguments.

(defmacro <= (arg1 arg2 &rest rest &aux result)
  (setq rest (list* arg1 arg2 rest))
  (do l rest (cdr l) (null (cdr l))
      (push `(> ,(car l) ,(cadr l)) result))
  (cond ((null (cdr result)) `(not ,(car result)))
	(t `(not (or . ,(nreverse result))))))

;; (>= a b) --> (not (< a b))
;; (>= a b c) --> (not (or (< a b) (< b c)))
;; funny arglist to check for correct number of arguments.

(defmacro >= (arg1 arg2 &rest rest &aux result)
  (setq rest (list* arg1 arg2 rest))
  (do l rest (cdr l) (null (cdr l))
      (push `(< ,(car l) ,(cadr l)) result))
  (cond ((null (cdr result)) `(not ,(car result)))
	(t `(not (or . ,(nreverse result))))))



(defmacro psetq (var value . rest)
  (cond (rest `(setq ,var (prog1 ,value (psetq . ,rest))))
	(t `(setq ,var ,value))))

 
;; (dotimes (i n) body) evaluates body n times, with i bound to 0, 1, ..., n-1.
;; (dolist (x l) body) successively binds x to the elements of l, and evaluates
;; body each time.

;; things to beware of:
;; [1] this won't work for count being a bignum.
;; [2] if count is a symbol, somebody could clobber its value inside the body.
;; [3] somebody inside of body could reference **count**.

(defmacro dotimes ((var count) . body)
  (if (or (fixp count) (symbolp count))
      `(do ((,var 0 (1+ ,var)))
	   ((>= ,var ,count))
	   (declare (fixnum ,var))
	   . ,body)
      `(do ((,var 0 (1+ ,var))
	    (**count** ,count))
	   ((>= ,var **count**))
	   (declare (fixnum ,var **count**))
	   . ,body)))

(defmacro dolist ((var list) . body)
  `(do ((**list** ,list (cdr **list**))
	(,var))
       ((null **list**))
       (setq ,var (car **list**))
       . ,body))


;; symbolconc is the same as concat in franz
;
(defmacro symbolconc (&rest args) `(concat ,@args))


;-- these functions are from /usr/lib/lisp/lmhacks on the mit-vax

;;  This file contains miscellaneous functions and macros that 
;;  ZetaLisp users often find useful

(declare (macros t))

(defmacro macro (name argl &body body)
  `(def ,name (macro ,argl ,@body)))

(defun gcd (a b)
  (or (plusp a)
      (setq a (minus a)))
  (or (plusp b)
      (setq b (minus b)))
  (do ((a a b)
       (b b (remainder a b)))
      ((zerop b)
       a)))

(defmacro first (a) `(car ,a))
(defmacro second (a) `(cadr ,a))
(defmacro third (a) `(caddr ,a))
(defmacro fourth (a) `(cadddr ,a))
(defmacro fifth (a) `(car (cddddr ,a)))
(defmacro sixth (a) `(cadr (cddddr ,a)))
(defmacro seventh (a) `(caddr (cddddr ,a)))

(defmacro rest1 (list) `(cdr ,list))
(defmacro rest2 (list) `(cddr ,list))
(defmacro rest3 (list) `(cdddr ,list))
(defmacro rest4 (list) `(cddddr ,list))

(defmacro copylist (list) `(append ,list nil))
(defmacro copytree (list) `(subst nil nil ,list))

(defun circular-list (&rest elements)
  (setq elements (copylist elements))
  (rplacd (last elements) elements)
  elements)

(defun butlast (x)
  (cond ((null (cdr x)) nil)
	(t (cons (car x) (butlast (cdr x))))))

(defun find-position-in-list (item list)
  (do ((i 0 (1+ i)))
      ((null list) nil)
    (if (eq (car list) item)
	(return i)
	(setq list (cdr list)))))

(defun find-postion-in-list-equal (item list)
  (do ((i 0 (1+ i)))
      ((null list) nil)
    (if (equal (car list) item)
	(return i)
	(setq list (cdr list)))))

(defun mem (pred item list)
  (do ()
      ((null list) nil)
      (if (funcall pred item (car list))
	  (return list))
      (setq list (cdr list))))



;--- remq is in common2.l



(defun rem (pred item list &optional (cnt -1))
  (let ((head '())
	(tail nil))
    (do ((l list (cdr l))
	 (newcell))
	((null l) head)
      (cond ((or (funcall pred (car l) item)
		 (zerop cnt))
	     (setq newcell (list (car l)))
	     (cond ((null head) (setq head newcell))
		   (t (rplacd tail newcell)))
	     (setq tail newcell))
	    (t (setq cnt (1- cnt)))))))

(defun rem-if (pred list)
  (let ((head '())
	(tail nil))
    (do ((l list (cdr l))
	 (newcell))
	((null l) head)
      (cond ((not (funcall pred (car l)))
	     (setq newcell (list (car l)))
	     (cond ((null head) (setq head newcell))
		   (t (rplacd tail newcell)))
	     (setq tail newcell))))))

(defun rem-if-not (pred list)
  (let ((head '())
	(tail nil))
    (do ((l list (cdr l))
	 (newcell))
	((null l) head)
      (cond ((funcall pred (car l))
	     (setq newcell (list (car l)))
	     (cond ((null head) (setq head newcell))
		   (t (rplacd tail newcell)))
	     (setq tail newcell))))))

(make-equivalent subset rem-if-not)
(make-equivalent subset-not rem-if)

(defun del (pred item list &optional (cnt -1))
  (let ((ret (cons nil list)))
    (do ((list ret))
	((null (cdr list))
	 (cdr ret))
      (cond ((and (funcall pred item (second list))
		 (not (zerop cnt)))
	     (setq cnt (1- cnt))
	     (rplacd list (cddr list)))
	    (t (setq list (cdr list)))))))

(defun del-if (pred list)
  (let ((ret (cons nil list)))
    (do ((list ret))
	((null (cdr list))
	 (cdr ret))
	(if (funcall pred (second list))
	    (rplacd list (cddr list))
	    (setq list (cdr list))))))

(defun del-if-not (pred list)
  (let ((ret (cons nil list)))
    (do ((list ret))
	((null (cdr list))
	 (cdr ret))
	(if (not (funcall pred (second list)))
	    (rplacd list (cddr list))
	    (setq list (cdr list))))))

(defun some (forms pred &optional step-function)
  (and (not (null forms))
       (if (funcall pred (car forms))
	   forms
	   (some (if (null step-function)
		     (cdr forms)
		     (funcall step-function forms))
		 pred
		 step-function))))

(defun every (forms pred &optional step-function)
  (or (null forms)
      (and (funcall pred (car forms))
	   (every (if (null step-function)
		      (cdr forms)
		      (funcall step-function forms))
		  pred
		  step-function))))

(defmacro pairp (x) `(dtpr ,x))

(defun tailp (subset set)
  (do ((s set (cdr s)))
      ((null s) nil)
      (cond ((eq s subset) (return t)))))

; defunp
; like defun except it's an implicit prog
; expands
;  (defunp fn (args) form1 form2 ... formn)
; into
;  (defun fn (args) (prog () form1 form2 ... (return (formn))))
; and hence allows returns in the middle of "defun"'s
; If original defun body is just one form (eg, let, cond, etc.)
; return is wrapped around the whole thing.
;

(defmacro defunp (fn arglist . body)
  `(defun ,fn ,arglist
     (prog ()
       ,@(let ((bodyrev (reverse body)))
	      (nreconc (cdr bodyrev) 
		       (cond ((eq 'return (caar bodyrev))
			      ; last form is already a return
			      `(,(car bodyrev)))
			     (t `((return ,(car bodyrev))))))))))

(defmacro let-globally (vars-values . body)
  (let ((temp-vars (mapcar #'(lambda (q) (gensym)) vars-values)))
    `(progn ((lambda ,temp-vars ,@(mapcar #'(lambda (var-value value)
					      `(setq ,(car var-value) ,value))
					  vars-values temp-vars))
	      ,@(mapcar #'cadr vars-values))
	    ,@body)))

(defmacro local-declare (dcls . body)
    `(progn 'compile ,@(mapcar #'(lambda (x) `(declare ,x)) dcls) ,@body))

(defmacro defconst (variable &optional (initial-value nil iv-p) documentation)
  documentation ;; ignored for now.
  (if iv-p `(progn 'compile
		   (eval-when (eval compile load)
			      (declare (special ,variable)))
		   (setq ,variable ,initial-value))
      `(eval-when (eval compile load)
		  (declare (special ,variable)))))

(defmacro check-arg (var-name predicate description)
  `(if (not ,(if (atom predicate)
		 `(,predicate ,var-name)
		 predicate))
       (ferror t "The argument ~S was ~S, which is not ~A.~%"
	       ',var-name ,var-name ,description)))

(defmacro check-arg-type (var-name type-name &optional description)
  `(if (not (typep ,var-name ,type-name)
       (ferror t "The argument ~s was ~S, which is not ~A~A.~%"
	       ',var-name ,var-name
	       ,(if (null description) " a" "")
	       ,(if (null description) type-name description)))))

;;; Defsubst

(defmacro defsubst (function-spec lambda-list &body body)
  `(progn 'compile
     (defun ,function-spec ,lambda-list ,@body)
     (defcmacro ,function-spec ,lambda-list
       (sublis (list ,@(do ((v lambda-list (cdr v))
			    (r nil (cons `(cons ',(car v) ,(car v)) r)))
			 ((null v) (nreverse r))))
	       ',(if (null (cdr body)) (car body)
		    `(progn . ,body))))
     ',function-spec))

;--- ^ :: fixnum expt
(defun ^ (x y)
  (expt x y))

(putprop 'machacks t 'version)
EndOfFile
cat >  lisplib/loop.l  << 'EndOfFile'
(setq rcs-loop-
   "$Header: /usr/lib/lisp/loop.l,v 1.1 83/01/29 18:38:49 jkf Exp $")

;;;   LOOP  -*- Mode:LISP; Package:System-Internals; Base:8; Lowercase:T -*-
;;;   **********************************************************************
;;;   ****** Universal ******** LOOP Iteration Macro ***********************
;;;   **********************************************************************
;;;   **** (C) COPYRIGHT 1980, 1981 MASSACHUSETTS INSTITUTE OF TECHNOLOGY **
;;;   ******** THIS IS A READ-ONLY FILE! (ALL WRITES RESERVED) *************
;;;   **********************************************************************

;;;; LOOP Iteration Macro

;The master copy of this file is on ML:LSB1;LOOP >
;The current Lisp machine copy is on AI:LISPM2;LOOP >
;The FASL and QFASL should also be accessible from LIBLSP; on all machines.
;(Is this necessary anymore? LOOP is now in the Lisp Machine system and
; is accessible on LISP; and distributed with PDP10 Maclisp.)
;Duplicate source is usually also maintained on MC:LSB1;LOOP >
;Printed documentation is available as MIT-LCS Technical Memo 169,
; "LOOP Iteration Macro", from:
;	Publications
;	MIT Laboratory for Computer Science
;	545 Technology Square
;	Cambridge, MA 02139
; the text of which appears in only slightly modified form in the Lisp
; Machine manual.

; Bugs/complaints/suggestions/solicitations-for-documentation to BUG-LOOP
; at any ITS site (MIT-ML preferred).


; **********************************************************************
; *************************** NOTE WELL ********************************
; **********************************************************************
;Incremental compiling of things in this file will generate wrong code
; unless you first evaluate the 'feature' stuff on the next page
; ("readtime environment setup").  (This mainly of Lispm interest.)
;This source sincerely believes that it can run compatibly, WITHOUT ANY
; TEXTUAL MODIFICATIONS AT ALL, in PDP-10 Maclisp, Multics Maclisp, Lisp
; Machine Lisp (Zetalisp), VAX NIL, and Franz Lisp.  PLEASE do not make
; changes to this file (the master copy) if you are in any way unsure
; of the implications in a dialect you are not very familiar with;  let
; a LOOP maintainer take the responsibility for breaking the master copy
; and maintaining some semblance of sanity among the disparities.  Note
; in particular that LOOP also runs in the PDP10 Maclisp -> Vax NIL
; cross-compiler;  that environment requires LOOP to produce code which
; can at the same time be interpreted in Maclisp, and compiled for NIL.


; Bootstrap up our basic primitive environment.
; This includes backquote, sharpsign, defmacro, let.

(eval-when (eval compile)
  (cond ((status feature Multics)
	   (defun include-for-multics macro (x)
	     (cons '%include (cdr x))))
	('t #-Franz (macro include-for-multics (x) ())
	    #+Franz (defmacro include-for-multics (x) nil))))

(include-for-multics lisp_prelude)
(include-for-multics lisp_dcls)

#+Franz (environment-maclisp)


;;;; Readtime Environment Setup

;Now set up the readtime conditionalization environment.   This won't work
; in any compiler that reads the whole file before compiling anything.
; It is a good idea to pretend that case matters in ALL contexts.
; This is in fact true in Franz at the present.  Case matters to Multics
; in symbols, except for <frob> in (status feature <frob>).
(eval-when (eval compile)
  #+NIL (progn
	   (defmacro loop-featurep (f)
	     `(featurep ',f target-features))
	   (defmacro loop-nofeaturep (f)
	     `(nofeaturep ',f target-features))
	   (defmacro loop-set-feature (f)
	     `(set-feature ',f target-features))
	   (defmacro loop-set-nofeature (f)
	     `(set-nofeature ',f target-features))
	   )
  #-NIL (progn
	   (defmacro loop-featurep (f)
	     `(status feature ,f))
	   (defmacro loop-nofeaturep (f)
	     ; Multics doesn't have (status nofeature)...
	     `(not (status feature ,f)))
	   (defmacro loop-set-feature (f)
	     `(sstatus feature ,f))
	   (defmacro loop-set-nofeature (f)
	     ; Does this work on Multics???  I think not but we don't use.
	     `(sstatus nofeature ,f))
	   )
  ;Note:  NEVER in this file is "PDP-10" a valid feature or substring of
  ; a feature.  It is NEVER hyphenated.  Keep it that way.  (This because
  ; of continuous lossage with not setting up one or the other of the
  ; hyphenated/non-hyphenated one.)
  (cond ((and (loop-featurep PDP10)
	      (loop-featurep NILAID))
	   ;Compiling a PDP10 -> NIL cross-compiling LOOP.
	   ; We check the PDP10 feature first sort of gratuitously so that
	   ; other implementations don't think we are asking about an undefined
	   ; feature name.  (Vax-NIL specifically.)
	   (loop-set-feature For-NIL)
	   (loop-set-nofeature For-Maclisp)
	   (loop-set-nofeature For-PDP10)
	   (loop-set-feature Run-in-Maclisp)
	   (loop-set-feature Run-on-PDP10)
	   (loop-set-nofeature Franz))
	((and (loop-featurep Maclisp) (loop-nofeaturep For-NIL))
	   ; Standard in-Maclisp for-Maclisp.
	   (loop-set-feature For-Maclisp)
	   (loop-set-feature Run-In-Maclisp)
	   (cond ((loop-nofeaturep Multics)
		    (loop-set-feature For-PDP10)
		    (loop-set-feature PDP10)
		    (loop-set-feature Run-on-PDP10))))
	((loop-featurep NIL)
	   ; Real NIL
	   (loop-set-nofeature PDP10)
	   (loop-set-nofeature Multics)
	   (loop-set-nofeature Run-on-PDP10)
	   (loop-set-nofeature For-PDP10)
	   (loop-set-nofeature Run-In-Maclisp)
	   (loop-set-nofeature For-Maclisp))
	((loop-featurep Lispm))
	((loop-featurep franz)
	   ;The "natural" case of features in franz is all lower.
	   ; Since that is unlike the others used in here, we synonymize
	   ; the obvious other choice.
	   (loop-set-feature Franz))
	('t (break loop-implementation-unknown)))
  (cond ((or (loop-featurep Lispm) (loop-featurep For-PDP10))
	   (loop-set-feature Hairy-Collection))
	('t (loop-set-nofeature Hairy-Collection)))
  (cond ((or (loop-featurep For-NIL) (loop-featurep For-PDP10))
	   (loop-set-feature System-Destructuring))
	('t (loop-set-nofeature System-Destructuring)))
  (cond ((or (loop-featurep For-NIL) (loop-featurep Lispm))
	   (loop-set-feature Named-PROGs))
	('t (loop-set-nofeature Named-PROGs)))
  ;In the following two features, "Local" means the Lisp LOOP will be
  ; running in, not the one it is being compiled in.  "Targeted" means
  ; the Lisp it will be producing code for.  (All from the point of view
  ; of the running LOOP, you see.)
  (cond ((or (loop-featurep For-NIL) (loop-featurep Lispm))
	   (loop-set-feature Targeted-Lisp-has-Packages))
	('t (loop-set-nofeature Targeted-Lisp-has-Packages)))
  (cond ((or (loop-featurep Franz) (loop-featurep Run-in-Maclisp))
	   (loop-set-nofeature Local-Lisp-has-Packages))
	('t (loop-set-feature Local-Lisp-has-Packages)))
  (cond ((loop-featurep For-NIL) (loop-set-feature Vector-Destructuring))
	('t (loop-set-nofeature Vector-Destructuring)))
  ;Meaningful-Type-Declarations means that the declarations are (1)
  ; implemented by the compiler and (2) used for something.
  ; Assume minimally maclisp-like FIXNUM and FLONUM dcls, for local
  ; variables or function results.
  (cond ((loop-featurep Run-in-Maclisp)
	   (loop-set-feature Meaningful-Type-Declarations))
	('t (loop-set-nofeature Meaningful-Type-Declarations)))
  ;Hair for 3600 cross-compilation?
  (cond ((and (loop-featurep Lispm) (not (loop-featurep 3600.)))
	   (loop-set-feature Loop-Small-Floatp))
	('t (loop-set-nofeature Loop-Small-Floatp)))
  ; -> insert more conditionals here <-
  ())

#+Franz
(eval-when (eval compile)
  (setsyntax #// 143.) ; Make slash be slash
  (setsyntax #/\ 2.) ; make backslash alphabetic
  )


#+Run-on-PDP10
(eval-when (compile)
  ;Note this hack used when compiled only.
  ;Its purpose in life is to save a bit of space in the load-time environment,
  ; since loop doesn't actually need the PDP10 Maclisp doublequoted crocks
  ; to remember their origin as "strings".
  (setsyntax #/" 'macro
	     '(lambda ()
		(do ((ch (tyi) (tyi)) (l () (cons ch l)))
		    ((= ch #/")
		     (list squid (list 'quote (implode (nreverse l)))))
		  (and (= ch #//) (setq ch (tyi)))))))


;;;; Other basic header stuff


; Following isn't needed on Lispm, as loop is installed there (ie, these
; symbols are already in GLOBAL).
#+(and Targeted-Lisp-has-Packages (not Lispm))
(mapc 'globalize
      '("LOOP"					; Major macro
	"LOOP-FINISH"				; Handy macro
	"DEFINE-LOOP-MACRO"
	"DEFINE-LOOP-PATH"			; for users to define paths
	"DEFINE-LOOP-SEQUENCE-PATH"		; this too
	))

#+(or For-NIL For-PDP10)
(herald LOOP)


;;;; Macro Environment Setup

;Wrapper for putting around DEFMACRO etc. forms to determine whether
; they are defined in the compiled output file or not.  (It is assumed
; that DEFMACRO forms will be.)  Making loop-macro-progn output for loading
; is convenient if loop will have incremental-recompilation done on it.
; (Note, of course, that the readtime environment is NOT set up.)

#+Lispm
(defmacro loop-macro-progn (&rest forms)
    `(progn 'compile ,@forms))
#-Lispm
(eval-when (eval compile)
    (defmacro loop-macro-progn (&rest forms)
	`(eval-when (eval compile) ,@forms)))


; Hack up the stuff for data-types.  DATA-TYPE? will always be a macro
; so that it will not require the data-type package at run time if
; all uses of the other routines are conditionalized upon that value.
(eval-when (eval compile)
  ; Crock for DATA-TYPE? derives from DTDCL.  We just copy it rather
  ; than load it in, which requires knowing where it comes from (sigh).
  ; 
  #-Local-Lisp-has-Packages
    (defmacro data-type? (x) `(get ,x ':data-type))
  #+Local-Lisp-has-Packages
    (defmacro data-type? (frob)
      (let ((foo (gensym)))
	`((lambda (,foo)
	    ; NIL croaks if () given to GET...
	    (and #+NIL (symbolp ,foo) #-NIL 't
		 (or (get ,foo ':data-type)
		     (and (setq ,foo (intern-soft (get-pname ,foo) ""))
			  (get ,foo ':data-type)))))
	  ,frob))))

(declare (*lexpr variable-declarations)
	 ; Multics defaults to free-functional-variable since it is declared
	 ; special & used as function before it is defined:
	 (*expr loop-when-it-variable)
	 (*expr initial-value primitive-type)
       #+(or Maclisp Franz) (macros t) ; Defmacro dependency
       #+Run-in-Maclisp
	 (muzzled t)	; I know what i'm doing
	 )

#+Run-on-PDP10
(declare (mapex ())
	 (genprefix loop/|-)
	 (special squid)
       #+(and Run-in-Maclisp For-NIL) ; patch it up
         (*expr stringp vectorp vref vector-length)
         )

#-Run-on-PDP10
(declare
  #+Lispm (setq open-code-map-switch t)
  #+Run-in-Maclisp (mapex t)
  #+Run-in-Maclisp (genprefix loop-iteration/|-))

#+Run-on-PDP10
(mapc '(lambda (x)
	   (or (getl x '(subr lsubr fsubr macro fexpr expr autoload))
	       ; This dtdcl will sort of work for NIL code generation,
	       ; if declarations will ignored.
	       (putprop x '((lisp) dtdcl fasl) 'autoload)))
      '(data-type? variable-declarations initial-value primitive-type))

(loop-macro-progn
 (defmacro loop-copylist* (l)
    #+Lispm `(copylist* ,l)
    #-Lispm `(append ,l ())))


;;;; Random Macros

; Error macro.  Note that in the PDP10 version we call LOOP-DIE rather
; than ERROR -- there are so many occurences of it in this source that
; it is worth breaking off that function, since calling the lsubr ERROR
; takes more inline code.
(loop-macro-progn
 (defmacro loop-simple-error (unquoted-message &optional (datum () datump))
    #+(and Run-In-Maclisp (not Multics))
      (progn (cond ((symbolp unquoted-message))
		   ((and (not (atom unquoted-message))
			 compiler-state
			 (eq (car unquoted-message) squid)
			 (not (atom (setq unquoted-message
					  (cadr unquoted-message))))
			 (eq (car unquoted-message) 'quote)
			 (symbolp (cadr unquoted-message)))
		      (setq unquoted-message (cadr unquoted-message)))
		   ('t (error '|Uloze -- LOOP-SIMPLE-ERROR|
			      (list 'loop-simple-error
				    unquoted-message datum))))
	     (cond (datump `(loop-die ',unquoted-message ,datum))
		   ('t `(error ',unquoted-message))))
    #+(or Franz Multics)
      (progn (or (memq (typep unquoted-message) '(string symbol))
		 (error '|Uloze -- | (list 'loop-simple-error
					   unquoted-message datum)))
	     `(error ,(let ((l (list "lisp:  " unquoted-message
				     (if datump " -- " ""))))
			#+Franz (get_pname (apply 'uconcat l))
			#-Franz (apply 'catenate l))
		     . ,(and datump (list datum))))
    #-(or Run-In-Maclisp Franz)
      `(ferror () ,(if datump (string-append "~S " unquoted-message)
		       unquoted-message)
	       . ,(and datump (list datum)))))


#+(and Run-in-Maclisp (not Multics))
(defun loop-die (arg1 arg2)
    (error arg1 arg2))


; This is a KLUDGE.  But it apparently saves an average of two inline
; instructions per call in the PDP10 version...  The ACS prop is
; fairly gratuitous.

#+Run-on-PDP10
(progn 'compile
   (lap-a-list 
     '((lap loop-pop-source subr)
       (args loop-pop-source (() . 0))
	   (hlrz a @ (special loop-source-code))
	   (hrrz b @ (special loop-source-code))
	   (movem b (special loop-source-code))
	   (popj p)
       nil))
   (eval-when (compile)
       (defprop loop-pop-source 2 acs)
       ))

#-Run-on-PDP10
(loop-macro-progn
 (defmacro loop-pop-source () '(pop loop-source-code)))

(loop-macro-progn
 (defmacro object-that-cares-p (x)
   #+Lispm `(listp ,x)
   #+(or NIL PDP10) `(pairp ,x)
   #-(or Lispm NIL PDP10) `(eq (typep ,x) 'list)))


;;;; Variable defining macros

;There is some confusion among lisps as to whether or not a file containing
; a DEFVAR will declare the variable when the compiled file is loaded
; into a compiler.  LOOP assumes that DEFVAR does so (this is needed for
; various user-accessible variables).  DEFIVAR is for "private" variables.
; Note that this is moot for Lispm due to incremental-recompilation support
; anyway.
;Multics lcp has some bug whereby DECLARE and (EVAL-WHEN (COMPILE) ...)
; don't get hacked properly inside of more than one level of
; (PROGN 'COMPILE ...).  Thus we hack around DEFVAR and DEFIVAR to bypass
; this lossage.
;Franz DEFVAR does not make the declaration on loading, so we redefine it.

#+(or Multics Franz)
(loop-macro-progn
 (defmacro defvar (name &optional (init nil initp) documentation
		   &aux (dclform `(and #+Franz (getd 'special)
				       #-Franz (status feature compiler)
				       (special ,name))))
    ; For some obscure reason, (DECLARE ...) doesn't take effect within 2
    ; (PROGN 'COMPILE ...)s, but (EVAL-WHEN (COMPILE) ...) does, on Multics.
    (eval dclform) ; sigh
    (cond ((not initp) dclform)
	  (t `(progn 'compile
		     ,dclform
		     (or (boundp ',name) (setq ,name ,init)))))))

(loop-macro-progn
 ; A DEFVAR alternative - "DEFine Internal VARiable".
 (defmacro defivar (name &optional (init () initp))
    ; The Lispm choice here is based on likelihood of incremental compilation.
    #+Lispm `(defvar ,name ,@(and initp `(,init)))
    #+Multics (progn (apply 'special (list name))
		     (if initp `(or (boundp ',name) (setq ,name ,init))
			 `(progn 'compile)))
    #-(or Lispm Multics)
      `(progn 'compile
	      (declare (special ,name))
	      . ,(and initp `((or (boundp ',name) (setq ,name ,init)))))))

#+Franz
;Defconst is like defvar but always initializes.
; It happens in this case that we really don't care about the global
; declaration on loading, so actually treat it more like DEFIVAR.
; (This is now in Multics and PDP10 Maclisp, thanks to Maclisp Extensions
; Manual.)
(loop-macro-progn
  (defmacro defconst (name init &optional documentation)
    `(progn 'compile (declare (special ,name)) (setq ,name ,init))))



;;;; Setq Hackery

; Note:  LOOP-MAKE-PSETQ is NOT flushable depending on the existence
; of PSETQ, unless PSETQ handles destructuring.  Even then it is
; preferable for the code LOOP produces to not contain intermediate
; macros, especially in the PDP10 version.

(defun loop-make-psetq (frobs)
    (and frobs
	 (loop-make-setq
	    (list (car frobs)
		  (if (null (cddr frobs)) (cadr frobs)
		      `(prog1 ,(cadr frobs)
			      ,(loop-make-psetq (cddr frobs))))))))

#-System-Destructuring
(progn 'compile

(defvar si:loop-use-system-destructuring?
    ())

(defivar loop-desetq-temporary)

; Do we want this???  It is, admittedly, useful...
;(defmacro loop-desetq (&rest x)
;  (let ((loop-desetq-temporary ()))
;     (let ((setq-form (loop-make-desetq x)))
;	(if loop-desetq-temporary
;	    `((lambda (,loop-desetq-temporary) ,setq-form) ())
;	    setq-form))))


(defun loop-make-desetq (x)
   (if si:loop-use-system-destructuring?
       (cons (do ((l x (cddr l))) ((null l) 'setq)
	       (or (and (not (null (car l))) (symbolp (car l)))
		   (return 'desetq)))
	     x)
       (do ((x x (cddr x)) (r ()) (var) (val))
	   ((null x) (and r (cons 'setq r)))
	 (setq var (car x) val (cadr x))
	 (cond ((and (not (atom var))
		     (not (atom val))
		     (not (and (memq (car val)
				     '(car cdr cadr cddr caar cdar))
			       (atom (cadr val)))))
		  (setq x (list* (or loop-desetq-temporary
				     (setq loop-desetq-temporary (gensym)))
				 val var loop-desetq-temporary (cddr x)))))
	 (setq r (nconc r (loop-desetq-internal (car x) (cadr x)))))))

(defun loop-desetq-internal (var val)
  (cond ((null var) ())
	((atom var) (list var val))
	('t (nconc (loop-desetq-internal (car var) `(car ,val))
		   (loop-desetq-internal (cdr var) `(cdr ,val))))))
); End desetq hackery for #-System-Destructuring


(defun loop-make-setq (pairs)
    (and pairs
	 #-System-Destructuring
	   (loop-make-desetq pairs)
	 #+System-Destructuring
	   (cons (do ((l pairs (cddr l))) ((null l) 'setq)
		   (or (and (car l) (symbolp (car l))) (return 'desetq)))
		 pairs)))


(defconst loop-keyword-alist			;clause introducers
     '(
      #+Named-PROGs
	(named loop-do-named)
	(initially loop-do-initially)
	(finally loop-do-finally)
	(nodeclare loop-nodeclare)
	(do loop-do-do)
	(doing loop-do-do)
	(return loop-do-return)
	(collect loop-do-collect list)
	(collecting loop-do-collect list)
	(append loop-do-collect append)
	(appending loop-do-collect append)
	(nconc loop-do-collect nconc)
	(nconcing loop-do-collect nconc)
	(count loop-do-collect count)
	(counting loop-do-collect count)
	(sum loop-do-collect sum)
	(summing loop-do-collect sum)
	(maximize loop-do-collect max)
	(minimize loop-do-collect min)
	(always loop-do-always or)
	(never loop-do-always and)
	(thereis loop-do-thereis)
	(while loop-do-while or while)
	(until loop-do-while and until)
	(when loop-do-when ())
	(if loop-do-when ())
 	(unless loop-do-when t)
	(with loop-do-with)))


(defconst loop-iteration-keyword-alist
    `((for loop-do-for)
      (as loop-do-for)
      (repeat loop-do-repeat)))


(defconst loop-for-keyword-alist			;Types of FOR
     '( (= loop-for-equals)
        (first loop-for-first)
	(in loop-list-stepper car)
	(on loop-list-stepper ())
	(from loop-for-arithmetic from)
	(downfrom loop-for-arithmetic downfrom)
	(upfrom loop-for-arithmetic upfrom)
	(below loop-for-arithmetic below)
	(to loop-for-arithmetic to)
	(being loop-for-being)))

#+Named-PROGs
(defivar loop-prog-names)

(defvar loop-path-keyword-alist ())		; PATH functions
(defivar loop-named-variables)			; see SI:LOOP-NAMED-VARIABLE
(defivar loop-collection-crocks)		; see LOOP-DO-COLLECT etc
(defivar loop-variables)			;Variables local to the loop
(defivar loop-declarations)			; Local dcls for above
(defivar loop-nodeclare)			; but don't declare these
(defivar loop-variable-stack)
(defivar loop-declaration-stack)
#-System-Destructuring
(defivar loop-desetq-crocks)			; see loop-make-variable
#-System-Destructuring
(defivar loop-desetq-stack)			; and loop-translate-1
(defivar loop-prologue)				;List of forms in reverse order
(defivar loop-before-loop)
(defivar loop-body)				;..
(defivar loop-after-body)			;.. for FOR steppers
(defivar loop-epilogue)				;..
(defivar loop-after-epilogue)			;So COLLECT's RETURN comes after FINALLY
(defivar loop-conditionals)			;If non-NIL, condition for next form in body
  ;The above is actually a list of entries of the form
  ;(cond (condition forms...))
  ;When it is output, each successive condition will get
  ;nested inside the previous one, but it is not built up
  ;that way because you wouldn't be able to tell a WHEN-generated
  ;COND from a user-generated COND.
  ;When ELSE is used, each cond can get a second clause

(defivar loop-when-it-variable)			;See LOOP-DO-WHEN
(defivar loop-never-stepped-variable)		; see LOOP-FOR-FIRST
(defivar loop-emitted-body?)			; see LOOP-EMIT-BODY,
						; and LOOP-DO-FOR
(defivar loop-iteration-variables)		; LOOP-MAKE-ITERATION-VARIABLE
(defivar loop-iteration-variablep)		; ditto
(defivar loop-collect-cruft)			; for multiple COLLECTs (etc)
(defivar loop-source-code)
(defvar loop-duplicate-code ())  ; see LOOP-OPTIMIZE-DUPLICATED-CODE-ETC


;;;; Token Hackery

;Compare two "tokens".  The first is the frob out of LOOP-SOURCE-CODE,
;the second a symbol to check against.

; Consider having case-independent comparison on Multics.
#+(or Multics Franz)
(progn 'compile
    (defmacro si:loop-tequal (x1 x2)
	`(eq ,x1 ,x2))
    (defmacro si:loop-tmember (x l)
	`(memq ,x ,l))
    (defmacro si:loop-tassoc (x l)
	`(assq ,x ,l)))


#+Lispm
(progn 'compile
   (defun si:loop-tequal (x1 x2)
	(and (symbolp x1) (string-equal x1 x2)))
   (defun si:loop-tassoc (kwd alist)
	(and (symbolp kwd) (ass #'string-equal kwd alist)))
   (defun si:loop-tmember (kwd list)
	(and (symbolp kwd) (mem #'string-equal kwd list))))


#+Run-on-PDP10
(progn 'compile
   #+For-NIL
     (defun si:loop-tequal (x1 x2)
	 (eq x1 x2))
   #-For-NIL
     (progn 'compile
	(eval-when (load compile)
	   (cond ((status feature complr)
		    ; Gross me out!
		    (setq macrolist
			  (cons '(si:loop-tequal
				    . (lambda (x) (cons 'eq (cdr x))))
				(delq (assq 'si:loop-tequal macrolist)
				      macrolist)))
		    (*expr si:loop-tmember si:loop-tassoc))))
	(defun si:loop-tequal (x1 x2)
	   (eq x1 x2)))
     (defun si:loop-tmember (kwd list)
	 (memq kwd list))
     (defun si:loop-tassoc (kwd alist)
	 (assq kwd alist))
     )

#+(and For-NIL (not Run-in-Maclisp))
(progn 'compile
  ; STRING-EQUAL only accepts strings.  GET-PNAME can be open-coded
  ; however.
  (defun si:loop-tequal (kwd1 kwd2)
      (and (symbolp kwd1) (string-equal (get-pname kwd1) (get-pname kwd2))))
  (defun si:loop-tassoc (kwd alist)
    (cond ((symbolp kwd)
	     (setq kwd (get-pname kwd))
	     (do ((l alist (cdr l))) ((null l) ())
	       (and (string-equal kwd (get-pname (caar l)))
		    (return (car l)))))))
  (defun si:loop-tmember (token list)
     (cond ((symbolp token)
	      (setq token (get-pname token))
	      (do ((l list (cdr l))) ((null l))
		(and (string-equal token (get-pname (car l)))
		     (return l)))))))


#+(or For-PDP10 For-NIL)
(eval-when (eval compile) (setq defmacro-displace-call ()))

(defmacro define-loop-macro (keyword)
    (or (eq keyword 'loop)
	(si:loop-tassoc keyword loop-keyword-alist)
	(si:loop-tassoc keyword loop-iteration-keyword-alist)
	(loop-simple-error "not a loop keyword - define-loop-macro" keyword))
    (subst keyword 'keyword
	   '(eval-when (compile load eval)
	      #+(or For-NIL Run-on-PDP10)
	        (progn (flush-macromemos 'keyword ())
		       (flush-macromemos 'loop ()))
	      #-Run-in-Maclisp
	        (progn
		  #+Franz
		    (putd 'keyword
			  '(macro (macroarg) (loop-translate macroarg)))
		  #-Franz
		    (fset-carefully 'keyword '(macro . loop-translate)))
	      #+Run-in-Maclisp
	        (progn (defprop keyword loop-translate macro))
	      )))

#+(or For-PDP10 For-NIL)
(eval-when (eval compile) (setq defmacro-displace-call 't))

(define-loop-macro loop)

#+Run-in-Maclisp
(defun (loop-finish macro) (form)
    ;This definition solves two problems:
    ; (1) wasted address space
    ; (2) displacing of a form which might tend to be pure.
    ; There is little point in macro-memoizing a constant anyway.
    (and (cdr form) (loop-simple-error "Wrong number of args" form))
    '(go end-loop))

#-Run-in-Maclisp
(defmacro loop-finish () 
    '(go end-loop))


(defun loop-translate (x)
    #-(or For-NIL Run-on-PDP10) (displace x (loop-translate-1 x))
    #+(or For-NIL Run-on-PDP10)
      (or (macrofetch x) (macromemo x (loop-translate-1 x) 'loop)))


(defun loop-end-testify (list-of-forms)
    (if (null list-of-forms) ()
	`(and ,(if (null (cdr (setq list-of-forms (nreverse list-of-forms))))
		   (car list-of-forms)
		   (cons 'or list-of-forms))
	      (go end-loop))))

(defun loop-optimize-duplicated-code-etc (&aux before after groupa groupb a b
					       lastdiff)
    (do ((l1 (nreverse loop-before-loop) (cdr l1))
	 (l2 (nreverse loop-after-body) (cdr l2)))
	((equal l1 l2)
	   (setq loop-body (nconc (delq '() l1) (nreverse loop-body))))
      (push (car l1) before) (push (car l2) after))
    (cond ((not (null loop-duplicate-code))
	     (setq loop-before-loop (nreverse (delq () before))
		   loop-after-body (nreverse (delq () after))))
	  ('t (setq loop-before-loop () loop-after-body ()
		    before (nreverse before) after (nreverse after))
	      (do ((bb before (cdr bb)) (aa after (cdr aa)))
		  ((null aa))
		(cond ((not (equal (car aa) (car bb))) (setq lastdiff aa))
		      ((not (si:loop-simplep (car aa)))	;Mustn't duplicate
		       (return ()))))
	      (cond (lastdiff  ;Down through lastdiff should be duplicated
		     (do () (())
		       (and (car before) (push (car before) loop-before-loop))
		       (and (car after) (push (car after) loop-after-body))
		       (setq before (cdr before) after (cdr after))
		       (and (eq after (cdr lastdiff)) (return ())))
		     (setq loop-before-loop (nreverse loop-before-loop)
			   loop-after-body (nreverse loop-after-body))))
	      (do ((bb (nreverse before) (cdr bb))
		   (aa (nreverse after) (cdr aa)))
		  ((null aa))
		(setq a (car aa) b (car bb))
		(cond ((and (null a) (null b)))
		      ((equal a b)
		         (loop-output-group groupb groupa)
			 (push a loop-body)
			 (setq groupb () groupa ()))
		      ('t (and a (push a groupa)) (and b (push b groupb)))))
	      (loop-output-group groupb groupa)))
    (and loop-never-stepped-variable
	 (push `(setq ,loop-never-stepped-variable ()) loop-after-body))
    ())


(defun loop-output-group (before after)
    (and (or after before)
	 (let ((v (or loop-never-stepped-variable
		      (setq loop-never-stepped-variable
			    (loop-make-variable (gensym) ''t ())))))
	    (push (cond ((not before) `(or ,v (progn . ,after)))
			((not after) `(and ,v (progn . ,before)))
			('t `(cond (,v . ,before) ('t . ,after))))
		  loop-body))))


(defun loop-translate-1 (loop-source-code)
  (and (eq (car loop-source-code) 'loop)
       (setq loop-source-code (cdr loop-source-code)))
  (do ((loop-iteration-variables ())
       (loop-iteration-variablep ())
       (loop-variables ())
       (loop-nodeclare ())
       (loop-named-variables ())
       (loop-declarations ())
     #-System-Destructuring
       (loop-desetq-crocks ())
       (loop-variable-stack ())
       (loop-declaration-stack ())
     #-System-destructuring
       (loop-desetq-stack ())
       (loop-prologue ())
       (loop-before-loop ())
       (loop-body ())
       (loop-emitted-body? ())
       (loop-after-body ())
       (loop-epilogue ())
       (loop-after-epilogue ())
       (loop-conditionals ())
       (loop-when-it-variable ())
       (loop-never-stepped-variable ())
     #-System-Destructuring
       (loop-desetq-temporary ())
     #+Named-PROGs
       (loop-prog-names ())
       (loop-collect-cruft ())
       (loop-collection-crocks ())
       (keyword)
       (tem)
       (progvars))
      ((null loop-source-code)
       (and loop-conditionals
	    (loop-simple-error "Hanging conditional in loop macro"
			       (caadar loop-conditionals)))
       (loop-optimize-duplicated-code-etc)
       (loop-bind-block)
       (setq progvars loop-collection-crocks)
     #-System-Destructuring
       (and loop-desetq-temporary (push loop-desetq-temporary progvars))
       (setq tem `(prog #+Named-PROGs ,.loop-prog-names
			,progvars
		      #+Hairy-Collection
		        ,.(do ((l loop-collection-crocks (cddr l))
			       (v () (cons `(loop-collect-init
					        ,(cadr l) ,(car l))
					    v)))
			      ((null l) v))
		      ,.(nreverse loop-prologue)
		      ,.loop-before-loop
		   next-loop
		      ,.loop-body
		      ,.loop-after-body
		      (go next-loop)
		      ; Multics complr notices when end-loop is not gone
		      ; to.  So we put in a dummy go.  This does not generate
		      ; extra code, at least in the simple example i tried,
		      ; but it does keep it from complaining about unused
		      ; go tag.
	    #+Multics (go end-loop)
		   end-loop
		      ,.(nreverse loop-epilogue)
		      ,.(nreverse loop-after-epilogue)))
       (do ((vars) (dcls) #-System-Destructuring (crocks))
	   ((null loop-variable-stack))
	 (setq vars (car loop-variable-stack)
	       loop-variable-stack (cdr loop-variable-stack)
	       dcls (car loop-declaration-stack)
	       loop-declaration-stack (cdr loop-declaration-stack)
	       tem (ncons tem))
	 #-System-Destructuring
	   (and (setq crocks (pop loop-desetq-stack))
		(push (loop-make-desetq crocks) tem))
	 (and dcls (push (cons 'declare dcls) tem))
	 (cond ((do ((l vars (cdr l))) ((null l) ())
		  (and (not (atom (car l)))
		       (or (null (caar l)) (not (symbolp (caar l))))
		       (return 't)))
		  (setq tem `(let ,(nreverse vars) ,.tem)))
	       ('t (let ((lambda-vars ()) (lambda-vals ()))
		     (do ((l vars (cdr l)) (v)) ((null l))
		       (cond ((atom (setq v (car l)))
				(push v lambda-vars)
				(push () lambda-vals))
			     ('t (push (car v) lambda-vars)
				 (push (cadr v) lambda-vals))))
		     (setq tem `((lambda ,lambda-vars ,.tem)
				 ,.lambda-vals))))))
       tem)
    (if (symbolp (setq keyword (loop-pop-source)))
	(if (setq tem (si:loop-tassoc keyword loop-keyword-alist))
	    (apply (cadr tem) (cddr tem))
	    (if (setq tem (si:loop-tassoc
			     keyword loop-iteration-keyword-alist))
		(loop-hack-iteration tem)
		(if (si:loop-tmember keyword '(and else))
		    ; Alternative is to ignore it, ie let it go around to the
		    ; next keyword...
		    (loop-simple-error
		       "secondary clause misplaced at top level in LOOP macro"
		       (list keyword (car loop-source-code)
			     (cadr loop-source-code)))
		    (loop-simple-error
		       "unknown keyword in LOOP macro" keyword))))
	(loop-simple-error
	   "found where keyword expected in LOOP macro" keyword))))


(defun loop-bind-block ()
   (cond ((not (null loop-variables))
	    (push loop-variables loop-variable-stack)
	    (push loop-declarations loop-declaration-stack)
	    (setq loop-variables () loop-declarations ())
	    #-System-Destructuring
	      (progn (push loop-desetq-crocks loop-desetq-stack)
		     (setq loop-desetq-crocks ())))))


;Get FORM argument to a keyword.  Read up to atom.  PROGNify if necessary.
(defun loop-get-form ()
  (do ((forms (ncons (loop-pop-source)) (cons (loop-pop-source) forms))
       (nextform (car loop-source-code) (car loop-source-code)))
      ((atom nextform)
       (if (null (cdr forms)) (car forms)
	   (cons 'progn (nreverse forms))))))


;Note that this function is not absolutely general.  For instance, in Maclisp,
; the functions < and > can only take 2 args, whereas greaterp and lessp
; may take any number.  Also, certain of the generic functions behave
; differently from the type-specific ones in "degenerate" cases, like
; QUOTIENT or DIFFERENCE of one arg.
;And of course one always must be careful doing textual substitution.
(defun loop-typed-arith (substitutable-expression data-type)
  #-(or Lispm Franz)
    (if (setq data-type (car (si:loop-tmember (if (data-type? data-type)
						  (primitive-type data-type)
						  data-type)
					      '(fixnum flonum))))
	(sublis (cond ((eq data-type 'fixnum)
		         #+For-NIL
			   '((plus . +&) (add1 . 1+&)
			     (difference . -&) (sub1 . 1-&)
			     (quotient . //&) (remainder . \&) (times . *&)
			     (zerop . 0p) (plusp . +p) (minusp . -p)
			     (greaterp . >&) (lessp . <&)
			     (min . min&) (max . max&))
			 #-For-NIL
			   '((plus . +) (add1 . 1+)
			     (difference . -) (sub1 . 1-)
			     (quotient . //) (remainder . \) (times . *)
			     (greaterp . >) (lessp . <)))
		      ('t #+For-NIL
			    '((plus . +$) (difference . -$)
			      (add1 . 1+$) (sub1 . 1-$)
			      (quotient . //$) (times . *$)
			      (greaterp . >$) (lessp . <$)
			      (max . max$) (min . min$))
			  #-For-NIL
			    '((plus . +$) (difference . -$)
			      (add1 . 1+$) (sub1 . 1-$)
			      (quotient . //$) (times . *$)
			      (greaterp . >) (lessp . <))))
		substitutable-expression)
	substitutable-expression)
  #+Lispm
    (progn data-type substitutable-expression)
  #+Franz
    (if (si:loop-tequal data-type 'fixnum)
	(sublis '((add1 . 1+) (sub1 . 1-) (plus . +) (difference . -)
		  (times . *) (quotient . //) (remainder . \))
		substitutable-expression)
	substitutable-expression)
  )


(defun loop-typed-init (data-type)
    (cond ((data-type? data-type) (initial-value data-type))
	  ((setq data-type (car (si:loop-tmember
				   data-type '(fixnum flonum integer number
					       #+Loop-Small-Floatp
					         small-flonum))))
	     (cond ((eq data-type 'flonum) 0.0)
		 #+Loop-Small-Floatp
		   ((eq data-type 'small-flonum)
		      #.(and (loop-featurep Loop-Small-Floatp)
			     (small-float 0)))
		   ('t 0)))))


(defun loop-make-variable (name initialization dtype)
  (cond ((null name)
	   (cond ((not (null initialization))
		    (push (list #+Lispm 'ignore
				#+Multics (setq name (gensym))
				#-(or Lispm Multics) ()
				initialization)
			  loop-variables)
		    #+Multics (push `(progn ,name) loop-prologue))))
	(#-Vector-Destructuring (atom name)
	 #+Vector-Destructuring (symbolp name)
	   (cond (loop-iteration-variablep
		    (if (memq name loop-iteration-variables)
			(loop-simple-error
			   "Duplicated iteration variable somewhere in LOOP"
			   name)
			(push name loop-iteration-variables)))
		 ((assq name loop-variables)
		    (loop-simple-error
		       "Duplicated var in LOOP bind block" name)))
	 #-Vector-Destructuring
	   (or (symbolp name)
	       (loop-simple-error "Bad variable somewhere in LOOP" name))
	   (loop-declare-variable name dtype)
	   ; We use ASSQ on this list to check for duplications (above),
	   ; so don't optimize out this list:
	   (push (list name (or initialization (loop-typed-init dtype)))
		 loop-variables))
	(initialization
	   #+System-Destructuring
	     (progn (loop-declare-variable name dtype)
		    (push (list name initialization) loop-variables))
	   #-System-Destructuring
	     (cond (si:loop-use-system-destructuring?
		      (loop-declare-variable name dtype)
		      (push (list name initialization) loop-variables))
		   ('t (let ((newvar (gensym)))
			  (push (list newvar initialization) loop-variables)
			  ; LOOP-DESETQ-CROCKS gathered in reverse order.
			  (setq loop-desetq-crocks
				(list* name newvar loop-desetq-crocks))
			  (loop-make-variable name () dtype)))))
	('t
	  #-Vector-Destructuring
	    (let ((tcar) (tcdr))
	      (if (atom dtype) (setq tcar (setq tcdr dtype))
		  (setq tcar (car dtype) tcdr (cdr dtype)))
	      (loop-make-variable (car name) () tcar)
	      (loop-make-variable (cdr name) () tcdr))
	  #+Vector-Destructuring
	    (cond ((object-that-cares-p name)
		     (let ((tcar) (tcdr))
			(if (object-that-cares-p dtype)
			    (setq tcar (car dtype) tcdr (cdr dtype))
			    (setq tcar (setq tcdr dtype)))
			(loop-make-variable (car name) () tcar)
			(loop-make-variable (cdr name) () tcdr)))
		  ((vectorp name)
		     (do ((i 0 (1+ i))
			  (n (vector-length name))
			  (dti 0 (1+ dti))
			  (dtn (and (vectorp dtype) (vector-length dtype))))
			 ((= i n))
		       #+Run-in-Maclisp (declare (fixnum i n dti))
		       (loop-make-variable
			  (vref name i) ()
			  (if (null dtn) dtype
			      (and (< dti dtn) (vref dtype dti))))))
		  ('t (loop-simple-error
		         "bad variable somewhere in LOOP" name)))
	  ))
  name)


(defun loop-make-iteration-variable (name initialization dtype)
    (let ((loop-iteration-variablep 't))
       (loop-make-variable name initialization dtype)))


(defun loop-declare-variable (name dtype)
    (cond ((or (null name) (null dtype)) ())
	  ((symbolp name)
	     (cond ((memq name loop-nodeclare))
		 #+Multics
		   ; local type dcls of specials lose.  This doesn't work
		   ; for locally-declared specials.
		   ((get name 'special))
		   ((data-type? dtype)
		      (setq loop-declarations
			    (append (variable-declarations dtype name)
				    loop-declarations)))
		#+Meaningful-Type-Declarations
		   ((si:loop-tmember dtype '(fixnum flonum))
		      (push `(,dtype ,name) loop-declarations))))
	  ((object-that-cares-p name)
	      (cond ((object-that-cares-p dtype)
		       (loop-declare-variable (car name) (car dtype))
		       (loop-declare-variable (cdr name) (cdr dtype)))
		    ('t (loop-declare-variable (car name) dtype)
			(loop-declare-variable (cdr name) dtype))))
	#+Vector-Destructuring
	  ((vectorp name)
	     (do ((i 0 (1+ i))
		  (n (vector-length name))
		  (dtn (and (vectorp dtype) (vector-length dtype)))
		  (dti 0 (1+ dti)))
		 ((= i n))
	       #+Meaningful-Type-Declarations (declare (fixnum i n dti))
	       (loop-declare-variable
		  (vref name i)
		  (if (null dtn) dtype (and (< dti dtn) (vref dtype dti))))))
	  ('t (loop-simple-error "can't hack this"
				 (list 'loop-declare-variable name dtype)))))


#+For-PDP10
(declare (special squid))

(defun loop-constantp (form)
    (or (numberp form)
	#+For-NIL (or (null form) (vectorp form))
	#-For-NIL (memq form '(t ()))
	#-For-PDP10 (stringp form)
	(and (not (atom form))
	     #-Run-on-PDP10 (eq (car form) 'quote)
	     #+Run-on-PDP10 (or (eq (car form) 'quote)
				; SQUID implies quoting.
				(and compiler-state (eq (car form) squid))))
	))

(defun loop-maybe-bind-form (form data-type?)
    ; Consider implementations which will not keep EQ quoted constants
    ; EQ after compilation & loading.
    ; Note FUNCTION is not hacked, multiple occurences might cause the
    ; compiler to break the function off multiple times!
    ; Hacking it probably isn't too important here anyway.  The ones that
    ; matter are the ones that use it as a stepper (or whatever), which
    ; handle it specially.
    (if (loop-constantp form) form
	(loop-make-variable (gensym) form data-type?)))


(defun loop-optional-type ()
    (let ((token (car loop-source-code)))
	(and (not (null token))
	     (or (not (atom token))
		 (data-type? token)
		 (si:loop-tmember token '(fixnum flonum integer number notype
					  #+Loop-Small-Floatp small-flonum)))
	     (loop-pop-source))))


;Incorporates conditional if necessary
(defun loop-make-conditionalization (form)
  (cond ((not (null loop-conditionals))
	   (rplacd (last (car (last (car (last loop-conditionals)))))
		   (ncons form))
	   (cond ((si:loop-tequal (car loop-source-code) 'and)
		    (loop-pop-source)
		    ())
		 ((si:loop-tequal (car loop-source-code) 'else)
		    (loop-pop-source)
		    ;; If we are already inside an else clause, close it off
		    ;; and nest it inside the containing when clause
		    (let ((innermost (car (last loop-conditionals))))
		      (cond ((null (cddr innermost)))	;Now in a WHEN clause, OK
			    ((null (cdr loop-conditionals))
			     (loop-simple-error "More ELSEs than WHENs"
						(list 'else (car loop-source-code)
						      (cadr loop-source-code))))
			    ('t (setq loop-conditionals (cdr (nreverse loop-conditionals)))
				(rplacd (last (car (last (car loop-conditionals))))
					(ncons innermost))
				(setq loop-conditionals (nreverse loop-conditionals)))))
		    ;; Start a new else clause
		    (rplacd (last (car (last loop-conditionals)))
			    (ncons (ncons ''t)))
		    ())
		 ('t ;Nest up the conditionals and output them
		     (do ((prev (car loop-conditionals) (car l))
			  (l (cdr loop-conditionals) (cdr l)))
			 ((null l))
		       (rplacd (last (car (last prev))) (ncons (car l))))
		     (prog1 (car loop-conditionals)
			    (setq loop-conditionals ())))))
	('t form)))

(defun loop-pseudo-body (form &aux (z (loop-make-conditionalization form)))
   (cond ((not (null z))
	    (cond (loop-emitted-body? (push z loop-body))
		  ('t (push z loop-before-loop) (push z loop-after-body))))))

(defun loop-emit-body (form)
  (setq loop-emitted-body? 't)
  (loop-pseudo-body form))


#+Named-PROGs
(defun loop-do-named ()
    (let ((name (loop-pop-source)))
       (or (and name (symbolp name))
	   (loop-simple-error "Bad name for your loop construct" name))
       (and (cdr (setq loop-prog-names (cons name loop-prog-names)))
	    (loop-simple-error "Too many names for your loop construct"
			       loop-prog-names))))

(defun loop-do-initially ()
  (push (loop-get-form) loop-prologue))

(defun loop-nodeclare (&aux (varlist (loop-pop-source)))
    (or (and varlist (eq (typep varlist) 'list))
	(loop-simple-error "Bad varlist to nodeclare loop clause" varlist))
    (setq loop-nodeclare (append varlist loop-nodeclare)))

(defun loop-do-finally ()
  (push (loop-get-form) loop-epilogue))

(defun loop-do-do ()
  (loop-emit-body (loop-get-form)))

(defun loop-do-return ()
   (loop-pseudo-body `(return ,(loop-get-form))))


;;;; List Collection

; The way we collect (list-collect) things is to bind two variables.
; One is the final result, and is accessible for value during the
; loop compuation.  The second is the "tail".  In implementations where
; we can do so, the tail var is initialized to a locative of the first,
; such that it can be updated with RPLACD.  In other implementations,
; the update must be conditionalized (on whether or not the tail is NIL).

; For PDP10 Maclisp:
; The "value cell" of a special variable is a (pseudo) list cell, the CDR
; of which is the value.  Hence the abovementioned tail variable gets
; initialized to this.  (It happens to be the CDAR of the symbol.)
; For local variables in compiled code, the Maclisp compiler implements
; a (undocumented private) form of the
; "(setq tail (variable-location var))" construct;  specifically, it
; is of the form  (#.gofoo var tail).  This construct must appear in
; the binding environment those variables are bound in, currently.
; Note that this hack only currently works for local variables, so loop
; has to check to see if the variable is special.  It is anticipated,
; however, that the compiler will be able to do this all by itself
; at some point.

#+For-PDP10
  (progn 'compile
     (cond ((status feature complr)
	      (setq loop-specvar-hack ((lambda (obarray)
					   (implode '(s p e c v a r s)))
				       sobarray))
	      (defun loop-collect-init-compiler (form)
		(cond ((memq compiler-state '(toplevel maklap))
		         ; We are being "toplevel" macro expanded.
			 ; We MUST expand into something which can be
			 ; evaluated without loop, in the interpreter.
			 `(setq ,(caddr form) (munkam (value-cell-location
						         ',(cadr form)))))
		      ((or specials
			   (get (cadr form) 'special)
			   (assq (cadr form) (symeval loop-specvar-hack)))
		         `(setq ,(caddr form) (cdar ',(cadr form))))
		      (t (cons gofoo (cdr form)))))
	      (push '(loop-collect-init . loop-collect-init-compiler)
		    macrolist)))
     (defun loop-collect-init fexpr (x)
	(set (cadr x) (cdar (car x)))))

#+(and Hairy-Collection (not For-PDP10))
(defmacro loop-collect-init (var1 var2)
   #+Lispm ;*****  Remove kludgey fboundp when everyone up-to-date *****
	   `(setq ,var2 ,(if (fboundp 'variable-location)
			     `(variable-location ,var1)
			     `(value-cell-location ',var1)))
   #-Lispm `(setq ,var2 (munkam (value-cell-location ',var1))))


(defun loop-do-collect (type)
  (let ((var) (form) (tem) (tail) (dtype) (cruft) (rvar)
	(ctype (cond ((memq type '(max min)) 'maxmin)
		     ((memq type '(nconc list append)) 'list)
		     ((memq type '(count sum)) 'sum)
		     ('t (loop-simple-error
			    "unrecognized LOOP collecting keyword" type)))))
    (setq form (loop-get-form) dtype (loop-optional-type))
    (cond ((si:loop-tequal (car loop-source-code) 'into)
	     (loop-pop-source)
	     (setq rvar (setq var (loop-pop-source)))))
    ; CRUFT will be (varname ctype dtype var tail (optional tem))
    (cond ((setq cruft (assq var loop-collect-cruft))
	     (cond ((not (eq ctype (car (setq cruft (cdr cruft)))))
		      (loop-simple-error
		         "incompatible LOOP collection types"
			 (list ctype (car cruft))))
		   ((and dtype (not (eq dtype (cadr cruft))))
		      ;Conditional should be on data-type reality
		      #+Run-in-Maclisp
		        (loop-simple-error
			   "Unequal data types in multiple collections"
			   (list dtype (cadr cruft) (car cruft)))
		      #-Run-in-Maclisp
		        (ferror () "~A and ~A Unequal data types into ~A"
				dtype (cadr cruft) (car cruft))))
	     (setq dtype (car (setq cruft (cdr cruft)))
		   var (car (setq cruft (cdr cruft)))
		   tail (car (setq cruft (cdr cruft)))
		   tem (cadr cruft))
	     (and (eq ctype 'maxmin)
		  (not (atom form)) (null tem)
		  (rplaca (cdr cruft) (setq tem (loop-make-variable
						   (gensym) () dtype)))))
	  ('t (and (null dtype)
		   (setq dtype (cond ((eq type 'count) 'fixnum)
				     ((memq type '(min max sum)) 'number))))
	     (or var (push `(return ,(setq var (gensym)))
			   loop-after-epilogue))
	     (or (eq ctype 'list) (loop-make-iteration-variable var () dtype))
	     (setq tail 
		   (cond ((eq ctype 'list)
			    #-Hairy-Collection
			      (setq tem (loop-make-variable (gensym) () ()))
			    (car (setq loop-collection-crocks
				       (list* (gensym) var
					      loop-collection-crocks))))
			 ((eq ctype 'maxmin)
			    (or (atom form)
				(setq tem (loop-make-variable
					     (gensym) () dtype)))
			    (loop-make-variable (gensym) ''t ()))))
	     (push (list rvar ctype dtype var tail tem)
		   loop-collect-cruft)))
    (loop-emit-body
	(caseq type
	  (count (setq tem `(setq ,var (,(loop-typed-arith 'add1 dtype)
					,var)))
		 (if (member form '(t 't)) tem `(and ,form ,tem)))
	  (sum `(setq ,var (,(loop-typed-arith 'plus dtype) ,form ,var)))
	  ((max min)
	     (let ((forms ()) (arglist ()))
		; TEM is temporary, properly typed.
		(and tem (setq forms `((setq ,tem ,form)) form tem))
		(setq arglist (list var form))
		(push (if (si:loop-tmember dtype '(fixnum flonum
						   #+Loop-Small-Floatp
						     small-flonum))
			  ; no contagious arithmetic
			  `(and (or ,tail
				    (,(loop-typed-arith
				         (if (eq type 'max) 'lessp 'greaterp)
					 dtype)
				     . ,arglist))
				(setq ,tail () . ,arglist))
			  ; potentially contagious arithmetic -- must use
			  ; MAX or MIN so that var will be contaminated
			  `(setq ,var (cond (,tail (setq ,tail ()) ,form)
					    ((,type . ,arglist)))))
		      forms)
		(if (cdr forms) (cons 'progn (nreverse forms)) (car forms))))
	  (t (caseq type
		(list (setq form (list 'list form)))
		(append (or (and (not (atom form)) (eq (car form) 'list))
			    (setq form #+Lispm `(copylist* ,form)
				       #-Lispm `(append ,form ())))))
	   #+Hairy-Collection
	     (let ((q `(rplacd ,tail ,form)))
		(cond ((and (not (atom form)) (eq (car form) 'list)
			    (not (null (cdr form))))
		         ; RPLACD of cdr-coded list:
			 #+Lispm
			   (rplaca (cddr q)
				   (if (cddr form) `(list* ,@(cdr form) ())
				       `(ncons ,(cadr form))))
			 `(setq ,tail ,(loop-cdrify (cdr form) q)))
		      ('t `(and (cdr ,q)
				(setq ,tail (last (cdr ,tail)))))))
	   #-Hairy-Collection
	     (let ((q `(cond (,tail (cdr (rplacd ,tail ,tem)))
			     ((setq ,var ,tem)))))
		(if (and (not (atom form)) (eq (car form) 'list) (cdr form))
		    `(setq ,tem ,form ,tail ,(loop-cdrify (cddr form) q))
		    `(and (setq ,tem ,form) (setq ,tail (last ,q))))))))))


(defun loop-cdrify (arglist form)
    (do ((size (length arglist) (- size 4)))
	((< size 4)
	 (if (zerop size) form
	     (list (cond ((= size 1) 'cdr) ((= size 2) 'cddr) ('t 'cdddr))
		   form)))
      #+Meaningful-Type-Declarations (declare (fixnum size))
      (setq form (list 'cddddr form))))


(defun loop-do-while (cond kwd &aux (form (loop-get-form)))
    (and loop-conditionals (loop-simple-error
			      "not allowed inside LOOP conditional"
			      (list kwd form)))
    (loop-pseudo-body `(,cond ,form (go end-loop))))


(defun loop-do-when (negate?)
  (let ((form (loop-get-form)) (cond))
    (cond ((si:loop-tequal (cadr loop-source-code) 'it)
	     ;WHEN foo RETURN IT and the like
	     (setq cond `(setq ,(loop-when-it-variable) ,form))
	     (setq loop-source-code		;Plug in variable for IT
		   (list* (car loop-source-code)
			  loop-when-it-variable
			  (cddr loop-source-code))))
	  ('t (setq cond form)))
    (and negate? (setq cond `(not ,cond)))
    (setq loop-conditionals (nconc loop-conditionals `((cond (,cond)))))))

(defun loop-do-with ()
  (do ((var) (equals) (val) (dtype)) (())
    (setq var (loop-pop-source) equals (car loop-source-code))
    (cond ((si:loop-tequal equals '=)
	     (loop-pop-source)
	     (setq val (loop-get-form) dtype ()))
	  ((or (si:loop-tequal equals 'and)
	       (si:loop-tassoc equals loop-keyword-alist)
	       (si:loop-tassoc equals loop-iteration-keyword-alist))
	     (setq val () dtype ()))
	  ('t (setq dtype (loop-pop-source) equals (car loop-source-code))
	      (cond ((si:loop-tequal equals '=)
		       (loop-pop-source)
		       (setq val (loop-get-form)))
		    ((and (not (null loop-source-code))
			  (not (si:loop-tassoc equals loop-keyword-alist))
			  (not (si:loop-tassoc
				  equals loop-iteration-keyword-alist))
			  (not (si:loop-tequal equals 'and)))
		       (loop-simple-error "Garbage where = expected" equals))
		    ('t (setq val ())))))
    (loop-make-variable var val dtype)
    (if (not (si:loop-tequal (car loop-source-code) 'and)) (return ())
	(loop-pop-source)))
  (loop-bind-block))

(defun loop-do-always (pred)
  (let ((form (loop-get-form)))
    (loop-emit-body `(,pred ,form (return ())))
    (push '(return 't) loop-after-epilogue)))

;THEREIS expression
;If expression evaluates non-nil, return that value.
(defun loop-do-thereis ()
   (loop-emit-body `(and (setq ,(loop-when-it-variable) ,(loop-get-form))
			 (return ,loop-when-it-variable))))


;;;; Hacks

#+Meaningful-Type-Declarations
  (declare (fixnum (loop-simplep-1 notype)))

(defun si:loop-simplep (expr)
    (if (null expr) 0
	(*catch 'si:loop-simplep
	    (let ((ans (si:loop-simplep-1 expr)))
	       #+Meaningful-Type-Declarations (declare (fixnum ans))
	       (and (< ans 20.) ans)))))

(defvar si:loop-simplep
  (append '(> < greaterp lessp plusp minusp typep zerop
	    plus difference + - add1 sub1 1+ 1-
	    +$ -$ 1+$ 1-$ boole rot ash ldb equal atom
	    setq prog1 prog2 and or =)
	  #+(or Lispm NIL) '(aref ar-1 ar-2 ar-3)
	  #+Lispm '#.(and (loop-featurep Lispm)
			  (mapcar 'ascii '(#/ #/ #/)))
	  #+For-NIL '(vref vector-length 1+& 1-& +& -& +p -p 0p *& //& \&
                      si:xref char string-length)
	  ))

(defun si:loop-simplep-1 (x)
  (let ((z 0))
    #+Meaningful-Type-Declarations (declare (fixnum z))
    (cond ((loop-constantp x) 0)
	  ((atom x) 1)
	  ((eq (car x) 'cond)
	     (do ((cl (cdr x) (cdr cl))) ((null cl))
	       (do ((f (car cl) (cdr f))) ((null f))
		 (setq z (+ (si:loop-simplep-1 (car f)) z 1))))
	     z)
	  ((symbolp (car x))
	     (let ((fn (car x)) (tem ()))
	       (cond ((setq tem (get fn 'si:loop-simplep))
		        (if (fixp tem) (setq z tem)
			    (setq z (funcall tem x) x ())))
		     ((memq fn '(null not eq go return progn)))
		     (#+Run-on-PDP10
		        (or (not (minusp (+internal-carcdrp fn)))
				      (eq fn 'cxr))
		      #-Run-on-PDP10 (memq fn '(car cdr))
		        (setq z 1))
		   #-Run-on-PDP10
		     ((memq fn '(caar cadr cdar cddr)) (setq z 2))
		   #-Run-on-PDP10
		     ((memq fn '(caaar caadr cadar caddr
				 cdaar cdadr cddar cdddr))
		        (setq z 3))
		   #-Run-on-PDP10
		     ((memq fn '(caaaar caaadr caadar caaddr
				 cadaar cadadr caddar cadddr
				 cdaaar cdaadr cdadar cdaddr
				 cddaar cddadr cdddar cddddr))
		        (setq z 4))
		     ((memq fn si:loop-simplep)
		        (setq z 2))
		     (#+(or Lispm For-PDP10 For-NIL)
		        (not (eq (setq tem (macroexpand-1 x)) x))
		      #+Franz (not (eq (setq tem (macroexpand x)) x))
		      #+Multics
		        (setq tem (get (car x) 'macro))
		      #+Multics (setq tem (funcall tem x))
		      (setq z (si:loop-simplep-1 tem) x ()))
		     ('t (*throw 'si:loop-simplep ())))
	       (do ((l (cdr x) (cdr l))) ((null l))
		 (setq z (+ (si:loop-simplep-1 (car l)) 1 z)))
	       z))
	  ('t (*throw 'si:loop-simplep ())))))


;;;; The iteration driver
(defun loop-hack-iteration (entry)
  (do ((last-entry entry)
       (source loop-source-code loop-source-code)
       (pre-step-tests ())
       (steps ())
       (post-step-tests ())
       (pseudo-steps ())
       (pre-loop-pre-step-tests ())
       (pre-loop-steps ())
       (pre-loop-post-step-tests ())
       (pre-loop-pseudo-steps ())
       (tem) (data) (foo) (bar))
      (())
    ; Note we collect endtests in reverse order, but steps in correct
    ; order.  LOOP-END-TESTIFY does the nreverse for us.
    (setq tem (setq data (apply (cadr entry) (cddr entry))))
    (and (car tem) (push (car tem) pre-step-tests))
    (setq steps (nconc steps (loop-copylist* (car (setq tem (cdr tem))))))
    (and (car (setq tem (cdr tem))) (push (car tem) post-step-tests))
    (setq pseudo-steps
	  (nconc pseudo-steps (loop-copylist* (car (setq tem (cdr tem))))))
    (setq tem (cdr tem))
    (and (or loop-conditionals loop-emitted-body?)
	 (or tem pre-step-tests post-step-tests pseudo-steps)
	 (let ((cruft (list (car entry) (car source)
			    (cadr source) (caddr source))))
	    (if loop-emitted-body?
		(loop-simple-error
		   "Iteration is not allowed to follow body code" cruft)
		(loop-simple-error
		   "Iteration starting inside of conditional in LOOP"
		   cruft))))
    (or tem (setq tem data))
    (and (car tem) (push (car tem) pre-loop-pre-step-tests))
    (setq pre-loop-steps
	  (nconc pre-loop-steps (loop-copylist* (car (setq tem (cdr tem))))))
    (and (car (setq tem (cdr tem))) (push (car tem) pre-loop-post-step-tests))
    (setq pre-loop-pseudo-steps
	  (nconc pre-loop-pseudo-steps (loop-copylist* (cadr tem))))
    (cond ((or (not (si:loop-tequal (car loop-source-code) 'and))
	       (and loop-conditionals
		    (not (si:loop-tassoc (cadr loop-source-code)
					 loop-iteration-keyword-alist))))
	     (setq foo (list (loop-end-testify pre-loop-pre-step-tests)
			     (loop-make-psetq pre-loop-steps)
			     (loop-end-testify pre-loop-post-step-tests)
			     (loop-make-setq pre-loop-pseudo-steps))
		   bar (list (loop-end-testify pre-step-tests)
			     (loop-make-psetq steps)
			     (loop-end-testify post-step-tests)
			     (loop-make-setq pseudo-steps)))
	     (cond ((not loop-conditionals)
		      (setq loop-before-loop (nreconc foo loop-before-loop)
			    loop-after-body (nreconc bar loop-after-body)))
		   ('t ((lambda (loop-conditionals)
			   (push (loop-make-conditionalization
				    (cons 'progn (delq () foo)))
				 loop-before-loop))
			(mapcar '(lambda (x)	;Copy parts that will get rplacd'ed
				   (cons (car x)
					 (mapcar '(lambda (x) (loop-copylist* x)) (cdr x))))
				loop-conditionals))
		       (push (loop-make-conditionalization
			        (cons 'progn (delq () bar)))
			     loop-after-body)))
	     (loop-bind-block)
	     (return ())))
    (loop-pop-source) ; flush the "AND"
    (setq entry (cond ((setq tem (si:loop-tassoc
				    (car loop-source-code)
				    loop-iteration-keyword-alist))
		         (loop-pop-source)
			 (setq last-entry tem))
		      ('t last-entry)))))


;FOR variable keyword ..args..
(defun loop-do-for ()
  (let ((var (loop-pop-source))
	(data-type? (loop-optional-type))
	(keyword (loop-pop-source))
	(first-arg (loop-get-form))
	(tem ()))
    (or (setq tem (si:loop-tassoc keyword loop-for-keyword-alist))
	(loop-simple-error
	   "Unknown keyword in FOR or AS clause in LOOP"
	   (list 'for var keyword)))
    (lexpr-funcall (cadr tem) var first-arg data-type? (cddr tem))))


(defun loop-do-repeat ()
    (let ((var (loop-make-variable (gensym) (loop-get-form) 'fixnum)))
       `((not (,(loop-typed-arith 'plusp 'fixnum) ,var))
         () ()
         (,var (,(loop-typed-arith 'sub1 'fixnum) ,var)))))


; Kludge the First
(defun loop-when-it-variable ()
    (or loop-when-it-variable
	(setq loop-when-it-variable
	      (loop-make-variable (gensym) () ()))))



(defun loop-for-equals (var val data-type?)
  (cond ((si:loop-tequal (car loop-source-code) 'then)
	   ;FOR var = first THEN next
	   (loop-pop-source)
	   (loop-make-iteration-variable var val data-type?)
	   `(() (,var ,(loop-get-form)) () ()
	     () () () ()))
	('t (loop-make-iteration-variable var () data-type?)
	    (let ((varval (list var val)))
	      (cond (loop-emitted-body?
		     (loop-emit-body (loop-make-setq varval))
		     '(() () () ()))
		    (`(() ,varval () ())))))))

(defun loop-for-first (var val data-type?)
    (or (si:loop-tequal (car loop-source-code) 'then)
	(loop-simple-error "found where THEN expected in FOR ... FIRST"
			   (car loop-source-code)))
    (loop-pop-source)
    (loop-make-iteration-variable var () data-type?)
    `(() (,var ,(loop-get-form)) () () () (,var ,val) () ()))


(defun loop-list-stepper (var val data-type? fn)
    (let ((stepper (cond ((si:loop-tequal (car loop-source-code) 'by)
			    (loop-pop-source) (loop-get-form))
			 ('t '(function cdr))))
	  (var1 ()) (stepvar ()) (step ()) (et ()) (pseudo ()))
       (setq step (if (or (atom stepper)
			  (not (memq (car stepper) '(quote function))))
		      `(funcall ,(setq stepvar (gensym)))
		      (list (cadr stepper))))
       (cond ((and (atom var)
		   ;; (eq (car step) 'cdr)
		   (not fn))
	        (setq var1 (loop-make-iteration-variable var val data-type?)))
	     ('t (loop-make-iteration-variable var () data-type?)
		 (setq var1 (loop-make-variable (gensym) val ()))
		 (setq pseudo (list var (if fn (list fn var1) var1)))))
       (rplacd (last step) (list var1))
       (and stepvar (loop-make-variable stepvar stepper ()))
       (setq stepper (list var1 step) et `(null ,var1))
       (if (not pseudo) `(() ,stepper ,et () () () ,et ())
	   (if (eq (car step) 'cdr) `(,et ,pseudo () ,stepper)
	       `((null (setq . ,stepper)) () () ,pseudo ,et () () ,pseudo)))))


(defun loop-for-arithmetic (var val data-type? kwd)
  ; Args to loop-sequencer:
  ; indexv indexv-type variable? vtype? sequencev? sequence-type
  ; stephack? default-top? crap prep-phrases
  (si:loop-sequencer
     var (or data-type? 'fixnum) () () () () () () `(for ,var ,kwd ,val)
     (cons (list kwd val)
	   (loop-gather-preps
	      '(from upfrom downfrom to upto downto above below by)
	      ()))))


(defun si:loop-named-variable (name)
    (let ((tem (si:loop-tassoc name loop-named-variables)))
       (cond ((null tem) (gensym))
	     ('t (setq loop-named-variables (delq tem loop-named-variables))
		 (cdr tem)))))

#+Run-in-Maclisp ;Gross me out
(and (status feature #+Multics Compiler #-Multics complr)
     (*expr si:loop-named-variable))


; Note:  path functions are allowed to use loop-make-variable, hack
; the prologue, etc.
(defun loop-for-being (var val data-type?)
   ; FOR var BEING something ... - var = VAR, something = VAL.
   ; If what passes syntactically for a pathname isn't, then
   ; we trap to the DEFAULT-LOOP-PATH path;  the expression which looked like
   ; a path is given as an argument to the IN preposition.  Thus,
   ; by default, FOR var BEING EACH expr OF expr-2
   ; ==> FOR var BEING DEFAULT-LOOP-PATH IN expr OF expr-2.
   (let ((tem) (inclusive?) (ipps) (each?) (attachment))
     (if (or (si:loop-tequal val 'each) (si:loop-tequal val 'the))
	 (setq each? 't val (car loop-source-code))
	 (push val loop-source-code))
     (cond ((and (setq tem (si:loop-tassoc val loop-path-keyword-alist))
		 (or each? (not (si:loop-tequal (cadr loop-source-code)
						'and))))
	      ;; FOR var BEING {each} path {prep expr}..., but NOT
	      ;; FOR var BEING var-which-looks-like-path AND {ITS} ...
	      (loop-pop-source))
	   ('t (setq val (loop-get-form))
	       (cond ((si:loop-tequal (car loop-source-code) 'and)
			;; FOR var BEING value AND ITS path-or-ar
			(or (null each?)
			    (loop-simple-error
			       "Malformed BEING EACH clause in LOOP" var))
			(setq ipps `((of ,val)) inclusive? 't)
			(loop-pop-source)
			(or (si:loop-tmember (setq tem (loop-pop-source))
					     '(its his her their each))
			    (loop-simple-error
			       "found where ITS or EACH expected in LOOP path"
			       tem))
			(if (setq tem (si:loop-tassoc
					 (car loop-source-code)
					 loop-path-keyword-alist))
			    (loop-pop-source)
			    (push (setq attachment `(in ,(loop-get-form)))
				  ipps)))
		     ((not (setq tem (si:loop-tassoc
					(car loop-source-code)
					loop-path-keyword-alist)))
			; FOR var BEING {each} a-r ...
			(setq ipps (list (setq attachment (list 'in val)))))
		     ('t ; FOR var BEING {each} pathname ...
			 ; Here, VAL should be just PATHNAME.
			 (loop-pop-source)))))
     (cond ((not (null tem)))
	   ((not (setq tem (si:loop-tassoc 'default-loop-path
					   loop-path-keyword-alist)))
	      (loop-simple-error "Undefined LOOP iteration path"
				 (cadr attachment))))
     (setq tem (funcall (cadr tem) (car tem) var data-type?
			(nreconc ipps (loop-gather-preps (caddr tem) 't))
			inclusive? (caddr tem) (cdddr tem)))
     (and loop-named-variables
	  (loop-simple-error "unused USING variables" loop-named-variables))
     ; For error continuability (if there is any):
     (setq loop-named-variables ())
     ;; TEM is now (bindings prologue-forms . stuff-to-pass-back)
     (do ((l (car tem) (cdr l)) (x)) ((null l))
       (if (atom (setq x (car l)))
	   (loop-make-iteration-variable x () ())
	   (loop-make-iteration-variable (car x) (cadr x) (caddr x))))
     (setq loop-prologue (nconc (reverse (cadr tem)) loop-prologue))
     (cddr tem)))


(defun loop-gather-preps (preps-allowed crockp)
   (do ((token (car loop-source-code) (car loop-source-code)) (preps ()))
       (())
     (cond ((si:loop-tmember token preps-allowed)
	      (push (list (loop-pop-source) (loop-get-form)) preps))
	   ((si:loop-tequal token 'using)
	      (loop-pop-source)
	      (or crockp (loop-simple-error
			    "USING used in illegal context"
			    (list 'using (car loop-source-code))))
	      (do ((z (car loop-source-code) (car loop-source-code)) (tem))
		  ((atom z))
		(and (or (atom (cdr z))
			 (not (null (cddr z)))
			 (not (symbolp (car z)))
			 (and (cadr z) (not (symbolp (cadr z)))))
		     (loop-simple-error
		        "bad variable pair in path USING phrase" z))
		(cond ((not (null (cadr z)))
		         (and (setq tem (si:loop-tassoc
					   (car z) loop-named-variables))
			      (loop-simple-error
			         "Duplicated var substitition in USING phrase"
				 (list tem z)))
			 (push (cons (car z) (cadr z)) loop-named-variables)))
		(loop-pop-source)))
	   ('t (return (nreverse preps))))))

(defun loop-add-path (name data)
    (setq loop-path-keyword-alist
	  (cons (cons name data)
		; Don't change this to use DELASSQ in PDP10, the lsubr
		; calling sequence makes that lose.
		(delq (si:loop-tassoc name loop-path-keyword-alist)
		      loop-path-keyword-alist)))
    ())

#+Run-on-PDP10
(declare ; Suck my obarray...
	 (own-symbol define-loop-path define-loop-sequence-path))

(defmacro define-loop-path (names &rest cruft)
  (setq names (if (atom names) (list names) names))
  #-For-Maclisp
    (let ((forms (mapcar #'(lambda (name) `(loop-add-path ',name ',cruft))
			 names)))
       `(eval-when (eval load compile)
	    #+For-NIL (flush-macromemos 'loop ())
	    ,@forms))
  #+For-Maclisp
    (subst (do ((l)) ((null names) l)
	     (setq l (cons `(setq loop-path-keyword-alist
				  (cons '(,(car names) . ,cruft)
					(delq (assq ',(car names)
						    loop-path-keyword-alist)
					      loop-path-keyword-alist)))
			   l)
		   names (cdr names)))
	   'progn
	   '(eval-when (eval load compile)
	     #-For-PDP10 (or (boundp 'loop-path-keyword-alist)
			      (setq loop-path-keyword-alist ()))
	     #+For-PDP10 (and (or (boundp 'loop-path-keyword-alist)
				   (setq loop-path-keyword-alist ()))
			       (flush-macromemos 'loop ()))
	       . progn)))


(defun si:loop-sequencer (indexv indexv-type
			  variable? vtype?
			  sequencev? sequence-type?
			  stephack? default-top?
			  crap prep-phrases)
   (let ((endform) (sequencep) (test)
	 (step ; Gross me out!
	       (add1 (or (loop-typed-init indexv-type) 0)))
	 (dir) (inclusive-iteration?) (start-given?) (limit-given?))
     (and variable? (loop-make-iteration-variable variable? () vtype?))
     (do ((l prep-phrases (cdr l)) (prep) (form) (odir)) ((null l))
       (setq prep (caar l) form (cadar l))
       (cond ((si:loop-tmember prep '(of in))
		(and sequencep (loop-simple-error
				  "Sequence duplicated in LOOP path"
				  (list variable? (car l))))
		(setq sequencep 't)
		(loop-make-variable sequencev? form sequence-type?))
	     ((si:loop-tmember prep '(from downfrom upfrom))
	        (and start-given?
		     (loop-simple-error
		        "Iteration start redundantly specified in LOOP sequencing"
			(append crap l)))
		(setq start-given? 't)
		(cond ((si:loop-tequal prep 'downfrom) (setq dir 'down))
		      ((si:loop-tequal prep 'upfrom) (setq dir 'up)))
		(loop-make-iteration-variable indexv form indexv-type))
	     ((cond ((si:loop-tequal prep 'upto)
		       (setq inclusive-iteration? (setq dir 'up)))
		    ((si:loop-tequal prep 'to)
		       (setq inclusive-iteration? 't))
		    ((si:loop-tequal prep 'downto)
		       (setq inclusive-iteration? (setq dir 'down)))
		    ((si:loop-tequal prep 'above) (setq dir 'down))
		    ((si:loop-tequal prep 'below) (setq dir 'up)))
		(and limit-given?
		     (loop-simple-error
		       "Endtest redundantly specified in LOOP sequencing path"
		       (append crap l)))
		(setq limit-given? 't)
		(setq endform (loop-maybe-bind-form form indexv-type)))
	     ((si:loop-tequal prep 'by)
		(setq step (if (loop-constantp form) form
			       (loop-make-variable (gensym) form 'fixnum))))
	     ('t ; This is a fatal internal error...
		 (loop-simple-error "Illegal prep in sequence path"
				    (append crap l))))
       (and odir dir (not (eq dir odir))
	    (loop-simple-error
	       "Conflicting stepping directions in LOOP sequencing path"
	       (append crap l)))
       (setq odir dir))
     (and sequencev? (not sequencep)
	  (loop-simple-error "Missing OF phrase in sequence path" crap))
     ; Now fill in the defaults.
     (setq step (list indexv step))
     (cond ((memq dir '(() up))
	      (or start-given?
		  (loop-make-iteration-variable indexv 0 indexv-type))
	      (and (or limit-given?
		       (cond (default-top?
			        (loop-make-variable
				   (setq endform (gensym)) () indexv-type)
				(push `(setq ,endform ,default-top?)
				      loop-prologue))))
		   (setq test (if inclusive-iteration? '(greaterp . args)
				  '(not (lessp . args)))))
	      (push 'plus step))
	   ('t (cond ((not start-given?)
		        (or default-top?
			    (loop-simple-error
			       "Don't know where to start stepping"
			       (append crap prep-phrases)))
			(loop-make-iteration-variable indexv 0 indexv-type)
			(push `(setq ,indexv
				     (,(loop-typed-arith 'sub1 indexv-type)
				      ,default-top?))
			      loop-prologue)))
	       (cond ((and default-top? (not endform))
		        (setq endform (loop-typed-init indexv-type)
			      inclusive-iteration? 't)))
	       (and (not (null endform))
		    (setq test (if inclusive-iteration? '(lessp . args)
				   '(not (greaterp . args)))))
	       (push 'difference step)))
     (and (member (caddr step)
		  #+Loop-Small-Floatp
		    '(1 1.0 #.(and (loop-featurep Loop-Small-Floatp)
				   (small-float 1)))
		  #-Loop-Small-Floatp '(1 1.0))
	  (rplacd (cdr (rplaca step (if (eq (car step) 'plus) 'add1 'sub1)))
		  ()))
     (rplaca step (loop-typed-arith (car step) indexv-type))
     (setq step (list indexv step))
     (setq test (loop-typed-arith test indexv-type))
     (setq test (subst (list indexv endform) 'args test))
     (and stephack? (setq stephack? `(,variable? ,stephack?)))
     `(() ,step ,test ,stephack?
       () () ,test ,stephack?)))


; Although this function is no longer documented, the "SI:" is needed
; because compiled files may reference it that way (via
; DEFINE-LOOP-SEQUENCE-PATH).
(defun si:loop-sequence-elements-path (path variable data-type
				       prep-phrases inclusive?
				       allowed-preps data)
    allowed-preps ; unused
    (let ((indexv (si:loop-named-variable 'index))
	  (sequencev (si:loop-named-variable 'sequence))
	  (fetchfun ()) (sizefun ()) (type ()) (default-var-type ())
	  (crap `(for ,variable being the ,path)))
       (cond ((not (null inclusive?))
	        (rplacd (cddr crap) `(,(cadar prep-phrases) and its ,path))
		(loop-simple-error "Can't step sequence inclusively" crap)))
       (setq fetchfun (car data)
	     sizefun (car (setq data (cdr data)))
	     type (car (setq data (cdr data)))
	     default-var-type (cadr data))
       (list* () () ; dummy bindings and prologue
	      (si:loop-sequencer
	         indexv 'fixnum
		 variable (or data-type default-var-type)
		 sequencev type
		 `(,fetchfun ,sequencev ,indexv) `(,sizefun ,sequencev)
		 crap prep-phrases))))


#+Run-on-PDP10
(defun (define-loop-sequence-path macro) (x)
    `(define-loop-path ,(cadr x) si:loop-sequence-elements-path
	(of in from downfrom to downto below above by)
	. ,(cddr x)))

#-Run-on-PDP10
(defmacro define-loop-sequence-path (path-name-or-names fetchfun sizefun
				     &optional sequence-type element-type)
    `(define-loop-path ,path-name-or-names
	si:loop-sequence-elements-path
	(of in from downfrom to downto below above by)
	,fetchfun ,sizefun ,sequence-type ,element-type))


;;;; NIL interned-symbols path

#+For-NIL
(progn 'compile
(defun loop-interned-symbols-path (path variable data-type prep-phrases
				   inclusive? allowed-preps data
				   &aux statev1 statev2 statev3
					(localp (car data)))
   allowed-preps	; unused
   (and inclusive? (loop-simple-error
		      "INTERNED-SYMBOLS path doesn't work inclusively"
		      variable))
   (and (not (null prep-phrases))
	(or (cdr prep-phrases)
	    (not (si:loop-tmember (caar prep-phrases) '(in of))))
	(ferror () "Illegal prep phrase(s) in ~A path of ~A - ~A"
		path variable prep-phrases))
   (loop-make-variable variable () data-type)
   (loop-make-variable
      (setq statev1 (gensym))
      `(loop-find-package
	  ,@(and prep-phrases `(,(cadar prep-phrases))))
      ())
   (loop-make-variable (setq statev2 (gensym)) () ())
   (loop-make-variable (setq statev3 (gensym)) () ())
   (push `(multiple-value (,statev1 ,statev2 ,statev3)
	       (loop-initialize-mapatoms-state ,statev1 ',localp))
	 loop-prologue)
   `(() () (multiple-value (() ,statev1 ,statev2 ,statev3)
	      (,(if localp 'loop-test-and-step-mapatoms-local
		    'loop-test-and-step-mapatoms)
	       ,statev1 ,statev2 ,statev3))
     (,variable (loop-get-mapatoms-symbol ,statev1 ,statev2 ,statev3)) () ()))

(defun loop-find-package (&optional (pkg () pkgp))
  #+Run-in-Maclisp
    (if pkgp pkg obarray)
  #-Run-in-Maclisp
    (if pkgp (pkg-find-package pkg) package))

(defun loop-find-package-translate (form)
  ; Note that we can only be compiling for nil-nil, so we only need
  ; to consider that.  The run-in-maclisp conditionals in the functions
  ; are for the benefit of running interpreted code.
  (values (if (null (cdr form)) 'package `(pkg-find-package ,(cadr form))) 't))

(putprop 'loop-find-package
	 '(loop-find-package-translate)
	 'source-trans)

#-Run-in-Maclisp
(defun loop-initialize-mapatoms-state (pkg localp)
    (let* ((symtab (si:package-symbol-table pkg))
	   (len (vector-length symtab)))
       (values pkg len (if localp symtab (cons (ncons pkg) ())))))

#+Run-in-Maclisp
(defun loop-initialize-mapatoms-state (ob ())
    (values ob (ncons nil) 511.))

#-Run-in-Maclisp
(defun loop-test-and-step-mapatoms (pkg index location &aux val)
    (prog (symtab)
	 (setq symtab (si:package-symbol-table pkg))
      lp (cond ((-p (setq index (1-& index)))
                  ;(do ((l (si:package-super-packages pkg) (cdr l)))
		  ;    ((null l) (cdr location))
		  ;  (or (memq (car l) (car location))
		  ;      (memq (car l) (cdr location))
		  ;      (rplacd location (cons (car l) (cdr location)))))
                  (let ((p (si:package-super-package pkg)))
                    (or (memq p (car location))
                        (memq p (cdr location))
                        (rplacd location (cons p (cdr location)))))
		  (or (cdr location) (return (setq val 't)))
		  (rplacd location
			  (prog1 (cddr location)
				 (rplaca location
					 (rplacd (cdr location)
						 (car location)))))
		  (setq pkg (caar location))
		  (setq symtab (si:package-symbol-table pkg))
		  (setq index (vector-length symtab))
		  (go lp))
	       ((symbolp (vref symtab index)) (return ()))
	       ('t (go lp))))
    (values val pkg index location))

#+Run-in-Maclisp
(defun loop-test-and-step-mapatoms (ob list index)
    (loop-test-and-step-mapatoms-local ob list index))

#-Run-in-Maclisp
(defun loop-test-and-step-mapatoms-local (pkg index symtab &aux val)
    (prog ()
      lp (cond ((-p (setq index (1-& index))) (return (setq val 't)))
	       ((symbolp (vref symtab index)) (return ()))
	       ('t (go lp))))
    (values val pkg index symtab))

#+Run-in-Maclisp
(defun loop-test-and-step-mapatoms-local (ob list index &aux val)
    (declare (fixnum index))
    (prog () 
     lp (cond ((not (null (cdr list)))
	         (rplaca list (cadr list))
		 (rplacd list (cddr list))
		 (return ()))
	      ((minusp (setq index (1- index))) (return (setq val 't)))
	      ('t ; If this is going to run in multics maclisp also the
		  ; arraycall should be hacked to have type `obarray'.
		  (rplacd list (arraycall t ob index))
		  (go lp))))
    (values val ob list index))

#-Run-in-Maclisp
(defun loop-get-mapatoms-symbol (pkg index something-or-other)
    ;Note there is a potential bug/timing screw in here.  We should be
    ; looking in the symbol-table saved initially, not the current one.
    ; There just isn't enough state saved (sigh).
    (declare (ignore something-or-other))
    (vref (si:package-symbol-table pkg) index))

#+Run-in-Maclisp
(defun loop-get-mapatoms-symbol (ob list index)
    (declare (ignore ob index))
    (car list))

(and #+Run-in-Maclisp (status feature complr)
     (*expr loop-get-mapatoms-symbol
	    loop-initialize-mapatoms-state
	    loop-test-and-step-mapatoms
	    loop-test-and-step-mapatoms-local))
)


;;;; Maclisp interned-symbols path

#+For-Maclisp
(defun loop-interned-symbols-path (path variable data-type prep-phrases
				   inclusive? allowed-preps data
				   &aux indexv listv ob)
   allowed-preps data	; unused vars
   (and inclusive? (loop-simple-error
		      "INTERNED-SYMBOLS path doesn't work inclusively"
		      variable))
   (and (not (null prep-phrases))
	(or (cdr prep-phrases)
	    (not (si:loop-tmember (caar prep-phrases) '(in of))))
	(loop-simple-error
	   "Illegal prep phrase(s) in INTERNED-SYMBOLS LOOP path"
	   (list* variable 'being path prep-phrases)))
   (loop-make-variable variable () data-type)
   (loop-make-variable
      (setq ob (gensym)) (if prep-phrases (cadar prep-phrases) 'obarray) ())
   ; Multics lisp does not store single-char-obs in the obarray buckets.
   ; Thus, we need to iterate over the portion of the obarray
   ; containing them also.  (511. = (ascii 0))
   (loop-make-variable
      (setq indexv (gensym)) #+Multics 639. #-Multics 511. 'fixnum)
   (loop-make-variable (setq listv (gensym)) () ())
   `(() ()
     (and #-Multics (null ,listv)
	  #+Multics (or (> ,indexv 510.) (null ,listv))
	  (prog ()
	   lp (cond ((minusp (setq ,indexv (1- ,indexv))) (return t))
		    ((setq ,listv (arraycall ; The following is the kind of
					     ; gratuity that pisses me off:
					     #+Multics obarray #-Multics t
					     ,ob ,indexv))
		       (return ()))
		    ((go lp)))))
     (,variable
       #+Multics (cond ((> ,indexv 510.) ,listv)
		       (t (prog2 () (car ,listv) (setq ,listv (cdr ,listv)))))
       #-Multics (car ,listv))
      ()
     #+Multics () #-Multics (,listv (cdr ,listv))))


;;;; Lispm interned-symbols path

#+Lispm
(progn 'compile

 (defun loop-interned-symbols-path (path variable data-type prep-phrases
				    inclusive? allowed-preps data
				    &aux statev1 statev2 statev3
					 (localp (car data)))
    path data-type allowed-preps			; unused vars
    (and inclusive? (loop-simple-error
		       "INTERNED-SYMBOLS path doesn't work inclusively"
		       variable))
    (and (not (null prep-phrases))
	 (or (cdr prep-phrases)
	     (not (si:loop-tmember (caar prep-phrases) '(in of))))
	   (ferror () "Illegal prep phrase(s) in ~A path of ~A - ~A"
		   path variable prep-phrases))
    (loop-make-variable variable () data-type)
    (loop-make-variable
       (setq statev1 (gensym))
       (if prep-phrases `(pkg-find-package ,(cadar prep-phrases)) 'package)
       ())
    (loop-make-variable (setq statev2 (gensym)) () ())
    (loop-make-variable (setq statev3 (gensym)) () ())
    (push `(multiple-value (,statev1 ,statev2 ,statev3)
		  (loop-initialize-mapatoms-state ,statev1 ,localp))
	    loop-prologue)
    `(() () (multiple-value (nil ,statev1 ,statev2 ,statev3)
	       (,(if localp 'loop-test-and-step-mapatoms-local
		     'loop-test-and-step-mapatoms)
		,statev1 ,statev2 ,statev3)) 
      (,variable (loop-get-mapatoms-symbol ,statev1 ,statev2 ,statev3))
      () ()))

 (defun loop-initialize-mapatoms-state (pkg localp)
    ; Return the initial values of the three state variables.
    ; This scheme uses them to be:
    ; (1)  Index into the package (decremented as we go)
    ; (2)  Temporary (to hold the symbol)
    ; (3)  the package
    localp ; ignored
    (prog ()
       (return (array-dimension-n 2 pkg) () pkg)))

 (defun loop-test-and-step-mapatoms (index temp pkg)
    temp ; ignored
    (prog ()
     lp (cond ((< (setq index (1- index)) 0)
	         (cond ((setq pkg (pkg-super-package pkg))
			  (setq index (array-dimension-n 2 pkg))
			  (go lp))
		       (t (return t))))
	      ((numberp (ar-2 pkg 0 index))
	         (return nil index (ar-2 pkg 1 index) pkg))
	      (t (go lp)))))

 (defun loop-test-and-step-mapatoms-local (index temp pkg)
    temp ; ignored
    (prog ()
     lp (cond ((minusp (setq index (1- index))) (return t))
	      ((numberp (ar-2 pkg 0 index))
	         (return () index (ar-2 pkg 1 index) pkg))
	      (t (go lp)))))

 (defun loop-get-mapatoms-symbol (index temp pkg)
    index pkg ; ignored
    temp)
 )

; We don't want these defined in the compilation environment because
; the appropriate environment hasn't been set up.  So, we just bootstrap
; them up.
(mapc '(lambda (x)
	  (mapc '(lambda (y)
		    (setq loop-path-keyword-alist
			  (cons (cons y (cdr x))
				(delq (si:loop-tassoc
				         y loop-path-keyword-alist)
				      loop-path-keyword-alist))))
		(car x)))
      '(
      #+(or For-NIL For-Maclisp Lispm)
	((interned-symbols interned-symbol)
	   loop-interned-symbols-path (in))
      #+(or For-NIL Lispm)
	((local-interned-symbols local-interned-symbol)
	   loop-interned-symbols-path (in) t)
	))

#-Multics ; none defined yet
(mapc '(lambda (x)
	 (mapc '(lambda (y)
		  (setq loop-path-keyword-alist
			(cons `(,y si:loop-sequence-elements-path
				(of in from downfrom to downto below above by)
				. ,(cdr x))
			      (delq (si:loop-tassoc
				      y loop-path-keyword-alist)
				    loop-path-keyword-alist))))
	       (car x)))
      '(#+Lispm
        ((array-element array-elements) aref array-active-length)
	; These NIL guys are set up by NILAID in the PDP10 version but no one
	; sets them up on the VAX.  Anyway redundancy won't hurt unless i
	; break something.
	#+(and For-NIL (not Run-in-Maclisp))
	  ((vector-element vector-elements) vref vector-length vector)
        #+(and For-NIL (not Run-in-Maclisp))
	  ((bit bits) bit bits-length bits fixnum)
	#+(and For-NIL (not Run-in-Maclisp))
	  ((character characters) char string-length string character)
	)
      )

; Sigh. (c.f. loop-featurep, note macro-expansion lossage.)
; Note that we end up doing both in the PDP10 NIL version.
#+(or (not For-NIL) Run-in-Maclisp)
  (or (status feature loop) (sstatus feature loop))
#+For-NIL
  (set-feature 'loop 'local)

EndOfFile
cat >  lisplib/ucifnc.l  << 'EndOfFile'
(setq rcs-ucifnc-
   "$Header: /usr/lib/lisp/ucifnc.l,v 1.1 83/01/29 18:41:16 jkf Exp $")

;
; There is problems with the ucilisp do being
;	incompatible with maclisp/franz do,
;	The problems with compiling do are gone, but
;	due to these possible problems, the ucilisp do function
;	is in a seperate file ucido.l and users of it
;	should also load that file in at compile time before
;	any call to do (since do is a macro) (and
;	at runtime if do is to be interpreted).
;
; This file is meant to be fasl'd or used with liszt -u
;	not to be read in interpretively (the syntax changes
;	will not work in that case.
;
;	to compile this file do liszt ucifnc.l
;
;	one who wants to use these functions or compile and run
;	a ucilisp program should do both
;	liszt -u file.l 	when compiling.
;	and
;	(fasl '/usr/lib/lisp/ucifnc)
;		before loading in and running them
;		programs in lisp.
;	This is because some functions are macros and others are too
;		complicated and need other functions around.
;	Note this file will not load in directly and when fasl'd in will
;		cause the syntax of lisp to change to ucilisp syntax.
;
(declare (macros t))

;
; ucilisp (de df dm) declare function macros.
;
; (de name args body) -> declare exprs and lexprs.
;
(defun de macro (l) 
  `(defun ,@(cdr l)))
  
;
; (df name args body) -> declare fexprs.
;
(defun df macro (l) 
  `(defun ,(cadr l)
	  fexpr
	  ,@(cddr l)))

;
; macro's are not compiled except under the same
;	conditions as in franz lisp.
;	(usually just do (declare (macros t))
;		to have macros also compiled).
;
;
; (dm name args body) -> declare macros. same as (defun name 'macro body)
;
(defun dm macro (l) 
  `(defun ,(cadr l)
	  macro
	  ,@(cddr l)))
  
;
; ucilisp let macro.
;
(eval-when (compile load eval)
  (defun let1 (l vars vals body)
	 (cond ((null l) 
		(cons (cons 'lambda (cons vars body)) vals))
	       (t 
		(let1 (cddr l) 
		      (cons (car l) vars) 
		      (cons (cadr l) vals) body)))))
  
(defun let macro (l)
  (let1 (cadr l) nil nil (cddr l)))
  
(defun nconc1 macro (l) 
  `(nconc ,(cadr l) (list ,(caddr l))))
  
(putd 'expandmacro (getd 'macroexpand))
  
;
; ucilisp selectq function. (written by jkf)
;
(def selectq
  (macro (form)
	 ((lambda (x)
		  `((lambda (,x)
			    (cond 
			     ,@(maplist 
				'(lambda (ff)
					 (cond ((null (cdr ff))
						`(t  ,(car ff)))
					       ((atom (caar ff))
						`((eq ,x ',(caar ff))
						  . ,(cdar ff)))
					       (t
						`((memq ,x ',(caar ff))
						  . ,(cdar ff)))))
				(cddr form))))
		    ,(cadr form)))
	  (gensym 'Z))))

;
; ucilisp functions which declare read macros.
;
; dsm - declare splicing read macro.
;
(defun dsm macro (l) 
  `(eval-when (compile load eval)
	      (setsyntax ',(cadr l) 'splicing ',(caddr l))))

;
; drm - declare read macro.
;
(defun drm macro (l) 
  `(eval-when (compile load eval)
	      (setsyntax ',(cadr l) 'macro ',(caddr l))))

;
;(:= a b) -> ucilisp assignment macro.
;
(defun := macro (expression)
      (let (lft (macroexpand (cadr expression)) rgt (caddr expression))
	   (cond ((atom lft) 
		  `(setq ,lft ,(subst lft '*-* rgt)))
		 ((get (car lft) 'set-program)
		  (cons (get (car lft) 'set-program)
			(append (cdr lft) (list (subst lft '*-* rgt))))))))
  
(defprop car rplaca set-program)
(defprop cdr rplacd set-program)
(defprop cadr rplacad set-program)
(defprop cddr rplacdd set-program)
(defprop caddr rplacadd set-program)
(defprop cadddr rplacaddd set-program)
(defprop get get-set-program set-program)

(defun get-set-program (atm prop val) 
  (putprop atm val prop))

(defun rplacad (exp1 exp2) 
  (rplaca (cdr exp1) exp2))

(defun rplacdd (exp1 exp2) 
  (rplacd (cdr exp1) exp2))

(defun rplacadd (exp1 exp2) 
  (rplaca (cddr exp1) exp2))

(defun rplacaddd (exp1 exp2) 
  (rplaca (cdddr exp1) exp2))

;
; ucilisp record-type package to declare records and field extraction
;	macros.
;

(declare (special *type*))

(defun record-type macro (l)
  (let (*type* (cadr l) *flag* (caddr l) slots (car (last l)))
       `(progn 'compile
	       (defun ,*type*
		      ,(slot-funs-extract slots (and *flag* '(d)))
		      ,(cond ((null *flag*) (struc-cons-form slots))
			     (t (append `(cons ',*flag*)
					(list (struc-cons-form slots))))))
	       ,(cond (*flag*
		       (cond ((dtpr *flag*) (setq *flag* *type*)))
		       `(defun ,(concat 'is- *type*)
			       macro
			       (l)
			       (list 'and (list 'dtpr (cadr l))
				     (list 'eq (list 'car (cadr l))
					   '',*flag*))))))))
  
(defun slot-funs-extract (slots path)
  (cond ((null slots) nil)
	((atom slots)
	 (eval `(defun ,(concat slots ': *type*)
		       macro
		       (l)
		       (list ',(readlist `(c ,@path r))
			     (cadr l))))
	 (list slots))
	((nconc (slot-funs-extract (car slots) (cons 'a path))
		(slot-funs-extract (cdr slots) (cons 'd path))))))
  
(defun struc-cons-form (struc)
  (cond ((null struc) nil)
	((atom struc) struc)
	(t `(cons ,(struc-cons-form (car struc))
		  ,(struc-cons-form (cdr struc))))))

(defun some macro (l)
  `((lambda (f a)
	    (prog ()
		  loop
		  (cond ((null a) (return nil))
			((funcall f (car a))
			 (return a))
			(t (setq a (cdr a))
			   (go loop)))))
    ,(cadr l)
    ,(caddr l)))

(declare (special vars))
  
(defun for macro (*l*)
  (let (vars (vars:for *l*)
	     args (args:for *l*)
	     test (test:for *l*)
	     type (type:for *l*)
	     body (body:for *l*))
       (cons (make-mapfn vars test type body)
	     (cons (list 'quote
			 (make-lambda 
			  vars (add-test test
					 (make-body vars test type body))))
		   args))))
  
(defun type:for (*l*)
  (let (item (item:for '(do save splice filter) *l*))
       (cond (item (car item))
	     ((error '"No body in for loop")))))
  
(defun error (l &optional x)
  (cond (x (terpri) (patom l) (terpri) (drain) (break) l)
	(t l)))
  
(defun vars:for (*m*)
  (mapcan '(lambda (x) (cond ((is-var-form x) (list (var:var-form x))))) *m*))

(defun args:for (*n*)
  (mapcan '(lambda (x) 
		   (cond ((is-var-form x) (list (args:var-form x)))))
	  *n*))

(defun is-var-form (x) (and (eq (length x) 3) (eq (cadr x) 'in)))
  
(defun var:var-form (x) (car x))
(defun args:var-form (x) (caddr x))
  
(defun test:for (*o*)
  (let (item (item:for '(when) *o*))
       (cond (item (cadr item)))))
  
(defun body:for (*p*)
  (let (item (item:for '(do save splice filter) *p*))
       (cond ((not item) (error '"NO body in for loop"))
	     ((eq (length (cdr item)) 1) (cadr item))
	     ((cons 'progn (cdr item))))))

(declare (special *l* item))

(defun item:for (keywords *l*)
  (let (item nil)
       (some '(lambda (key) (setq item (assoc key (cdr *l*))))
	     keywords)
       item))

(defun make-mapfn (vars test type body)
  (cond ((equal type 'do) 'mapc)
	((not (equal type 'save)) 'mapcan)
	((null test) 'mapcar)
	((subset-test vars body) 'subset)
	('mapcan)))
  
(defun subset-test (vars body)
  (and (equal (length vars) 1) (equal (car vars) body)))
  
(defun make-body (vars test type body)
  (cond ((equal type 'filter)
	 (list 'let (list 'x body) '(cond (x (list x)))))
	((or (not (equal type 'save)) (null test)) body)
	((subset-test vars body) nil)
	((list 'list body))))
  
(defun add-test (test body)
  (cond ((null test) body)
	((null body) test)
	(t (list 'cond (cond ((eq (car body) 'progn) (cons test (cdr body)))
			     ((list test body)))))))
  
(defun make-lambda (var body)
  (cond ((equal var (cdr body)) (car body))
	((eq (car body) 'progn) (cons 'lambda (cons vars (cdr body))))
	((list 'lambda vars body))))
  
(defun pop macro (q)
  `(prog (*q*)
	 (setq *q* (car ,(cadr q)))
	 (setq ,(cadr q) (cdr ,(cadr q)))
	 (return *q*)))
  
(defun length (*u*)
  (cond ((null *u*) 0)
	((atom *u*) 0)
	((add1 (length (cdr *u*))))))
  
(declare (special l))
  
(defun every macro (l)
  `(prog ($$k $v)
	 (setq $$k ,(caddr l))
	 loop
	 (cond ((null $$k)
		(return t))
	       ((apply ,(cadr l) (list (car $$k)))
		(setq $$k (cdr $$k))
		(go loop)))
	 (return nil)))

(defun timer fexpr (request)
  (prog (timein timeout result cpu garbage)
	(setq timein (ptime))
	(prog ()
	      loop (setq result (eval (car request)))
	      (setq request (cdr request))
	      (cond ((null request) (return result))
		    ((go loop))))
	(setq timeout (ptime))
	(setq cpu (quotient (times 1000.0
				   (quotient (difference (car timeout) 
							 (car timein))
					     60.0))
			    1000.0))
	(setq garbage (quotient (times 1000.0
				       (quotient (difference (cadr timeout) 
							     (cadr timein)) 
						 60.0))
				1000.0))
	(print (cons cpu garbage))
	(terpri)
	(return result)))
  
(defun addprop (id value prop)
  (putprop id (enter value (get id prop)) prop))
  
(defun enter (v l)
  (cond ((member v l) l)
	(t (cons v l))))
  
(defmacro subset (fun lis)
  `(mapcan '(lambda (ele)
		    (cond ((funcall ,fun ele) (ncons ele))))
	   ,lis))
  
(defun push macro (varval)
  `(setq ,(cadr varval)
	 (cons ,(caddr varval)
	       ,(cadr varval))))
  
(putd 'consp (getd 'dtpr))
  
(defun prelist (a b)
  (cond ((null a) nil)
	((eq b 0) nil)
	((cons (car a) (prelist (cdr a) (sub1 b))))))
  
(defun suflist (a b)
  (cond ((null a) nil)
	((eq b 0) a)
	((suflist (cdr a) (sub1 b)))))
  
(defun loop macro (l)
  `(prog ,(var-list (get-keyword 'initial l))
	 ,@(subset (function caddr)
		   (setq-steps (get-keyword 'initial l)))
	 loop
	 ,@(apply (function append) (mapcar (function do-clause) (cdr l)))
	 (go loop)
	 exit
	 (return ,@(get-keyword 'result l))))
  
(defun do-clause (clause)
  (cond ((memq (car clause) '(initial result)) nil)
	((eq (car clause) 'while)
	 (list (list 'or (cadr clause) '(go exit))))
	((eq (car clause) 'do) (cdr clause))
	((eq (car clause) 'next) (setq-steps (cdr clause)))
	((eq (car clause) 'until)
	 (list (list 'and (cadr clause) '(go exit))))
	(t (terpri) (patom '"unknown keyword clause")
	   (patom (car clause))
	   (terpri))))
  
(defun get-keyword (key l)
  (cdr (assoc key (cdr l))))
  
(defun var-list (r)
  (and r (cons (car r) (var-list (cddr r)))))
  
(defun setq-steps (s)
  (and s (cons (list 'setq (car s) (cadr s))
	       (setq-steps (cddr s)))))

(putd 'readch (getd 'readc))


;
; ucilisp msg function. (written by jkf)
;
(defmacro msg ( &rest body)
  `(progn ,@(mapcar 
	     '(lambda (form)
		      (cond ((eq form t) '(line-feed 1))
			    ((numberp form)
			     (cond ((greaterp form 0) 
				    `(msg-space ,form))
				   (t `(line-feed ,(minus form)))))
			    ((atom form) `(patom ,form))
			    ((eq (car form) t) '(patom '/	))
			    ((eq (car form) 'e) 
			     `(patom ,(cadr form)))
			    (t `(patom ,form))))
	     body)))
  
;
; this must be fixed to not use do.
;
(defmacro msg-space (n)
  (cond ((eq 1 n) '(patom '" "))
	(t `(do i ,n (sub1 i) (lessp i 1) (patom '/ ))))) 

(defmacro line-feed (n)
  (cond ((eq 1 n) '(terpr))
	(t `(do i ,n (sub1 i) (lessp i 1) (terpr)))))

(defmacro prog1 ( first &rest rest &aux (foo (gensym)))
  `((lambda (,foo) ,@rest ,foo) ,first))

(defun append1 (l x) (append l (list x)))

; compatability functions: functions required by uci lisp but not
;	present in franz
;
; union uses the franz do loop (not the ucilisp one defined in this file).
;

(def union 
  (lexpr (n)
	 (do ((res (arg n))
	      (i (sub1 n) (sub1 i)))
	     ((zerop i) res)
	     (mapc '(lambda (arg)
			    (cond ((not (member arg res)) 
				   (setq res (cons arg res)))))
		   (arg i)))))


(putd 'newsym (getd 'gensym))	; this is not exactly correct.
				; it only uses the first letter of the arg.
(putd 'remove (getd 'delete))

; ignore column count
(def sprint
  (lambda (form column)
	  ($prpr form)))

(def save  (lambda (f) (putprop f (getd f) 'olddef)))

(def unsave 
  (lambda (f) 
	  (putd f (get f 'olddef))))

(putd 'atcat (getd 'concat))
(putd 'consp (getd 'dtpr))

(defun neq macro (x)
  `(not (eq ,@(cdr x))))

(putd 'gt (getd '>))
(putd 'lt (getd '<))

(defun le macro (x)
  `(not (> ,@(cdr x))))

(defun ge macro (x)
  `(not (< ,@(cdr x))))

(defun litatom macro (x)
  `(and (atom ,@(cdr x))
	(not (numberp ,@(cdr x)))))

(putd 'apply\# (getd 'apply))

(defun tconc (ptr x)
  (cond ((null ptr)
	 (prog (temp)
	       (setq temp (list x))
	       (return (setq ptr (cons temp (last temp))))))
	((null (car ptr))
	 (rplaca ptr (list x))
	 (rplacd ptr (last (car ptr)))
	 ptr)
	(t (prog (temp)
		 (setq temp (cdr ptr))
		 (rplacd (cdr ptr) (list x))
		 (rplacd ptr (cdr temp))
		 (return ptr)))))

;
;	unbound - (setq x (unbound)) will unbind x.
; "this [code] is sick" - jkf.
;
(defun unbound macro (l)
  `(fake -4))

;
;
;	due to problems with franz do in the compiler, this
;		has been commented out and is left in a seperate
;		file called /usr/lib/lisp/ucido.l
;
;(defun do macro (l)
;  ((lambda (dotype alist)
;	   (selectq dotype 
;		    (while (dowhile (car alist) (cdr alist)))
;		    (until (dowhile (list 'not (car alist))
;				    (cdr alist)))
;		    (for (dofor (car alist) 
;				(cadr alist)
;				(caddr alist)
;				(cdddr alist)))
;		    `((lambda ()
;			      ,@alist))))
;   (cadr l)
;   (cddr l)))
;
;(defun dowhile (expr alist)
;  `(prog (returnvar)
;	 loop
;	 (cond (,expr
;		(setq returnvar ((lambda ()
;					 ,@alist)))
;		(go loop))
;	       (t (return returnvar)))))
;
;(defun dofor (var fortype varlist stmlist)
;  (selectq fortype 
;	   (in `(prog (returnvar l1 l2)
;		      (setq l2 ',varlist)
;		      loop
;		      (setq l1 (car l2))
;		      (setq l2 (cdr l2))
;		      (cond ((null l1) 
;			     (return returnvar)))
;		      (setq returnvar
;			    ((lambda (,var)
;				     ,@stmlist)
;			     (l1)))
;		      (go loop)))
;	   (on `(prog (returnvar l1 l2)
;		      (setq l2 ',varlist)
;		      loop
;		      (cond ((null l2) 
;			     (return returnvar)))
;		      (setq returnvar
;			    ((lambda (,var)
;				     ,@stmlist)
;			     (l2)))
;		      (setq l2 (cdr l2))
;		      (go loop)))
;	   (rpt `(prog (returnvar ,var)
;		       (setq ,var 1)
;		       loop
;		       (cond ((not (> ,var ,varlist))
;			      (setq returnvar ((lambda ()
;						       ,@stmlist)))
;			      (setq ,var (1+ ,var))
;			      (go loop))
;			     (t (return returnvar)))))
;	   nil))
;
(putd 'dddd* (getd 'boundp))
(defun boundp (l)
  (cond ((arrayp l))
	((dddd* l))))

;
; now change to ucilisp syntax.
;
(sstatus uctolc t)
;
;	Leave backquote macro in for now.
;		These characters should be declared as follows for real
;		ucilisp syntax though.
;(setsyntax '\` 2)
;(setsyntax '\, 2)
;(setsyntax '\@ 201)
;(setsyntax '\@ 'macro '(lambda () (list 'quote (read))))
; 
; ~ as comment character, not ; and / instead of \ for escape
(setsyntax '\~ 'splicing 'zapline)
(setsyntax '\; 2)
(setsyntax '\# 2)
(setsyntax '\/ 143)
(setsyntax '\\   2)
(setsyntax '\! 2)
EndOfFile
cat >  lisplib/ucido.l  << 'EndOfFile'
(setq SCCS-ucido "@(#)ucido.l      1.3     6/29/81")
;
; ucilisp do loop,  this is a seperate file due to conflicts with
;	the franz lisp do function.  To use this, one needs
;	to load this file in at run time.  (And have calls to
;	do be close compiled in compiled code).
;
;	NOTE: do is a macro and must be declared before calls to it
;		in code to be compiled!
;
;	to compile this file: liszt ucido.l
;
(declare (macros t))

(eval-when (compile)
  (load 'ucifnc))

(defun do macro (l)
  ((lambda (dotype alist)
	   (cond ((eq dotype 'while)
		  (dowhile (car alist) (cdr alist)))
		 ((eq dotype 'until)
		  (dowhile (list 'not (car alist))
			   (cdr alist)))
		 ((eq dotype 'for)
		  (dofor (car alist) 
			 (cadr alist)
			 (caddr alist)
			 (cdddr alist)))
		 (t `((lambda ()
			      ,@alist)))))
   (cadr l)
   (cddr l)))

(defun dowhile (expr alist)
  `(prog (returnvar)
	 loop
	 (cond (,expr
		(setq returnvar ((lambda ()
					 ,@alist)))
		(go loop))
	       (t (return returnvar)))))

(defun dofor (var fortype varlist stmlist)
  (selectq fortype 
	   (in `(prog (returnvar l1 l2)
		      (setq l2 ',varlist)
		      loop
		      (setq l1 (car l2))
		      (setq l2 (cdr l2))
		      (cond ((null l1) 
			     (return returnvar)))
		      (setq returnvar
			    ((lambda (,var)
				     ,@stmlist)
			     (l1)))
		      (go loop)))
	   (on `(prog (returnvar l1 l2)
		      (setq l2 ',varlist)
		      loop
		      (cond ((null l2) 
			     (return returnvar)))
		      (setq returnvar
			    ((lambda (,var)
				     ,@stmlist)
			     (l2)))
		      (setq l2 (cdr l2))
		      (go loop)))
	   (rpt `(prog (returnvar ,var)
		       (setq ,var 1)
		       loop
		       (cond ((not (> ,var ,varlist))
			      (setq returnvar ((lambda ()
						       ,@stmlist)))
			      (setq ,var (1+ ,var))
			      (go loop))
			     (t (return returnvar)))))
	   nil))
EndOfFile
cat >  lisplib/jkfmacs.l  << 'EndOfFile'
(setq SCCS-jkfmacs "%Z%%M%	%I%	%G%")

;------ jkfmacs :: common and useful macros
;
;; as of Franz opus 38.36 all the macros in this file all available in
;; the standard lisp system, so there is no reason to load this file.
;;

(msg "message from jkfmacs: " N
     "All the macros in this file are now available in the default franz." N
     "Thus you should not be loading jkfmacs." N
     "One warning: the order of the arguments is different in the version " N
     "of the push macro in the default franz.  it is now (push val stack) " N
     "You should check your code " N
     "Also, there isn't an 'unpush' macro any more " N)
EndOfFile
cat >  lisplib/trace.l  << 'EndOfFile'
(setq rcs-trace-
   "$Header: /usr/lib/lisp/RCS/trace.l,v 1.2 83/08/15 22:30:36 jkf Exp $")

;---- The Joseph Lister Trace Package, v1
;         John Foderaro, Sept 1979
;------------------------------------------------------------------;
; Copyright (c) 1979 The Regents of the University of California   ;
;	All rights reserved.					   ;
;------------------------------------------------------------------;
(eval-when (eval)
  (setq old-read-table-trace readtable)
  (setq readtable (makereadtable t))
  (setq old-uctolc-value (status uctolc))
  (sstatus uctolc nil)		; turn off case conversion
  (load 'charmac)
  (setsyntax '\; 'macro 'zapline)
  )



;----
; trace uses these properties on the property list:
;    trace-orig-fcn: original occupant of the function cell
;    trace-trace-fcn: the value trace puts in the  function cell
;	(used to check if the trace function has be overwritten).
;    trace-trace-args: the arguments when function was traced.
;    trace-printargs: function to print argument to function
;    trace-printres: function to print result of function

(declare (nlambda T-status T-sstatus)
  (special piport
	   if ifnot evalin evalout 
	   printargs printres evfcn
	   traceenter traceexit
	   prinlevel prinlength
	   $$traced-functions$$		; all functions being traced
	   $$functions-in-trace$$	; active functions 
	   $$funcargs-in-trace$$	; arguments to active functions.
	   $tracemute			; if t, then enters and exits
					; are quiet, but info is still
					; kept so (tracedump) will work
	   trace-prinlevel		; default values
	   trace-prinlength
	   trace-printer		; function trace uses to print
	   ))



(cond ((null (boundp '$$traced-functions$$)) (setq $$traced-functions$$ nil)))
(cond ((null (boundp '$$functions-in-trace$$)) (setq $$functions-in-trace$$ nil)))
(cond ((null (boundp '$$funcargs-in-trace$$)) (setq $$funcargs-in-trace$$ nil)))
(cond ((null (boundp '$tracemute)) (setq $tracemute nil)))
(cond ((null (boundp 'trace-prinlevel)) (setq trace-prinlevel 4)))
(cond ((null (boundp 'trace-prinlength)) (setq trace-prinlength 5)))
(cond ((null (boundp 'trace-printer)) (setq trace-printer 'Trace-print)))

;----> It is important that the trace package not use traced functions
;	thus we give the functions the trace package uses different
;	names and make them equivalent at this time to their 
;	traceable counterparts.  
(defun trace-startup-func nil
  (do ((i '( (add1 T-add1)(append T-append)
	     (and T-and)  (apply T-apply)
	     (cond T-cond) (cons T-cons) (delq T-delq)
	     (def T-def) (do T-do) (drain T-drain)
	     (dtpr T-dtpr)  (eval T-eval)(funcall T-funcall)
	     (get T-get) (getd T-getd)(getdisc T-getdisc)
	     (greaterp T-greaterp)(lessp T-lessp)
	     (mapc T-mapc) (not T-not)(nreverse T-nreverse)
	     (patom T-patom) (print T-print) (prog T-prog)
	     (patom T-patom)(putd T-putd) 
	     (putprop T-putprop)
	     (read T-read)(remprop T-remprop) (reverse T-reverse)
	     (return T-return)
	     (set T-set) (setq T-setq)
	     (status T-status) (sstatus T-sstatus)
	     (sub1 T-sub1) (terpr T-terpr) 
	     (zerop T-zerop))
	  (cdr i)))
      ((null i))
      (putd (cadar i) (getd (caar i)))
      (putprop (cadar i) t 'Untraceable)))

(trace-startup-func)


(putprop 'quote t 'Untraceable)		; this prevents the common error
					; of (trace 'foo) from causing big
					; problems.

;--- trace - arg1,arg2, ... names of functions to trace
;	This is the main user callable trace routine. 
; work in progress, documentation incomplete since im not sure exactly
; where this is going.	
;
(def trace
  (nlambda (argl)
   (prog (if ifnot evalin evalout funnm  typ
	  funcd did break printargs printres evfcn traceenter traceexit
	  traceargs)

    ; turn off transfer table linkages if they are on
    (cond ((T-status translink) (T-sstatus translink nil)))

    ; process each argument	 

    (do ((ll argl (cdr ll))
	 (funnm) 
	 (funcd))
	((null ll))
      (setq funnm (car ll)
		if t
		break nil
		ifnot nil
		evalin nil
		evalout nil
		printargs nil
		printres nil
		evfcn nil
		traceenter 'T-traceenter
		traceexit  'T-traceexit
		traceargs  nil)

	; a list as an argument means that the user is specifying
	; conditions on the trace
      (cond ((not (atom funnm))
	     (cond ((not (atom (setq funnm (car funnm))))
		    (T-print (car funnm))
		    (T-patom '" is non an function name")
		    (go botloop)))
	     ; remember the arguments in case a retrace is requested
	     (setq traceargs (cdar ll))
	     ; scan the arguments
	     (do ((rr (cdar ll) (cdr rr)))
		 ((null rr))
		 (cond ((memq (car rr) '(if ifnot evalin evalout
					    printargs printres evfcn
					    traceenter traceexit))
			(T-set (car rr) (cadr rr))
			(setq rr    (cdr rr)))
		       ((eq (car rr) 'evalinout)
			(setq evalin (setq evalout (cadr rr))
			      rr (cdr rr)))
		       ((eq (car rr) 'break)
			(setq break t))
		       ((eq (car rr) 'lprint)
			(setq printargs 'T-levprint
			      printres  'T-levprint))
		       (t (T-patom '"bad request: ")
			  (T-print (car rr))
			  (T-terpr)))))
	    (t (setq traceargs nil)  ;no args given
	       ))

	    ; if function is untraceable, print error message and skip
       (cond ((get funnm 'Untraceable)
	      (setq did (cons `(,funnm untraceable) did))
	      (go botloop)))


       ; Untrace before tracing
       (let ((res (funcall 'untrace (list funnm))))
	  (cond (res (setq did (cons `(,funnm untraced) did)))))

       ; store the names of the arg printing routines if they are
       ; different than print

       (cond (printargs (T-putprop funnm printargs 'trace-printargs)))
       (cond (printres  (T-putprop funnm printres 'trace-printres)))
       (T-putprop funnm traceargs 'trace-trace-args)

       ; we must determine the type of function being traced
       ; in order to create the correct replacement function

       (cond ((setq funcd (T-getd funnm))
	      (cond ((bcdp funcd)		; machine code
		     (cond ((or (eq 'lambda (T-getdisc funcd))
				(eq 'nlambda (T-getdisc funcd))
				(eq 'macro (T-getdisc funcd)))
			    (setq typ (T-getdisc funcd)))
			   ((stringp (T-getdisc funcd))	; foreign func
			    (setq typ 'lambda))		; close enough
			   (t (T-patom '"Unknown type of compiled function")
			      (T-print funnm)
			      (setq typ nil))))

		    ((dtpr funcd)		; lisp coded
		     (cond ((or (eq 'lambda (car funcd))
				(eq 'lexpr (car funcd)))
			    (setq typ 'lambda))
			   ((or (eq 'nlambda (car funcd))
				(eq 'macro (car funcd)))
			    (setq typ (car funcd)))
			   (t (T-patom '"Bad function definition: ")
			      (T-print funnm)
			      (setq typ nil))))
		    ((arrayp funcd)		; array
		     (setq typ 'lambda))
		    (t (T-patom '"Bad function defintion: ")
		       (T-print funnm)))

	      ; now that the arguments have been examined for this
	      ; function, do the tracing stuff.
	      ; First save the old function on the property list

	      (T-putprop funnm funcd 'trace-orig-fcn)

	      ; now build a replacement

	      (cond
		 ((eq typ 'lambda)
		  (T-eval
		     `(T-def
			 ,funnm
			 (lexpr (T-nargs)
				((lambda (T-arglst T-res T-rslt
						   $$functions-in-trace$$
						   $$funcargs-in-trace$$)
				    (T-do ((i T-nargs (T-sub1 i)))
					  ((T-zerop i))
					  (T-setq T-arglst
						  (T-cons (arg i) T-arglst)))
				    (T-setq $$funcargs-in-trace$$
					    (T-cons T-arglst
						    $$funcargs-in-trace$$))
				    (T-cond ((T-setq T-res
						     (T-and ,if
							     (T-not ,ifnot)))
					     (,traceenter ',funnm T-arglst)
					     ,@(cond (evalin
							`((T-patom ,'":in: ")
							  ,evalin
							  (T-terpr))))
					     (T-cond (,break
						       (trace-break)))))
				    (T-setq T-rslt
					    ,(cond
						(evfcn)
						(t `(T-apply
						       ',funcd
						       T-arglst))))
				    (T-cond (T-res
					       ,@(cond (evalout
							  `((T-patom ,'":out: ")
							    ,evalout
							    (T-terpr))))
					       (,traceexit ',funnm T-rslt)))
				    T-rslt)
				 nil nil nil
				 (T-cons ',funnm $$functions-in-trace$$)
				 $$funcargs-in-trace$$))))
		  (T-putprop funnm (T-getd funnm) 'trace-trace-fcn)
		  (setq did (cons funnm did)
			$$traced-functions$$ (cons funnm
						   $$traced-functions$$)))

		 ((or (eq typ 'nlambda)
		      (eq typ 'macro))
		  (T-eval
		     `(T-def ,funnm
			      (,typ (T-arglst)
				((lambda (T-res T-rslt
						$$functions-in-trace$$
						$$funcargs-in-trace$$)
				    (T-setq $$funcargs-in-trace$$
					    (T-cons
					       T-arglst
					       $$funcargs-in-trace$$))
				    (T-cond ((T-setq
						T-res
						(T-and ,if
							(not ,ifnot)))
					     (,traceenter
					       ',funnm
					       T-arglst)
					     ,evalin
					     (T-cond (,break
						       (trace-break)))))
				    (T-setq T-rslt
					    ,(cond
						(evfcn `(,evfcn
							  ',funcd
							  T-arglst))
						(t `(T-apply ',funcd
							     T-arglst))))
				    (T-cond (T-res
					       ,evalout
					       (,traceexit ',funnm T-rslt)))
				    T-rslt)
				 nil nil
				 (cons ',funnm $$functions-in-trace$$)
				 $$funcargs-in-trace$$))))
		  (T-putprop funnm (T-getd funnm) 'trace-trace-fcn)
		  (setq did (cons funnm did)
			$$traced-functions$$ (cons funnm
						   $$traced-functions$$)))

		 (t (T-patom '"No such function as: ")
		    (T-print funnm)
		    (T-terpr)))))
	    botloop )
	 ; if given no args, just return the function currently being traced
	 (return (cond ((null argl) $$traced-functions$$)
		       (t (T-nreverse did)))))))

;--- untrace
; (untrace foo bar baz)
;    untraces foo, bar and baz.
; (untrace)
;    untraces all functions being traced.
;

(def untrace
  (nlambda (argl)
	   (cond ((null argl) (setq argl $$traced-functions$$)))

	   (do ((i argl (cdr i))
		(tmp)
		(curf)
		(res))
	       ((null i)  
		(cond ((null $$traced-functions$$)
		       (setq $$functions-in-trace$$ nil)
		       (setq $$funcargs-in-trace$$ nil)))
		res)
	       (cond ((and (T-getd (setq curf (car i)))
			   (eq (T-getd (car i))
			       (get (car i) 'trace-trace-fcn)))
		      ; we only want to restore the original definition
		      ; if this function has not been redefined!
		      ; we test this by checking to be sure that the
		      ; trace-trace-property is the same as the function
		      ; definition.
		      (T-putd curf (get curf 'trace-orig-fcn))
		      (T-remprop curf 'trace-orig-fcn)
		      (T-remprop curf 'trace-trace-fcn)
		      (T-remprop curf 'trace-trace-args)
		      (T-remprop curf 'entercount)
		      (setq $$traced-functions$$ 
			      (T-delq curf $$traced-functions$$))
		      (setq res (cons curf res)))))))


;--- retrace :: trace again all function thought to be traced.
;
(def retrace
   (nlambda (args)
	(cond ((null args) (setq args $$traced-functions$$)))
	(mapcan '(lambda (fcn)
		    (cond ((and (symbolp fcn)
				(not (eq (T-getd fcn)
					 (get fcn 'trace-trace-fcn))))
			   
			   (funcall 'trace
				    `((,fcn ,@(get fcn 'trace-trace-args)))))))
		args)))

;--- tracedump :: dump the currently active trace frames
;
(def tracedump
  (lambda nil
	  (let (($tracemute nil))
	       (T-tracedump-recursive $$functions-in-trace$$ 
				      $$funcargs-in-trace$$))))


;--- traceargs :: return list of args to currently entered traced functions
;  call is:
;	(traceargs foo)  returns first call to foo starting at most current
;       (traceargs foo 3) returns args to third call to foo, starting at
;			  most current
;
(def traceargs
  (nlambda (args)
	   (cond ((and args $$functions-in-trace$$)
		  (let ((name (car args))
			(amt (cond ((numberp (cadr args)) (cadr args))
				   (t 1))))
		       (do ((fit $$functions-in-trace$$ (cdr fit))
			    (fat $$funcargs-in-trace$$ (cdr fat)))
			   ((null fit))
			   (cond ((eq name (car fit))
				  (cond ((zerop (setq amt (1- amt)))
					 (return (car fat))))))))))))

;--- T-tracedump-recursive
; since the lists of functions being traced and arguments are in the reverse
; of the order we want to print them, we recurse down the lists and on the
; way back we print the information.
;
(def T-tracedump-recursive
  (lambda ($$functions-in-trace$$ $$funcargs-in-trace$$)
	  (cond ((null $$functions-in-trace$$))
		(t (T-tracedump-recursive (cdr $$functions-in-trace$$)
					  (cdr $$funcargs-in-trace$$))
		   (T-traceenter (car $$functions-in-trace$$)
				 (car $$funcargs-in-trace$$))))))



;--- T-traceenter - funnm : name of function just entered
;		  - count : count to print out
;	This routine is called to print the entry banner for a
;	traced function.
;
(def T-traceenter
  (lambda (name args)
	  (prog (count indent)
		(cond ((not $tracemute)
		       (setq count 0 indent 0)
		       (do ((ll $$functions-in-trace$$ (cdr ll)))
			   ((null ll))
			   (cond ((eq (car ll) name) (setq count (1+ count))))
			   (setq indent (1+ indent)))
		       
		       (T-traceindent indent)
		       (T-print count)
		       (T-patom '" <Enter> ")
		       (T-print name)
		       (T-patom '" ")
		       (cond ((setq count (T-get name 'trace-printargs))
			      (funcall count args))
			     (t (funcall trace-printer args)))
		       (T-terpr))))))

(def T-traceexit
  (lambda (name res)
	  (prog (count indent)
		(cond ((not $tracemute)
		       (setq count 0 indent 0)
		       (do ((ll $$functions-in-trace$$ (cdr ll)))
			   ((null ll))
			   (cond ((eq (car ll) name) (setq count (1+ count))))
			   (setq indent (1+ indent)))
		       
		       
		       (T-traceindent indent)
		       (T-print count)
		       (T-patom " <EXIT>  ")
		       (T-print name)
		       (T-patom "  ")
		       
		       (cond ((setq count (T-get name 'trace-printres))
			      (funcall count res))
			     (t (funcall trace-printer res)))
		       
		       (T-terpr))))))


;--- Trace-printer
;  this is the default value of trace-printer.  It prints a form after
; binding prinlevel and prinlength.
;
(def Trace-print
   (lambda (form)
      (let ((prinlevel trace-prinlevel)
	    (prinlength trace-prinlength))
	 (T-print form))))

; T-traceindent
; - n   :  indent to column n

(def T-traceindent
  (lambda (col)
	  (do ((i col (1- i))
	       (char '| |))
	      ((< i 2))
	      (T-patom (cond ((eq char '| |) (setq char '\|))
			     (t (setq char '| |)))))))
; from toplevel.l:
;
;--- read and print functions are user-selectable by just
; assigning another value to top-level-print and top-level-read
;
(declare (special top-level-read top-level-print))

(defmacro top-print (&rest args)
   `(cond (top-level-print (funcall top-level-print ,@args))
	  (t (T-print ,@args))))

(defmacro top-read (&rest args)
   `(cond ((and top-level-read
		(T-getd top-level-read))
	   (funcall top-level-read ,@args))
	  (t (T-read ,@args))))


; trace-break  - this is the trace break loop
(def trace-break
  (lambda nil
	 (prog (tracevalread piport)
	       (T-terpr) (T-patom '"[tracebreak]")
	loop   (T-terpr)
	       (T-patom '"T>")
	       (T-drain)
	       (cond ((or (eq nil (setq tracevalread
					 (car
					  (errset (top-read nil nil)))))
			  (and (dtpr tracevalread)
			       (eq 'tracereturn (car tracevalread))))
			(T-terpr)
		        (return nil)))
	       (top-print (car (errset (T-eval tracevalread))))
	       (go loop))))


(def T-levprint
  (lambda (x)
	  ((lambda (prinlevel prinlength)
		  (T-print x))
	   3 10)))

		       
(eval-when (eval)
  (apply 'sstatus `(uctolc ,old-uctolc-value))
  (setq readtable old-read-table-trace)
  )
EndOfFile
cat >  lisplib/record.l  << 'EndOfFile'
(setq rcs-common0-
   "$Header: record.l,v 1.3 84/02/29 19:33:50 jkf Exp $")

;;					-[Mon Feb 20 15:00:52 1984 by jkf]-
;; simple record package
;;

(eval-when (compile)
   (or (get 'record 'version) (load 'record)))

(defvar record-pkg-indicator 'record-package-dr-record)

(declare (macros nil))

;; internal macro
(defmacro dr-error (message &rest args)
   ;; print an error preceeded by 'defrecord'
   ;; internal use only
   `(error ',(concat "defrecord: " message) ,@args))


;(defrecord dr-record
;   	name	; name of record
;	storage ; 'list' or 'vector'
;	options	; subset of 'named', 'access-check'
;   	fields  ; list of dr-field records
;)

(eval-when (compile eval)
   (putprop 'dr-record
	    '(dr-record list nil ((fields 3 nil)
				  (options 2 nil)
				  (storage 1 nil)
				  (name 0 nil)))
	    record-pkg-indicator))
(defmacro make-dr-record (&rest args) (record-pkg-construct 'dr-record args))
(defmacro dr-record-storage (arg) `(nth 1 ,arg))
(defmacro dr-record-options (arg) `(nth 2 ,arg))
(defmacro dr-record-fields (arg) `(nth 3 ,arg))

;(defrecord dr-field
;   ;; internal structure used to store info on fields
;   name
;   offset
;   defaultvalue)

(eval-when (compile eval)
   (putprop 'dr-field
	    '(dr-field list nil ((defaultvalue 2 nil)
				 (offset 1 nil)
				 (name 0 nil)))
	    record-pkg-indicator))
(defmacro make-dr-field (&rest args) (record-pkg-construct 'dr-field args))

(defmacro dr-field-name (arg) `(nth 0 ,arg))
(defmacro dr-field-offset (arg) `(nth 1 ,arg))
(defmacro dr-field-defaultvalue (arg) `(nth 2 ,arg))

;; internal functions (called by macros)

(defun record-pkg-construct (recname args)
   ;; called to expand a make- form.
   ;; recname is the name of a record

   ; convert to an assq list, verifing field names
   (let* ((dr-record (get recname record-pkg-indicator))
	  (fields (dr-record-fields dr-record))
	  (given))
      (do ((xx args (cddr xx)))
	  ((null xx))
	  (if (assq (car xx) fields)
	     then (push (cons (car xx) (cadr xx)) given)
	     else (dr-error " for record " recname
			   ", this field doesn't exist " (car xx))))
      ;; now build a list of values.
      ;; use the fact that the fields list is in the reverse order
      (do ((xx fields (cdr xx))
	   (got)
	   (res))
	  ((null xx)
	   ;; now we have a list of values to compute to build this
	   ;; form.  
	   (caseq (dr-record-storage dr-record)
	      (list `(list ,@res))
	      (vector `(vector ,@res))
	      (t (error "record package is confused about storage type "))))
	  (if (setq got (assq (dr-field-name (car xx)) given))
	     then (push (cdr got) res)	; given value
	     else (push (dr-field-defaultvalue (car xx))
			res)))))



(defun record-pkg-access (recname fieldname arg)
   ;; return code access the given field in the given record
   (let ((dr-record (get recname record-pkg-indicator))
	 (recnamefield)
	 (fieldinfo)
	 (options)
	 (storage))
      (setq fieldinfo (assq fieldname (dr-record-fields dr-record)))
      (setq options (dr-record-options dr-record))
      (setq storage (dr-record-storage dr-record))
      (if (null fieldinfo)
	 then (dr-error "internal error: can't find field " fieldname
			" in record " recname))
      (if (memq 'access-check options)
	 then (setq recnamefield (assq '-record-field-name-
				       (dr-record-fields dr-record)))
	      `((lambda (defrecord-acma)
		   (cond ((not (eq ',recname
				   ,(dr-accessor storage
						 (dr-field-offset
						    recnamefield)
						 'defrecord-acma)))
			  (record-pkg-illegal-access ',recname ',fieldname
						     defrecord-acma))
			 (t ,(dr-accessor storage
					  (dr-field-offset fieldinfo)
					  'defrecord-acma))))
		,arg)
	 else (dr-accessor storage (dr-field-offset fieldinfo) arg))))


(defun dr-accessor (class index obj)
   ;; determine the correct field accessor to get the index'th element
   ;; from obj, give the storage type class (either list or vector).
   ;;
   (caseq class
      (list `(nth ,index ,obj))
      (vector `(vref ,obj ,index))
      (t (error "record package: illegal storage class " class))))

(defun record-pkg-illegal-access (recname fieldname value)
   (error "Unable to access field " fieldname " of record " recname
	  " because this is not an instance of that record: "
	  value))
		    
      
	  
	  
(defun defrecord-name (form)
   ;; user callable function to return the record name of
   ;; a record
   (if (defrecord-namedp form)
      then (if (dtpr form) then (cadr form)
	    elseif (vectorp form)
	      then (vref form 1))
      else (error "record-name: this record doesn't have a name " form)))

(defun defrecord-namedp (form)
   ;; return t iff form is a named record
   (let (name)
      (and (or (and (dtpr form)
		    (cdr form)
		    (progn (setq name (cadr form)) t)
		    (symbolp name))
	       (and (vectorp form)
		    (>& (vsize form) 1)
		    (progn (setq name (vref form 1)) t)
		    (symbolp name)))
	   (get name record-pkg-indicator)
	   t)))

;; external functions
;; The following functions are user callable


(declare (macros t))

(defvar defrecord-default-flags nil)  ; what is assumed in the flag field

(defmacro defrecord (&rest form)
   ;; user callable function
   (if (null form)
      then (error "defrecord: missing record name in " form))

   (let ((name (car form))
	 (args (cdr form))
	 (fields)
	 (nameargs)
	 (givenoptions defrecord-default-flags)
	 (savedoptions)
	 ;;options
	 (namedp)(access-checkp) (vectorp))
      (if (dtpr name)
	 then (setq givenoptions (append givenoptions (cdr name))
		    name (car name)))

      (if (not (symbolp name))
	 then (dr-error "non symbol record name " name))

      ;; process given options
      (do ((xx  givenoptions (cdr xx)))
	  ((null xx))
	  (caseq (car xx)
	     (named (setq namedp t))
	     (access-check (setq access-checkp t))
	     (vector (setq vectorp t))
	     (t ; ignore
	     )))
      ;; look for conflicting options
      (if (and access-checkp (not namedp))
	 then (error "defrecord: Can't specify access-check without also specifying named " form))

      (if namedp then (push 'named savedoptions))
      (if access-checkp then (push 'access-check savedoptions))

      (if namedp
	 then (let ((namefield `(-record-field-name- ',name)))
		 (if args
		    then (setq args (cons (car args)
					  (cons namefield
						(cdr args))))
			 else (setq args (list namefield)))))

      (do ((xx args (cdr xx))
	   (off 0 (1+ off)))
	  ((null xx))
	  (if (dtpr (car xx))
	     then (push (make-dr-field
			   name (caar xx)
			   offset off
			   defaultvalue (cadar xx))
			fields)
	     else (push (make-dr-field
			   name (car xx)
			   offset off)
			fields)))

      
      ; return a progn compile of an accessor and a collection
      ; of accessors
      `(progn 'compile
	      (eval-when (compile load eval)
			 (putprop ',name ',(make-dr-record
					    name name
					    storage (if vectorp
							then 'vector
							else 'list)
					    options savedoptions
					    fields fields)
				  ',record-pkg-indicator))
	      (defmacro ,(concat 'make- name) (&rest args)
			 (record-pkg-construct ',name args))
	      ,@(mapcar '(lambda (dr-field)
			    `(defmacro ,(concat name
						'-
						(dr-field-name dr-field))
					(arg)
					(record-pkg-access
					   ',name
					   ',(dr-field-name dr-field)
					   arg)))
			fields))))


(putprop 'record t 'version)
EndOfFile
cat >  lisplib/syscall.l  << 'EndOfFile'
(setq rcs-syscall-
   "$Header: /usr/lib/lisp/RCS/syscall.l,v 1.2 83/01/30 11:52:43 jkf Exp $")

;
;   syscall
;
; This file contains macro definitions of some of the Unix system calls.
; The documentation for these system calls can be found in the Unix
; manual.
;
; It is believed that all of these system calls can be executed by the
; Unix emulator Eunice under VMS.
;
; Unix system calls which return values in registers other than r0 cannot
; be called in this way.  An example of this is fork, for which there is
; a seperate lisp function.

(declare (macros t))

(defmacro sys_access (name mode)
  `(syscall 33 ,name ,mode))

(defmacro sys_alarm (secs)
  `(syscall 27 ,secs))

(defmacro sys_brk (addr)
  `(syscall 17 ,addr))

(defmacro sys_chdir (dir)
  `(syscall 12 ,dir))

(defmacro sys_chmod (name mode)
  `(syscall 15 ,name ,mode))

(defmacro sys_chown (name ownerid groupid)
  `(syscall 16 name ownerid groupid))

(defmacro sys_close (filedes)
  `(syscall 6 ,filedes))

(defmacro sys_creat (name mode)
  `(syscall 8 ,name ,mode))

(defmacro sys_exit (status)
  `(syscall 1 ,status))

(defmacro sys_getpid nil
  `(syscall 20))

(defmacro sys_getuid nil
  `(syscall 24))

(defmacro sys_getgid nil
  `(syscall 47))

; sys_kill - need to get value into r0
(defmacro sys_kill (pid)
  `(syscall 37 ,pid))


(defmacro sys_link (name newname)
  `(syscall 9 ,name ,newname))

(defmacro sys_nice (value)
  `(syscall 34 ,value))

; sys_lseek this may not be correct the explanation is given for a pdp-11
; where certain values must be stored in two words.
; also need to get value into r0

(defmacro sys_open (name how)  
  `(syscall 5 ,name ,how))

(defmacro sys_pause nil
  `(syscall 29))

(defmacro sys_setuid (uid)
  `(syscall 23 ,uid))


(defmacro sys_setgid (gid)
  `(syscall 46 ,gid))

(defmacro sys_sync nil
  `(syscall 36))

(defmacro sys_time nil
  `(syscall 13))

(defmacro sys_umask (complementmode)
  `(syscall 60 ,complementmode))

(defmacro sys_unlink (name)
  `(syscall 10 ,name))

(defmacro sys_wait nil
  `(syscall 7))

(defmacro sys_ioctl (portnumber arg)
  `(syscall 54 ,portnumber ,arg))


(putprop 'syscall t 'version)	; flag that this file has been loaded
EndOfFile
cat >  lisplib/cmumacs.l  << 'EndOfFile'
;; file of common cmu functions which should be macros 
;; I hope that by just loading in the file an environment will be
;; created which will permit the cmu files to be compiled.

(setq rcs-cmumacs-
   "$Header: /usr/lib/lisp/cmumacs.l,v 1.1 83/01/29 18:34:31 jkf Exp $")

(declare (macros t))

(eval-when (compile eval load)
   (or (boundp 'CMU-fcn-def) (setq CMU-fcn-def (getd 'def))))

;-- contents
;	dv	mark!changed 	***	list* [construct-list* lambda]
;	neq	push	pop	mukname (equivlance)
;	prin1 (equiv to print)	selectq	lineread
;

;--- dv :: set variable to value and remember it was changed
; (dv name value)   name is setq'ed to value (no evaluation) and
;		 the fact that it was done is remembered
;
(defmacro dv (name value)
  `(progn 'compile
	  (setq ,name ',value)
	  (mark!changed ',name)))

(defmacro mark!changed (name)
  `(let ((atomname ,name))
        (and (boundp '%changes) (setq %changes (cons atomname %changes)))
	atomname))

;--- *** :: comment macro
;
(defmacro *** (&rest x) nil)

;; this must be rewritten as a macro		****
;(def quote! (nlambda (a) (quote!-expr a)))

; this will be thrown away if the code below it works
(def quote!-expr
     (lambda 
      (x)
      (cond ((atom x) x)
            ((eq (car x) '!)
             (cons (eval (cadr x)) (quote!-expr (cddr x))))
            ((eq (car x) '!!)
             (cond ((cddr x)
                    (append (eval (cadr x)) (quote!-expr (cddr x))))
                   (t (eval (cadr x)))))
            (t
             (prog (u v)
                   (setq u (quote!-expr (car x)))
                   (setq v (quote!-expr (cdr x)))
                   (cond ((and (eq u (car x)) (eq v (cdr x))) (return x)))
                   (return (cons u v)))))))
;; this is probably what the above forms do. (jkf)
(defmacro quote! (&rest a) (quote!-expr-mac a))
(eval-when (compile eval load)
   
(defun quote!-expr-mac (form)
   (cond ((null form) nil)
	 ((atom form) `',form)
	 ((eq (car form) '!)
	  `(cons ,(cadr form) ,(quote!-expr-mac (cddr form))))
	 ((eq (car form) '!!)
	  (cond ((cddr form) `(append ,(cadr form)
				       ,(quote!-expr-mac (cddr form))))
		(t (cadr form))))
	 (t `(cons ,(quote!-expr-mac (car form))
		    ,(quote!-expr-mac (cdr form))))))

); end eval-when
		 
	 
;--- the following are macroizations from cmu3.l

;(jkf)- ucb list* macro.
;
(defmacro list* (&rest forms)
	  (cond ((null forms) nil)
		((null (cdr forms)) (car forms))
		(t (construct-list* forms))))

(defun construct-list* (forms)
       (setq forms (reverse forms))
       (do ((forms (cddr forms) (cdr forms))
	    (return-form `(cons ,(cadr forms) ,(car forms))
			 `(cons ,(car forms) ,return-form)))
	   ((null forms) return-form))) 

(defmacro neq (a b) `(not (eq ,a ,b)))


(defmacro push (value stack) `(setq ,stack (cons ,value ,stack)))





;(jkf) this is actually maknum is the maclisp terminology
(putd 'munknam (getd 'maknum))

; added for CMULisp compatibilty (used by editor etc)
(putd 'prin1 (getd 'print))

;--- selectq :: case statement type construct
;
;   (selectq <form>
;	     (<tag1> <expr1> ...)
;	     (<tag2> <expr2> ...)
;		 ...
;	     (<tagn> <exprn> ...)
;	      (<exprfinal> ...))
; <form> is evaluated and then compared with the tagi, if it matches
; the expri are evaluated.  If it doesn't match, then <exprfinal> are
; evaluated.
;
(def selectq
   (macro (form)
	  ((lambda (x)
		   `((lambda (,x)
			     (cond
				  ,@(maplist
					 '(lambda (ff)
						  (cond ((null (cdr ff))
							 `(t  ,(car ff)))
							((atom (caar ff))
							 `((eq ,x ',(caar ff))
							   . ,(cdar ff)))
							(t
							     `((memq ,x ',(caar ff))
							       . ,(cdar ff)))))
					  (cddr form))))
		     ,(cadr form)))
	  (gensym 'Z))))

(defmacro lineread (&optional (x nil)) 
  `(%lineread ,x))



(defmacro de (name &rest body)
   (cond ((status feature complr) `(def ,name (lambda ,@body)))
	 (t `(progn (putd ,name '(lambda ,@body))
		    (mark!changed ',name)))))
(defmacro dn (name &rest body)
   (cond ((status feature complr) `(def ,name (nlambda ,@body)))
	 (t `(progn (putd ,name '(nlambda ,@body))
		    (mark!changed ',name)))))
(defmacro dm (name &rest body)
   (cond ((status feature complr) `(def ,name (macro ,@body)))
	 (t `(progn (putd ,name '(macro ,@body))
		    (mark!changed ',name)))))

(eval-when (compile eval load)
   (or (boundp 'OLD-fcn-def) (setq OLD-fcn-def (getd 'def))))

(defmacro def (&rest form)
    (cond ((status feature complr)
	   `(progn 'compile
		    (eval-when (compile) (putd 'def OLD-fcn-def))
		    (def ,@form)
		    (eval-when (compile) (putd 'def CMU-fcn-def))))
	  (t `(progn (putd ',(car form) ',(cadr form))
		    (mark!changed ',(car form))))))

(eval-when (compile eval load)
   (or (boundp 'CMU-fcn-def) (setq CMU-fcn-def (getd 'def))))

;--iteration macros

(def Cdo (macro (l) (expand-do l)))

(def exists (macro (l) (expand-ex 'some l)))

(declare (special var))

(eval-when (compile eval load)
   
(def expand-ex
     (lambda 
      (fn form)
      (quote! !
              fn
              !
              (caddr form)
              (function
               (lambda 
                !
                (cond ((atom (cadr form)) (ncons (cadr form)))
                      (t (cadr form)))
                !
                (car (setq form (cdddr form)))))
              !
              (cond ((cdr form) (list 'function (cadr form)))))))
) ; end eval-when

(def expand-do
     (lambda 
      (l)
      (prog (label var init incr limit part)
            (cond
             ((setq part (memq 'for l))
              (setq var (cadr part))
              (setq l (append (ldiff l part) (cddr part)))))
            (cond
             ((setq part (exists w l (memq w '(gets = _ :=))))
              (setq init (cadr part))
              (setq l (append (ldiff l part) (cddr part)))))
            (cond
             ((setq part (exists w l (memq w '(step by))))
              (setq incr (cadr part))
              (setq l (append (ldiff l part) (cddr part)))))
            (cond
             ((setq part (memq 'to l))
              (setq limit (cadr part))
              (setq l (append (ldiff l part) (cddr part)))))
            (return
             (quote! prog
                     !
                     (cond (var (ncons var)))
                     !!
                     (cond
                      (var
                       (ncons
                        (list 'setq var (cond (init) (t 1))))))
                     !
                     (setq label (gensym))
                     !!
                     (mapcan (function
                              (lambda 
                               (exp)
                               (cond ((eq part 'while)
                                      (setq part nil)
                                      (quote!
                                       (cond
                                        ((not ! exp) (return nil)))))
                                     ((eq part 'until)
                                      (setq part nil)
                                      (quote!
                                       (cond (! exp (return nil)))))
                                     ((memq (setq part exp)
                                            '(while until do Cdo))
                                      nil)
                                     (t (ncons exp)))))
                             l)
                     !!
                     (cond
                      (var
                       (quote!
                        (setq ! var (+ ! var ! (cond (incr) (t 1)))))))
                     !!
                     (cond
                      ((and var limit)
                       (quote! (cond ((> ! var ! limit) (return nil))))))
                     (go ! label))))))


(def expand-fe
     (lambda 
      (form)
      (prog (vars body)
            (return
             (cons (cond ((memq (cadr form)
                                (quote
                                 (map mapc
                                      mapcan
                                      mapcar
                                      mapcon
                                      mapconc
                                      maplist)))
                          (setq form (cdr form))
                          (car form))
                         (t 'mapc))
                   (progn (setq vars (cadr form))
                          (cond ((atom vars) (setq vars (list vars))))
                          (cons (cons 'function
                                      (ncons
                                       (cons 'lambda
                                             (cons vars
                                                   (setq body
                                                         (Cnth (cdddr
                                                                form)
                                                               (length
                                                                vars)))))))
                                (ldiff (cddr form) body))))))))
(def expand-set-of
     (lambda 
      (form)
      (prog (vars body)
            (setq vars (cadr form))
            (cond ((atom vars) (setq vars (list vars))))
            (setq form (cddr form))
            (return
             (quote! mapcan
                     (function
                      (lambda 
                       !
                       vars
                       (cond
                        (! (car
                            (setq body (Cnth (cdr form) (length vars))))
                           (list ! (car vars))))))
                     !!
                     (ldiff form body))))))

(dv filelst nil)

(def for (macro (l) (expand-do l)))

(def for-each (macro (l) (expand-fe l)))

(def forall (macro (l) (expand-ex 'every l)))

(def set-of (macro (l) (expand-set-of l)))

(def ty (macro (f) (append '(exec cat) (cdr f))))

(def until (macro (l) (expand-do l)))

(def while (macro (l) (expand-do l)))

(putprop 'cmumacs t 'version)
EndOfFile
cat >  lisplib/cmufncs.l  << 'EndOfFile'
(setq rcs-cmufncs-
   "$Header: /usr/lib/lisp/cmufncs.l,v 1.1 83/01/29 18:34:20 jkf Exp $")

(eval-when (compile eval) (load 'cmumacs))

(declare (special filelst %changes $%dotflg %prevfn% %%cfn part %%l
		  lastword %trcflg form fn))
(def tab (lexpr (n)
		(prog (nn prt) (setq nn (arg 1))
			       (cond ((> n 1)(setq prt (arg 2))))
			       (cond ((> (nwritn prt) nn) (terpri prt)))
			       (printblanks (- nn (nwritn prt)) prt))))


(dv $%dotflg nil)
(def %lineread
     (lambda 
      (chan)
      (prog (ans)
       loop (setq ans (cons (read chan 'EOF) ans))
	    (cond ((eq (car ans) 'EOF) (return (reverse (cdr ans)))))
       loop2(cond ((eq 10 (tyipeek chan)) (return (reverse ans)))
                  ((memq (tyipeek chan) '(41 93))
                   (tyi chan)
                   (go loop2))
                  (t (go loop))))))


(dv %prevfn% " ")
(dv %trcflg t)
   
(def attach
     (lambda 
      (x y)
      (cond ((dtpr y) (rplacd y (cons (car y) (cdr y))) (rplaca y x))
            (t (eprint y) (error '"IS AN ATOM, CAN'T BE ATTACHED TO")))))

(dv %changes ())

(def dremove
   (lambda (x l)
	   (cond ((atom l) nil)
		 ((eq x (car l))
		  (cond ((cdr l)
			 (rplaca l (cadr l))
			 (rplacd l (cddr l))
			 (dremove x l))))
		 (t (prog (z)
			  (setq z l)
		    lp    (cond ((atom (cdr l)) (return z))
				((eq x (cadr l)) (rplacd l (cddr l)))
				(t (setq l (cdr l))))
			  (go lp))))))
(def dreverse
     (lambda (l)
      (prog (l1 y z)
            (setq l1 l)
       l1   (cond
             ((atom (setq y l))
              (cond ((or (null z) (null (cdr z))) (return z))
                    ((null (cddr z))
                     (setq y (car l1))
                     (rplaca l1 (car z))
                     (rplaca z y)
                     (rplacd l1 z)
                     (rplacd z nil)
                     (return l1))
                    (t (rplacd (Cnth z (sub1 (length z))) z)
                       (setq y (car l1))
                       (rplaca l1 (car z))
                       (rplaca z y)
                       (rplacd l1 (cdr z))
                       (rplacd z nil)
                       (return l1)))))
            (setq l (cdr l))
            (setq z (rplacd y z))
            (go l1))))

(def dsubst
     (lambda (x y z)
      (prog (b)
            (cond ((eq y (setq b z)) (return (copy x))))
       lp   (cond ((atom z) (return b))
                  ((cond ((symbolp y) (eq y (car z))) (t (equal y (car z))))
                   (rplaca z (copy x)))
                  (t (dsubst x y (car z))))
            (cond ((and y (eq y (cdr z))) (rplacd z (copy x)) (return b)))
            (setq z (cdr z))
            (go lp))))

(putd 'eqstr (getd 'equal))

; where are the functions this calls??
(def every
     (lambda 
      (everyx everyfn1 everyfn2)
      (prog nil
       a    (cond ((null everyx) (return t))
                  ((funcall everyfn1 (car everyx))
                   (setq everyx
                         (cond ((null everyfn2) (cdr everyx))
                               (t (funcall everyfn2 everyx))))
                   (go a))
                  (t (return nil))))))
(def insert
     (lambda 
      (x l comparefn nodups)
      (cond ((null l) (list x))
            ((atom l)
             (eprint l)
             (error '"is an atom, can't be inserted into"))
            (t (cond
                ((null comparefn) (setq comparefn (function alphalessp))))
               (prog (l1 n n1 y)
                     (setq l1 l)
                     (setq n (length l))
                a    (setq n1 (*quo (add1 n) 2))
                     (setq y (Cnth l1 n1))
                     (cond ((< n 3)
                            (cond ((funcall comparefn x (car y))
                                   (cond
                                    ((not
                                      (and nodups (equal x (car y))))
                                     (rplacd y (cons (car y) (cdr y)))
                                     (rplaca y x))))
                                  ((eq n 1) (rplacd y (cons x (cdr y))))
                                  ((funcall comparefn x (cadr y))
                                   (cond
                                    ((not
                                      (and nodups (equal x (cadr y))))
                                     (rplacd (cdr y)
                                             (cons (cadr y) (cddr y)))
                                     (rplaca (cdr y) x))))
                                  (t (rplacd (cdr y) (cons x (cddr y))))))
                           ((funcall comparefn x (car y))
                            (cond
                             ((not (and nodups (equal x (car y))))
                              (setq n (sub1 n1))
                              (go a))))
                           (t (setq l1 (cdr y)) (setq n (- n n1)) (go a))))
               l))))

(def kwote (lambda (x) (list 'quote x)))

(def lconc
     (lambda 
      (ptr x)
      (prog (xx)
            (return
             (cond ((atom x) ptr)
                   (t (setq xx (last x))
                      (cond ((atom ptr) (cons x xx))
                            ((dtpr (cdr ptr))
                             (rplacd (cdr ptr) x)
                             (rplacd ptr xx))
                            (t (rplaca (rplacd ptr xx) x)))))))))

(def ldiff
     (lambda 
      (x y)
      (cond ((eq x y) nil)
            ((null y) x)
            (t
             (prog (v z)
                   (setq z (setq v (ncons (car x))))
              loop (setq x (cdr x))
                   (cond ((eq x y) (return z))
                         ((null x) (error '"NOT A TAIL - LDIFF")))
                   (setq v (cdr (rplacd v (ncons (car x)))))
                   (go loop))))))


(def lsubst
     (lambda 
      (x y z)
      (cond ((null z) nil)
            ((atom z) (cond ((eq y z) x) (t z)))
            ((equal y (car z)) (nconc (copy x) (lsubst x y (cdr z))))
            (t (cons (lsubst x y (car z)) (lsubst x y (cdr z)))))))

(def memcdr
     (lambda 
      (%x% %y%)
      (prog nil
       l1   (cond ((eq %x% (cdr %y%)) (return t))
                  ((eq %x% %y%) (return nil)))
            (setq %x% (cdr %x%))
            (go l1))))

(def merge
     (lambda 
      (a b %%cfn)
      (cond ((null %%cfn) (setq %%cfn (function alphalessp))))
      (merge1 a b)))

(def merge1
     (lambda 
      (a b)
      (cond ((null a) b)
            ((null b) a)
            (t
             (prog (val end)
                   (setq val
                         (setq end
                               (cond ((funcall %%cfn (car a) (car b))
                                      (prog1 a (setq a (cdr a))))
                                     (t (prog1 b (setq b (cdr b)))))))
              loop (cond ((null a) (rplacd end b) (return val))
                         ((null b) (rplacd end a) (return val))
                         ((funcall %%cfn (car a) (car b))
                          (rplacd end a)
                          (setq a (cdr a)))
                         (t (rplacd end b) (setq b (cdr b))))
                   (setq end (cdr end))
                   (go loop))))))

(def notany
     (lambda (somex somefn1 somefn2) (not (some somex somefn1 somefn2))))

(def notevery
     (lambda 
      (everyx everyfn1 everyfn2)
      (not (every everyx everyfn1 everyfn2))))

(def Cnth
     (lambda 
      (x n)
      (cond ((> 1 n) (cons nil x))
            (t
             (prog nil
              lp   (cond ((or (atom x) (eq n 1)) (return x)))
                   (setq x (cdr x))
                   (setq n (sub1 n))
                   (go lp))))))

(def nthchar
     (lambda 
      (x n)
      (cond ((plusp n) (car (Cnth (explodec x) n)))
            ((minusp n) (car (Cnth (reverse (explodec x)) (minus n))))
            ((zerop n) nil))))

(def prinlev
     (lambda 
      ($%x $%n)
      (cond ((not (dtpr $%x)) (print $%x))
            ((and %trcflg (eq (car $%x) 'evl-trace) (dtpr (cdr $%x)))
             (prinlev (cadr $%x) $%n))
            ((and %trcflg
                  (eq (car $%x) '\#)
                  (dtpr (cdr $%x))
                  (dtpr (cddr $%x)))
             (prinlev (caddr $%x) $%n))
            ((eq %prevfn% $%x) (princ '//\#//))
            ((eq $%n 0) (princ '"& "))
            (t
             (prog ($%kk $%cl)
                   (princ
                    (cond ($%dotflg (setq $%dotflg nil) '"... ")
                          (t '"(")))
                   (prinlev (car $%x) (sub1 $%n))
                   (setq $%kk $%x)
              lp   (cond
                    ((memcdr $%x $%kk)
                     (cond ($%cl (princ '" ...]") (return nil))
                           (t (setq $%cl t)))))
                   (cond ((not (*** eq (cdr $%kk) (unbound)))
                          (setq $%kk (cdr $%kk)))
                         (t (princ '" . unbound)") (return nil)))
                   (cond ((null $%kk) (princ '")") (return nil))
                         ((atom $%kk)
                          (princ '" . ")
                          (patom $%kk)
                          (princ '")")
                          (return nil)))
                   (princ '" ")
                   (prinlev (car $%kk) (sub1 $%n))
                   (go lp))))))

(def printlev (lambda ($%x $%n) (terpri) (prinlev $%x $%n) $%x))



(def remove
     (lambda 
      (elt list)
      (cond ((atom list) list)
            ((equal (car list) elt) (remove elt (cdr list)))
            ((cons (car list) (remove elt (cdr list)))))))

(def some
     (lambda 
      (somex somefn1 somefn2)
      (prog nil
       a    (cond ((null somex) (return nil))
                  ((funcall somefn1 (car somex)) (return somex))
                  (t (setq somex
                           (cond ((null somefn2) (cdr somex))
                                 (t (funcall somefn2 somex))))
                     (go a))))))

; this probably should have another names since is   ****
; just a duplication of an existing function and since it has a
; default second arg which I believe is not documented.
(def sort
     (lambda 
      (%%l %%cfn)
      (prog (val n)
            (cond ((null %%cfn) (setq %%cfn (function alphalessp))))
            (setq n 0)
            (setq val (sort1 0))
       loop (cond ((null %%l) (return val))
                  (t (setq val (merge1 val (sort1 n)))
                     (setq n (add1 n))
                     (go loop))))))

(def sort1
     (lambda 
      (n)
      (cond ((null %%l) nil)
            ((zerop n)
             (prog (run end)
                   (setq run %%l)
              loop (setq end %%l)
                   (setq %%l (cdr %%l))
                   (cond ((or (null %%l)
                              (not (funcall %%cfn (car end) (car %%l))))
                          (rplacd end nil)
                          (return run))
                         (t (go loop)))))
            (t (merge1 (sort1 (sub1 n)) (sort1 (sub1 n)))))))

(def subpair
     (lambda 
      (old new expr)
      (cond (old (subpr expr old (or new '(nil)))) (t expr))))

(def subpr
     (lambda 
      (expr l1 l2)
      (prog (d a)
            (cond ((atom expr) (go lp))
                  ((setq d (cdr expr)) (setq d (subpr d l1 l2))))
            (setq a (subpr (car expr) l1 l2))
            (return
             (cond ((or (neq a (car expr)) (neq d (cdr expr))) (cons a d))
                   (t expr)))
       lp   (cond ((null l1) (return expr))
                  (l2 (cond ((eq expr (car l1)) (return (car l2)))))
                  (t (cond ((eq expr (caar l1)) (return (cdar l1))))))
            (setq l1 (cdr l1))
            (and l2 (setq l2 (or (cdr l2) '(nil))))
            (go lp))))

(def tailp
     (lambda 
      (x y)
      (and x
           (prog nil
            lp   (cond ((atom y) (return nil)) ((eq x y) (return x)))
                 (setq y (cdr y))
                 (go lp)))))

(def tconc
     (lambda 
      (p x)
      (cond ((atom p) (cons (setq x (ncons x)) x))
            ((dtpr (cdr p)) (rplacd p (cdr (rplacd (cdr p) (ncons x)))))
            (t (rplaca p (cdr (rplacd p (ncons x))))))))

(def ttyesno (lambda nil (yesno (read))))

(def yesno (lambda (x) (selectq x ((t y yes) t) ((nil n no) nil) x)))

; this really duplicates a function in auxfns1.l but this does more
; error checking.
(defun nth (N L)
	(cond ((null L)nil)
	      (t(do ((LCDR L (cdr LCDR))
		     (COUNT N (1- COUNT)))
		    ((or (and (atom LCDR) LCDR
   		              (err '"non-proper list passed to nth"))
		         (or (lessp COUNT 0)(zerop COUNT)))
		     (car LCDR))
		    nil))))
(declare (special piport))
(def dc-dskin			; LWE Hacking to compile OK
   (nlambda (args)
	    (prog (tmp tmp1 tmp2)
		  (setq tmp
			(prog (c cc)
			      (setq cc (get (car args) 'comment))
			      loop
			      (cond ((not cc)(return nil)))
			      (setq c (car cc))
			      (cond ((eq (car c)(cadr args))
				     (return nil)))
			      (setq cc (cdr cc))
			      (go loop)))
		  (setq tmp2 piport)
		  (setq tmp1 (get-comment 27 tmp2))
		  (cond (tmp  (disgusting tmp
					  (cons (cadr args)
						(cons (caddr args) tmp1))))
			(t (putprop (car args)
				    (cons (cons (cadr args)
						(cons (caddr args) tmp1))
					  (get (car args) 'comment))
				    'comment)))
		  (mark!changed (car args))
		  (return nil))))

(def disgusting (lambda (a b) ; (rplaca a b)))
b))

(def get-comment
  (lambda (stopper piport)
    (prog (ans line)
          (cond ((eq 10 (tyipeek piport)) (tyi piport)))
     l:   (setq line nil)
;          (until (member (car line) (list 10 stopper))
;                 (setq line (cons (tyi piport) line)))
	   (prog nil loop
		(cond ((member (car line)(list 10 stopper))
		       (return nil)))
	        (setq line (cons (tyi piport) line))
		(go loop))
          (setq ans (cons (implode (dreverse (cdr line))) ans))
          (cond ((eq (car line) 10) (go l:)) (t (return (dreverse ans)))))))
EndOfFile
cat >  lisplib/fix.l  << 'EndOfFile'
(setq rcs-fix-
   "$Header: /usr/lib/lisp/RCS/fix.l,v 1.2 83/08/06 08:39:58 jkf Exp $")

; vi: set lisp :

(eval-when (compile eval)
  (or (get 'cmumacs 'version) (load 'cmumacs)))

; LWE 1/11/81 Hack hack....
;
; LWE 1/11/81 Bet you didn't know this, but this won't work INTERPRETED,
;	      but Dave assures me it works compiled. (In MACLisp...)
; 
(declare (special cmd frame x cnt var init label part incr limit selectq))

(dv fixfns
    ((*** This is FIXIT written by David Touretzky and adapted to Franz by Don
      Cohen)
     (declare (special framelist rframelist interrupt-handlers handler-labels)
              (special prinlevel prinlength evalhook-switch traced-stuff)
              (special lastword piport hush-debug)
              (*fexpr editf step type))
     (sstatus feature fixit)
     (*rset t)
     ER%tpl
     fixit
     debug
     debug-iter
     debug1
     debug-bktrace
     debug-print
     debug-print1
     debug-findcall
     debug-replace-function-name
     debug-scanflist
     debug-scanstk
     debug-getframes
     debug-nextframe
     debug-upframe
     debug-dnframe
     debug-upfn
     debug-dnfn
     debug-showvar
     debug-nedit
     debug-insidep
     debug-findusrfn
     debug-findexpr
     debug-pop
     debug-where
     debug-sysp
     interrupt-handlers
     handler-labels
     (or (boundp 'traced-stuff) (setq traced-stuff nil))
     (or (boundp 'evalhook-switch) (setq evalhook-switch nil))
     (setq hush-debug nil)))

(or (boundp 'traced-stuff) (setq traced-stuff nil))
(or (boundp 'evalhook-switch) (setq evalhook-switch nil))
(or (boundp 'debug-sysmode) (setq debug-sysmode nil))
(setq hush-debug nil)

(*** This is FIXIT written by David Touretzky and adapted to Franz by Don Cohen)

(declare (special framelist rframelist interrupt-handlers handler-labels)
         (special prinlevel prinlength evalhook-switch traced-stuff)
         (special lastword piport hush-debug debug-sysmode)
         (*fexpr editf step type))

(defvar fixit-eval nil)
(defvar fixit-print nil)
(defvar fixit-pp nil)

(sstatus feature fixit)

(*rset t)

; (jkf) it is not clear that you want this to take over on all errors,
; but the cmu people seem to want that.
#+cmu (progn 'compile
	     (dv ER%tpl fixit)
	     (dv ER%all fixit) ; LWE 1/17/81 MAYBE THIS WILL FIX THIS code
	     )

;--- eval, print and pretty-print functions are user-selectable by just
; assigning another value to fixit-eval, fixit-print and fixit-pp.
;
(defmacro fix-eval (&rest args)
   `(cond ((and fixit-eval
		(getd fixit-eval))
	   (funcall fixit-eval ,@args))
	  (t (eval ,@args))))

(defmacro fix-print (&rest args)
   `(cond ((and fixit-print
		(getd fixit-print))
	   (funcall fixit-print ,@args))
	  (t (print ,@args))))

(defmacro fix-pp (&rest args)
   `(cond ((and fixit-pp
		(getd fixit-pp))
	   (funcall fixit-pp ,@args))
	  (t ($prpr ,@args))))

(def fixit
  (nlambda (l)
    (prog (piport)
          (do nil (nil) (eval (cons 'debug l))))))

(def debug
  (nlambda (params)
    (prog (cmd frame framelist rframelist nframe val infile)
          (setq infile t)
          (and evalhook-switch (step nil))
          (setq rframelist
                (reverse
                 (setq framelist
                       (or (debug-getframes)
                           (list
                            (debug-scanstk '(nil) '(debug)))))))
          (setq frame (debug-findexpr (car framelist)))
          ;(tab 0)
          (cond
           ((and (car params) (not (eq (car params) 'edit)))
            (terpri)
            (princ '|;debug: |)
            (princ (cadddr params))
            (cond ((cddddr params)
                   (princ '| -- |)
                   (fix-print (cddddr params))))
            (terpri)
            (go loop)))
          (debug-print1 frame nil)
          (terpri)
          (cond (hush-debug (setq hush-debug nil) (go loop))
                ((not (memq 'edit params)) (go loop)))
          (drain nil)
          (princ '|type e to edit, <cr> to debug: |)
          (setq val (tyi))
          (cond ((or (= val 69) (= val 101))
                 (and (errset (debug-nedit frame))
                      (setq cmd '(ok))
                      (go cmdr)))
                ((or (= val 78) (= val 110)) (terpri) (debug-pop)))
     loop (terpri)
          (princ ':)
          (cond ((null (setq cmd (lineread))) (reset)))
     cmdr (cond
           ((dtpr (car cmd))
            (setq val (fix-eval (car cmd) (cadddr frame)))
            (fix-print val)
            (terpri)
            (go loop)))
          (setq nframe (debug1 cmd frame))
          (and (not (atom nframe)) (setq frame nframe) (go loop))
          (fix-print (or nframe (car cmd)))
          (princ '" Huh? - type h for help")
          (go loop))))

(def debug-iter
  (macro (x)
    (cons 'prog
          (cons 'nil
                (cons 'loop
                      (cons (list 'setq 'nframe (cadr x))
                            '((setq cnt (|1-| cnt))
                              (and (or (null nframe) (zerop cnt))
                                   (return nframe))
                              (setq frame nframe)
                              (go loop))))))))

(def debug1
  (lambda (cmd frame)
    (prog (nframe val topframe cnt item)
          (setq topframe (car framelist))
          (or (eq (typep (car cmd)) 'symbol) (return nil))
          ; if "> name", replace function or variable name with new atom
          (and (eq (car cmd) '>)
               (return (debug-replace-function-name cmd topframe)))
          (and (eq (getchar (car cmd) 1) 'b)
               (eq (getchar (car cmd) 2) 'k)
               (return (debug-bktrace cmd frame)))
          (setq cnt
                (cond ((fixp (cadr cmd)) (cadr cmd))
                      ((fixp (caddr cmd)) (caddr cmd))
                      (t 1)))
          (and (< cnt 1) (setq cnt 1))
          (setq item
                (cond ((symbolp (cadr cmd)) (cadr cmd))
                      ((symbolp (caddr cmd)) (caddr cmd))))
          (and item
               (cond ((memq (car cmd) '(u up))
                      (setq cmd (cons 'ups (cdr cmd))))
                     ((memq (car cmd) '(d dn))
                      (setq cmd (cons 'dns (cdr cmd))))))
          (selectq (car cmd)
                   (top (debug-print1 (setq frame topframe) nil))
                   (bot (debug-print1 (setq frame (car rframelist)) nil))
                   (p (debug-print1 frame nil))
                   (pp (fix-pp (caddr frame)))
                   (where (debug-where frame))
                   (help
                    (cond ((cdr cmd) (eval cmd))
                          (t (ty |/usr/lib/lisp/fixit.ref|))))
                   ((? h) (ty |/usr/lib/lisp/fixit.ref|))
                   ((go ok)
                    (setq frame (debug-findexpr topframe))
                    (cond ((eq (caaddr frame) 'debug)
                           (freturn (cadr frame) t))
                          (t (fretry (cadr frame) frame))))
                   (pop (debug-pop))
                   (step (setq frame (debug-findexpr frame))
                         (step t)
                         (fretry (cadr (debug-dnframe frame)) frame))
                   (redo (and item
                              (setq frame
                                    (debug-findcall item frame framelist)))
                         (and frame (fretry (cadr frame) frame)))
                   (return (setq val (eval (cadr cmd)))
                           (freturn (cadr frame) val))
                   (edit (debug-nedit frame))
                   (editf
                    (cond ((null item)
                           (setq frame
                                 (or (debug-findusrfn (debug-nedit frame))
                                     (car rframelist))))
                          ((dtpr (getd item))
                           (errset (funcall 'editf (list item))))
                          (t (setq frame nil))))
                   (u (debug-iter (debug-upframe frame))
                      (cond
                       ((null nframe) (terpri) (princ '|<top of stack>|)))
                      (debug-print1 (setq frame (or nframe frame)) nil))
                   (d (setq nframe
                            (or (debug-iter (debug-dnframe frame)) frame))
                      (debug-print1 nframe nil)
                      (cond ((eq frame nframe)
                             (terpri)
                             (princ '|<bottom of stack>|))
                            (t (setq frame nframe))))
                   (up (setq nframe (debug-iter (debug-upfn frame)))
                       (cond
                        ((null nframe) (terpri) (princ '|top of stack|)))
                       (setq frame (or nframe topframe))
                       (debug-print1 frame nil))
                   (dn (setq frame
                             (or (debug-iter (debug-dnfn frame))
                                 (car rframelist)))
                       (debug-print1 frame nil)
                       (cond
                        ((not (eq frame nframe))
                         (terpri)
                         (princ '|<bottom of stack>|))))
                   (ups (setq frame
                              (debug-iter
                               (debug-findcall item frame rframelist)))
                        (and frame (debug-print1 frame nil)))
                   (dns (setq frame
                              (debug-iter
                               (debug-findcall item frame framelist)))
                        (and frame (debug-print1 frame nil)))
		   (sys (setq debug-sysmode (not debug-sysmode))
			(patom "sysmode now ")(patom debug-sysmode) (terpr))
                   (cond ((not (dtpr (car cmd)))
                          (*** should there also be a boundp test here)
                          (debug-showvar (car cmd) frame))
                         (t (setq frame (car cmd)))))
          (return (or frame item)))))

(def debug-replace-function-name 
  (lambda (cmd frame)
    (prog (oldname newname errorcall nframe)
	  (setq errorcall (caddr frame))
	  (cond ((eq (caddddr errorcall) '|eval: Undefined function |)
		 (setq oldname (cadddddr errorcall))
		 (setq newname (cadr cmd))
		 (setq cnt 3.)
		 (setq frame (debug-iter (debug-dnframe frame)))
		 (dsubst newname oldname frame)
		 (fretry (cadr frame) frame))
		((eq (caddddr errorcall) '|Unbound Variable:|)
		 (setq oldname (cadddddr errorcall))
		 (setq newname (eval (cadr cmd)))
		 (setq cnt 3.)
		 (setq frame (debug-iter (debug-dnframe frame)))
		 (dsubst newname oldname frame)
		 (fretry (cadr frame) frame))
		( t (return nil))))))

(def debug-bktrace
  (lambda (cmd oframe)
    (prog (sel cnt item frame nframe)
          (mapc '(lambda (x)
                         (setq sel
                               (cons (selectq x
                                              (f 'fns)
                                              (a 'sysp)
                                              (v 'bind)
                                              (e 'expr)
                                              (c 'current)
                                              'bogus)
                                     sel)))
                (cddr (explodec (car cmd))))
          (setq item
                (cond ((eq (typep (cadr cmd)) 'symbol) (cadr cmd))
                      ((eq (typep (caddr cmd)) 'symbol) (caddr cmd))))
          (cond ((debug-sysp item) (setq sel (cons 'sysp sel)))
                ((not (memq 'sysp sel))
                 (setq sel (cons 'user sel))))
          (setq cnt
                (cond ((fixp (cadr cmd)) (cadr cmd))
                      ((fixp (caddr cmd)) (caddr cmd))
                      (item 1)))
          (cond ((null cnt)
                 (setq frame
                       (cond ((memq 'current sel) oframe)
                             (t (car rframelist))))
                 (go dbpr))
                ((null item)
                 (setq frame (car framelist))
                 (and (or (not (memq 'user sel))
                          (atom (caddr (car framelist)))
                          (not (debug-sysp (caaddr (car framelist)))))
                      (setq cnt (|1-| cnt)))
                 (setq frame
                       (cond ((zerop cnt) frame)
                             ((memq 'user sel)
                              (debug-iter (debug-dnfn frame)))
                             (t (debug-iter (debug-dnframe frame)))))
                 (setq frame (or frame (car rframelist)))
                 (go dbpr))
                (t (setq frame (car framelist))))
          (setq frame
                (cond ((and (= cnt 1)
                            (not (atom (caddr (car framelist))))
                            (eq item (caaddr (car framelist))))
                       (car framelist))
                      ((debug-iter (debug-findcall item frame framelist)))
                      (t (car rframelist))))
     dbpr (debug-print frame sel oframe)
          (cond ((eq frame (car rframelist))
                 (terpri)
                 (princ '|<bottom of stack>|)
                 (terpri))
                (t (terpri)))
          (cond
           ((memq 'bogus sel)
            (terpri)
            (princ (car cmd))
            (princ '| contains an invalid bk modifier|)))
          (return oframe))))

(def debug-print
  (lambda (frame sel ptr)
    (prog (curframe)
          (setq curframe (car framelist))
     loop (cond ((not
                  (and (memq 'user sel)
                       (not (atom (caddr curframe)))
                       (debug-sysp (caaddr curframe))))
                 (debug-print1 curframe sel)
                 (and (eq curframe ptr) (princ '|   <--- you are here|)))
                ((eq curframe ptr)
                 (terpri)
                 (princ '|  <--- you are somewhere in here|)))
          (and (eq curframe frame) (return frame))
          (setq curframe (debug-dnframe curframe))
          (or curframe (return frame))
          (go loop))))

(def debug-print1
  (lambda (frame sel)
    (prog (prinlevel prinlength varlist)
          (and (not (memq 'expr sel))
               (setq prinlevel 2)
               (setq prinlength 5))
          (cond
           ((atom (caddr frame))
            (terpri)
            (princ '|   |)
            (fix-print (caddr frame))
            (princ '| <- eval error|)
            (return t)))
          (and (memq 'bind sel)
               (cond ((memq (caaddr frame) '(prog lambda))
                      (setq varlist (cadr (caddr frame))))
                     ((and (atom (caaddr frame)) (dtpr (getd (caaddr frame))))
                      (setq varlist (cadr (getd (caaddr frame))))))
               (mapc (function
                      (lambda (v)
                              (debug-showvar v
                                             (or (debug-upframe frame)
                                                 frame))))
                     (cond ((and varlist (atom varlist)) (ncons varlist))
                           (t varlist))))
          (and (memq 'user sel)
               (debug-sysp (caaddr frame))
               (return nil))
          (cond ((memq (caaddr frame) interrupt-handlers)
                 (terpri)
                 (princ '<------------)
                 (fix-print (cadr (assq (caaddr frame) handler-labels)))
                 (princ '-->))
                ((eq (caaddr frame) 'debug)
                 (terpri)
                 (princ '<------debug------>))
                ((memq 'fns sel)
                 (terpri)
                 (and (debug-sysp (caaddr frame)) (princ '|  |))
                 (fix-print (caaddr frame)))
                (t (terpri)
                   (fix-print
                    (cond ((eq (car frame) 'eval) (caddr frame))
                          (t (cons (caaddr frame) (cadr (caddr frame))))))))
          (or (not (symbolp (caaddr frame)))
              (eq (caaddr frame) (concat (caaddr frame)))
              (princ '|  <not interned>|))
          (return t))))

(def debug-findcall
  (lambda (fn frame flist)
    (prog nil
     loop (setq frame (debug-nextframe frame flist nil))
          (or frame (return nil))
          (cond ((atom (caddr frame))
                 (cond ((eq (caddr frame) fn) (return frame)) (t (go loop))))
                ((eq (caaddr frame) fn) (return frame))
                (t (go loop))))))

(def debug-scanflist
  (lambda (frame fnset)
    (prog nil
     loop (or frame (return nil))
          (and (not (atom (caddr frame)))
               (memq (caaddr frame) fnset)
               (return frame))
          (setq frame (debug-dnframe frame))
          (go loop))))

(def debug-scanstk
  (lambda (frame fnset)
    (prog nil
     loop (or frame (return nil))
          (and (not (atom (caddr frame)))
               (memq (caaddr frame) fnset)
               (return frame))
          (setq frame (evalframe (cadr frame)))
          (go loop))))

(def debug-getframes
  (lambda nil
    (prog (flist fnew)
          (setq fnew
                (debug-scanstk '(nil)
                               (cons 'debug interrupt-handlers)))
     loop (and (not debug-sysmode)
	       (not (atom (caddr fnew)))
               (eq (caaddr fnew) 'debug)
               (eq (car (evalframe (cadr fnew))) 'apply)
               (memq (caaddr (evalframe (cadr fnew))) interrupt-handlers)
               (setq fnew (evalframe (cadr fnew))))
          (and (not debug-sysmode)
	       (null flist)
               (eq (car fnew) 'apply)
               (memq (caaddr fnew) interrupt-handlers)
               (setq fnew (evalframe (cadr fnew))))
          (and (not debug-sysmode)
	       (eq (car fnew) 'apply)
               (eq (typep (caaddr fnew)) 'symbol)
               (not (eq (caaddr fnew) (concat (caaddr fnew))))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and (not debug-sysmode)
	       (not (atom (caddr fnew)))
               (memq (caaddr fnew) '(evalhook* evalhook))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and (not debug-sysmode)
	       (eq (car fnew) 'apply)
               (eq (caaddr fnew) 'eval)
               (cadadr (caddr fnew))
               (or (not (fixp (cadadr (caddr fnew))))
                   (= (cadadr (caddr fnew)) -1))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (and fnew
               (setq flist (cons fnew flist))
               (setq fnew (evalframe (cadr fnew)))
               (go loop))
          (return (nreverse flist)))))

(def debug-nextframe
  (lambda (frame flist sel)
    (prog nil
          (setq flist (cdr (memq frame flist)))
          (and (not (memq 'user sel)) (return (car flist)))
     loop (or flist (return nil))
          (cond
           ((or (atom (caddr (car flist)))
                (not (debug-sysp (caaddr (car flist)))))
            (return (car flist))))
          (setq flist (cdr flist))
          (go loop))))

(def debug-upframe
  (lambda (frame)
    (debug-nextframe frame rframelist nil)))

(def debug-dnframe
  (lambda (frame)
    (debug-nextframe frame framelist nil)))

(def debug-upfn
  (lambda (frame)
    (debug-nextframe frame rframelist '(user))))

(def debug-dnfn
  (lambda (frame)
    (debug-nextframe frame framelist '(user))))

(def debug-showvar
  (lambda (var frame)
    (terpri)
    (princ '|   |)
    (princ var)
    (princ '| = |)
    (fix-print
     ((lambda (val) (cond ((atom val) '?) (t (car val))))
      (errset (fix-eval var (cadddr frame)) nil)))))

(def debug-nedit
  (lambda (frame)
    (prog (val body elem nframe)
          (setq elem (caddr frame))
          (setq val frame)
     scan (setq val (debug-findusrfn val))
          (or val (go nofn))
          (setq body (getd (caaddr val)))
          (cond ((debug-insidep elem body)
                 (princ '=)
                 (fix-print (caaddr val))
                 (edite body
                        (list 'f (cons '== elem) 'tty:)
                        (caaddr val))
                 (return frame))
                ((or (eq elem (caddr val)) (debug-insidep elem (caddr val)))
                 (setq val (debug-dnframe val))
                 (go scan)))
     nofn (setq nframe (debug-dnframe frame))
          (or nframe (go doit))
          (and (debug-insidep elem (caddr nframe))
               (setq frame nframe)
               (go nofn))
     doit (edite (caddr frame)
                 (and (debug-insidep elem (caddr frame))
                      (list 'f (cons '== elem) 'tty:))
                 nil)
          (return frame))))

(def debug-insidep
  (lambda (elem expr)
    (car (errset (edite expr (list 'f (cons '== elem)) nil)))))

(def debug-findusrfn
  (lambda (frame)
    (cond ((null frame) nil)
          ((and (dtpr (caddr frame))
                (symbolp (caaddr frame))
                (dtpr (getd (caaddr frame))))
           frame)
          (t (debug-findusrfn (debug-dnframe frame))))))

(def debug-findexpr
  (lambda (frame)
    (cond ((null frame) nil)
          ((and (eq (car frame) 'eval) (not (atom (caddr frame))))
           frame)
          (t (debug-findexpr (debug-dnframe frame))))))

(def debug-pop
  (lambda nil
    (prog (frame)
	  (setq frame (car framelist))
     l    (cond ((null (setq frame (evalframe (cadr frame))))(reset)))
	  (cond ((and (dtpr (caddr frame))(eq (caaddr frame) 'debug))
		 (freturn (cadr frame) nil)))
	  (go l))))

(def debug-where
  (lambda (frame)
    (prog (lev diff nframe)
          (setq lev (- (length framelist) (length (memq frame rframelist))))
          (setq diff (- (length framelist) lev 1))
          (debug-print1 frame nil)
          (terpri)
          (cond ((zerop diff) (princ '|you are at top of stack.|))
                ((zerop lev) (princ '|you are at bottom of stack.|))
                (t (princ '|you are |)
                   (princ diff)
                   (cond ((= diff 1) (princ '| frame from the top.|))
                         (t (princ '| frames from the top.|)))))
          (terpri)
          (and (or (atom (caddr frame)) (not (eq (car frame) 'eval)))
               (return nil))
          (setq lev 0)
          (setq nframe frame)
     lp   (and (setq nframe (debug-findcall (caaddr nframe) nframe framelist))
               (setq lev (|1+| lev))
               (go lp))
          (princ '|there are |)
          (princ lev)
          (princ '| |)
          (princ (caaddr frame))
          (princ '|'s below.|)
          (terpri))))

(def debug-sysp
  (lambda (x)
    (and (sysp x) (symbolp x) (not (dtpr (getd x))))))

(dv interrupt-handlers (fixit))

(dv handler-labels
    ((fixit error)
     (debug-ubv-handler ubv)
     (debug-udf-handler udf)
     (debug-fac-handler fac)
     (debug-ugt-handler ugt)
     (debug-wta-handler wta)
     (debug-wna-handler wna)
     (debug-iol-handler iol)
     (debug-*rset-handler rst)
     (debug-mer-handler mer)
     (debug-gcd-handler gcd)
     (debug-gcl-handler gcl)
     (debug-gco-handler gco)
     (debug-pdl-handler pdl)))


(or (boundp 'traced-stuff) (setq traced-stuff nil))

(or (boundp 'evalhook-switch) (setq evalhook-switch nil))

(setq hush-debug nil)


;; other functions grabbed from other cmu files to make this file complete
;; unto itself

;- from sysfunc.l
(declare (special system-functions\))
(defun build-sysp nil
  (do ((temp (oblist) (cdr temp))
       (sysfuncs))
      ((null temp)(setq system-functions\ sysfuncs));atom has ^G at end
      (cond ((getd (car temp))
	     (setq sysfuncs (cons (car temp) sysfuncs))))))

(defun sysp (x) ; (cond ((memq x system-functions\)t))
	(memq x '(funcallhook* funcallhook evalhook evalhook* 
			       continue-evaluation)))

(or (boundp 'system-functions\) (build-sysp))

(defun fretry (pdlpnt frame)
  (freturn pdlpnt
	   (cond ((eq (car frame) 'eval) (eval (caddr frame) (cadddr frame)))
		 ((eq (car frame) 'apply)
		  (eval `(apply ',(caaddr frame) ',(cadaddr frame)) 
			(cadddr frame))))))


; - from cmu.l

(def %lineread
  (lambda (chan)
	  (prog (ans)
	   loop (setq ans (cons (read chan 'EOF) ans))
		(cond ((eq (car ans) 'EOF) (return (reverse (cdr ans)))))
	   loop2(cond ((eq 10 (tyipeek chan)) (return (reverse ans)))
		      ((memq (tyipeek chan) '(41 93))
		       (tyi chan)
		       (go loop2))
		      (t (go loop))))))
EndOfFile
cat >  lisplib/step.l  << 'EndOfFile'
(setq rcs-step-
   "$Header: /usr/lib/lisp/step.l,v 1.1 83/01/29 18:39:46 jkf Exp $")

; vi: set lisp :

;;;                     LISP Stepping Package
;;;
;;; Adapted by Mitch Marcus for Franz Lisp from Chuck Rich's MACLISP
;;; package.
;;;
;;;
;;; Adapted 2/80 from the Maclisp version of 11/03/76
;;; Further modified 5/80 by Don Cohen (DNC)
;;;
;;; modified by jkf 6/81 to handle funcallhook.
;;;
;;; User Interface Function
;;;
;;;             Valid Forms:                            
;;; (step) or (step nil)	:: turn off stepping
;;; (step t) 			:: turn on stepping right away.
;;; (step e)			:: turn on stepping of eval only
;;; (step foo1 foo2 ...)  	:: turn on stepping when one of fooi is
;;;				:: called
;;;
;------ implementation:
; evalhook* is nil meaning no stepping, or t meaning always step
;    or is a list of forms which will start continuous stepping.
;
; The hook functions are evalhook* and funcallhook*.
;

(declare (special 
	  evalhook-switch piport 	
	  hookautolfcount funcallhook
	  evalhook evalhook* |evalhook#| prinlevel prinlength
  	  fcn-evalhook fcn-funcallhook
	  Standard-Input)
         (macros nil))

;; First Some Macros

(defun 7bit macro (s)
       ;; (7BIT n c) tests if n is ascii for c
       (list '= (list 'boole 1 127. (cadr s)) (caddr s)))

;--- print* 
; indent based on current evalhook recursion level then print the
; arg in form
;
(defun print* macro (s)
          ;; print with indentation
         '(do ((i 1 (1+ i))
               (indent (* 2 |evalhook#|))
               (prinlevel 3)
               (prinlength 5))
              ((> i indent) 
	       (cond ((eq type 'funcall) (patom "f:")))
	       (print form))
              (tyo 32.)))

(defun step fexpr (arg)
  (cond ((or (null arg) (car arg))
	 (setq evalhook-switch t) ; for fixit package
	 (setq |evalhook#| 0.)                  ;initialize depth count
	  (setq hookautolfcount 0)		; count if auto lfs at break
	 (setq evalhook nil)                  ;for safety
	 (setq funcallhook nil)
	 ; (step e) means just step eval things, else step eval and funcal
	 (cond ((eq (car arg) 'e) 
		(setq fcn-evalhook 'evalhook* fcn-funcallhook nil))
	       (t (setq fcn-evalhook 'evalhook* fcn-funcallhook 'funcallhook*)))
	 (setq evalhook*
	       (cond ((null arg) nil)
		     ((or (eq (car arg) t) (eq (car arg) 'e)))
		     (arg)))
	 (setq evalhook fcn-evalhook)      ;turn system hook to my function
	 (setq funcallhook fcn-funcallhook)
	 (sstatus translink nil)
	 (*rset t)                            ;must be on for hook to work
	 (sstatus evalhook t))           ;arm it
	(t (setq evalhook* nil)
	   (setq evalhook nil)
	   (setq hookautolfcount 0)		; count if auto lfs at break
	   (setq evalhook-switch nil)
	   (sstatus evalhook nil))))


;---- funcall-evalhook*
;
; common function to handle evalhook's and funcallhook's.
; the form to be evaluated is given as form and the type (eval or funcall)
; is given as type.
;

(defun funcall-evalhook* (form type)
  (cond (evalhook*
	 ;; see if selective feature kicks in here
	 (and (not (atom form))
	      (not (eq evalhook* t))
	      (memq (car form) evalhook*)
	      (setq evalhook* t))	; yes, begin stepping always

	 (cond ((eq evalhook* t)
		;; print out form before evaluation
		(print*)

		(cond ((atom form)
		       ;; since form is atom, we just eval it and print
		       ;; out its value, no need to ask user what to do
		       (cond ((not (or (numberp form)(null form)(eq form t)))
			      (princ '" = ")
			      ((lambda (prinlevel prinlength)
				       (setq form (evalhook form nil nil))
				       (print form))	
			       3 5)))
		       (terpri))
		      (t ; s-expression
			 (prog (cmd ehookfn fhookfcn)

			   cmdlp  (cond ((greaterp hookautolfcount 0)
					 (setq hookautolfcount (sub1 hookautolfcount))
					 (terpr)
					 (setq cmd #\lf))
					(t (setq cmd (let ((piport 
							    Standard-Input))
							  (drain piport)
							  (tyi piport)))))

			       ;; uppercase alphabetics
			       ;; dispatch on command character
			       (cond ((eq cmd #\lf)    
				      ; \n so continue
				      (setq ehookfn fcn-evalhook
					    fhookfcn fcn-funcallhook))

				     ((memq cmd '(#/p #/P))
				      ; "P" print in full
				      (print form)
				      (go cmdlp))

				     ; "G"
				     ((memq cmd '(#/g #/G))
				      (setq evalhook* nil  ;stop everything
					    ehookfn nil
					    fhookfcn nil))

				     ((memq cmd '(#/c #/C))
				      ;"C" no deeper
				      (setq ehookfn nil
					    fhookfcn nil))

				     ((memq cmd '(#/d #/D))
				      ;"D" call debug
				      (setq evalhook-switch nil)
				      (sstatus evalhook nil)
				      (debug)
				      (setq evalhook-switch t)
				      (sstatus evalhook t)
				      (go cmdlp))


				     ((memq cmd '(#/b #/B))
				      ; "B" give breakpoint
				      (break step)
				      (print*)
				      (go cmdlp))

				     ((memq cmd '(#/q #/Q))
				      ; "Q" stop stepping
				      (step nil)
				      (reset))

				     ((memq cmd '(#/n #/N))
				      (setq hookautolfcount 
					    (let ((piport Standard-Input))
						 (read)))
				      (cond ((not (numberp hookautolfcount))
					     (patom "arg to n should be number")
					     (terpr)
					     (setq hookautolfcount 0))))

				     ; "s" eval form
				     ((memq cmd '(#/s #/S))
				      (let ((piport Standard-Input)
					    (fcns nil))
					   (setq fcns (read))
					   (cond ((dtpr fcns) 
						  (setq evalhook* fcns))
						 ((symbolp fcns)
						  (setq evalhook* (list fcns))))))

				     ; "e" step eval only
				     ((memq cmd '(#/e #/E))
				      (setq fcn-funcallhook nil))

				     ; "?", "H" show the options
				     ((memq cmd '(72 104 63.))
				      #+cmu (ty /usr/lisp/doc/step\.ref)
				      #-cmu(stephelpform)
				      (terpri)
				      (go cmdlp))
				     ((eq cmd #\eof)
				      (patom "EOF typed")
				      (terpr))

				     (t (princ '"Try one of ?BCDGMPQ or <cr>")
					(go cmdlp)))

			       ;; evaluate form
			       (clear-input-buffer)
			       ((lambda (|evalhook#|)
					(setq form (continue-evaluation 
						    form 
						    type 
						    ehookfn 
						    fhookfcn)))
				(1+ |evalhook#|))

			       ;; print out evaluated form
			       (cond ((and evalhook* 
					   (or (eq type 'funcall)
					       (not (zerop |evalhook#|))))
				      (let ((type nil))
					   (print*))
				      (terpri)
				      )))))
		;;return evaluated form
		form)
	       (t ;  why was this here? (clear-input-buffer)
		  (continue-evaluation form type fcn-evalhook fcn-funcallhook))))   
	(t ;  why was this here? (clear-input-buffer)
	   (continue-evaluation form type fcn-evalhook fcn-funcallhook))))

;--- stephelpform 
;
; print a summary of the functions of step
;
(defun stephelpform nil
  (patom "<cr> - single step;  n <number> - step <number> times")(terpr)
  (patom "b - break;  q - quit stepping;  d - call debug;") (terpri)
  (patom "c - turn off step for deeper levels; e - stop at eval forms only")
  (terpri)
  (patom "h,? - print this") (terpr))

;--- funcallhook* 
;
; automatically called when a funcall is done and funcallhook*'s 
; value is the name of this function (funcallhook*).  When this is
; called, a function with n-1 args is being funcalled, the args
; to the function are (arg 1) through (arg (sub1 n)), the name of
; the function is (arg n)
;
(defun funcallhook* n
  (let ((name (arg n))
	(args (listify (sub1 n))))
       (funcall-evalhook* (cons name args) 'funcall)))

;--- evalhook* 
;
; called whenever an eval is done and evalhook*'s value is the 
; name of this function (evalhook*).  arg is the thing being
; evaluated.
;
(defun evalhook* (arg)
  (funcall-evalhook* arg 'eval))

(defun continue-evaluation (form type evalhookfcn funcallhookfcn)
  (cond ((eq type 'eval) (evalhook form evalhookfcn funcallhookfcn))
	(t (funcallhook form funcallhookfcn evalhookfcn))))


(or (boundp 'prinlength) (setq prinlength nil))

(or (boundp 'prinlevel) (setq prinlevel nil))

; Standard-Input is a variable bound to the initial stdin port. It is 
; bound in the auxfns0 package, but older lisps may not have that new
; package, so in case they don't we approximate Standard-Input with nil
; which works in many cases, but drain's do not work.
(or (boundp 'Standard-Input) (setq Standard-Input nil))
(defun clear-input-buffer nil (drain Standard-Input))
EndOfFile
cat >  lisplib/cmufile.l  << 'EndOfFile'
;;; cmu file package.
;;;
(setq rcs-cmufile-
   "$Header: /usr/lib/lisp/cmufile.l,v 1.1 83/01/29 18:34:10 jkf Exp $")

(eval-when (compile eval)
   (load 'cmumacs)
   (load 'cmufncs)
   )

(declare (special $cur$ dc-switch piport %indent dc-switch
		  vars body form var init label part incr limit
		  getdeftable $outport$ tlmacros f tmp))

(declare (nlambda msg))

(declare
 (special %changes
          def-comment
          filelst
          found
          getdefchan
          getdefprops
          history
          historylength
          args
          i
          l
          lasthelp
          prop
          special
          special
          tlbuffer
          z))

(dv dc-switch dc-define)

(dv %indent 0)

(dv *digits ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))

(dv *letters (a b c d e f g h i j k l m n o p q r s t u v w x y z))

(def changes
  (lambda nil
    (changes1)
    (for-each f
              filelst
              (cond
               ((get f 'changes)
                (terpri)
                (princ f)
                (tab 15)
                (princ (get f 'changes)))))
    (cond
     (%changes (terpri) (princ '<no-file>) (tab 15) (princ %changes)))
    nil))

(def changes1
  (lambda nil
    (cond ((null %changes) nil)
          (t
           (prog (found prop)
                 (for-each f
                           filelst
                           (setq found
                                 (cons (set-of fn
                                               (cons (concat f 'fns)
                                                     (eval
                                                      (concat f
                                                              'fns)))
                                               (memq fn %changes))
                                       found))
                           (setq prop (get f 'changes))
                           (for-each fn
                                     (car found)
                                     (setq prop (insert fn prop nil t)))
                           (putprop f prop 'changes))
                 (setq found (apply 'append found))
                 (setq %changes (set-of fn %changes (not (memq fn found)))))))))

(def dc
  (nlambda (args)
    (eval (cons dc-switch args]

(def dc-define
  (nlambda (args)
    (msg "Enter comment followed by <esc>" (N 1))
    (drain piport)
    (eval (cons 'dc-dskin args]

(def dc-help
  (nlambda (args)
    (cond
     ((eval (cons 'helpfilter (cons (car args) (caddr args))))
      (transprint getdefchan)))))

(def dskin
  (nlambda (files)
    (mapc (function
           (lambda (f)
                   (prog nil
                         (setq dc-switch 'dc-dskin)
                         (file f)
                         (load f)
                         (changes1)
                         (putprop f nil 'changes)
			 (setq dc-switch 'dc-define)
)))
          files]

(***
The new version of dskout (7/26/80) tries to keep backup versions  It returns
the setof its arguments that were successfully written  If it can not write
a file (typically because of protection restrictions) it offers to (try to)
write a copy to /tmp  A file written to /tmp is not considered to have been
successfully written (and changes will not consider it to be up-to-date) )

(def dskout
  (nlambda (files)
    (changes1)
    (set-of f
            files
            (prog (ffns p tmp)
                  (cond ((atom (errset (setq p (infile f)) nil))
                         (msg "creating " f N D))
                        (t (close p)
                           (cond ((zerop
                                   (eval
                                    (list 'exec
                                          'mv
                                          f
                                          (setq tmp
                                                (concat f '|.back|)))))
                                  (msg  "old version moved to " 
					tmp N D))
                                 (t (msg 
                                         "Unable to back up "
                                         f
                                         " - continue? (y/n) " D)
                                    (cond ((not (ttyesno)) (return nil)))))))
                  (cond
                   ((atom
                     (errset (apply (function pp)
                                    (cons (list 'F f)
                                          (cons (setq ffns
                                                      (concat f
                                                              'fns))
                                                (eval ffns))))
                             nil))
                    (msg
                         "Unable to write "
                         f
                         " - try to put it on /tmp? (y/n) " D)
                    (cond
                     ((ttyesno)
                      (setq f (explode f))
                      (while (memq '/ f)
                             (setq f (cdr (memq '/ f))))
                      (setq f
                            (apply (function concat)
                                   (cons '/tmp/ f)))
                      (cond ((atom
                              (errset
                               (apply (function pp)
                                      (cons (list 'F f)
                                            (cons ffns (eval ffns))))))
                             (msg
                                  "Unable to create "
                                 f
                                  " - I give up! " N D  ))
                            (t (msg f " written " N D  )))))
                    (return nil)))
                  (putprop f nil 'changes)
                  (return t)))))

(def dskouts
  (lambda nil
    (changes1)
    (apply (function dskout) (set-of f filelst (get f 'changes)))))

(def evl-trace
  (nlambda (exp)
    (prog (val)
          (tab %indent)
          (prinlev (car exp) 2)
          ((lambda (%indent) (setq val (eval (car exp)))) (+ 2 %indent))
          (tab %indent)
          (prinlev val 2)
          (return val))))


(def file
  (lambda (name)
    (setq filelst (insert name filelst nil t))
    (cond
     ((not (boundp (concat name 'fns)))
      (set (concat name 'fns) nil)))
    name))

(def getdef
  (nlambda (%%l)
    (prog (x u getdefchan found)
          (setq getdefchan (infile (car %%l)))
     l    (cond ((atom
                  (setq u
                        (errset
                         (prog (x y z)
                               (cond
                                ((eq (tyipeek getdefchan) -1)
                                 (err 'EOF)))
                               (cond
                                ((memq (tyipeek getdefchan)
                                       '(12 13))
                                 (tyi getdefchan)))
                               (return
                                (cond
                                 ((memq (tyipeek getdefchan)
                                        '(40 91))
                                  (tyi getdefchan)
                                  (cond
                                   ((and (symbolp
                                          (setq y (ratom getdefchan)))
                                         (cond (t (comment - what about
                                                   intern?)
                                                  (setq x y)
                                                  t)
                                               ((neq y
                                                     (setq x
                                                           (intern y)))
                                                t)
                                               (t (remob1 x) nil))
                                         (assoc x getdeftable)
                                         (or (setq z (ratom getdefchan))
                                             t)
                                         (some (cdr %%l)
                                               (function
                                                (lambda (x)
                                                        (matchq x z)))
                                               nil)
                                         (cond ((symbolp z)
                                                (setq y z)
                                                t)
                                               (t (setq y z) t))
                                         (cond ((memq y found))
                                               ((setq found
                                                      (cons y found))))
                                         (not
                                          (cond
                                           ((memq (tyipeek
                                                   getdefchan)
                                                  '(40 91))
                                            (print x)
                                            (terpri)
                                            (princ y)
                                            (tyo 32)
                                            (princ
                                             '" -- bad format")
                                            t))))
                                    (cons x
                                          (cons y
                                                (cond ((memq (tyipeek
                                                              getdefchan)
                                                             '(41
                                                               93))
                                                       (tyi
                                                        getdefchan)
                                                       nil)
                                                      (t (untyi 40
                                                                getdefchan)
                                                         (read
                                                          getdefchan))))))))))))))
                 (close getdefchan)
                 (return found))
                (t (setq x (car u))
                   (*** free u)
                   (setq u nil)
                   (cond
                    ((not (atom x))
                     (apply (cdr (assoc (car x) getdeftable)) (ncons x))))))
          (cond ((not (eq (tyi getdefchan) 10)) (zap getdefchan)))
          (go l))))

(def getdefact
  (lambda (i p exp)
    (prog nil
          (cond ((or (null getdefprops) (memq p getdefprops))
                 (terpri)
                 (print (eval exp))
                 (princ '" ")
                 (prin1 p))
                (t (terpri)
                   (print i)
                   (princ '" ")
                   (prin1 p)
                   (princ '" ")
                   (princ 'bypassed))))))

(dv getdefprops (function value expr fexpr macro))

(dv getdeftable
    ((defprop lambda (x) (getdefact (cadr x) (cadddr x) x))
     (dc lambda
         (x)
         (cond
          ((or (null getdefprops) (memq 'comment getdefprops))
           (eval x))))
     (de lambda (x) (getdefact (cadr x) 'expr x))
     (df lambda (x) (getdefact (cadr x) 'fexpr x))
     (dm lambda (x) (getdefact (cadr x) 'macro x))
     (setq lambda (x) (getdefact (cadr x) 'value x))
     (dv lambda (x) (getdefact (cadr x) 'value x))
     (def lambda (x) (getdefact (cadr x) 'function x))))

(setq filelst nil)	;; initial values
(setq %changes nil)
EndOfFile
cat >  lisplib/cmutpl.l  << 'EndOfFile'
;;; cmu top level.
;;; Eventually this file will be able to be read in along with
;;; the standard franz top level and thus allow the user to select
;;; (possible via the .lisprc) the top level he wants.
;;;
(setq rcs-cmutpl-
   "$Header: /usr/lib/lisp/cmutpl.l,v 1.1 83/01/29 18:34:38 jkf Exp $")

(eval-when (compile eval)
   (or (get 'cmumacs 'version) (load 'cmumacs))
   (or (get 'cmufncs 'version) (load 'cmufncs)))

(declare (special history tlbuffer tlmacros historylength))

(dv historylength 25)

(def matchq
  (lambda (x y)
    (prog (xx yy)
          (return
           (cond
            ((and (atom x) (atom y))
             (cond ((matchq1 (setq xx (explode x)) (setq yy (explode y)))
                    (*** freelist xx)
                    (*** freelist yy)
                    t)
                   (t (*** freelist xx) (*** freelist yy)))))))))

(def matchq1
  (lambda (x y)
    (prog nil
     l1   (cond ((eq x y) (return t))
                ((or (equal y '(@)) (equal x '(@))) (return t))
                ((or (null x) (null y)) (return nil))
                ((eq (car x) (car y))
                 (setq x (cdr x))
                 (setq y (cdr y))
                 (go l1))
                (t (return nil))))))

(def showevents
  (lambda (evs)
    (for-each ev
              evs
              (terpri)
              (princ (car ev))
              (princ '".")
              (tlprint (cadr ev))
              (cond ((cddr ev) (terpri) (tlprint (caddr ev)))))))

(def tleval
  (lambda (exp)
    (prog (val)
          (setq val (eval exp))
          (rplacd (cdar history) (ncons val))
          (return val))))

(def tlgetevent
  (lambda (x)
    (cond ((null x) (car history))
          ((and (fixp x) (plusp x)) (assoc x history))
          ((and (fixp x) (minusp x)) (car (Cnth history (minus x)))))))

(dv tlmacros
    ((ed lambda
         (x)
         (prog (exp)
               (cond ((setq exp (copy (cadr (tlgetevent (cadr x)))))
                      (edite exp nil nil)
                      (return (ncons exp)))
                     (t (princ '"No such event")))))
     (redo lambda
           (x)
           (prog (exp)
                 (cond ((setq exp (tlgetevent (cadr x)))
                        (return (ncons (cadr exp))))
                       (t (princ '"No such event")))))
     (?? lambda
         (x)
         (prog (e1 e2 rest)
               (cond ((null (cdr x)) (showevents (reverse history)))
                     ((null (setq e1 (tlgetevent (cadr x))))
                      (princ '"No such event as ")
                      (princ (cadr x)))
                     ((null (cddr x)) (showevents (ncons e1)))
                     ((null (setq e2 (tlgetevent (caddr x))))
                      (princ '"No such event as ")
                      (princ (caddr x)))
                     (t (setq e1 (memq e1 history))
                        (cond ((setq rest (memq e2 e1))
                               (showevents
                                (cons e2 (reverse (ldiff e1 rest)))))
                              (t
                               (showevents
                                (cons (car e1)
                                      (reverse
                                       (ldiff (memq e2 history) e1))))))))))))

(def tlprint
  (lambda (x)
    (prinlev x 4)))

(def tlquote
  (lambda (x)
    (prog (ans)
     l    (cond ((null x) (return (reverse ans)))
                ((eq (car x) '!)
                 (setq ans (cons (cadr x) ans))
                 (setq x (cddr x)))
                (t (setq ans (cons (kwote (car x)) ans)) (setq x (cdr x))))
          (go l))))

(def tlread
  (lambda nil
    (prog (cmd tmp)
     top  (cond ((not (boundp 'history)) (setq history nil)))
          (cond
           ((null tlbuffer)
            (terpri)
            (princ (add1 (cond (history (caar history)) (t 0))))
            (princ '".")
            (cond
             ((null (setq tlbuffer (lineread)))
              (princ 'Bye)
              (terpri)
              (exit)))))
          (cond ((not (atom (setq cmd (car tlbuffer))))
                 (setq tlbuffer (cdr tlbuffer))
                 (go record))
                ((setq cmd (assoc cmd tlmacros))
                 (setq tmp tlbuffer)
                 (setq tlbuffer nil)
                 (setq cmd (apply (cdr cmd) (ncons tmp)))
                 (cond ((atom cmd) (go top))
                       (t (setq cmd (car cmd)) (go record))))
                ((and (null (cdr tlbuffer))
                      (or (numberp (car tlbuffer))
                          (stringp (car tlbuffer))
                          (hunkp (car tlbuffer))
                          (boundp (car tlbuffer))))
                 (setq cmd (car tlbuffer))
                 (setq tlbuffer nil)
                 (go record))
                ((or (and (dtpr (getd (car tlbuffer)))
                          (memq (car (getd (car tlbuffer)))
                                '(lexpr lambda)))
                     (and (bcdp (getd (car tlbuffer)))
                          (eq (getdisc (getd (car tlbuffer)))
                              'lambda)))
                 (setq cmd (cons (car tlbuffer) (tlquote (cdr tlbuffer))))
                 (setq tlbuffer nil)
                 (go record)))
          (setq cmd tlbuffer)
          (setq tlbuffer nil)
     record
          (setq history
                (cons (list (add1 (cond (history (caar history)) (t 0))) cmd)
                      history))
          (cond
           ((dtpr (cdr (setq tmp (Cnth history historylength))))
            (rplacd tmp nil)))
          (return cmd)))]

(def cmu-top-level
  (lambda nil
    (prog (tlbuffer)
     l    (tlprint (tleval (tlread)))
          (go l)))]

; LWE 1/11/81 The following might make this sucker work after resets:

(setq user-top-level 'cmu-top-level)
(putd 'user-top-level (getd 'cmu-top-level))
(setq top-level 'cmu-top-level)
(putd 'top-level (getd 'cmu-top-level))

(def transprint
  (lambda (prt)
    (prog nil
     l    (cond ((memq (tyipeek prt) '(27 -1)) (return nil))
                (t (tyo (tyi prt)) (go l))))))

(def valueof
  (lambda (x)
    (caddr (tlgetevent x))))

(def zap
  (lambda (prt)
    (prog nil
     l    (cond ((memq (tyi prt) '(10 -1)) (return nil)) (t (go l))))))
(dv dc-switch dc-define)
EndOfFile
cat >  lisplib/cmuedit.l  << 'EndOfFile'
(setq rcs-cmuedit-
   "$Header: /usr/lib/lisp/cmuedit.l,v 1.1 83/01/29 18:33:36 jkf Exp $")

(eval-when (compile load eval) (load 'cmumacs) (load 'cmufncs))

(declare (special c2 c3 tem nopr %changes))

(dv editsfns
    ((declare
      (special |#1|
               |#2|
               |#3|
               $%dotflg
               %lookdpth
               %prevfn%
               atm
               autop
               com
               com0
               coms
               copyflg
               editcomsl
               editracefn
               %%w
               findflag
               l
               l0
               lastail
               lastp1
               lastp2
               lastword
               lcflg
               marklst
               maxlevel
               maxloop
               mess
               noprint
               oldprompt
               readbuf
               %%x
               toflg
               topflg
               undolst
               undolst1
               unfind
               upfindflg
               usermacros
               findarg
               commentflg
               changed))
     |##|
     editfns
     editf
     editv
     editp
     edite
     editl
     editl0
     edval
     editread
     (declare (*expr editracefn))
     editcom
     editcoma
     editcoml
     editmac
     editcoms
     edith
     edit!undo
     undoeditcom
     editsmash
     editnconc
     editdsubst
     edit1f
     edit2f
     edit4e
     editqf
     edit4f
     editfpat
     edit4f1
     editfindp
     editbf
     editbf1
     editnth
     bpnt0
     bpnt
     editri
     editro
     editli
     editlo
     editbi
     editbo
     editdefault
     edup
     edit*l
     edit*
     edor
     errcom
     edrpt
     edloc
     edlocl
     edit:
     editmbd
     editxtr
     editelt
     editcont
     editsw
     editmv
     editto
     editbelow
     editran
     edit!0
     editrepack
     editmakefn
     usermacros
     editracefn
     lastword
     maxlevel
     maxloop
     editcomsl
     autop
     upfindflg))

(declare
 (special |#1|
          |#2|
          |#3|
          $%dotflg
          %lookdpth
          %prevfn%
          atm
          autop
          com
          com0
          coms
          copyflg
          editcomsl
          editracefn
          %%w
          findflag
          l
          l0
          lastail
          lastp1
          lastp2
          lastword
          lcflg
          marklst
          maxlevel
          maxloop
          mess
          noprint
          oldprompt
          readbuf
          %%x
          toflg
          topflg
          undolst
          undolst1
          unfind
          upfindflg
          usermacros
          findarg
          commentflg
          changed))
(declare (special c nopr))	; LWE 1/11/80 Hacks for new compiler.
(def |##|
  (nlambda (coms)
    ((lambda (l undolst1) (editcoms coms)) l nil)))

(def editfns
  (nlambda (x)
    (prog (y)
          (setq y (eval (car x)))
     l1   (cond
           (y (print (car y))
              (eval
               (list 'errset
                     (cons 'editf (cons (car y) (cdr x)))))
              (setq y (cdr y))
              (go l1))))))

(def editf
  (nlambda (x)
    (prog (y fn changed)
          (cond
           ((null x)
            (print '=)
            (prin1 lastword)
            (setq x (ncons lastword))))
          (cond ((symbolp (car x))
                 (setq fn (car x))
                 (cond ((*** setq y (get fn 'trace)) (setq fn (cdr y))))
                 (cond ((setq y (getd fn))
                        (edite y (cdr x) (car x))
                        (cond
                         (changed
                          (*** cond
                               ((eq (car x) fn)
                                (*** move property to front)
                                (remprop (car x) (car y))
                                (putprop (car x) (cadr y) (car y)))
                               ((setq y (cdr (get fn 'funtype)))
                                (*** move the *right* property of the
                                 original word to the front)
                                (setq fn (get (car x) y))
                                (remprop (car x) y)
                                (putprop (car x) fn y)))))
                        (return (setq lastword (car x))))
                       ((and (boundp fn) (dtpr (cdr y))) (go l1))))
                ((dtpr (car x)) (go l1)))
          (print (car x))
          (princ '" not editable")
          (err nil)
     l1   (print '=editv)
          (return (eval (cons 'editv x))))))

(def editv
  (nlambda (x)
    (prog (y)
          (cond
           ((null x)
            (print '=)
            (prin1 lastword)
            (setq x (ncons lastword))))
          (cond ((dtpr (car x)) (edite (eval (car x)) (cdr x) nil) (return t))
                ((and (symbolp (car x))
                      (boundp (car x))
                      (setq y (eval (car x))))
                 (edite y (cdr x) (car x))
                 (return (setq lastword (car x))))
                (t (print (car x)) (princ '" not editable") (err nil))))))

(def editp
  (nlambda (x)
    (cond
     ((null x) (print '=) (prin1 lastword) (setq x (ncons lastword))))
    (cond ((dtpr (car x)) (print '=editv) (eval (cons 'editv x)))
          ((symbolp (car x))
           (edite (plist (car x)) (cdr x) (car x))
           (setq lastword (car x)))
          (t (print (car x)) (princ '" not editable") (err nil)))))

(def edite
  (lambda (expr coms atm)
    (cond ((atom expr) (print expr) (princ '" not editable") (err nil))
          (t (car (last (editl (ncons expr) coms atm nil nil)))))))

(def editl
  (lambda (l coms atm marklst mess)
    (prog (com lastail undolst undolst1 findflag lcflg unfind lastp1 lastp2 readbuf l0 com0 oldprompt upfindflg noprint findarg)
          (makunbound 'findarg)
          (setq upfindflg t)
          (cond ((dtpr (setq l (catch (eval '(editl0)) edit-abort)))
                 (return l))
                (t (err nil))))))

(def editl0
  (lambda nil
    (prog nil
          (cond
           (coms
            (cond ((eq (car coms) 'start)
                   (setq readbuf (append (cdr coms) (list nil)))
                   (setq coms nil)
                   (*** don 't quit if command fails))
                  (t (editcoms (append coms (list 'ok))) (return l)))))
          (cond
           ((or (null coms) (eq (car coms) 'start))
            (print (or mess 'edit))))
          (cond
           ((or (eq (car l)
                    (car
                     (last
                      (car
                       (cond ((setq com
                                    (get 'edit 'lastvalue)))
                             (t '((nil))))))))
                (and atm
                     (eq (car l)
                         (car
                          (last
                           (car
                            (cond ((setq com
                                         (get atm 'edit-save)))
                                  (t '((nil))))))))))
            (setq l (car com))
            (setq marklst (cadr com))
            (setq undolst (caddr com))
            (cond ((car undolst) (setq undolst (cons nil undolst))))
            (setq unfind (cdddr com))))
          (*** setq
               oldprompt
               (cons (sub1 (stkcount 'editl0 (add1 (spdlpt)) 0))
                     (prompt 35)))
     ct   (setq noprint t)
          (setq findflag nil)
     a    (setq undolst1 nil)
          (cond
           ((and autop (null readbuf) (not noprint)) (bpnt (list 0 autop))))
          (setq com (editread))
          (setq l0 l)
          (setq com0 (cond ((atom com) com) (t (car com))))
          (cond
           ((dtpr
             (prog1 (errset (editcom com t))
                    (cond
                     (undolst1 (setq undolst1
                                     (cons com0 (cons l0 undolst1)))
                               (setq undolst (cons undolst1 undolst))))))
            (go a)))
          (setq readbuf nil)
          (cond (coms (err nil)))
          (terpri)
          (cond (com (prin1 com) (princ '"  ?") (terpri)))
          (go ct))))

(def edval
  (lambda (%%x)
    (errset (eval %%x))))

(def editread
  (lambda nil
    (prog (x)
          (cond
           ((null readbuf)
            (prog nil
             l1   (terpri)
                  (princ '|#|)
                  (*** cond
                       ((neq (car oldprompt) 0) (princ (car oldprompt))))
                  (*** prompt 35)
                  (cond
                   ((atom (setq readbuf (errset (lineread))))
                    (terpri)
                    (go l1)))
                  (setq readbuf (car readbuf)))))
          (setq x (car readbuf))
          (setq readbuf (cdr readbuf))
          (return x))))

(declare (*expr editracefn))

(def editcom
  (lambda (c topflg)
    (setq com c)
    (cond (editracefn (editracefn c)))
    (cond (findflag
           (cond ((eq findflag 'bf) (setq findflag nil) (editbf c nil))
                 (t (setq findflag nil) (editqf c))))
          ((numberp c) (setq l (edit1f c l)) (setq noprint nil))
          ((atom c) (editcoma c (null topflg)))
          (t (editcoml c (null topflg))))
    (car l)))

(def editcoma
  (lambda (c copyflg)
    (prog (tem nopr)
          (selectq c
                   (help (setq nopr t)
                         (eval (cons 'help readbuf))
                         (setq readbuf nil)
                         (*** inserted dec 78 by don cohen))
                   (!0 (edit!0))
                   (!nx
                    (setq l
                          ((lambda (l)
                                   (prog (uf)
                                         (setq uf l)
                                    lp   (cond ((or (null (setq l (cdr l)))
                                                    (null (cdr l)))
                                                (err nil))
                                               ((or (null
                                                     (setq tem
                                                           (memq (car l)
                                                                 (cadr
                                                                  l))))
                                                    (null (cdr tem)))
                                                (go lp)))
                                         (edit* 1)
                                         (setq unfind uf)
                                         (return l)))
                           l)))
                   (!undo (edit!undo t t nil))
                   (? (bpnt0 (car l) 64) (setq nopr t))
                   (?? (edith undolst) (setq nopr t))
                   (bk (edit* -1))
                   (delete (setq c '(delete)) (edit: ': nil nil))
                   (mark (setq marklst (cons l marklst)) (setq nopr t))
                   (nex
                    (setq l
                          ((lambda (l) (editbelow '_ 1) (edit* 1) l)
                           l)))
                   ((f bf)
                    (cond ((null topflg) (setq findflag c))
                          (t (setq findarg
                                   (cond ((or readbuf
                                              (not
                                               (boundp 'findarg)))
                                          (editread))
                                         (t findarg)))
                             (selectq c
                                      (f (editqf findarg))
                                      (bf (editbf findarg nil))
                                      (err nil)))))
                   (nil (setq nopr t))
                   (autop nil)
                   (nx (edit* 1))
                   (ok (cond
                        (atm (cond
                              ((and (dtpr undolst) (car undolst))
                               (setq changed t)
                               (*** bound in editf)
                               (mark!changed atm)))
                             (remprop atm 'edit-save)))
                       (putprop 'edit
                                (cons (last l) (cons marklst (cons undolst l)))
                                'lastvalue)
                       (throw l edit-abort)
                       (*** prompt (cdr oldprompt))
                       (*** retfrom 'editl0 l))
                   (p (bpnt0 (car l) 2) (setq nopr t))
                   (pp (bpnt0 (car l) nil) (setq nopr t))
                   (pp* ((lambda (commentflg) (bpnt0 (car l) nil)) t)
                        (setq nopr t))
                   (repack (editrepack))
                   (save (cond
                          (atm (cond
                                ((and (dtpr undolst) (car undolst))
                                 (mark!changed atm)))
                               (putprop 'edit
                                        (putprop atm
                                                 (cons l
                                                       (cons marklst
                                                             (cons undolst
                                                                   unfind)))
                                                 'edit-save)
                                        'lastvalue)))
                         (*** prompt (cdr oldprompt))
                         (*** retfrom 'editl0 l)
                         (throw l edit-abort))
                   (stop (*** prompt (cdr oldprompt))
                         (*** spreval
                              (stksrch 'editl0 (spdlpt) nil)
                              '(err nil))
                         (throw nil edit-abort))
                   (test (setq undolst (cons nil undolst)) (setq nopr t))
                   (tty: (setq com com0)
                         (setq l (editl l nil atm nil 'tty:)))
                   (unblock (cond ((setq tem (memq nil undolst))
                                   (editsmash tem (ncons nil) (cdr tem)))
                                  (t (terpri) (princ '"not blocked")))
                            (setq nopr t))
                   (undo (edit!undo topflg nil (cond (readbuf (editread)))))
                   (up (edup))
                   (/
                    (cond (unfind (setq c l)
                                  (setq l unfind)
                                  (and (cdr c) (setq unfind c)))
                          (t (err nil))))
                   (/p
                    (cond ((and lastp1 (neq lastp1 l)) (setq l lastp1))
                          ((and lastp2 (neq lastp2 l)) (setq l lastp2))
                          (t (err nil))))
                   (^ (and (cdr l) (setq unfind l)) (setq l (last l)))
                   (_
                    (cond (marklst (and (cdr l) (setq unfind l))
                                   (setq l (car marklst)))
                          (t (err nil))))
                   (__
                    (cond (marklst
                           (and (cdr l)
                                (setq unfind l)
                                (setq l (car marklst))
                                (setq marklst (cdr marklst))))
                          (t (err nil))))
                   (tl (top-level) (setq nopr t))
                   (cond ((null (setq tem (editmac c usermacros nil)))
                          (editdefault c)
                          (setq nopr noprint))
                         (t (editcoms (copy (cdr tem))) (setq nopr noprint))))
          (setq noprint nopr))))

(def editcoml
  (lambda (c copyflg)
    (prog (c2 c3 tem nopr)
     lp   (cond ((dtpr (cdr c))
                 (setq c2 (cadr c))
                 (cond ((dtpr (cddr c)) (setq c3 (caddr c)))
                       (t (setq c3 nil))))
                (t (setq c2 (setq c3 nil))))
          (cond ((and lcflg
                      (selectq c2
                               ((to thru through)
                                (cond
                                 ((null (cddr c))
                                  (setq c3 -1)
                                  (setq c2 'thru)))
                                t)
                               nil))
                 (editto (car c) c3 c2)
                 (return nil))
                ((numberp (car c))
                 (edit2f (car c) (cdr c))
                 (setq noprint nil)
                 (return nil))
                ((eq c2 '::)
                 (editcont (car c) (cddr c))
                 (setq noprint nil)
                 (return nil)))
          (selectq (car c)
                   ((a b :) (edit: (car c) nil (cdr c)))
                   (below (editbelow c2 (cond ((cddr c) c3) (t 1))))
                   (bf (editbf c2 c3))
                   (bi
                    (editbi c2
                            (cond ((cddr c) c3) (t c2))
                            (and (cdr c) (car l))))
                   (bind (prog (|#1| |#2| |#3|)
                               (editcoms (cdr c)))
                         (setq nopr noprint))
                   (bk (edit* (minus c2)))
                   (bo (editbo c2 (and (cdr c) (car l))))
                   (change (editran c '((to) (edit: : |#1| |#3|))))
                   (coms (prog nil
                          l1   (cond
                                ((setq c (cdr c))
                                 (editcom (setq com (eval (car c))) nil)
                                 (go l1))))
                         (setq nopr noprint))
                   (comsq (editcoms (cdr c)) (setq nopr noprint))
                   (copy
                    (editran c '((to) (editmv |#1| (car |#3|) (cdr |#3|) t))))
                   (cp (editmv nil (cadr c) (cddr c) t))
                   (delete (editran c '(nil (edit: : |#1| nil))))
                   (e (setq tem (eval c2))
                      (cond ((null (cddr c)) (print tem)))
                      (setq nopr t))
                   (embed (editran c '((in with) (editmbd |#1| |#3|))))
                   (extract (editran c '((from) (editxtr |#3| |#1|))))
                   (f (edit4f c2 c3))
                   (f= (edit4f (cons '== c2) c3))
                   (fs
                    (prog nil
                     l1   (cond
                           ((setq c (cdr c))
                            (editqf (setq com (car c)))
                            (go l1)))))
                   (help (eval c)
                         (setq nopr t)
                         (*** inserted dec 78 by don cohen))
                   (i (setq c
                            (cons (cond ((atom c2) c2) (t (eval c2)))
                                  (mapcar (function
                                           (lambda (x)
                                                   (cond (topflg (print
                                                                  (setq x
                                                                        (eval
                                                                         x)))
                                                                 x)
                                                         (t (eval x)))))
                                          (cddr c))))
                      (setq copyflg nil)
                      (go lp))
                   (if (cond ((and (dtpr (setq tem (edval c2))) (car tem))
                              (cond ((cdr c) (editcoms c3))))
                             ((and (cddr c) (cdddr c)) (editcoms (cadddr c)))
                             (t (err nil)))
                       (setq nopr noprint))
                   (insert
                    (editran c '((before after for) (edit: |#2| |#3| |#1|))))
                   (lc (edloc (cdr c)))
                   (lcl (edlocl (cdr c)))
                   (li (editli c2 (and (cdr c) (car l))))
                   (lo (editlo c2 (and (cdr c) (car l))))
                   ((lp lpq)
                    (edrpt (cdr c) (eq (car c) 'lpq))
                    (setq nopr noprint))
                   (m (cond ((atom c2)
                             (cond ((setq tem (editmac c2 usermacros nil))
                                    (rplacd tem (cddr c)))
                                   (t
                                    (setq usermacros
                                          (cons (cons c2
                                                      (cons nil (cddr c)))
                                                usermacros)))))
                            (t
                             (cond ((setq tem
                                          (editmac (car c2) usermacros t))
                                    (rplaca tem (caddr c))
                                    (rplacd tem (cdddr c)))
                                   (t (nconc editcomsl (ncons (car c2)))
                                      (mark!changed 'editcomsl)
                                      (setq usermacros
                                            (cons (cons (car c2) (cddr c))
                                                  usermacros))))))
                      (mark!changed 'usermacros)
                      (setq nopr t))
                   (makefn
                    (cond ((or (null c2) (null c3) (null (cdddr c)))
                           (err nil))
                          (t
                           (editmakefn c2
                                       c3
                                       (cadddr c)
                                       (cond ((null (cddddr c)) (cadddr c))
                                             (t (car (cddddr c))))))))
                   (mbd (editmbd nil (cdr c)))
                   (move
                    (editran c
                             '((to) (editmv |#1| (car |#3|) (cdr |#3|) nil))))
                   (mv (editmv nil (cadr c) (cddr c) nil))
                   (n (cond ((atom (car l)) (err nil)))
                      (editnconc (car l)
                                 (cond (copyflg (copy (cdr c)))
                                       (t (append (cdr c) nil)))))
                   (nex
                    (setq l
                          ((lambda (l)
                                   (editbelow c2 (cond ((cddr c) c3) (t 1)))
                                   (edit* 1)
                                   l)
                           l)))
                   (nth
                    (cond
                     ((neq (setq tem (editnth (car l) c2)) (car l))
                      (setq l (cons tem l)))))
                   (nx (edit* c2))
                   (orf (edit4f (cons '*any* (cdr c)) 'n))
                   (orr (edor (cdr c)) (setq nopr noprint))
                   (p (cond
                       ((neq lastp1 l) (setq lastp2 lastp1) (setq lastp1 l)))
                      (bpnt (cdr c))
                      (setq nopr t))
                   (r ((lambda (l)
                               (edit4f c2 t)
                               (setq unfind l)
                               (setq c2
                                     (cond ((and (atom c2)
                                                 upfindflg
                                                 (dtpr (car l)))
                                            (caar l))
                                           (t (car l)))))
                       (ncons (car l)))
                      (editdsubst c3 c2 (car l)))
                   (repack (edloc (cdr c)) (editrepack))
                   (replace (editran c '((with by) (edit: : |#1| |#3|))))
                   (ri (editri c2 c3 (and (cdr c) (cddr c) (car l))))
                   (ro (editro c2 (and (cdr c) (car l))))
                   (s (set c2
                           (cond ((null c2) (err nil))
                                 (t ((lambda (l) (edloc (cddr c))) l))))
                      (setq nopr t))
                   (second (edloc (append (cdr c) (cdr c))))
                   (surround (editran c '((with in) (editmbd |#1| |#3|))))
                   (sw (editsw (cadr c) (caddr c)))
                   (third (edloc (append (cdr c) (cdr c) (cdr c))))
                   ((thru to) (editto nil c2 (car c)))
                   (undo (edit!undo topflg nil c2))
                   (xtr (editxtr nil (cdr c)))
                   (_
                    (setq l
                          ((lambda (l)
                                   (prog (uf)
                                         (setq uf l)
                                         (setq c2 (editfpat c2))
                                    lp   (cond ((cond ((and (atom c2)
                                                            (dtpr (car l)))
                                                       (eq c2 (caar l)))
                                                      ((eq (car c2)
                                                           'if)
                                                       (cond ((atom
                                                               (setq tem
                                                                     (edval
                                                                      (cadr
                                                                       c2))))
                                                              nil)
                                                             (t tem)))
                                                      (t
                                                       (edit4e c2
                                                               (cond ((eq (car
                                                                           c2)
                                                                          '@)
                                                                      (caar
                                                                       l))
                                                                     (t
                                                                      (car
                                                                       l))))))
                                                (setq unfind uf)
                                                (return l))
                                               ((setq l (cdr l)) (go lp)))
                                         (err nil)))
                           l)))
                   (cond ((null (setq tem (editmac (car c) usermacros t)))
                          (editdefault c)
                          (setq nopr noprint))
                         ((not (atom (setq c3 (car tem))))
                          (editcoms (subpair c3 (cdr c) (cdr tem)))
                          (setq nopr noprint))
                         (t (editcoms (subst (cdr c) c3 (cdr tem)))
                            (setq nopr noprint))))
          (setq noprint nopr))))

(def editmac
  (lambda (c lst flg)
    (prog (x y)
     lp   (cond ((null lst) (return nil))
                ((eq c (car (setq x (car lst))))
                 (setq y (cdr x))
                 (cond ((cond (flg (car y)) (t (null (car y)))) (return y)))))
          (setq lst (cdr lst))
          (go lp))))

(def editcoms
  (lambda (coms)
    (prog nil
     l1   (cond ((atom coms) (return (car l))))
          (editcom (car coms) nil)
          (setq coms (cdr coms))
          (go l1))))

(def edith
  (lambda (lst)
    (prog nil
          (terpri)
     l1   (cond ((null lst) (return nil))
                ((null (car lst)) (prin1 'block) (go l2))
                ((null (caar lst)) (go l3))
                ((numberp (caar lst))
                 (prin1 (list (caar lst) '--))
                 (go l2)))
          (prin1 (caar lst))
     l2   (princ '" ")
     l3   (setq lst (cdr lst))
          (go l1))))

(def edit!undo
  (lambda (printflg !undoflg undop)
    (prog (lst flg)
          (setq lst undolst)
     lp   (cond ((or (null lst) (null (car lst))) (go out)))
          (cond ((null undop)
                 (selectq (caar lst)
                          ((nil !undo unblock) (go lp1))
                          (undo (cond ((null !undoflg) (go lp1))))
                          nil))
                ((neq undop (caar lst)) (go lp1)))
          (undoeditcom (car lst) printflg)
          (cond ((null !undoflg) (return nil)))
          (setq flg t)
     lp1  (setq lst (cdr lst))
          (go lp)
     out  (cond (flg (return nil))
                ((and lst (cdr lst)) (print 'blocked))
                (t (terpri) (princ '"nothing saved"))))))

(def undoeditcom
  (lambda (x flg)
    (prog (c)
          (cond ((atom x) (err nil))
                ((neq (car (last l)) (car (last (cadr x))))
                 (terpri)
                 (princ '"different expression")
                 (setq com nil)
                 (err nil)))
          (setq c (car x))
          (setq l (cadr x))
          (prog (y z)
                (setq y (cdr x))
           l1   (cond
                 ((setq y (cdr y))
                  (setq z (car y))
                  (cond ((eq (car z) 'r)
                         ((lambda (l)
                                  (editcom (list 'r
                                                 (cadr z)
                                                 (caddr z))
                                           nil))
                          (cadddr z)))
                        (t (editsmash (car z) (cadr z) (cddr z))))
                  (go l1))))
          (editsmash x nil (cons (car x) (cdr x)))
          (and flg
               (setq flg
                     (cond ((not (numberp c)) c) (t (cons c '(--)))))
               (print flg)
               (princ 'undone))
          (return t))))

(def editsmash
  (lambda (old a d)
    (cond ((atom old) (err nil)))
    (setq undolst1 (cons (cons old (cons (car old) (cdr old))) undolst1))
    (rplaca old a)
    (rplacd old d)))

(def editnconc
  (lambda (x y)
    (prog (tem)
          (return
           (cond ((null x) y)
                 ((atom x) (err nil))
                 (t (editsmash (setq tem (last x)) (car tem) y) x))))))

(def editdsubst
  (lambda (x y z)
    (prog nil
     lp   (cond ((atom z) (return nil))
                ((cond ((symbolp y)
                        (or (eq y (car z))
                            (and (stringp (car z)) (eqstr y (car z)))))
                       (t (equal y (car z))))
                 (editsmash z (copy x) (cdr z)))
                (t (editdsubst x y (car z))))
          (cond
           ((and y (eq y (cdr z)))
            (editsmash z (car z) (copy x))
            (return nil)))
          (setq z (cdr z))
          (go lp))))

(def edit1f
  (lambda (c l)
    (cond ((eq c 0) (cond ((null (cdr l)) (err nil)) (t (cdr l))))
          ((atom (car l)) (err nil))
          ((> c 0)
           (cond ((> c (length (car l))) (err nil))
                 (t (cons (car (setq lastail (Cnth (car l) c))) l))))
          ((> (minus c) (length (car l))) (err nil))
          (t
           (cons (car
                  (setq lastail
                        (Cnth (car l) (+ (length (car l)) (add1 c)))))
                 l)))))

(def edit2f
  (lambda (n x)
    (prog (cl)
          (setq cl (car l))
          (cond ((atom cl) (err nil))
                (copyflg (setq x (copy x)))
                (t (setq x (append x nil))))
          (cond ((> n 0)
                 (cond ((> n (length cl)) (err nil))
                       ((null x) (go delete))
                       (t (go replace))))
                ((or (eq n 0) (null x) (> (minus n) (length cl))) (err nil))
                (t (cond ((neq n -1) (setq cl (Cnth cl (minus n)))))
                   (editsmash cl (car x) (cons (car cl) (cdr cl)))
                   (cond
                    ((cdr x)
                     (editsmash cl (car cl) (nconc (cdr x) (cdr cl)))))
                   (return nil)))
     delete
          (cond ((eq n 1)
                 (or (dtpr (cdr cl)) (err nil))
                 (editsmash cl (cadr cl) (cddr cl)))
                (t (setq cl (Cnth cl (sub1 n)))
                   (editsmash cl (car cl) (cddr cl))))
          (return nil)
     replace
          (cond ((neq n 1) (setq cl (Cnth cl n))))
          (editsmash cl (car x) (cdr cl))
          (cond ((cdr x) (editsmash cl (car cl) (nconc (cdr x) (cdr cl))))))))

(def edit4e
  (lambda (pat y)
    (cond ((eq pat y) t)
          ((atom pat)
           (or (eq pat '&)
               (equal pat y)
               (and (stringp y) (stringp pat) (eqstr pat y))))
          ((eq (car pat) '*any*)
           (prog nil
            lp   (cond ((null (setq pat (cdr pat))) (return nil))
                       ((edit4e (car pat) y) (return t)))
                 (go lp)))
          ((and (eq (car pat) '@) (atom y))
           (prog (z)
                 (setq pat (cdr pat))
                 (setq z (explodec y))
            lp   (cond ((eq (car pat) '@)
                        (*** freelist z)
                        (print '=)
                        (prin1 y)
                        (return t))
                       ((null z) (return nil))
                       ((neq (car pat) (car z))
                        (*** freelist z)
                        (return nil)))
                 (setq pat (cdr pat))
                 (setq z (cdr z))
                 (go lp)))
          ((eq (car pat) '--)
           (or (null (setq pat (cdr pat)))
               (prog nil
                lp   (cond ((edit4e pat y) (return t))
                           ((atom y) (return nil)))
                     (setq y (cdr y))
                     (go lp))))
          ((eq (car pat) '==) (eq (cdr pat) y))
          ((atom y) nil)
          ((edit4e (car pat) (car y)) (edit4e (cdr pat) (cdr y))))))

(def editqf
  (lambda (pat)
    (prog (q1)
          (cond ((and (dtpr (car l))
                      (dtpr (setq q1 (cdar l)))
                      (setq q1 (memq pat q1)))
                 (setq l
                       (cons (cond (upfindflg q1)
                                   (t (setq lastail q1) (car q1)))
                             l)))
                (t (edit4f pat 'n))))))

(def edit4f
  (lambda (pat %%x)
    (prog (ll x %%w)
          (setq %%w (ncons nil))
          (setq com pat)
          (setq pat (editfpat pat))
          (setq ll l)
          (cond
           ((eq %%x 'n)
            (setq %%x 1)
            (cond ((atom (car l)) (go lp1))
                  ((and (atom (caar l)) upfindflg)
                   (setq ll (cons (caar l) l))
                   (go lp1))
                  (t (setq ll (cons (caar l) l))))))
          (cond ((and %%x (not (numberp %%x))) (setq %%x 1)))
          (cond
           ((and (edit4e (cond ((and (dtpr pat) (eq (car pat) ':::))
                                (cdr pat))
                               (t pat))
                         (car ll))
                 (or (null %%x) (eq (setq %%x (sub1 %%x)) 0)))
            (return (setq l ll))))
          (setq x (car ll))
     lp   (cond ((edit4f1 pat x maxlevel)
                 (and (cdr l) (setq unfind l))
                 (return
                  (car
                   (setq l
                         (nconc (car %%w)
                                (cond ((eq (cadr %%w) (car ll)) (cdr ll))
                                      (t ll)))))))
                ((null %%x) (err nil)))
     lp1  (setq x (car ll))
          (cond ((null (setq ll (cdr ll))) (err nil))
                ((and (setq x (memq x (car ll))) (dtpr (setq x (cdr x))))
                 (go lp)))
          (go lp1))))

(def editfpat
  (lambda (pat)
    (cond ((dtpr pat)
           (cond ((or (eq (car pat) '==) (eq (car pat) '@)) pat)
                 (t (mapcar (function editfpat) pat))))
          ((eq (nthchar pat -1) '@) (cons '@ (explodec pat)))
          (t pat))))

(def edit4f1
  (lambda (pat x lvl)
    (prog nil
     lp   (cond ((not (> lvl 0))
                 (terpri)
                 (princ '"maxlevel exceeded")
                 (return nil))
                ((atom x) (return nil))
                ((and (dtpr pat)
                      (eq (car pat) ':::)
                      (edit4e (cdr pat) x)
                      (or (null %%x) (eq (setq %%x (sub1 %%x)) 0))))
                ((and (or (atom pat) (neq (car pat) ':::))
                      (edit4e pat (car x))
                      (or (null %%x) (eq (setq %%x (sub1 %%x)) 0)))
                 (cond
                  ((or (null upfindflg) (dtpr (car x)))
                   (setq lastail x)
                   (setq x (car x)))))
                ((and pat
                      (eq pat (cdr x))
                      (or (null %%x) (eq (setq %%x (sub1 %%x)) 0)))
                 (setq x (cdr x)))
                ((and %%x
                      (dtpr (car x))
                      (edit4f1 pat (car x) (sub1 lvl))
                      (eq %%x 0))
                 (setq x (car x)))
                (t (setq x (cdr x)) (setq lvl (sub1 lvl)) (go lp)))
          (cond ((and %%w (neq x (cadr %%w))) (tconc %%w x)))
          (return (or %%w t)))))

(def editfindp
  (lambda (x pat flg)
    (prog (%%x lastail %%w)
          (setq %%x 1)
          (and (null flg) (setq pat (editfpat pat)))
          (return (or (edit4e pat x) (edit4f1 pat x maxlevel))))))

(def editbf
  (lambda (pat n)
    (prog (ll x y %%w)
          (setq ll l)
          (setq %%w (ncons nil))
          (setq com pat)
          (setq pat (editfpat pat))
          (cond ((and (null n) (cdr ll)) (go lp1)))
     lp   (cond
           ((editbf1 pat (car ll) maxlevel y)
            (setq unfind l)
            (return
             (car
              (setq l
                    (nconc (car %%w)
                           (cond ((eq (car ll) (cadr %%w)) (cdr ll))
                                 (t ll))))))))
     lp1  (setq x (car ll))
          (cond ((null (setq ll (cdr ll))) (err nil))
                ((or (setq y (memq x (car ll))) (setq y (tailp x (car ll))))
                 (go lp)))
          (go lp1))))

(def editbf1
  (lambda (pat x lvl tail)
    (prog (y)
     lp   (cond ((not (> lvl 0))
                 (terpri)
                 (princ '"maxlevel exceeded")
                 (return nil))
                ((eq tail x)
                 (return
                  (cond
                   ((edit4e (cond ((and (dtpr pat)
                                        (eq (car pat) ':::))
                                   (cdr pat))
                                  (t pat))
                            x)
                    (tconc %%w x))))))
          (setq y x)
     lp1  (cond
           ((null (or (eq (cdr y) tail) (atom (cdr y))))
            (setq y (cdr y))
            (go lp1)))
          (setq tail y)
          (cond ((and (dtpr (car tail))
                      (editbf1 pat (car tail) (sub1 lvl) nil))
                 (setq tail (car tail)))
                ((and (dtpr pat)
                      (eq (car pat) ':::)
                      (edit4e (cdr pat) tail)))
                ((and (or (atom pat) (neq (car pat) ':::))
                      (edit4e pat (car tail)))
                 (cond
                  ((or (null upfindflg) (dtpr (car tail)))
                   (setq lastail tail)
                   (setq tail (car tail)))))
                ((and pat (eq pat (cdr tail))) (setq x (cdr x)))
                (t (setq lvl (sub1 lvl)) (go lp)))
          (cond ((neq tail (cadr %%w)) (tconc %%w tail)))
          (return %%w))))

(def editnth
  (lambda (x n)
    (cond ((atom x) (err nil))
          ((not (numberp n))
           (or (memq n x) (memq (setq n (editelt n (ncons x))) x) (tailp n x)))
          ((eq n 0) (err nil))
          ((null
            (setq n
                  (cond
                   ((or (not (minusp n))
                        (> (setq n (plus (length x) n 1)) 0))
                    (Cnth x n)))))
           (err nil))
          (t n))))

(def bpnt0
  (lambda (y n)
    (cond ((neq lastp1 l) (setq lastp2 lastp1) (setq lastp1 l)))
    (cond (n (setq $%dotflg (tailp (car l) (cadr l)))
             (setq %prevfn% '" ")
             (printlev y n))
          (t (terpri) (*** sprint y 1) ($prpr y) (terpri)))))

(def bpnt
  (lambda (x)
    (prog (y n)
          (cond ((eq (car x) 0)
                 (setq y (car l))
                 (setq $%dotflg (tailp (car l) (cadr l))))
                (t (setq y (car (editnth (car l) (car x))))))
          (cond ((null (cdr x)) (setq n 2))
                ((not (numberp (setq n (cadr x)))) (err nil))
                ((minusp n) (err nil)))
          (setq %prevfn% '" ")
          (return (printlev y n)))))

(def editri
  (lambda (m n x)
    (prog (a b)
          (setq a (editnth x m))
          (setq b (editnth (car a) n))
          (cond ((or (null a) (null b)) (err nil)))
          (editsmash a (car a) (editnconc (cdr b) (cdr a)))
          (editsmash b (car b) nil))))

(def editro
  (lambda (n x)
    (setq x (editnth x n))
    (cond ((or (null x) (atom (car x))) (err nil)))
    (editsmash (setq n (last (car x))) (car n) (cdr x))
    (editsmash x (car x) nil)))

(def editli
  (lambda (n x)
    (setq x (editnth x n))
    (cond ((null x) (err nil)))
    (editsmash x (cons (car x) (cdr x)) nil)))

(def editlo
  (lambda (n x)
    (setq x (editnth x n))
    (cond ((or (null x) (atom (car x))) (err nil)))
    (editsmash x (caar x) (cdar x))))

(def editbi
  (lambda (m n x)
    (prog (a b)
          (setq b (cdr (setq a (editnth x n))))
          (setq x (editnth x m))
          (cond ((and a (not (> (length a) (length x))))
                 (editsmash a (car a) nil)
                 (editsmash x (cons (car x) (cdr x)) b))
                (t (err nil))))))

(def editbo
  (lambda (n x)
    (setq x (editnth x n))
    (cond ((atom (car x)) (err nil)))
    (editsmash x (caar x) (editnconc (cdar x) (cdr x)))))

(def editdefault
  (lambda (editx)
    (prog nil
          (cond (lcflg
                 (return
                  (cond ((eq lcflg t) (editqf editx))
                        (t (editcom (list lcflg editx) topflg)))))
                ((null topflg) (err nil))
                ((memq editx editcomsl)
                 (cond (readbuf (setq editx (cons editx readbuf))
                                (setq readbuf nil))
                       (t (err nil))))
                (t (err nil)))
          (return (editcom (setq com editx) topflg)))))

(def edup
  (lambda nil
    (prog (c-exp l1 x y)
          (setq c-exp (car l))
     lp   (cond ((null (setq l1 (cdr l))) (err nil))
                ((tailp c-exp (car l1)) (return nil))
                ((not (setq x (memq c-exp (car l1)))) (err nil))
                ((or (eq x lastail) (not (setq y (memq c-exp (cdr x))))))
                ((and (eq c-exp (car lastail)) (tailp lastail y))
                 (setq x lastail))
                (t (terpri)
                   (princ c-exp)
                   (princ '"- location uncertain")))
          (cond ((eq x (car l1)) (setq l l1)) (t (setq l (cons x l1))))
          (return nil))))

(def edit*l
  (lambda (l)
    (edup)
    (length (car l))))

(def edit*
  (lambda (n)
    (car
     (setq l
           ((lambda (com l m)
                    (cond ((not (> m n)) (err nil)))
                    (edit!0)
                    (edit1f (difference n m) l))
            nil
            l
            (edit*l l))))))

(def edor
  (lambda (coms)
    (prog nil
     lp   (cond ((null coms) (err nil))
                ((dtpr
                  (errset
                   (setq l
                         ((lambda (l)
                                  (cond ((atom (car coms))
                                         (editcom (car coms) nil))
                                        (t (editcoms (car coms))))
                                  l)
                          l))))
                 (return (car l))))
          (setq coms (cdr coms))
          (go lp))))

(def errcom
  (lambda (coms)
    (errset (editcoms coms))))

(def edrpt
  (lambda (edrx quiet)
    (prog (edrl edrptcnt)
          (setq edrl l)
          (setq edrptcnt 0)
     lp   (cond ((> edrptcnt maxloop)
                 (terpri)
                 (princ '"maxloop exceeded"))
                ((dtpr (errcom edrx))
                 (setq edrl l)
                 (setq edrptcnt (add1 edrptcnt))
                 (go lp))
                ((null quiet) (print edrptcnt) (princ 'occurrences)))
          (setq l edrl))))

(def edloc
  (lambda (edx)
    (prog (oldl oldf lcflg edl)
          (setq oldl l)
          (setq oldf unfind)
          (setq lcflg t)
          (cond ((atom edx) (editcom edx nil))
                ((and (null (cdr edx)) (atom (car edx)))
                 (editcom (car edx) nil))
                (t (go lp)))
          (setq unfind oldl)
          (return (car l))
     lp   (setq edl l)
          (cond ((dtpr (errcom edx)) (setq unfind oldl) (return (car l))))
          (cond ((equal edl l) (setq l oldl) (setq unfind oldf) (err nil)))
          (go lp))))

(def edlocl
  (lambda (coms)
    (car
     (setq l
           (nconc ((lambda (l unfind) (edloc coms) l) (ncons (car l)) nil)
                  (cdr l))))))

(def edit:
  (lambda (type lc x)
    (prog (toflg l0)
          (setq l0 l)
          (setq x
                (mapcar (function
                         (lambda (x)
                                 (cond ((and (dtpr x)
                                             (eq (car x) '|##|))
                                        ((lambda (l undolst1)
                                                 (copy (editcoms (cdr x))))
                                         l
                                         nil))
                                       (t x))))
                        x))
          (cond
           (lc (cond ((eq (car lc) 'here) (setq lc (cdr lc))))
               (edloc lc)))
          (edup)
          (cond ((eq l0 l) (setq lc nil)))
          (selectq type
                   ((b before) (edit2f -1 x))
                   ((a after)
                    (cond ((cdar l) (edit2f -2 x))
                          (t (editcoml (cons 'n x) copyflg))))
                   ((: for)
                    (cond ((or x (cdar l)) (edit2f 1 x))
                          ((memq (car l) (cadr l))
                           (edup)
                           (edit2f 1 (ncons nil)))
                          (t (editcoms '(0 (nth -2) (2)))))
                    (return (cond ((null lc) l))))
                   (err nil))
          (return nil))))

(def editmbd
  (lambda (lc x)
    (prog (y toflg)
          (cond (lc (edloc lc)))
          (edup)
          (setq y (cond (toflg (caar l)) (t (ncons (caar l)))))
          (edit2f 1
                  (ncons
                   (cond ((or (atom (car x)) (cdr x)) (append x y))
                         (t (lsubst y '* (car x))))))
          (setq l
                (cons (caar l)
                      (cond ((tailp (car l) (cadr l)) (cdr l)) (t l))))
          (return (cond ((null lc) l))))))

(def editxtr
  (lambda (lc x)
    (prog (toflg)
          (cond (lc (edloc lc)))
          ((lambda (l unfind)
                   (edloc x)
                   (setq x
                         (cond ((tailp (car l) (cadr l)) (caar l))
                               (t (car l)))))
           (ncons (cond ((tailp (car l) (cadr l)) (caar l)) (t (car l))))
           nil)
          (edup)
          (edit2f 1 (cond (toflg (append x nil)) (t (ncons x))))
          (and (null toflg)
               (dtpr (caar l))
               (setq l
                     (cons (caar l)
                           (cond ((tailp (car l) (cadr l)) (cdr l)) (t l))))))))

(def editelt
  (lambda (lc l)
    (prog (y)
          (edloc lc)
     lp   (setq y l)
          (cond ((cdr (setq l (cdr l))) (go lp)))
          (return (car y)))))

(def editcont
  (lambda (lc1 %%x)
    (setq l
          ((lambda (l)
                   (prog nil
                         (setq lc1 (editfpat lc1))
                    lp   (cond ((null (edit4f lc1 'n)) (err nil))
                               ((atom (errset (edlocl %%x))) (go lp)))
                    lp1  (cond ((null (setq l (cdr l))) (err nil))
                               ((cond ((atom lc1) (eq lc1 (caar l)))
                                      ((eq (car lc1) '@)
                                       (edit4e lc1 (caar l)))
                                      (t (edit4e lc1 (car l))))
                                (return l)))
                         (go lp1)))
           l))))

(def editsw
  (lambda (m n)
    (prog (y z tem)
          (setq y (editnth (car l) m))
          (setq z (editnth (car l) n))
          (setq tem (car y))
          (editsmash y (car z) (cdr y))
          (editsmash z tem (cdr z)))))

(def editmv
  (lambda (lc op x cp)
    (prog (l0 l1 z toflg)
          (setq l0 l)
          (and lc (edloc lc))
          (cond ((eq op 'here)
                 (cond ((null lc) (edloc x) (setq x nil)))
                 (setq op ':))
                ((eq (car x) 'here)
                 (cond ((null lc) (edloc (cdr x)) (setq x nil))
                       (t (setq x (cdr x))))))
          (edup)
          (setq l1 l)
          (setq z (cond (cp (copy (caar l))) (t (caar l))))
          (setq l l0)
          (and x (edloc x))
          (cond ((eq op 'after) (setq op 'a))
                ((eq op 'before) (setq op 'b)))
          (editcoml (cond (toflg (cons op (append z nil))) (t (list op z)))
                    nil)
          (prog (l)
                (setq l l1)
                (cond ((not cp) (editcoms '(1 delete)))
                      (toflg (editcoml '(bo 1) nil))))
          (return
           (cond ((null lc) (setq unfind l1) l)
                 ((null x) (setq unfind l1) l0)
                 (t (setq unfind l) l0))))))

(def editto
  (lambda (lc1 lc2 flg)
    (setq l
          ((lambda (l)
                   (cond (lc1 (edloc lc1) (edup)))
                   (editbi 1
                           (cond ((and (numberp lc1)
                                       (numberp lc2)
                                       (> lc2 lc1))
                                  (difference (add1 lc2) lc1))
                                 (t lc2))
                           (car l))
                   (cond
                    ((and (eq flg 'to) (cdaar l))
                     (editri 1 -2 (car l))))
                   (editcom 1 nil)
                   l)
           l))
    (setq toflg t)))

(def editbelow
  (lambda (place depth)
    (cond ((minusp (setq depth (eval depth))) (err nil)))
    (prog (n1 n2)
          (setq n1
                (length
                 ((lambda (l lcflg) (editcom place nil) l) l '_)))
          (setq n2 (length l))
          (cond ((< n2 (+ n1 depth)) (err nil)))
          (setq unfind l)
          (setq l (Cnth l (difference (add1 n2) n1 depth))))))

(def editran
  (lambda (c def)
    (setq l
          (or ((lambda (l)
                       (prog (z w)
                             (cond ((null def) (err nil))
                                   ((null (setq z (car def))) (go out)))
                        lp   (cond ((null z) (err nil))
                                   ((null (setq w (memq (car z) c)))
                                    (setq z (cdr z))
                                    (go lp)))
                        out  (setq z
                                   (apply (car (setq def (cadr def)))
                                          (prog (|#1| |#2| |#3|)
                                                (setq |#1| (cdr
                                                            (ldiff c w)))
                                                (setq |#2| (car z))
                                                (setq |#3| (cdr w))
                                                (return
                                                 (mapcar (function
                                                          (lambda (x)
                                                                  (cond ((atom
                                                                          x)
                                                                         (selectq x
                                                                                  (|#1|
                                                                                   |#1|)
                                                                                  (|#2|
                                                                                   |#2|)
                                                                                  (|#3|
                                                                                   |#3|)
                                                                                  x))
                                                                        (t
                                                                         (eval
                                                                          x)))))
                                                         (cdr def))))))
                             (return
                              (cond ((null z) (setq unfind l) nil) (t z)))))
               l)
              l))))

(def edit!0
  (lambda nil
    (cond ((null (cdr l)) (err nil)))
    (prog nil
     lp   (setq l (cdr l))
          (cond ((tailp (car l) (cadr l)) (go lp))))))

(def editrepack
  (lambda nil
    (cond ((dtpr (car l)) (setq l (edit1f 1 l))))
    (edit: ': nil (ncons (readlist (edite (explode (car l)) nil nil))))))

(def editmakefn
  (lambda (ex args n m)
    (editbi n m (car l))
    (edloc n)
    (editbelow '/ 1)
    (mapc (function (lambda (x y) (editdsubst x y (car l)))) args (cdr ex))
    (putprop (car ex) (cons 'lambda (cons args (car l))) 'expr)
    (mark!changed (car ex))
    (edup)
    (edit2f 1 (ncons ex))))

(dv usermacros nil)

(dv editracefn nil)

(dv lastword editsfns)

(dv maxlevel 192)

(dv maxloop 24)

(dv editcomsl
    (: a
       b
       below
       bf
       bi
       bind
       bk
       bo
       change
       coms
       comsq
       copy
       cp
       delete
       e
       embed
       extract
       f
       f=
       fs
       help
       i
       if
       insert
       lc
       lcl
       li
       lo
       lp
       lpq
       m
       makefn
       mbd
       move
       mv
       n
       nex
       nth
       nx
       orf
       orr
       p
       r
       repack
       replace
       ri
       ro
       s
       second
       surround
       sw
       third
       thru
       to
       undo
       xtr
       _))

(dv autop 2)

(dv upfindflg t)
EndOfFile
cat >  lisplib/structini.l  << 'EndOfFile'
;;;-*-lisp-*-
(setq rcs-strictini-
   "$Header: /usr/lib/lisp/structini.l,v 1.1 83/01/29 18:40:11 jkf Exp $")

#+franz
(declare (macros t))

(defmacro defstruct ((name . opts) . slots)
  (let ((dp (cadr (assq ':default-pointer opts)))
	(conc-name (cadr (assq ':conc-name opts)))
	(cons-name (implode (append '(m a k e -) (explodec name)))))
    #Q (fset-carefully cons-name '(macro . initial_defstruct-cons))
    #M (putprop cons-name 'initial_defstruct-cons 'macro)
    #F (putd cons-name '(macro (x) (initial_defstruct-cons x)))
    (do ((i 0 (1+ i))
	 (l slots (cdr l))
	 (foo nil (cons (list slot init) foo))
	 (chars (explodec conc-name))
	 (slot) (acsor) (init))
	((null l)
	 (putprop cons-name foo 'initial_defstruct-inits)
	 `',name)
      (cond ((atom (car l))
	     (setq slot (car l))
	     (setq init nil))
	    (t (setq slot (caar l))
	       (setq init (cadar l))))
      (setq acsor (implode (append chars (explodec slot))))
      (putprop acsor dp 'initial_defstruct-dp)
      #Q (fset-carefully acsor '(macro . initial_defstruct-ref))
      #M (putprop acsor 'initial_defstruct-ref 'macro)
      #F (putd acsor '(macro (x) (initial_defstruct-ref x)))
      (putprop acsor i 'initial_defstruct-i))))

(defun initial_defstruct-ref (form)
  (let ((i (get (car form) 'initial_defstruct-i))
	(p (if (null (cdr form))
	       (get (car form) 'initial_defstruct-dp)
	       (cadr form))))
    #-Multics `(nth ,i ,p)
    #+Multics `(car ,(do ((i i (1- i))
			  (x p `(cdr ,x)))
			 ((zerop i) x)))
    ))

(defun initial_defstruct-cons (form)
  (do ((inits (get (car form) 'initial_defstruct-inits)
	      (cdr inits))
       (gen (gensym))
       (x nil (cons (or (get form (caar inits))
			(cadar inits))
		    x)))
      ((null inits)
       `(list . ,x))))

EndOfFile
cat >  lisplib/struct.l  << 'EndOfFile'
;;; -*- Mode:Lisp; Package:SI; Lowercase:True; Base:8 -*-
;;;	** (c) Copyright 1980 Massachusetts Institute of Technology **
(setq rcs-struct-
   "$Header: /usr/lib/lisp/RCS/struct.l,v 1.2 83/08/06 08:41:10 jkf Exp $")

;The master copy of this file is in MC:ALAN;NSTRUCT >
;The current Lisp machine copy is in AI:LISPM2;STRUCT >
;The current Multics copy is in >udd>Mathlab>Bawden>defstruct.lisp

;*****  READ THIS PLEASE!  *****
;If you are thinking of munging anything in this file you might want
;to consider finding me (ALAN) and asking me to mung it for you.
;There is more than one copy of this file in the world (it runs in PDP10
;and Multics MacLisp and on LispMachines) and whatever amazing
;features you are considering adding might be usefull to those people
;as well.  If you still cannot contain yourself long enough to find
;me, AT LEAST send me a piece of mail describing what you did and why.
;Thanks for reading this flame.
;					 Alan Bawden (ALAN@MC)

;Things to fix:

;For LispMachine:
; :%P-LDB type (this is hard to do, punt for now.)

;For Multics:
; displacement is a problem (no displace)
; nth, nthcdr don't exist there
; ldb, dpb don't exist, so byte fields don't work without Mathlab macros
; callable accessors don't work
; dpb is needed at the user's compile time if he is using byte fields.

#+Franz (environment-maclisp)

(eval-when (compile)
  (cond ((status feature ITS)
	 (load '|alan;lspenv init|))
	((status feature Multics)
	 (load '|>udd>Mathlab>Bawden>lspenv.lisp|))))

#+PDP10
(cond ((status nofeature noldmsg)
       (terpri msgfiles)
       (princ '#.(and (status feature PDP10)
		      (maknam (nconc (exploden ";Loading DEFSTRUCT ")
				     (exploden (caddr (truename infile))))))
	      msgfiles)))

#+Multics
(declare (genprefix defstruct-internal-)
	 (macros t))

#+Franz
(declare (macros t))

#M
(eval-when (eval compile)
  (setsyntax #/: (ascii #\space) nil))

;; #+Franz
;; (eval-when (eval compile)
;;    (setsyntax #/: 'vseparator))		; make :'s go away

(eval-when (eval)
  ;;So we may run the thing interpreted we need the simple
  ;;defstruct that lives here:
  (cond ((status feature ITS)
	 (load '|alan;struct initial|))
	((status feature Multics)
	 (load '|>udd>Mathlab>Bawden>initial_defstruct|))
	((status feature Franz)
	 (load 'structini.l))))

(eval-when (compile)
  ;;To compile the thing this probably is an old fasl: (!)
  (cond ((status feature ITS)
	 (load '|alan;struct boot|))
	((status feature Multics)
	 (load '|>udd>Mathlab>Bawden>boot_defstruct|))
	((status feature Franz)	; This is only needed for bootstrapping
	 (cond ((and (null (getd 'defstruct))
		     (not (probef
			     (concat lisp-library-directory "//struct.o"))))
		(load 'structini))))
	))

#+Multics
(defun nth (n l)
  (do ((n n (1- n))
       (l l (cdr l)))
      ((zerop n) (car l))))

#+Multics
(defun nthcdr (n l)
  (do ((n n (1- n))
       (l l (cdr l)))
      ((zerop n) l)))

#+(or Franz Multics)
(defun displace (x y)
  (cond ((atom y)
	 (rplaca x 'progn)
	 (rplacd x (list y)))
	(t
	 (rplaca x (car y))
	 (rplacd x (cdr y))))
  x)

;;; You might think you could use progn for this, but you can't!
(defun defstruct-dont-displace (x y)
  x	;ignored
  y)

;;; Eval this before attempting incremental compilation
(eval-when (eval compile)

#+PDP10
(defmacro append-symbols args
  (do ((l (reverse args) (cdr l))
       (x)
       (a nil (if (or (atom x)
		      (not (eq (car x) 'quote)))
		  (if (null a)
		      `(exploden ,x)
		      `(nconc (exploden ,x) ,a))
		  (let ((l (exploden (cadr x))))
		    (cond ((null a) `',l)
			  ((= 1 (length l)) `(cons ,(car l) ,a))
			  (t `(append ',l ,a)))))))

            ((null l) `(implode ,a))
    (setq x (car l))))

#+Multics
(defmacro append-symbols args
  `(make_atom (catenate . ,args)))

#+LispM
(defmacro append-symbols args
  `(intern (string-append . ,args)))

#+Franz
(defmacro append-symbols (&rest args)
   `(concat . ,args))
   
(defmacro defstruct-putprop (sym val ind)
  `(push `(defprop ,,sym ,,val ,,ind) returns))

(defmacro defstruct-put-macro (sym fcn)
  #M `(defstruct-putprop ,sym ,fcn 'macro)
  #+lispm
    (setq fcn (if (and (not (atom fcn))
			(eq (car fcn) 'quote))
		   `'(macro . ,(cadr fcn))
		   `(cons 'macro ,fcn)))
  #+Franz
    (setq fcn (if (and (not (atom fcn))
		       (eq (car fcn) 'quote))
		  `'(macro (macroarg) (,(cadr fcn) macroarg))
		  `(cons 'macro ,fcn)))   ;; probably incorrect
			   
  #Q `(push `(fdefine ',,sym ',,fcn t) returns)
  #+Franz `(push `(def ,,sym ,,fcn) returns)
  )

(defmacro make-empty () `'%%defstruct-empty%%)

(defmacro emptyp (x) `(eq ,x '%%defstruct-empty%%))

;;;Here we must deal with the fact that error reporting works
;;;differently everywhere!

#+(or Franz PDP10)
;;;first arg is ALWAYS a symbol or a quoted symbol:
(defmacro defstruct-error (message &rest args)
  (let* ((chars (nconc (exploden (if (atom message)
				     message
				     (cadr message)))
		       '(#/.)))		;"Bad frob" => "Bad frob."
	 (new-message
	  (maknam (if (null args)
		      chars
		      (let ((c (car chars)))	;"Bad frob." => "-- bad frob."
			(or (< c #/A)
			    (> c #/Z)
			    (rplaca chars (+ c #o40)))
			(append '(#/- #/- #\space) chars))))))
  `(error ',new-message
	  ,@(cond ((null args) `())
		  ((null (cdr args)) `(,(car args)))
		  (t `((list ,@args)))))))

#+Multics
;;;first arg is ALWAYS a string:
(defmacro defstruct-error (message &rest args)
  `(error ,(catenate "defstruct: "
		     message
		     (if (null args)
			 "."
			 ": "))
	  ,@(cond ((null args) `())
		  ((null (cdr args)) `(,(car args)))
		  (t `((list ,@args))))))

#+LispM
;;;first arg is ALWAYS a string:
(defmacro defstruct-error (message &rest args)
  `(ferror nil
	   ,(string-append message
			   (if (null args)
			       "."
			       ":~@{ ~S~}"))
	   ,@args))

);End of eval-when (eval compile)

;;;If you mung the the ordering af any of the slots in this structure,
;;;be sure to change the version slot and the definition of the function
;;;get-defstruct-description.  Munging the defstruct-slot-description
;;;structure should also cause you to change the version "number" in this manner.
(defstruct (defstruct-description
	     (:type :list)
	     (:default-pointer description)
	     (:conc-name defstruct-description-)
	     (:alterant nil))
  (version 'one)
  type
  (displace 'defstruct-dont-displace)
  slot-alist
  named-p
  constructors
  (default-pointer nil)
  (but-first nil)
  size
  (property-alist nil)
  ;;end of "expand-time" slots
  name
  include
  (initial-offset 0)
  (eval-when '(eval compile load))
  alterant
  (conc-name nil)
  (callable-accessors #M nil #Q t)
  (size-macro nil)
  (size-symbol nil)
  )

(defun get-defstruct-description (name)
  (let ((description (get name 'defstruct-description)))
    (cond ((null description)
	   (defstruct-error
	     "A structure with this name has not been defined" name))
	  ((not (eq (defstruct-description-version) 'one))
	   (defstruct-error "The description of this structure is out of date,
it should be recompiled using the current version of defstruct"
		  name))
	  (t description))))

;;;See note above defstruct-description structure before munging this one.
(defstruct (defstruct-slot-description
	     (:type :list)
	     (:default-pointer slot-description)
	     (:conc-name defstruct-slot-description-)
	     (:alterant nil))
  number
  (ppss nil)
  init-code
  (type 'notype)
  (property-alist nil)
  ref-macro-name
  )

;;;Perhaps this structure wants a version slot too?
(defstruct (defstruct-type-description
	     (:type :list)
	     (:default-pointer type-description)
	     (:conc-name defstruct-type-description-)
	     (:alterant nil))
  ref-expander
  ref-no-args
  cons-expander
  cons-flavor
  (cons-keywords nil)
  (named-type nil)
  (overhead 0)
  (defstruct-expander nil)
  )

;; (DEFSTRUCT (<name> . <options>) . <slots>) or (DEFSTRUCT <name> . <slots>)
;;
;; <options> is of the form (<option> <option> (<option> <val>) ...)
;;
;; <slots> is of the form (<slot> (<slot> <initial-value>) ...)
;;
;; Options:
;;   :TYPE defaults to HUNK
;;   :CONSTRUCTOR defaults to "MAKE-<name>"
;;   :DEFAULT-POINTER defaults to empty (if no <val> given defaults to "<name>")
;;   :CONC-NAME defaults to empty (if no <val> given defaults to "<name>-")
;;   :SIZE-SYMBOL defaults to empty (if no <val> given defaults to "<name>-SIZE")
;;   :SIZE-MACRO defaults to empty (if no <val> given defaults to "<name>-SIZE")
;;   :ALTERANT defaults to "ALTER-<name>"
;;   :BUT-FIRST must have a <val> given
;;   :INCLUDE must have a <val> given
;;   :PROPERTY (:property foo bar) gives the structure a foo property of bar.
;;   :INITIAL-OFFSET can cause defstruct to skip over that many slots.
;;   :NAMED takes no value.  Tries to make the structure a named type.
;;   :CALLABLE-ACCESSORS defaults to T on the LispMachine, NIL elsewhere.
;;   <type> any type name can be used without a <val> instead of saying (TYPE <type>)
;;   <other> any symbol with a non-nil :defstruct-option property.  You say
;;     (<other> <val>) and the effect is that of (:property <other> <val>)
;;
;; Properties used:
;;   DEFSTRUCT-TYPE-DESCRIPTION each type has one, it is a type-description.
;;   DEFSTRUCT-NAME each constructor, alterant and size macro has one, it is a name.
;;   DEFSTRUCT-DESCRIPTION each name has one, it is a description (see below).
;;   DEFSTRUCT-SLOT each accesor has one, it is of the form: (<name> . <slot>)
;;   :DEFSTRUCT-OPTION if a symbol FOO has this property then it can be used as an
;;     option giving the structure a FOO property of the value (which must be given).

(defmacro defstruct (options &body items)
  (let* ((description (defstruct-parse-options options))
	 (type-description (get (defstruct-description-type)
				'defstruct-type-description))
	 (name (defstruct-description-name))
	 (new-slots (defstruct-parse-items items description))
	 (returns nil))
    (push `',name returns)
    (or (null (defstruct-type-description-defstruct-expander))
	(setq returns (append (funcall (defstruct-type-description-defstruct-expander)
				       description)
			      returns)))
    #Q (push `(record-source-file-name ',name) returns)
    (defstruct-putprop name description 'defstruct-description)
    (let ((alterant (defstruct-description-alterant))
	  (size-macro (defstruct-description-size-macro))
	  (size-symbol (defstruct-description-size-symbol)))
      (cond (alterant
	     (defstruct-put-macro alterant 'defstruct-expand-alter-macro)
	     (defstruct-putprop alterant name 'defstruct-name)))
      (cond (size-macro
	     (defstruct-put-macro size-macro 'defstruct-expand-size-macro)
	     (defstruct-putprop size-macro name 'defstruct-name)))
      (cond (size-symbol
	     (push `(#M defvar #Q defconst #F setq ,size-symbol
			,(+ (defstruct-description-size)
			    (defstruct-type-description-overhead)))
		   returns))))
    (do cs (defstruct-description-constructors) (cdr cs) (null cs)
	(defstruct-put-macro (caar cs) 'defstruct-expand-cons-macro)
	(defstruct-putprop (caar cs) name 'defstruct-name))
    `(eval-when ,(defstruct-description-eval-when)
		,.(defstruct-define-ref-macros new-slots description)
		. ,returns)))

(defun defstruct-parse-options (options)
  (let ((name (if (atom options) options (car options)))
	(type nil)
	(constructors (make-empty))
	(alterant (make-empty))
	(included nil)
	(named-p nil)
	(description (make-defstruct-description)))
    (setf (defstruct-description-name) name)
    (do ((op) (val) (vals)
	 (options (if (atom options) nil (cdr options))
		  (cdr options)))
	((null options))
      (if (atom (setq op (car options)))
	  (setq vals nil)
	  (setq op (prog1 (car op) (setq vals (cdr op)))))
      (setq val (if (null vals) (make-empty) (car vals)))
  #Q AGAIN 
      (selectq op
	(:type
	 (if (emptyp val)
	     (defstruct-error
	       "The type option to defstruct must have a value given"
	       name))
	 (setq type val))
	(:default-pointer
	 (setf (defstruct-description-default-pointer)
	       (if (emptyp val) name val)))
	(:but-first
	 (if (emptyp val)
	     (defstruct-error
	       "The but-first option to defstruct must have a value given"
	       name))
	 (setf (defstruct-description-but-first) val))
	(:conc-name
	 (setf (defstruct-description-conc-name)
	       (if (emptyp val)
		   (append-symbols name '-)
		   val)))
	(:callable-accessors
	 (setf (defstruct-description-callable-accessors)
	       (if (emptyp val) t val)))
	(:displace
	 (setf (defstruct-description-displace)
	       (cond ((or (emptyp val)
			  (eq val 't))
		      'displace)
		     ((null val) 'defstruct-dont-displace)
		     (t val))))
	(:constructor
	 (cond ((null val)
		(setq constructors nil))
	       (t
		(and (emptyp val)
		     (setq val (append-symbols 'make- name)))
		(setq val (cons val (cdr vals)))
		(if (emptyp constructors)
		    (setq constructors (list val))
		    (push val constructors)))))
	(:alterant
	 (setq alterant val))
	(:size-macro
	 (setf (defstruct-description-size-macro)
	       (if (emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:size-symbol
	 (setf (defstruct-description-size-symbol)
	       (if (emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:include
	 (and (emptyp val)
	      (defstruct-error
		"The include option to defstruct requires a value"
		name))
	 (setq included val)
	 (setf (defstruct-description-include) vals))
	(:property
	 (push (cons (car vals) (if (null (cdr vals)) t (cadr vals)))
	       (defstruct-description-property-alist)))
	(:named
	 (or (emptyp val)
	     (defstruct-error
	       "The named option to defstruct doesn't take a value" name))
	 (setq named-p t))
	(:eval-when
	 (and (emptyp val)
	      (defstruct-error
		"The eval-when option to defstruct requires a value"
		name))
	 (setf (defstruct-description-eval-when) val))
	(:initial-offset
	 (and (or (emptyp val)
		  (not (fixp val)))
	      (defstruct-error
		"The initial-offset option to defstruct requires a fixnum"
		name))
	 (setf (defstruct-description-initial-offset) val))
	(otherwise
	 (cond ((get op 'defstruct-type-description)
		(or (emptyp val)
		    (defstruct-error
		      "defstruct type used as an option with a value"
		      op 'in name))
		(setq type op))
	       ((get op ':defstruct-option)
		(push (cons op (if (emptyp val) t val))
		      (defstruct-description-property-alist)))
	       (t
		#Q (multiple-value-bind (new foundp)
					(intern-soft op si:pkg-user-package)
		     (or (not foundp)
			 (eq op new)
			 (progn (setq op new) (go AGAIN))))
		(defstruct-error
		  "defstruct doesn't understand this option"
		  op 'in name))))))
    (cond ((emptyp constructors)
	   (setq constructors
		 (list (cons (append-symbols 'make- name)
			     nil)))))
    (setf (defstruct-description-constructors) constructors)
    (cond ((emptyp alterant)
	   (setq alterant
		 (append-symbols 'alter- name))))
    (setf (defstruct-description-alterant) alterant)
    (cond ((not (null type))
	   (let ((type-description
		  (or (get type 'defstruct-type-description)
		   #Q (multiple-value-bind
				(new foundp)
				(intern-soft type si:pkg-user-package)
			(and foundp
			     (not (eq type new))
			     (progn (setq type new)
				    (get type 'defstruct-type-description))))
		      (defstruct-error
			"Unknown type in defstruct"
			type 'in name))))
	     (if named-p
		 (setq type
		       (or (defstruct-type-description-named-type)
			   (defstruct-error
			    "There is no way to make this defstruct type named"
			    type 'in name)))))))
    (cond (included
	   (let ((d (get-defstruct-description included)))
	     (if (null type)
		 (setq type (defstruct-description-type d))
		 (or (eq type (defstruct-description-type d))
		     (defstruct-error
		       "defstruct types must agree for include option"
		       included 'included-by name)))
	     (and named-p
		  (not (eq type (defstruct-type-description-named-type
				  (or (get type 'defstruct-type-description)
				      (defstruct-error
					"Unknown type in defstruct"
					type 'in name 'including included)))))
		  (defstruct-error
		    "Included defstruct's type isn't a named type"
		    included 'included-by name))))
	  ((null type)
	   (setq type
	     (cond (named-p
		    #+PDP10 ':named-hunk
		    #+Franz ':named-vector
		    #+Multics ':named-list
		    #+LispM ':named-array)
		   (t
		    #+PDP10 ':hunk
		    #+Franz ':named-vector
		    #+Multics ':list
		    #+LispM ':array)))))
    (let ((type-description (or (get type 'defstruct-type-description)
				(defstruct-error
				  "Undefined defstruct type"
				  type 'in name))))
      (setf (defstruct-description-type) type)
      (setf (defstruct-description-named-p)
	    (eq (defstruct-type-description-named-type) type)))
    description))

(defun defstruct-parse-items (items description)
  (let ((name (defstruct-description-name))
	(offset (defstruct-description-initial-offset))
	(include (defstruct-description-include))
	(o-slot-alist nil)
	(conc-name (defstruct-description-conc-name)))
    (or (null include)
	(let ((d (get (car include) 'defstruct-description)))
	  (setq offset (+ offset (defstruct-description-size d))) 
	  (setq o-slot-alist
		(subst nil nil (defstruct-description-slot-alist d)))
	  (do ((l (cdr include) (cdr l))
	       (it) (val))
	      ((null l))
	    (cond ((atom (setq it (car l)))
		   (setq val (make-empty)))
		  (t
		   (setq val (cadr it))
		   (setq it (car it))))
	    (let ((slot-description (cdr (assq it o-slot-alist))))
	      (and (null slot-description)
		   (defstruct-error
		     "Unknown slot in included defstruct"
		     it 'in include 'included-by name))
	      (setf (defstruct-slot-description-init-code) val)))))
    (do ((i offset (1+ i))
	 (l items (cdr l))
	 (slot-alist nil)
	 #+PDP10 (chars (exploden conc-name)))
	((null l)
	 (setq slot-alist (nreverse slot-alist))
	 (setf (defstruct-description-size) i)
	 (setf (defstruct-description-slot-alist)
	       (nconc o-slot-alist slot-alist))
	 slot-alist)
      (cond ((atom (car l))
	     (push (defstruct-parse-one-field
		     (car l) i nil nil conc-name #+PDP10 chars)
		   slot-alist))
	    ((atom (caar l))
	     (push (defstruct-parse-one-field
		     (caar l) i nil (cdar l) conc-name #+PDP10 chars)
		   slot-alist))
	    (t
	     (do ll (car l) (cdr ll) (null ll)
		 (push (defstruct-parse-one-field
			 (caar ll) i (cadar ll)
			 (cddar ll) conc-name #+PDP10 chars)
		       slot-alist)))))))

(defun defstruct-parse-one-field (it number ppss rest conc-name #+PDP10 chars)
  (let ((mname (if conc-name #+PDP10 (implode (append chars (exploden it)))
			     #+Multics (make_atom (catenate conc-name it))
			     #+Franz (concat conc-name it)
			     #+LispM (intern (string-append conc-name it))
		   it)))
    (cons it (make-defstruct-slot-description
	       number number
	       ppss ppss
	       init-code (if (null rest) (make-empty) (car rest))
	       ref-macro-name mname))))

(defun defstruct-define-ref-macros (new-slots description)
  (let ((name (defstruct-description-name))
	(returns nil))
    (if (not (defstruct-description-callable-accessors))
	(do ((l new-slots (cdr l))
	     (mname))
	    ((null l))
	  (setq mname (defstruct-slot-description-ref-macro-name (cdar l)))
	  (defstruct-put-macro mname 'defstruct-expand-ref-macro)
	  (defstruct-putprop mname (cons name (caar l)) 'defstruct-slot))
	(let ((type-description
		(get (defstruct-description-type)
		     'defstruct-type-description)))
	  (let ((code (defstruct-type-description-ref-expander))
		(n (defstruct-type-description-ref-no-args))
		(but-first (defstruct-description-but-first))
		(default-pointer (defstruct-description-default-pointer)))
	    (do ((args nil (cons (gensym) args))
		 (i n (1- i)))
		((< i 2)
		 ;;Last arg (if it exists) is name of structure,
		 ;; for documentation purposes.
		 (and (= i 1)
		      (setq args (cons name args)))
		 (let ((body (cons (if but-first
				       `(,but-first ,(car args))
				       (car args))
				   (cdr args))))
		   (and default-pointer
			(setq args `((,(car args) ,default-pointer)
				     &optional . ,(cdr args))))
		   (setq args (reverse args))
		   (setq body (reverse body))
		   (do ((l new-slots (cdr l))
			(mname))
		       ((null l))
		     (setq mname (defstruct-slot-description-ref-macro-name
				   (cdar l)))
		     #M ;;This must come BEFORE the defun. THINK!
		     (defstruct-put-macro mname 'defstruct-expand-ref-macro)
		     (let ((ref (lexpr-funcall
				  code
				  (defstruct-slot-description-number (cdar l))
				  description
				  body))
			   (ppss (defstruct-slot-description-ppss (cdar l))))
		       (push `(#+(or Franz Maclisp)
				defun #Q defsubst ,mname ,args
				,(if (null ppss) ref `(ldb ,ppss ,ref)))
			   returns))
		     (defstruct-putprop mname
					(cons name (caar l))
					'defstruct-slot))))))))
    returns))

(defun defstruct-expand-size-macro (x)
  (let ((description (get-defstruct-description (get (car x) 'defstruct-name))))
    (let ((type-description (get (defstruct-description-type)
				 'defstruct-type-description)))
      (funcall (defstruct-description-displace)
	       x
	       (+ (defstruct-description-size)
		  (defstruct-type-description-overhead))))))

(defun defstruct-expand-ref-macro (x)
  (let* ((pair (get (car x) 'defstruct-slot))
	 (description (get-defstruct-description (car pair)))
	 (type-description
	   (get (defstruct-description-type) 'defstruct-type-description))
	 (code (defstruct-type-description-ref-expander))
	 (n (defstruct-type-description-ref-no-args))
	 (args (reverse (cdr x)))
	 (nargs (length args))
	 (default (defstruct-description-default-pointer))
	 (but-first (defstruct-description-but-first)))
    (cond ((= n nargs)
	   (and but-first
		(rplaca args `(,but-first ,(car args)))))
	  ((and (= n (1+ nargs)) default)
	   (setq args (cons (if but-first
				`(,but-first ,default)
				default)
			    args)))
	  (t
	   (defstruct-error
	     "Wrong number of args to an accessor macro" x)))
    (let* ((slot-description 
	     (cdr (or (assq (cdr pair)
			    (defstruct-description-slot-alist))
		      (defstruct-error
			"This slot no longer exists in this structure"
			(cdr pair) 'in (car pair)))))
	    (ref (lexpr-funcall
		   code
		   (defstruct-slot-description-number)
		   description
		   (nreverse args)))
	    (ppss (defstruct-slot-description-ppss)))
      (funcall (defstruct-description-displace)
	       x
	       (if (null ppss)
		   ref
		   `(ldb ,ppss ,ref))))))

(defun defstruct-parse-setq-style-slots (l slots others x)
  (do ((l l (cddr l))
       (kludge (cons nil nil)))
      ((null l) kludge)
    (or (and (cdr l)
	     (symbolp (car l)))
	(defstruct-error
	  "Bad argument list to constructor or alterant macro" x))
    (defstruct-make-init-dsc kludge (car l) (cadr l) slots others x)))

(defun defstruct-make-init-dsc (kludge name code slots others x)
  (let ((p (assq name slots)))
    (if (null p)
	(if (memq name others)
	    (push (cons name code) (cdr kludge))
	    (defstruct-error
	      "Unknown slot to constructor or alterant macro" x))
	(let* ((slot-description (cdr p))
	       (number (defstruct-slot-description-number))
	       (ppss (defstruct-slot-description-ppss))
	       (dsc (assoc number (car kludge))))
	  (cond ((null dsc)
		 (setq dsc (list* number nil (make-empty) 0 0 nil))
		 (push dsc (car kludge))))
	  (cond ((null ppss)
		 (setf (car (cddr dsc)) code)
		 (setf (cadr dsc) t))
		(t (cond #-Franz
		         ((and (numberp ppss) (numberp code))
			  (setf (ldb ppss (cadr (cddr dsc))) -1)
			  (setf (ldb ppss (caddr (cddr dsc))) code))
			 (t
			  (push (cons ppss code) (cdddr (cddr dsc)))))
		   (or (eq t (cadr dsc))
		       (push name (cadr dsc)))))))))

(defun defstruct-code-from-dsc (dsc)
  (let ((code (car (cddr dsc)))
	(mask (cadr (cddr dsc)))
	(bits (caddr (cddr dsc))))
    (if (emptyp code)
	(setq code bits)
	(or (zerop mask)
	    (setq code (if (numberp code)
			   (boole 7 bits (boole 2 mask code))
			   (if (zerop (logand mask
					      (1+ (logior mask (1- mask)))))
			       (let ((ss (haulong (boole 2 mask (1- mask)))))
				 `(dpb ,(lsh bits (- ss))
				       ,(logior (lsh ss 6)
						(logand #o77
							(- (haulong mask) ss)))
				       ,code))
			       `(boole 7 ,bits (boole 2 ,mask ,code)))))))
    (do l (cdddr (cddr dsc)) (cdr l) (null l)
	(setq code `(dpb ,(cdar l) ,(caar l) ,code)))
    code))

(defun defstruct-expand-cons-macro (x)
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (get (defstruct-description-type)
				'defstruct-type-description))
	 (slot-alist (defstruct-description-slot-alist))
	 (cons-keywords (defstruct-type-description-cons-keywords))
	 inits kludge
	 (constructor-description 
	   (cdr (or (assq (car x) (defstruct-description-constructors))
		    (defstruct-error
		      "This constructor is no longer defined for this structure"
		      (car x) 'in (defstruct-description-name)))))
	 (aux nil)
	 (aux-init nil))
     (if (null constructor-description)
	 (setq kludge (defstruct-parse-setq-style-slots (cdr x)
							slot-alist
							cons-keywords
							x))
	 (prog (args l)
	       (setq kludge (cons nil nil))
	       (setq args (cdr x))
	       (setq l (car constructor-description))
	     R (cond ((null l)
		      (if (null args)
			  (return nil)
			  (go barf-tma)))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go O))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go A))
		     ((null args) (go barf-tfa)))
	       (defstruct-make-init-dsc kludge
					(pop l)
					(pop args)
					slot-alist
					cons-keywords
					x)
	       (go R)
	     O (and (null args) (go OD))
	       (pop l)
	       (cond ((null l) (go barf-tma))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go barf))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go barf-tma)))
	       (defstruct-make-init-dsc kludge
					(if (atom (car l)) (car l) (caar l))
					(pop args)
					slot-alist
					cons-keywords
					x)
	       (go O)
	    OD (pop l)
	       (cond ((null l) (return nil))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go barf))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go A)))
	       (or (atom (car l))
		   (defstruct-make-init-dsc kludge
					    (caar l)
					    (cadar l)
					    slot-alist
					    cons-keywords
					    x))
	       (go OD)
	     S (and (atom (cdr l)) (go barf))
	       (defstruct-make-init-dsc kludge
					(cadr l)
					`(list . ,args)
					slot-alist
					cons-keywords
					x)
	       (setq l (cddr l))
	       (and (null l) (return nil))
	       (and (atom l) (go barf))
	       (or (eq (car l) '&aux) (go barf))
	     A (pop l)
	       (cond ((null l) (return nil))
		     ((atom l) (go barf))
		     ((atom (car l))
		      (push (car l) aux)
		      (push (make-empty) aux-init))
		     (t
		      (push (caar l) aux)
		      (push (cadar l) aux-init)))
	       (go A)
	  barf (defstruct-error
		 "Bad format for defstruct constructor arglist"
		 `(,(car x) . ,(car constructor-description)))
      barf-tfa (defstruct-error "Too few arguments to constructor macro" x)
      barf-tma (defstruct-error "Too many arguments to constructor macro" x)))
     (do l slot-alist (cdr l) (null l)
	 (let* ((name (caar l))
		(slot-description (cdar l))
		(code (do ((aux aux (cdr aux))
			   (aux-init aux-init (cdr aux-init)))
			  ((null aux) (defstruct-slot-description-init-code))
			(and (eq name (car aux)) (return (car aux-init)))))
		(ppss (defstruct-slot-description-ppss)))
	   (or (and (emptyp code) (null ppss))
	       (let* ((number (defstruct-slot-description-number))
		      (dsc (assoc number (car kludge))))
		 (cond ((null dsc)
			(setq dsc (list* number nil (make-empty) 0 0 nil))
			(push dsc (car kludge))))
		 (cond ((emptyp code))
		       ((eq t (cadr dsc)))
		       ((null ppss)
			(and (emptyp (car (cddr dsc)))
			     (setf (car (cddr dsc)) code)))
		       ((memq name (cadr dsc)))
		       #-Franz
		       ((and (numberp ppss) (numberp code))
			(setf (ldb ppss (cadr (cddr dsc))) -1)
			(setf (ldb ppss (caddr (cddr dsc))) code))
		       (t
			(push (cons ppss code) (cdddr (cddr dsc)))))))))
     (selectq (defstruct-type-description-cons-flavor)
	      (:list
	       (do ((l nil (cons nil l))
		    (i (defstruct-description-size) (1- i)))
		   ((= i 0) (setq inits l)))
	       (do l (car kludge) (cdr l) (null l)
		   (setf (nth (caar l) inits)
			 (defstruct-code-from-dsc (car l)))))
	      (:alist
	       (setq inits (car kludge))
	       (do l inits (cdr l) (null l)
		   (rplacd (car l) (defstruct-code-from-dsc (car l)))))
	      (otherwise
	       (defstruct-error
		 "Unknown flavor to constructor macro expander"
		 (defstruct-description-type))))
     (funcall (defstruct-description-displace)
	      x (funcall (defstruct-type-description-cons-expander)
			 inits description (cdr kludge)))))

(defun defstruct-expand-alter-macro (x)
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (get (defstruct-description-type)
				'defstruct-type-description))
	 (ref-code (defstruct-type-description-ref-expander)))
    (or (= 1 (defstruct-type-description-ref-no-args))
	(defstruct-error
	  "Alterant macros cannot handle this defstruct type"
	  (defstruct-description-type)))
    (do ((l (car (defstruct-parse-setq-style-slots 
		   (cddr x)
		   (defstruct-description-slot-alist)
		   nil
		   x))
	    (cdr l))
	 (but-first (defstruct-description-but-first))
	 (body nil)
	 (var (gensym))
	 (vars nil)
	 (vals nil))
	((null l)
	 (funcall (defstruct-description-displace)
		  x
		  `((lambda (,var) 
		      . ,(if (null vars)
			     body
			     `(((lambda ,vars . ,body) . ,vals))))
		    ,(if but-first
			 `(,but-first ,(cadr x))
			 (cadr x)))))
      (let ((ref (funcall ref-code (caar l) description var)))
	(and (emptyp (car (cddr (car l))))
	     (setf (car (cddr (car l))) ref))
	(let ((code (defstruct-code-from-dsc (car l))))
	  (if (null (cdr l))
	      (push `(setf ,ref ,code) body)
	      (let ((sym (gensym)))
		(push `(setf ,ref ,sym) body)
		(push sym vars)
		(push code vals))))))))

(defmacro defstruct-define-type (type . options)
  (do ((options options (cdr options))
       (op) (args)
       (type-description (make-defstruct-type-description))
       (cons-expander nil)
       (ref-expander nil)
       (defstruct-expander nil))
      ((null options)
       (or cons-expander
	   (defstruct-error "No cons option in defstruct-define-type" type))
       (or ref-expander
	   (defstruct-error "No ref option in defstruct-define-type" type))
       `(progn 'compile
	       ,cons-expander
	       ,ref-expander
	       ,@(and defstruct-expander (list defstruct-expander))
	       (defprop ,type ,type-description defstruct-type-description)))
    (cond ((atom (setq op (car options)))
	   (setq args nil))
	  (t
	   (setq args (cdr op))
	   (setq op (car op))))
#Q AGAIN
    (selectq op
      (:cons
        (or (> (length args) 2)
	    (defstruct-error
	      "Bad cons option in defstruct-define-type"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (append-symbols type '-defstruct-cons)))
	  (or (= n 3)
	      (defstruct-error
		"Bad cons option in defstruct-define-type"
		(car options) 'in type))
	  (setf (defstruct-type-description-cons-flavor)
		#-LispM (cadr args)
		#+LispM (intern (string (cadr args)) si:pkg-user-package))
	  (setf (defstruct-type-description-cons-expander) name)
	  (setq cons-expander `(defun ,name ,(car args)
				 . ,(cddr args)))))
      (:ref
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad ref option in defstruct-define-type"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (append-symbols type '-defstruct-ref)))
	  (or (> n 2)
	      (defstruct-error
		"Bad ref option in defstruct-define-type"
		(car options) 'in type))
	  (setf (defstruct-type-description-ref-no-args) (- n 2))
	  (setf (defstruct-type-description-ref-expander) name)
	  (setq ref-expander `(defun ,name ,(car args)
				. ,(cdr args)))))
      (:overhead
        (setf (defstruct-type-description-overhead)
	      (if (null args)
		  (defstruct-error
		    "Bad option to defstruct-define-type"
		    (car options) 'in type)
		  (car args))))
      (:named
        (setf (defstruct-type-description-named-type)
	      (if (null args)
		  type
		  (car args))))
      (:keywords
        (setf (defstruct-type-description-cons-keywords) args))
      (:defstruct
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad defstruct option in defstruct-define-type"
	      (car options) 'in type))
	(let ((name (append-symbols type '-defstruct-expand)))
	  (setf (defstruct-type-description-defstruct-expander) name)
	  (setq defstruct-expander `(defun ,name . ,args))))
      (otherwise
       #Q (multiple-value-bind (new foundp)
	      (intern-soft op si:pkg-user-package)
	    (or (not foundp)
		(eq op new)
		(progn (setq op new) (go AGAIN))))
       (defstruct-error
	 "Unknown option to defstruct-define-type"
	 (car options) 'in type)))))

#Q
(defprop :make-array t :defstruct-option)

(defstruct-define-type :array
  #Q (:named :named-array)
  #Q (:keywords :make-array)
  (:cons
    (arg description etc) :alist
    #M etc		;ignored in MacLisp
    #F etc		;ignored in MacLisp
    #Q (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
				  description etc nil nil nil 1)
    #M (maclisp-array-for-defstruct arg description 't)
    #F (maclisp-array-for-defstruct arg description 't))
  (:ref
    (n description arg)
    description		;ignored
    #M `(arraycall t ,arg ,n)
    #F `(arraycall t ,arg ,n)
    #Q `(aref ,arg ,n)))

#Q
(defstruct-define-type :named-array
  (:keywords :make-array)
  :named (:overhead 1)
  (:cons
    (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,(1+ i)))
			       description etc nil t nil 1))
  (:ref (n description arg)
	description	;ignored
	`(aref ,arg ,(1+ n))))

(defstruct-define-type :fixnum-array
  #Q (:keywords :make-array)
  (:cons
    (arg description etc) :alist
    #M etc		;ignored in MacLisp
    #F etc		;ignored in MacLisp
    #Q (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
				  description etc 'art-32b nil nil 1)
    #M (maclisp-array-for-defstruct arg description 'fixnum)
    #F (maclisp-array-for-defstruct arg description 'fixnum))
  (:ref
    (n description arg)
    description		;ignored
    #M `(arraycall fixnum ,arg ,n)
    #F `(arraycall fixnum ,arg ,n)
    #Q `(aref ,arg ,n)))

(defstruct-define-type :flonum-array
  #Q (:keywords :make-array)
  (:cons
    (arg description etc) :alist
    #M etc		;ignored in MacLisp
    #F etc		;ignored in MacLisp
    #Q (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
				  description etc 'art-float nil nil 1)
    #M (maclisp-array-for-defstruct arg description 'flonum)
    #F (maclisp-array-for-defstruct arg description 'flonum))
  (:ref
    (n description arg)
    description		;ignored
    #M `(arraycall flonum ,arg ,n)
    #F `(arraycall flonum ,arg ,n)
    #Q `(aref ,arg ,n)))

#M
(defstruct-define-type :un-gc-array
  (:cons
    (arg description etc) :alist
    etc			;ignored
    (maclisp-array-for-defstruct arg description 'nil))
  (:ref
    (n description arg)
    description		;ignored
    `(arraycall nil ,arg ,n)))

#Q
(defstruct-define-type :array-leader
  (:named :named-array-leader)
  (:keywords :make-array)
  (:cons
    (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i)
				       `(store-array-leader ,v ,a ,i))
			       description etc nil nil t 1))
  (:ref
    (n description arg)
    description		;ignored
    `(array-leader ,arg ,n)))

#Q
(defstruct-define-type :named-array-leader
  (:keywords :make-array)
  :named (:overhead 1)
  (:cons
    (arg description etc) :alist
    (lispm-array-for-defstruct
      arg
      #'(lambda (v a i)
	  `(store-array-leader ,v ,a ,(if (zerop i)
					  0
					  (1+ i))))
      description etc nil t t 1))
  (:ref
    (n description arg)
    description		;ignored
    (if (zerop n)
	`(array-leader ,arg 0)
	`(array-leader ,arg ,(1+ n)))))

#Q
(defprop :times t :defstruct-option)

#Q
(defstruct-define-type :grouped-array
  (:keywords :make-array :times)
  (:cons
    (arg description etc) :alist
    (lispm-array-for-defstruct
      arg
      #'(lambda (v a i) `(aset ,v ,a ,i))
      description etc nil nil nil
      (or (cdr (or (assq ':times etc)
		   (assq ':times (defstruct-description-property-alist))))
	  1)))
  (:ref
    (n description index arg)
    description		;ignored
    (cond ((numberp index)
	   `(aref ,arg ,(+ n index)))
	  ((zerop n)
	   `(aref ,arg ,index))
	  (t `(aref ,arg (+ ,n ,index))))))

#Q
(defun lispm-array-for-defstruct (arg cons-init description etc type named-p leader-p times)
  (let ((p (cons nil nil))
	(no-op 'nil))
    (defstruct-grok-make-array-args
      (cdr (assq ':make-array (defstruct-description-property-alist)))
      p)
    (defstruct-grok-make-array-args
      (cdr (assq ':make-array etc))
      p)
    (and type (putprop p type ':type))
    (and named-p (putprop p `',(defstruct-description-name) ':named-structure-symbol))
    (putprop p
	     (let ((size (if named-p
			     (1+ (defstruct-description-size))
			     (defstruct-description-size))))
	       (if (numberp times)
		   (* size times)
		   `(* ,size ,times)))	     
	     (if leader-p ':leader-length ':dimensions))
    (or leader-p
	(let ((type (get p ':type)))
	  (or (atom type)
	      (not (eq (car type) 'quote))
	      (setq type (cadr type)))
	  (caseq type
	    ((nil art-q art-q-list))
	    ((art-32b art-16b art-8b art-4b art-2b art-1b art-string) (setq no-op '0))
	    ((art-float) (setq no-op '0.0))
	    (t (setq no-op (make-empty))))))
    (do ((creator
	   (let ((dims (remprop p ':dimensions)))
	     (do l (cdr p) (cddr l) (null l)
		 (rplaca l `',(car l)))
	     `(make-array ,(if (null dims) 0 (car dims)) ,@(cdr p))))
	 (var (gensym))
	 (set-ups nil (if (equal (cdar l) no-op)
			  set-ups
			  (cons (funcall cons-init (cdar l) var (caar l))
				set-ups)))
	 (l arg (cdr l)))
	((null l)
	 (if set-ups
	     `((lambda (,var)
		 ,@(nreverse set-ups)
		 ,var)
	       ,creator)
	     creator)))))

#Q
(defun defstruct-grok-make-array-args (args p)
  (let ((nargs (length args)))
    (if (and (not (> nargs 7))
	     (or (oddp nargs)
		 (do ((l args (cddr l)))
		     ((null l) nil)
		   (or (memq (car l) '(:area :type :displaced-to :leader-list
				       :leader-length :displaced-index-offset
				       :named-structure-symbol :dimensions
				       :length))
		       (return t)))))
	(do ((l args (cdr l))
	     (keylist '(:area :type :dimensions :displaced-to :old-leader-length-or-list
			:displaced-index-offset :named-structure-symbol)
		      (cdr keylist)))
	    ((null l)
	     (and (boundp 'compiler:compiler-warnings-context)
		  (boundp 'compiler:last-error-function)
		  (not (null compiler:compiler-warnings-context))
		  (compiler:barf args '|-- old style :MAKE-ARRAY constructor keyword argument|
				 'compiler:warn))
	     p)
	  (putprop p (car l) (car keylist)))
	(do ((l args (cddr l)))
	    ((null l) p)
	  (if (or (null (cdr l))
		  (not (memq (car l) '(:area :type :displaced-to :leader-list
				       :leader-length :displaced-index-offset
				       :named-structure-symbol :dimensions
				       :length))))
	      (defstruct-error
		"defstruct can't grok these make-array arguments"
		args))
	  (putprop p
		   (cadr l)
		   (if (eq (car l) ':length)
		       ':dimensions
		       (car l)))))))

#+(or Franz Maclisp)
(defun maclisp-array-for-defstruct (arg description type)
  (do ((creator `(array nil ,type ,(defstruct-description-size)))
       (var (gensym))
       (no-op (caseq type
		(fixnum 0)
		(flonum 0.0)
		((t nil) nil)))
       (set-ups nil (if (equal (cdar l) no-op)
			set-ups
			(cons `(store (arraycall ,type ,var ,(caar l))
				      ,(cdar l))
			      set-ups)))
       (l arg (cdr l)))
      ((null l)
       (if set-ups
	   `((lambda (,var)
	       ,@(nreverse set-ups)
	       ,var)
	     ,creator)
	   creator))))

#+PDP10
(defprop :sfa-function t :defstruct-option)

#+PDP10
(defprop :sfa-name t :defstruct-option)

#+PDP10
(defstruct-define-type :sfa
  (:keywords :sfa-function :sfa-name)
  (:cons
    (arg description etc) :alist
    (do ((creator `(sfa-create ,(or (cdr (or (assq ':sfa-function etc)
					     (assq ':sfa-function (defstruct-description-property-alist))))
				     `',(defstruct-description-name))
			       ,(defstruct-description-size)
			       ,(or (cdr (or (assq ':sfa-name etc)
					     (assq ':sfa-name (defstruct-description-property-alist))))
				    `',(defstruct-description-name))))
	 (l arg (cdr l))
	 (var (gensym))
	 (set-ups nil (if (null (cdar l))
			  set-ups
			  (cons `(sfa-store ,var ,(caar l)
					    ,(cdar l))
				set-ups))))
	((null l)
	 (if set-ups
	     `((lambda (,var)
		 ,@(nreverse set-ups)
		 ,var)
	       ,creator)
	     creator))))
  (:ref
    (n description arg)
    description		;ignored
    `(sfa-get ,arg ,n)))

#+(or Franz PDP10)
(defstruct-define-type :hunk
  (:named :named-hunk)
  (:cons
    (arg description etc) :list
    description		;ignored
    etc			;ignored
    (if arg
	#+PDP-10 `(hunk . ,(nconc (cdr arg) (ncons (car arg))))
	#+Franz `(hunk . ,arg)
	(defstruct-error "No slots in hunk type defstruct")))
  (:ref
    (n description arg)
    description		;ignored
    `(cxr ,n ,arg)))

#+(or Franz PDP10)
(defstruct-define-type :named-hunk
  :named (:overhead 1)
  (:cons
    (arg description etc) :list
    etc			;ignored
    (if arg
	#+PDP-10 `(hunk ',(defstruct-description-name)
	       . ,(nconc (cdr arg) (ncons (car arg))))
	#+Franz `(hunk ',(defstruct-description-name)
		       . ,arg)
	`(hunk ',(defstruct-description-name) nil)))
  (:ref
    (n description arg)
    description		;ignored
    (cond #+PDP-10 ((= n 0) `(cxr 0 ,arg))
	  (t `(cxr ,(1+ n) ,arg)))))

#+(or Franz PDP10 NIL )
(defstruct-define-type :vector
   #+Franz
   (:named :named-vector)
   (:cons
      (arg description etc) :list
      description		;ignored
      etc			;ignored
      `(vector ,@arg))
   (:ref
      (n description arg)
      description		;ignored
      `(vref ,arg ,n)))

#+Franz
(defstruct-define-type :named-vector
   :named
  (:cons
    (arg description etc) :list
    description		;ignored
    etc			;ignored
    `(let ((nv (vector ,@arg)))
	(vsetprop nv ',(defstruct-description-name))
	nv))
  (:ref
    (n description arg)
    description		;ignored
    `(vref ,arg ,n)))

(defstruct-define-type :list
  (:named :named-list)
  (:cons
    (arg description etc) :list
    description		;ignored
    etc			;ignored
    `(list . ,arg))
  (:ref
    (n description arg)
    description		;ignored
    #+Multics `(,(let ((i (\ n 4)))
		   (cond ((= i 0) 'car)
			 ((= i 1) 'cadr)
			 ((= i 2) 'caddr)
			 (t 'cadddr)))
		,(do ((a arg `(cddddr ,a))
		      (i (// n 4) (1- i)))
		     ((= i 0) a)))
    #-Multics `(nth ,n ,arg)))

(defstruct-define-type :named-list
  :named (:overhead 1)
  (:cons
    (arg description etc) :list
    etc			;ignored
    `(list ',(defstruct-description-name) . ,arg))
  (:ref
    (n description arg)
    description		;ignored
    #+Multics `(,(let ((i (\ (1+ n) 4)))
		   (cond ((= i 0) 'car)
			 ((= i 1) 'cadr)
			 ((= i 2) 'caddr)
			 (t 'cadddr)))
		,(do ((a arg `(cddddr ,a))
		      (i (// (1+ n) 4) (1- i)))
		     ((= i 0) a)))
    #-Multics `(nth ,(1+ n) ,arg)))

(defstruct-define-type :list*
  (:cons
    (arg description etc) :list
    description		;ignored
    etc			;ignored
    `(list* . ,arg))
  (:ref
    (n description arg)
    (let ((size (1- (defstruct-description-size))))
      #+Multics (do ((a arg `(cddddr ,a))
		     (i (// n 4) (1- i)))
		    ((= i 0)
		     (let* ((i (\ n 4))
			    (a (cond ((= i 0) a)
				     ((= i 1) `(cdr ,a))
				     ((= i 2) `(cddr ,a))
				     (t `(cdddr ,a)))))
		       (if (< n size) `(car ,a) a))))
      #-Multics (if (< n size)
		    `(nth ,n ,arg)
		    `(nthcdr ,n ,arg))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type list* cannot include another"
	   (defstruct-description-name)))
    nil))

(defstruct-define-type :tree
  (:cons
    (arg description etc) :list
    etc			;ignored
    (if (null arg) (defstruct-error
		     "defstruct cannot make an empty tree"
		     (defstruct-description-name)))
    (make-tree-for-defstruct arg (defstruct-description-size)))
  (:ref
    (n description arg)
    (do ((size (defstruct-description-size))
	 (a arg)
	 (tem))
	(())
      (cond ((= size 1) (return a))
	    ((< n (setq tem (// size 2)))
	     (setq a `(car ,a))
	     (setq size tem))
	    (t (setq a `(cdr ,a))
	       (setq size (- size tem))
	       (setq n (- n tem))))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type tree cannot include another"
	   (defstruct-description-name)))
    nil))

(defun make-tree-for-defstruct (arg size)
       (cond ((= size 1) (car arg))
	     ((= size 2) `(cons ,(car arg) ,(cadr arg)))
	     (t (do ((a (cdr arg) (cdr a))
		     (m (// size 2))
		     (n (1- (// size 2)) (1- n)))
		    ((zerop n)
		     `(cons ,(make-tree-for-defstruct arg m)
			    ,(make-tree-for-defstruct a (- size m))))))))

(defstruct-define-type :fixnum
  (:cons
    (arg description etc) :list
    etc			;ignored
    (and (or (null arg)
	     (not (null (cdr arg))))
	 (defstruct-error
	   "Structure of type fixnum must have exactly 1 slot to be constructable"
	   (defstruct-description-name)))
    (car arg))
  (:ref
    (n description arg)
    n			;ignored
    description		;ignored
    arg))

#+Multics
(defprop :external-ptr t :defstruct-option)

#+Multics
(defstruct-define-type :external
  (:keywords :external-ptr)
  (:cons (arg description etc) :alist
	 (let ((ptr (cdr (or (assq ':external-ptr etc)
			     (assq ':external-ptr
				   (defstruct-description-property-alist))
			     (defstruct-error
			       "No pointer given for external array"
			       (defstruct-description-name))))))
	   (do ((creator `(array nil external ,ptr ,(defstruct-description-size)))
	        (var (gensym))
	        (alist arg (cdr alist))
	        (inits nil (cons `(store (arraycall fixnum ,var ,(caar alist))
					 ,(cdar alist))
				 inits)))
	       ((null alist)
	        (if (null inits)
		    creator
		    `((lambda (,var) ,.inits ,var)
		      ,creator))))))
  (:ref (n description arg)
	description	;ignored
	`(arraycall fixnum ,arg ,n)))

(defvar *defstruct-examine&deposit-arg*)

(defun defstruct-examine (*defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list (defstruct-slot-description-ref-macro-name
		(defstruct-examine&deposit-find-slot-description
		  name slot-name))
	      '*defstruct-examine&deposit-arg*)))

(defvar *defstruct-examine&deposit-val*)

(defun defstruct-deposit (*defstruct-examine&deposit-val*
			  *defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list 'setf
	      (list (defstruct-slot-description-ref-macro-name
		     (defstruct-examine&deposit-find-slot-description
		       name slot-name))
		    '*defstruct-examine&deposit-arg*)
	      '*defstruct-examine&deposit-val*)))

#Q
(defun defstruct-get-locative (*defstruct-examine&deposit-arg*
			       name slot-name)
  (let ((slot-description (defstruct-examine&deposit-find-slot-description
			    name slot-name)))
    (or (null (defstruct-slot-description-ppss))
	(defstruct-error
	  "You cannot get a locative to a byte field"
	  slot-name 'in name))
    (eval (list 'locf
		(list (defstruct-slot-description-ref-macro-name)
		      '*defstruct-examine&deposit-arg*)))))

(defun defstruct-examine&deposit-find-slot-description (name slot-name)
  (let ((description (get-defstruct-description name)))
    (let ((slot-description
	    (cdr (or (assq slot-name (defstruct-description-slot-alist))
		     (defstruct-error
		       "No such slot in this structure"
		       slot-name 'in name))))
	  (type-description
	    (or (get (defstruct-description-type) 'defstruct-type-description)
		(defstruct-error
		  "Undefined defstruct type"
		  (defstruct-description-type)))))
      (or (= (defstruct-type-description-ref-no-args) 1)
	  (defstruct-error
	    "defstruct-examine and defstruct-deposit cannot handle structures of this type"
	    (defstruct-description-type)))
      slot-description)))

#+PDP10
(defprop defstruct
	 #.(and (status feature PDP10)
		(caddr (truename infile)))
	 version)

(sstatus feature defstruct)
EndOfFile
cat >  lisplib/prof.l  << 'EndOfFile'
(setq rcs-prof-
   "$Header: /usr/lib/lisp/RCS/prof.l,v 1.2 83/03/27 18:09:22 jkf Exp $")

;; prof
;; dynamic profiler for lisp	-[Tue Mar  8 08:15:47 1983 by jkf]-
;;
;; use:
;; -> (load 'prof)	;may not be necessary if autoloading is set up
;; -> (prof-start)	; start the profiling
;;   ... do what ever you want here, but don't do a (reset) since
;;   that turns off profiling
;; -> (prof-end)	; type this when you are finished
;; -> (prof-report)	; then type this, it will list each funtion
;;			; that was called, who called this function
;;			; and who this function calls.
;;
;; prof uses the evalhook/funcallhook mechanism to get control everytime
;; a function is called.  When it gets control, it knows what function
;; is doing the calling (via the Pcaller special variable) and what
;; function is being called.  It maintains a running count for each
;; function of the functions which call it and the number of time they
;; do the calling.
;;
;; When prof-end is called, the profiling is turned off and the
;; records kept are inverted, that is for each function it is calculated
;; how many times it calls other functions.  A list describing the results
;; is created and assigned to Profreport .  When prof-report is called,
;; this record (value of Profreport) is printed in a nice human
;; readable way.
;;
;; multiple profiling runs can be made one after the other and all
;; counts will revert to zero.
;;


(declare (special Pcalledby Pcalls Pfcns Pcaller evalhook funcallhook
		  Profreport Ptotcalls Pcallcnt Profile-in-progress))

;--- prof-start :: start profiling
;
;
(defun prof-start nil
   (setq Pcalledby (gensym)	; plist tag for who calls us
	 Pcalls (gensym) 	; plist tag for who we call
	 Pfcns (list '<top-lev>) ; list of all functions encountered
	 Pcaller '<top-lev>    ; function being evaluated
	 Pcallcnt (gensym)	; plist tag for tot number of times called
	 Ptotcalls 0		; total number of function calls
	 Profile-in-progress t) ; indicate we are begin done
   (sstatus translink nil)
   (setq evalhook 'Pevalhook* funcallhook 'Pfuncallhook*)
   (*rset t)
   (msg "profiling beginning" N)
   (sstatus evalhook t)
   t)

;--- prof-end :: turn off profiling and generate result list.
;
(defun prof-end nil
   ; turn off profiling
   (sstatus evalhook nil)
   (setq evalhook nil funcallhook nil)
   (*rset nil)
   (setq Profile-in-progress nil)
   (msg (length Pfcns) " different functions called" N)
   ; generate a profile report
   ; we already know for each function, who calls that function, now
   ; we want to figure out who each function calls
   (do ((xx Pfcns (cdr xx))
	(fcn))
       ((null xx))
       (setq fcn (car xx))
       (do ((called (get fcn Pcalledby) (cdr called))
	    (callcnt 0))
	   ((null called)
	    ; save total number of times this function was called
	    (putprop fcn callcnt Pcallcnt)
	    (setq Ptotcalls (+ callcnt Ptotcalls)))
	   ; keep count of the number of time we've been called
	   (setq callcnt (+ (cdar called) callcnt))
	   ; update data on caller.
	   (putprop (caar called)
		    (cons (cons fcn (cdar called))
			  (get (caar called) Pcalls))
		    Pcalls)))

   (msg Ptotcalls " function calls made" N)
   
   ; sort by total calls to function
   (setq Pfcns (sort Pfcns 'totcallsort))

   ; generate report list, really a list of lists each one with this
   ; form:
   ;    function-name  info who-called-it number-of-times-called who-it-called
   ;
   ; the car of the report form is the total number of function calls made
   (do ((rep nil)
	(xx Pfcns (cdr xx)))
       ((null xx)(setq Profreport (cons Ptotcalls rep)))
       (setq rep (cons (list (car xx)
			     (get (car xx) 'fcn-info)
			     (get (car xx) Pcalledby)
			     (get (car xx) Pcallcnt)
			     (get (car xx) Pcalls))
		       rep)))
   'done)

(declare (special poport))

;--- prof-report :: generate a human readable version of prof report
; input: Profreport (global) : variable set by (prof-end)
;
(defun prof-report (&optional (filename nil file-p))
   (if Profile-in-progress
      then (msg "[prof-end]" N)
	   (prof-end))
   (let ((totcalls (car Profreport))
	 (poport poport))
      (cond (file-p (setq poport (outfile filename))))
      (do ((xx (cdr Profreport) (cdr xx))
	   (name ) (info) (calledby) (calls) (callcnt))
	  ((null xx))
	  (setq name     (caar xx)
		info     (cadar xx)
		calledby (caddar xx)
		callcnt  (cadddar xx)
		calls    (caddddar xx))
	  (msg ":: " name " ")
	  (pctprint callcnt totcalls)
	  (If info then (msg " - " (cutatblank (cadr info))))
	  (msg N)
	  (If calledby
	     then (msg "Called by:" N)
		  (do ((yy (sort calledby 'lesscdr) (cdr yy)))
		      ((null yy))
		      (msg "	" (cdar yy) " :: " (caar yy) N)))
	  (If calls
	     then (msg " Calls: " N)
		  (do ((yy (sort calls 'lesscdr) (cdr yy)))
		      ((null yy))
		      (msg "	" (cdar yy) " :: " (caar yy) N)))
	  (msg N N))
      (cond (file-p (close poport)))
      nil))


;--- totcallsort :: sort by number of calls and then alphabetically
;
; this is the predicate used when sorting the list of functions
; called during the profiling run.
;
(defun totcallsort (x y)
   (let ((xc (get x Pcallcnt))
	 (yc (get y Pcallcnt)))
      (If (< xc yc)
	 thenret
       elseif (= xc yc)
	 then (alphalessp x y)
	 else nil)))

;--- lesscdr :: sort by decreasing cdr's
;
(defun lesscdr (x y)
   (> (cdr x) (cdr y)))

;--- pctprint :: print fraction and then percentage
;
(defun pctprint (this tot)
   (msg this "/" tot " " (quotient (* this 100) tot) "% "))

;--- cutatblank :: cut off a string at the first blank
;
(defun cutatblank (str)
   (do ((i 1 (1+ i)))
       ((> i 50) str)
       (If (= (substringn str i 0) #\sp)
	   then (return (substring str 1 i)))))


;--- Pfuncall-evalhook* :: common code to execute when function called.
;
; this function is called whenever a funcallhook or evalhook is taken.
; arguments are the form being evaluated and the type of the form
; which is either eval or funcall.  The difference is that a funcall's
; arguments are already evaluated.  This makes no difference to us
; but it will effect how the instruction is restarted.
;
(defun Pfuncall-evalhook* (form type)
   (let (name rcd (Pcaller Pcaller))
      (If (and (dtpr form) (symbolp (setq name (car form))))
	 then (If (setq rcd (get name Pcalledby))
		 then (let ((rent (assq Pcaller rcd)))
			 (If rent
			    then (rplacd rent (1+ (cdr rent)))
			    else (putprop name
					  (cons (cons Pcaller 1)
						rcd)
					  Pcalledby)))
		 else ; function hasn't been called before, set up a
		      ; record and add its name to the function list
		      (putprop name (ncons (cons Pcaller 1)) Pcalledby)
		      (setq Pfcns (cons name Pfcns)))
	      (setq Pcaller name))
      ; now continue executing the function
      (Pcontinue-evaluation form type)))

			      


;; the functions below are taken from /usr/lib/lisp/step.l and modified
; slightly (addition of P to name)

;--- Pfuncallhook* 
;
; automatically called when a funcall is done and funcallhook*'s 
; value is the name of this function (Pfuncallhook*).  When this is
; called, a function with n-1 args is being funcalled, the args
; to the function are (arg 1) through (arg (sub1 n)), the name of
; the function is (arg n)
;
(defun Pfuncallhook* n
  (let ((name (arg n))
	(args (listify (sub1 n))))
       (Pfuncall-evalhook* (cons name args) 'funcall)))

;--- Pevalhook* 
;
; called whenever an eval is done and evalhook*'s value is the 
; name of this function (Pevalhook*).  arg is the thing being
; evaluated.
;
(defun Pevalhook* (arg)
  (Pfuncall-evalhook* arg 'eval))

(defun Pcontinue-evaluation (form type)
  (cond ((eq type 'eval) (evalhook form 'Pevalhook* 'Pfuncallhook*))
	(t (funcallhook form 'Pfuncallhook* 'Pevalhook*))))
EndOfFile
cat >  lisplib/hash.l  << 'EndOfFile'
(setq rcs-hash-
   "$Header: hash.l,v 1.2 85/03/24 11:36:16 sklower Exp $")

;                Aug 5, 1982
; (c) copyright 1982, Massachusetts Institute of Technology
;
;   Hash tables are basically just fast property lists. There are much the
; same access functions: puthash, gethash, and remhash. The syntax is 
; different though. For small lists property lists are probably what you 
; want but when the lists start to become large hash tables become
; infinitely better than property lists.

;; Current bugs:  hash-table-rehash and the equal version need to be 
;;		  rewritten.  There is no reason to write the array twice.

;   Note very carefully that the syntax is <puthash key value hash-table>,
; <gethash key hash-table>, and <remhash key hash-table>.

;   Before hash tables are used they have to be made i.e. you first do
; (setq myhash (make-hash-table)) then (puthash 'name 'joe myhash).
; Make-hash-table takes several alternating keywords and arguments
; the only one of which you will probably use is :size. So 
; (setq otherhash (make-hash-table ':size 20)) will make otherhash a
; hash table of length 20. If you know what the length of the hash table
; will be and it is greater than about 20 it is a good idea to specify
; the length so that hash-table-rehash will not need to be called.
; This will speed up puthashing considerably especially when the hash
; table is very large.
;   Keys must be eq, equal will not work.

#+Franz (environment-maclisp)

(defstruct (hash-table (:constructor make-hash-table-internal)
		       :named)
  (real-hash-table (new-vector 17)) ;where entries are stored
  (hash-table-fullness 0)      ; how many entries in table
  (rehash-after-n-misses 4)    ; when puthashing you rehash the table
                               ; if you miss this many times
  (hash-table-size 17)         ; how big the vector is
  (hash-table-rehash-size 1.5) ; factor to multiply by current size 
                               ; to the get new size of the vector
  (hash-table-rehash-function 'hash-table-rehash))

;   Make-hash-table makes a hash table. The vector that all the information
; is stored in is made nmiss larger than the apparent size of the hash
; table so that if you hash to a number close to the size of the table
; you do not miss right off the table. So that for example if you
; hash to the last element of the table and miss you are not aff the table.

(defun make-hash-table (&rest options &aux (size 8) (rhf 'hash-table-rehash)
			                   (rhs 1.5) (nmisses 4))
  (loop for (key option) on options by #'cddr
	do (selectq key
		    (:size (setq size option))
		    (:rehash-function (setq rhf option))
		    (:rehash-size (setq rhs option))
		    (otherwise
		     (ferror () "~S is not a valid hash table option"
			     key))))
      (setq size (hash-table-good-size (* size 2)))
      (make-hash-table-internal
         real-hash-table (new-vector (+ size nmisses))
	 hash-table-size size
	 rehash-after-n-misses nmisses
	 hash-table-rehash-size rhs
	 hash-table-rehash-function rhf))

(defun hash-table-good-size (size)
  (setq size (max (fix size) 17))        ;minimum size is 17
  (or (oddp size) (setq size (1+ size))) ; make it odd
  (do ()
      ((and (not (zerop (\ size 3)))     ; make it a semi-prime number
	    (not (zerop (\ size 5)))
	    (not (zerop (\ size 7))))
       size)
      (setq size (+ size 2))))

;; Using conses instead of putting increasing the size of the data table
;; by a factor of two, decreases the amount of storage required for a 
;; partially full hash table but can adversely affect the paging and 
;; caching behavior of the hash table.  Sometime, should meter this 
;; difference.  (A compactifying garbage collector could help.)

(defmacro make-hash-element (key value)	; creates a hash element
  `(cons ,key ,value))

(defmacro hash-key (element)	; the key given a hash element
  `(car ,element)) 

(defmacro hash-value (element)	; the value of a hash element
  `(cdr ,element))

(defmacro si:hash-code (hash-table key)	;hash code for key
  `(\ (maknum ,key) (hash-table-size ,hash-table)))

;   Gethash either returns the value associated with that key in that 
; hash table or nil if there is none.

(defun gethash (key hash-table &aux position-value)
  (do ((try-position (si:hash-code hash-table key) (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n)) 
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n) nil) ;it is not there so just return nil
    (cond ((eq key
	       (hash-key (setq position-value
			       (vref real-hash-table try-position))))
	     (return (hash-value position-value))))))

(eval-when (compile load eval)
  (defsetf gethash (e v) `(puthash ,(cadr e) ,v ,(caddr e))))

;   Puthash inserts a hash-element for the given key and value in the
; hash table that is passed to it. If the key already exists in the hash 
; table the value of that key is replaced by the new value. If it finds an
; empty space it adds a hash-element for that key and value into that 
; space and increments hash-table-fullness by one. If it cannot find
; the key or an empty space in four tries then it calls rehash on the
; hash table and tries again. 

(declare (localf puthash-internal))

(defun puthash (key value hash-table)
  (puthash-internal key value hash-table nil))

(defun swaphash (key value hash-table)
  (puthash-internal key value hash-table t))

(defun puthash-internal (key value hash-table swap?)
  (do ((try-position (si:hash-code hash-table key) (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n))
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n)  ;if cannot find a place in n tries then rehash     
       (funcall (hash-table-rehash-function hash-table)
		hash-table (hash-table-rehash-size hash-table))
       (puthash key value hash-table))
    (cond ((or (eq (hash-key (vref real-hash-table try-position))
		   key)
	       (and (null (vref real-hash-table try-position))
		    (setf (hash-table-fullness hash-table)
			    (1+ (hash-table-fullness hash-table)))))
	   (return
	    (prog1 (if swap? (hash-value (vref real-hash-table try-position))
		       value)
		   (setf (vref real-hash-table try-position)
			 (make-hash-element key value))))))))

;   Remhash removes the hash-element associated with the given key from
; the hash table that is passed to it. If it finds the element and removes
; it then it returns the key. If it cannot find the element then it returns
; nil.

(defun remhash (key hash-table)
  (do ((try-position (si:hash-code hash-table key) (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n))
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n) nil)   ;not in the hash table return nil
    (cond ((eq (hash-key (vref real-hash-table try-position)) key)
	   (setf (vref real-hash-table try-position) nil)
	   (return key))))) ;return the key if found and removed

;    Hash-table-rehash first saves the contents of the current hash table
; in a temporary vector then puthashes the elements of this temporary vector
; into the original hash-table after making it larger by a factor of
; the variable grow.

(defun hash-table-rehash (hash-table grow)
  (let* ((real-hash-table  (real-hash-table hash-table))
	 (nmisses (rehash-after-n-misses hash-table))
	 (new-size (+ nmisses
		      (hash-table-good-size (times grow
					      (hash-table-size hash-table)))))
	 (j 0)
	 (temp-array (new-vector new-size)))
    (do ((current-position 0 (1+ current-position))
	 (old-size (+ (hash-table-size hash-table) nmisses)))
	((>= current-position old-size))
	(let ((current-hash-element (vref real-hash-table current-position)))
	  (cond ((null current-hash-element))
		(t (setf (vref temp-array j) current-hash-element)
		   (setq j (1+ j))))))
    (cond ((not (= grow 1)) ;if the hash table has grown
           (setf (real-hash-table hash-table) (new-vector new-size))
	   (setf (hash-table-fullness hash-table) 0)
	   (setf (hash-table-size hash-table) (- new-size nmisses))))
    (do ((position 0 (1+ position))) ;add old values to new table
	((= position j))
	(puthash (hash-key (vref temp-array position))
		 (hash-value (vref temp-array position))
		 hash-table))))

(defun si:lookhash (hash-table)
  (let ((real-hash-table (real-hash-table hash-table)))
    (loop for num from 0 to (1- (vsize real-hash-table))
	  collect (vref real-hash-table num))))

(defun maphash (func hash-table)
  (let ((real-hash-table (real-hash-table hash-table)))
    (loop for num from 0 to (1- (vsize real-hash-table))
	  with keyword and value
	  do (setq keyword (vref real-hash-table num))
	  unless (null keyword)
	  do (progn (setq value (cdr keyword)
			  keyword (car keyword))
		    (funcall func keyword value)))))

;; SXHASH
;;  Sigh, this also comes from the LISP machine

(defun sxhash (x)
  (cond ((symbolp x)
	 (sxhash-string (get_pname x)))
	((stringp x)
	 (sxhash-string x))
	((eq (typep x) 'fixnum)
	 (if (minusp x)
	     (logxor x #o-1777777777)
	     x))
	((dtpr x)
	 (do ((rot 4)
	      (hash 0)
	      (y))
	     ((atom x)
	      (if (not (null x))
		  (setq hash (logxor (rot (sxhash x) (- rot 4)) hash)))
	      (if (minusp hash)
		  (logxor hash #o-1777777777)
		  hash))
	   (setq y (pop x))
	   (if (>= (setq rot (+ rot 7)) 24)
	       (setq rot (- rot 24)))
	   (setq hash (logxor (rot (cond ((symbolp y)
					  (sxhash-string (get_pname y)))
					 ((stringp y)
					  (sxhash-string y))
					 ((eq (typep y) 'fixnum)
					  y)
					 (t (sxhash y)))
				   rot)
			      hash))))
	((bigp x)
	 (sxhash (bignum-to-list x)))
	((floatp x)
	 (fix x))
	(t 0)))

(defun sxhash-string (string)
  (do ((i 1 (1+ i))
       (n (flatc string))
       (hash 0))
    ((> i n)
     (if (minusp hash)
	 (logxor hash #o-1777777777)
	 hash))
    (setq hash (rot (logxor (getcharn string i) #o177) 7))))

;; Equal hash tables

;; Notice the slots are exactly the same as in hash-table so we use the same
;; macros.

(defstruct (equal-hash-table (:constructor make-equal-hash-table-internal)
			     :named)
  (real-hash-table (new-vector 17)) ;where entries are stored
  (hash-table-fullness 0)      ; how many entries in table
  (rehash-after-n-misses 4)    ; when puthashing you rehash the table
                               ; if you miss this many times
  (hash-table-size 17)         ; how big the vector is
  (hash-table-rehash-size 1.5) ; factor to multiply by current size 
                               ; to the get new size of the vector
  (hash-table-rehash-function 'equal-hash-table-rehash))

;   Make-hash-table makes a hash table. The vector that all the information
; is stored in is made nmiss larger than the apparent size of the hash
; table so that if you hash to a number close to the size of the table
; you do not miss right off the table. So that for example if you
; hash to the last element of the table and miss you are not aff the table.

(defun make-equal-hash-table (&rest options &aux (size 8)
				           (rhf 'hash-table-rehash)
			                   (rhs 1.5) (nmisses 4))
  (loop for (key option) on options by #'cddr
	do (selectq key
		    (:size (setq size option))
		    (:rehash-function (setq rhf option))
		    (:rehash-size (setq rhs option))
		    (otherwise
		     (ferror () "~S is not a valid hash table option"
			     key))))
      (setq size (hash-table-good-size (* size 2)))
      (make-equal-hash-table-internal
         real-hash-table (new-vector (+ size nmisses))
	 hash-table-size size
	 rehash-after-n-misses nmisses
	 hash-table-rehash-size rhs
	 hash-table-rehash-function rhf))

;   Gethash-equal either returns the value associated with that key in that 
; hash table or nil if there is none.

(defun gethash-equal (key hash-table &aux position-value)
  (do ((try-position (remainder (sxhash key) (hash-table-size  hash-table))
		     (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n)) 
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n) nil) ;it is not there so just return nil
      (cond ((equal key
		    (hash-key (setq position-value
				    (vref real-hash-table try-position))))
	     (return (hash-value position-value))))))

(eval-when (eval compile load)
  (defsetf gethash-equal (e v) `(puthash-equal ,(cadr e) v ,(caddr e))))

;   Puthash inserts a hash-element for the given key and value in the
; hash table that is passed to it. If the key already exists in the hash 
; table the value of that key is replaced by the new value. If it finds an
; empty space it adds a hash-element for that key and value into that 
; space and increments hash-table-fullness by one. If it cannot find
; the key or an empty space in four tries then it calls rehash on the
; hash table and tries again. 

(declare (localf puthash-equal-internal))

(defun puthash-equal (key value hash-table)
  (puthash-equal-internal key value hash-table nil))

(defun swaphash-equal (key value hash-table)
  (puthash-equal-internal key value hash-table t))

(defun puthash-equal-internal (key value hash-table swap?)
  (do ((try-position (remainder (sxhash key) (hash-table-size hash-table))
		     (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n))
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n)  ;if cannot find a place in n tries then rehash     
       (funcall (hash-table-rehash-function hash-table)
		hash-table (hash-table-rehash-size hash-table))
       (puthash-equal key value hash-table))

      (cond ((or (equal (hash-key (vref real-hash-table try-position))
		     key)
		 (and (null (vref real-hash-table try-position))
		      (setf (hash-table-fullness hash-table)
			    (1+ (hash-table-fullness hash-table)))))
	     (return
	      (prog1 (if swap? (hash-value
				(vref real-hash-table try-position))
			 value)
		     (setf (vref real-hash-table try-position)
			   (make-hash-element key value))))))))


;   Remhash removes the hash-element associated with the given key from
; the hash table that is passed to it. If it finds the element and removes
; it then it returns the key. If it cannot find the element then it returns
; nil.

(defun remhash-equal (key hash-table)
  (do ((try-position (remainder (sxhash key) (hash-table-size hash-table))
		     (1+ try-position))
       (n (rehash-after-n-misses hash-table) (1- n))
       (real-hash-table (real-hash-table hash-table)))
      ((zerop n) nil)   ;not in the hash table return nil
      (cond ((equal (hash-key (vref real-hash-table try-position)) key)
	     (setf (vref real-hash-table try-position) nil)
	     (return key))))) ;return the key if found and removed


;    Hash-table-rehash first saves the contents of the current hash table
; in a temporary vector then puthashes the elements of this temporary vector
; into the original hash-table after making it larger by a factor of
; the variable grow.

(defun equal-hash-table-rehash (hash-table grow)
  (let* ((real-hash-table  (real-hash-table hash-table))
	 (nmisses (rehash-after-n-misses hash-table))
	 (new-size (+ nmisses
		      (hash-table-good-size (times grow
					      (hash-table-size hash-table)))))
	 (j 0)
	 (temp-array (new-vector new-size)))
    (do ((current-position 0 (1+ current-position))
	 (old-size (+ (hash-table-size hash-table) nmisses)))
	((>= current-position old-size))
	(let ((current-hash-element (vref real-hash-table current-position)))
	  (cond ((null current-hash-element))
		(t (setf (vref temp-array j) current-hash-element)
		   (setq j (1+ j))))))
    (cond ((not (= grow 1)) ;if the hash table has grown
           (setf (real-hash-table hash-table) (new-vector new-size))
	   (setf (hash-table-fullness hash-table) 0)
	   (setf (hash-table-size hash-table) (- new-size nmisses))))
    (do ((position 0 (1+ position))) ;add old values to new table
	((= position j))
	(puthash (hash-key (vref temp-array position))
		 (hash-value (vref temp-array position))
		 hash-table))))

(defun maphash-equal (func hash-table)
  (let ((real-hash-table (real-hash-table hash-table)))
    (loop for num from 0 to (1- (vsize real-hash-table))
	  with keyword and value
	  do (setq keyword (vref real-hash-table num))
	  unless (null keyword)
	  do (progn (setq value (cdr keyword)
			  keyword (car keyword))
		    (funcall func keyword value)))))

(sstatus feature hash-tables)
EndOfFile
cat >  lisplib/flavorm.l  << 'EndOfFile'
;; (c) Copywrite 1983, Massachusetts Institute of Technology
(setq rcs-flavorm-
   "$Header: flavorm.l,v 1.2 85/03/24 11:25:34 sklower Exp $")

;; This file contains some of the support macros that are need by the
;; flavor system.

(environment-maclisp)
(declare (macros t))

; The data-structure on the FLAVOR property of a flavor-name
(DEFSTRUCT (FLAVOR :NAMED)
  FLAVOR-BINDINGS		;List of locatives to instance variable
				; internal value cells.  MUST BE CDR-CODED!!
				;Fixnums can also appear.  They say to skip
				;whatever number of instance variable slots.
  FLAVOR-METHOD-HASH-TABLE	;The hash table for methods of this flavor.
				; NIL means method-combination not composed yet.
  FLAVOR-NAME			;Symbol which is the name of the flavor.
				; This is returned by TYPEP.
  FLAVOR-LOCAL-INSTANCE-VARIABLES	;Names and initializations,
					; does not include inherited ones.
  FLAVOR-ALL-INSTANCE-VARIABLES	;Just names, only valid when "flavor 
				; combination" composed.  Corresponds directly
				; to FLAVOR-BINDINGS and the instances.
  FLAVOR-METHOD-TABLE		;Defined below.
  ;; End of locations depended on in many other files.
  FLAVOR-DEPENDS-ON		;List of names of flavors incorporated into this flavor.
  FLAVOR-DEPENDED-ON-BY		;List of names of flavors which incorporate this one.
				;The above are only immediate dependencies.
  FLAVOR-INCLUDES		;List of names of flavors to include at the end
				; rather than as immediate depends-on's.
  FLAVOR-DEPENDS-ON-ALL		;Names of all flavors depended on, to all levels, including
				; this flavor itself.  NIL means flavor-combination not
				; composed yet.  This is used by TYPEP of 2 arguments.
  (FLAVOR-WHICH-OPERATIONS NIL)	;List of operations handled, created when needed.
				; This is NIL if it has not been computed yet.
  ;; Redundant copy of :DEFAULT-HANDLER property, for speed in calling it.
  (FLAVOR-DEFAULT-HANDLER NIL)
  (FLAVOR-GETTABLE-INSTANCE-VARIABLES NIL)
  (FLAVOR-SETTABLE-INSTANCE-VARIABLES NIL)
  (FLAVOR-INITABLE-INSTANCE-VARIABLES NIL)
				;Alist from init keyword to name of variable
  (FLAVOR-INIT-KEYWORDS NIL)			;option
  (FLAVOR-PLIST NIL)		;Esoteric things stored here as properties
				;Known: :ORDERED-INSTANCE-VARIABLES, :DEFAULT-HANDLER
				; :OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES, :ACCESSOR-PREFIX,
				; :REQUIRED-INSTANCE-VARIABLES, :REQUIRED-METHODS,
				; :REQUIRED-FLAVORS, :SELECT-METHOD-ORDER,
				; :DEFAULT-INIT-PLIST, :DOCUMENTATION, :NO-VANILLA-FLAVOR
				; :GETTABLE-INSTANCE-VARIABLES :SETTABLE-INSTANCE-VARIABLES
				; ADDITIONAL-INSTANCE-VARIABLES
				; COMPILE-FLAVOR-METHODS
				; MAPPED-COMPONENT-FLAVORS
				; INSTANCE-VARIABLE-INITIALIZATIONS
				; ALL-INITABLE-INSTANCE-VARIABLES
				; REMAINING-DEFAULT-PLIST
				; REMAINING-INIT-KEYWORDS
				;The convention on these is supposed to be that
				;ones in the keyword packages are allowed to be
				;used by users.
				;Some of these are not used by the flavor system, they are
				;just remembered on the plist in case anyone cares.  The
				;flavor system does all its handling of them during the
				;expansion of the DEFFLAVOR macro.
  )

(defsubst instancep (x)
  (and (fclosurep x) (eq (fclosure-function x) #'flavor-dispatch)))

(defvar self ()
  "Self referential pointer for flavors")

(defmacro send (object message &rest args) 
  (if (eq object 'self)
      `(send-self ,message ,@args)
      `(send-internal ,object ,message ,@args)))

(defmacro lexpr-send (object &rest args)
  (if (eq object 'self)
      `(lexpr-send-self ,@args)
      `(lexpr-funcall #'send-internal ,object ,@args)))

;; These two functions are used when sending a message to yourself, for 
;; extra efficiency.  They avoid the variable unbinding and binding 
;; required when entering a closure.
(defmacro send-self (message &rest args)
  `(funcall (or (gethash ,message (flavor-method-hash-table .own-flavor.))
		(flavor-default-handler .own-flavor.))
	    ,message . ,args))
(defmacro funcall-self (&rest args) `(send-self . ,args))

(defmacro lexpr-send-self (message &rest args)
  `(lexpr-funcall (or (gethash ,message
			       (flavor-method-hash-table .own-flavor.))
		      (flavor-default-handler .own-flavor.))
		  ,message . ,args))
(defmacro lexpr-funcall-self (&rest args) `(lexpr-send-self . ,args))

(defsetf send (e v)
  (if (or (atom (caddr e))
	  (neq (car (caddr e)) 'quote))
      (ferror () "Don't know how to setf this ~S" e))
  (cond ((eq (cadr (caddr e)) ':get)
	 `(send ,(cadr e) ':putprop ,v ,(cadddr e)))
	(t
	 `(send ,(cadr e) ',(intern (format () ":set-~A"
					    (remove-colon (cadr (caddr e)))))
			  ,v))))

(putprop 'flavorm t 'version)
EndOfFile
cat >  lisplib/lmhacks.l  << 'EndOfFile'
(setq rcs-lmhacks-
   "$Header: lmhacks.l,v 1.2 83/08/15 22:32:31 jkf Exp $")

;;  This file contains miscellaneous functions and macros that 
;;  ZetaLisp users often find useful


;;;  (c) Copyright 1982 Massachusetts Institute of Technology 

;; This is a simple multiple value scheme based on the one implemented
;; in MACLISP.  It doesn't clean up after its self properly, so if
;; you ask for multiple values, you will get them regardless of whether
;; they are returned.

(environment-maclisp (compile eval) (files struct flavorm))

(declare (macros t))

(defvar si:argn () "Number of arguments returned by last values")
(defvar si:arg2 () "Second return value")
(defvar si:arg3 () "Third return value")
(defvar si:arg4 () "Fourth return value")
(defvar si:arg5 () "Fifth return value")
(defvar si:arg6 () "Sixth return value")
(defvar si:arg7 () "Seventh return value")
(defvar si:arg8 () "Eigth return value")
(defvar si:arglist () "Additional return values after the eigth")

(defvar si:return-registers
  '(si:arg2 si:arg3 si:arg4 si:arg5 si:arg6 si:arg7 si:arg8))

(defmacro values (&rest values)
  `(prog2 (setq si:argn ,(length values))
	  ,(first values)
	  ,@(do ((vals (cdr values) (cdr vals))
		 (regs si:return-registers (cdr regs))
		 (forms))
		(nil)
	      (cond ((null vals)
		     (return (reverse forms)))
		    ((null regs)
		     (return
		      `(,@(reverse forms)
			(setq si:arglist (list ,@vals)))))
		    (t (push `(setq ,(car regs) ,(car vals))
			     forms))))))

(defun values-list (list)
  (setq si:argn (length list))
  (do ((vals (cdr list) (cdr vals))
       (regs si:return-registers (cdr regs)))
      ((null regs)
       (if (not (null vals))
	   (setq si:arglist vals))
       (car list))
    (set (car regs) (car vals))))

(defmacro multiple-value (vars form)
  `(progn
     ,@(if (not (null (car vars)))
	  `((setq ,(car vars) ,form)
	    (if (< si:argn 1) (setq ,(car vars) nil)))
	  `(,form))
     ,@(do ((vs (cdr vars) (cdr vs))
	    (regs si:return-registers (cdr regs))
	    (i 2 (1+ i))
	    (forms))
	   (nil)
	 (cond ((null vars)
		(return (reverse forms)))
	       ((null regs)
		(return
		 (do ((vs vs (cdr vs)))
		     ((null vs) (nreverse forms))
		   (and (not (null (car vs)))
			(push
			 `(setq ,(car vs)
				(prog1
				 (if (not (> ,i si:argn))
				     (car si:arglist))
				 (setq si:arglist (cdr si:arglist))))
			 forms)))))
	       ((not (null (car vs)))
		(push `(setq ,(car vs) (if (not (> ,i si:argn)) ,(car regs))
			     ,(car regs) nil)
		      forms))))))

(defmacro multiple-value-bind (vars form &rest body)
  `(let ,vars
	(multiple-value ,vars ,form)
	,@body))

(defmacro multiple-value-list (form)
  `(multiple-value-list-1 ,form))

(defun multiple-value-list-1 (si:arg1)
  (cond ((= 0 si:argn) ())
	((= 1 si:argn)
	 (list si:arg1))
	((= 2 si:argn)
	 (list si:arg1 si:arg2))
	((= 3 si:argn)
	 (list si:arg1 si:arg2 si:arg3))
	((= 4 si:argn)
	 (list si:arg1 si:arg2 si:arg3 si:arg4))
	((= 5 si:argn)
	 (list si:arg1 si:arg2 si:arg3 si:arg4 si:arg5))
	((= 6 si:argn)
	 (list si:arg1 si:arg2 si:arg3 si:arg4 si:arg5 si:arg6))
	((= 7 si:argn)
	 (list si:arg1 si:arg2 si:arg3 si:arg4 si:arg5 si:arg6
	       si:arg7))
	((= 8 si:argn)
	 (list si:arg1 si:arg2 si:arg3 si:arg4 si:arg5 si:arg6
	       si:arg7 si:arg8))
	((> si:argn 8)
	 (rplacd (nthcdr (- si:argn 9) si:arglist) nil)
	 (list* si:arg1 si:arg2 si:arg3 si:arg4 si:arg5 si:arg6
		si:arg7 si:arg8 si:arglist))
	(t (ferror () "Internal error, si:argn = ~D" si:argn))))

(defun union (set &rest others)
  (loop for s in others
	do (loop for elt in s
		 unless (memq elt set)
		 do (push elt set))
	finally (return set)))

(defun make-list (length &rest options &aux (iv))
  (loop for (key val) on options by #'cddr
	do (selectq key
	     (:initial-value
		(setq iv val))
	     (:area)
	     (otherwise
	      (error "Illegal parameter to make-list" key))))
  (loop for i from 1 to length collect iv))

;; si:printing-random-object
;; A macro for aiding in the printing of random objects.
;; This macro generates a form which: (by default) includes the virtual 
;; address in the printed representation.
;; Options are	:NO-POINTER to suppress the pointer
;;		:TYPEP princs the typep of the object first.

;; Example:
;; (DEFSELECT ((:PROPERTY HACKER :NAMED-STRUCTURE-INVOKE))
;;   (:PRINT-SELF (HACKER STREAM IGNORE IGNORE)
;;     (SI:PRINTING-RANDOM-OBJECT (HACKER STREAM :TYPEP)
;;       (PRIN1 (HACKER-NAME HACKER) STREAM))))
;; ==> #<HACKER /"MMcM/" 6172536765>

(defmacro si:printing-random-object ((object stream . options) &body body)
  (let ((%pointer t)
	(typep nil))
    (do ((l options (cdr l)))
	((null l))
      (selectq (car l)
	(:no-pointer (setq %pointer nil))
	(:typep (setq typep t))
	(:fastp (setq l (cdr l)))		; for compatibility sake
	(otherwise
	 (ferror nil "~S is an unknown keyword in si:printing-random-object"
		 (car l)))))
    `(progn
       (patom "#<" ,stream)
       ,@(and typep
	      `((patom (:typep ,object) ,stream)))
       ,@(and typep body
	      `((patom " " ,stream)))
       ,@body
       ,@(and %pointer
	      `((patom " " ,stream)
		(patom (maknum ,object) ,stream)))
       (patom ">" ,stream)
       ,object)))

(defun named-structure-p (x &aux symbol)
  (cond ((or (and (hunkp x) (atom (setq symbol (cxr 0 x))))
	     (and (vectorp x)
		  (setq symbol (or (and (atom (vprop x)) (vprop x))
				   (and (dtpr (vprop x))
					(atom (car (vprop x)))
					(car (vprop x)))))))
				  
	 (if (get symbol 'defstruct-description)
	     symbol))))

(defun named-structure-symbol (x)
  (or (named-structure-p x)
      (ferror () "~S was supposed to have been a named structure."
	      x)))

(declare (localf named-structure-invoke-internal))

(defun named-structure-invoke (operation struct &rest args)
  (named-structure-invoke-internal operation struct args t))

(defun named-structure-invoke-carefully (operation struct &rest args)
  (named-structure-invoke-internal operation struct args nil))

(defun named-structure-invoke-internal (operation struct args error-p)
   (let (symbol fun)
      (setq symbol (named-structure-symbol struct))
      (if (setq fun (get symbol ':named-structure-invoke))
	 then (lexpr-funcall fun operation struct args)
	 else (and error-p
		   (ferror ()
			   "No named structure invoke function for ~S"
			   struct)))))

(defmacro defselect ((function-spec default-handler no-which-operations)
		     &rest args)
  (let ((name (intern (gensym)))
	fun-name)
    `(progn 'compile
       (defun ,(if (eq (car function-spec) ':property)
		   (cdr function-spec)
		   (ferror () "Can't interpret ~S defselect function spec"
				  function-spec))
	      (operation &rest args &aux temp)
	 (if (setq temp (gethash operation (get ',name 'select-table)))
	     (lexpr-funcall temp args)
	     ,(if default-handler
		  `(lexpr-funcall ,default-handler operation args)
		  `(ferror () "No handler for the ~S method of ~S"
			   operation ',function-spec))))
       (setf (get ',name 'select-table) (make-hash-table))
       ,@(do ((args args (cdr args))
	     (form)
	     (forms nil))
  	    ((null args) (nreverse forms))
	  (setq form (car args))
	  (cond ((atom (cdr form))
		 (setq fun-name (cdr form)))
		(t (setq fun-name
			 (intern (concat name (if (atom (car form)) (car form)
						  (caar form)))))
		   (push `(defun ,fun-name ,@(cdr form)) forms)))
	  (if (atom (car form))
	      (push `(puthash ',(car form) ',fun-name
			      (get ',name 'select-table))
		    forms)
	      (mapc #'(lambda (q)
			(push `(puthash ',q ',fun-name
					(get ',name 'select-table))
			      forms))
		    (car form))))
       ,@(and (not no-which-operations)
	      `((defun ,(setq fun-name (intern
					(concat name '-which-operations)))
		       (&rest args)
		  '(:which-operations ,@(loop for form in args
					      appending (if (atom (car form))
							    (list (car form))
							    (car form)))))
		(puthash ':which-operations ',fun-name
			 (get ',name 'select-table))))
       ',function-spec)))

(defun :typep (ob &optional (type nil) &aux temp)
  (cond ((instancep ob)
	 (instance-typep ob type))
	((setq temp (named-structure-p ob))
	 (if (null type) temp
	     (if (eq type temp) t
		 (memq type (nth 11. (get temp 'defstruct-description))))))
	((hunkp ob)
	 (if (null type) 'hunk (eq type 'hunk)))
	((null type)
	 (funcall 'typep ob))
	(t (eq type (funcall 'typep ob)))))

(defun send-internal (object message &rest args)
  (declare (special .own-flavor. self))
  (lexpr-funcall (if (eq self object)
		     (or (gethash message
				  (flavor-method-hash-table .own-flavor.))
			 (flavor-default-handler .own-flavor.))
		     object)
		 message args))

;; New printer

(declare (special poport prinlevel prinlength top-level-print))

(defun zprint (x &optional (stream poport))
       (zprin1 x stream)
       't)

(defun zprinc (x &optional (stream poport))
       (zprin1a x stream () (or prinlevel -1)))

(defun zprin1 (x &optional (stream poport))
       (zprin1a x stream 't (or prinlevel -1)))

(defun zprin1a (ob stream slashifyp level &aux temp)
  (cond ((null ob) (patom "()" stream))
	((setq temp (named-structure-p ob))
	 (or (named-structure-invoke-carefully ':print-self ob stream
						level slashifyp)
	     (si:printing-random-object (ob stream :typep))))
	((instancep ob)
	 (if (get-handler-for ob ':print-self)
	     (send ob ':print-self stream)
	     (si:printing-random-object (ob stream :typep))))
        ((atom ob)
	 (if slashifyp (xxprint ob stream)
	     (patom ob stream)))
	((dtpr ob) (zprint-list ob stream slashifyp (1- level)))
	((hunkp ob) (zprint-hunk ob stream slashifyp (1- level)))
	((= level 0)
	 (patom "&" stream))
	(t
	 (if slashifyp (xxprint ob stream)
	     (patom ob stream))))
  't)

(defun zprint-list (l stream slashifyp level)
       (tyo #/( stream)
       (do ((l l (cdr l))
	    (i (or prinlength -1) (1- i))
	    (first t nil))
	   ((not (dtpr l))
	    (cond ((not (null l))
		   (patom " . " stream)
		   (zprin1a l stream slashifyp level)))
	    't)
           (cond ((= i 0)
		  (patom " ..." stream)
		  (return 't)))
	   (if (not first)
	       (tyo #/  stream))
	   (zprin1a (car l) stream slashifyp level))
       (tyo #/) stream))

(defun zprint-hunk (l stream slashifyp level)
       (tyo #/{ stream)
       (do ((i 0 (1+ i))
	    (lim (hunksize l))
	    (first t nil))
	   ((= i lim)
	    't)
           (cond ((and (not (null prinlength)) (not (< i prinlength)))
		  (patom " ..." stream)
		  (return 't)))
	   (if (not first)
	       (tyo #/  stream))
	   (zprin1a (cxr i l) stream slashifyp level))
       (tyo #/} stream))

(eval-when (load eval)
   (putd 'xxprint (getd 'print))
   (putd 'xxprinc (getd 'princ)))

(defun new-printer ()
  (setq top-level-print 'zprint)
  (putd 'print (getd 'zprint))
  (putd 'prin1 (getd 'zprin1))
  't)

(defun old-printer ()
  (setq top-level-print 'xxprint)
  (putd 'print (getd 'xxprint))
  (putd 'princ (getd 'xxprinc))
  't)




(putprop 'lmhacks t 'version)
EndOfFile
cat >  lisplib/autorun/vax  << 'EndOfFile'
; $Header: vaxsoft 1.1 83/07/25 11:35:52 layer Exp $

".set	exit,1
.word	0x0000
subl2	$8,sp
movl	8(sp),(sp)  #  argc
movab	12(sp),r0
movl	r0,4(sp)  #  argv
QL1:
tstl	(r0)+  #  null args term ?
bneq	QL1
cmpl	r0,*4(sp)  #  end of 'env' or 'argv' ?
blss	QL2
tstl	-(r0)  # envp's are in list
QL2:
movab	dr,8(sp)
movab	ln,4(sp)
movab	4(sp),r1
movl	sp,r2
pushl	r0	#stack environment
pushl	r1
pushab	ln
calls	$3,_execve
chmk	$exit
ln:
"
".asciz	\"/usr/ucb/lisp\"
dr:
.asciz	\"-f\"
.set	exece,59
_execve:
.word	0x0000
chmk	$exece
chmk	$exit
ret
"
EndOfFile
cat >  lisplib/autorun/unisoft  << 'EndOfFile'
; $Header: unisoft 1.2 83/07/25 11:39:17 layer Exp $

"
OFFSET = 0xOFF
start:	movl	a7@(4),a0
clrl	a0@(-4)
movl	a7,a0
subql	#0x8,a7
movl	a0@,a7@
addql	#0x4,a0
movl	a0,a7@(4)
LL0:	tstl	a0@+
bnes	LL0
movl	a7@(4),a1
cmpl	a1@,a0
blts	LL1
subql	#0x4,a0
LL1:	movl	a0,a7@(8)
movl	a0,a1
movl	#OFFSET+file,a2
movl	a2,sp@(4)	| setup new argv[0]
movl	a2,a0		| file to execute
movl	#OFFSET+flag,a2
movl	a2,sp@(8)	| setup new argv[1]
lea	sp@(4),a2
movl	a2,d1
movw	#0x3B,d0
trap	#0x0
file:	.asciz	\"/usr/ucb/lisp\"
flag:	.asciz	\"-f\"
.even
"
EndOfFile
cat >  lisplib/autorun/sun4.2  << 'EndOfFile'
"start:movl	sp@,d2
lea	sp@(4),a3
movl	d2,d1
asll	#2,d1
lea	a3@(4,d1:l),a4
movl	#flag+0x8000,a3@-
movl	#lisp+0x8000,a3@-
movl	a3,sp
pea	a4@
pea	a3@
movl	#lisp+0x8000,sp@-
jsr	execve
execve: pea	0x3b:w
trap	#0
addw	#12,a7
pea	0:w
jsr	_exit
_exit: pea	1:w
trap	#0
flag:	.asciz	\"-f\"
lisp:	.asciz  \"/usr/ucb/lisp\"
.even
"
EndOfFile
cat >  lisplib/autorun/mc500  << 'EndOfFile'
" 
|
| Lisp startup program.
| insert two new parameters on the argv[] list and re-exec lisp
|
	.globl	exece
start:
	movl	sp@, d1		| get argc (# of parameters on stack)
	lea	sp@(4),a3	| save the address of argv[]
	asll	#2,d1		| multiply argc by 4 to get # of bytes of argv ptrs on stack
	lea	a3@(4,d1:l),a4	| save the address of arge[] (it's after all of the argv's)
	movl	#flag,a3@-	| insert (push) the address of the flag string on to top of argv stack
	movl	#lisp,a3@-	| insert (push) the address of the lisp string on to top of argv stack
	movl	a3,sp		| set the stack to point to the new stack head.
|
|	Set up a call to exece
	pea	a4@		| push the address of arge on the stack
	pea	a3@		| push the address of argv on the stack
	movl	#lisp,sp@-	| push the name of the program on the stack
	jsr	exece		| now call exece, you've got the right parameters
exece:
	moveq    #0x3b,d0
	movl	a7@(4),d1
	movl	a7@(8),a0
	movl	a7@(12),a1
	trap	#0
	movl	#0,d0
	movl	d0,d1
	trap	#0		| exit if exec fails
|
| call exit on a exec failure without losing the return code.
| we should NEVER return from _exit
|
flag:	.asciz	\"-f\"
lisp:	.asciz	\"/usr/ucb/lisp\"
.even
"
EndOfFile
cat >  lisplib/autorun/68k  << 'EndOfFile'
"start:movl	sp@,d2
lea	sp@(4),a3
movl	d2,d1
asll	#2,d1
lea	a3@(4,d1:l),a4
movl	#flag+0x8000,a3@-
movl	#lisp+0x8000,a3@-
movl	a3,sp
pea	a4@
pea	a3@
movl	#lisp+0x8000,sp@-
jsr	execve
execve: pea	0x3b:w
trap	#0
addw	#12,a7
pea	0:w
jsr	_exit
_exit: pea	1:w
trap	#0
flag:	.asciz	\"-f\"
lisp:	.asciz  \"/usr/ucb/lisp\"
.even
"
EndOfFile
cat >  lisplib/describe.l  << 'EndOfFile'
; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
; MACHINE MISCELLANEOUS FUNCTIONS NOT WORTHY OF BEING IN QFCTNS
;	** (c) Copyright 1980 Massachusetts Institute of Technology **
(setq rcs-describe-
   "$Header: describe.l,v 1.3 85/03/24 11:23:34 sklower Exp $")

(setq SCCS-describe "@(#) describe.l	1.1	83/01/27 @(#)")

;Describe anything

(environment-lmlisp (compile eval) (files struct flavorm))


(declare (special indent))

(defun describe (anything &optional no-complaints &aux (indent 0))
  (describe-2 anything no-complaints))

(defun describe-2 (anything no-complaints &aux type)
  (cond ((named-structure-p anything)
	 (describe-defstruct anything))
	((and (instancep anything)
	      (get-handler-for anything ':describe))
	 (send anything ':describe))
	((:typep anything 'flavor)
	 (describe-flavor anything))
	((arrayp anything)
	 (describe-array anything))
	((symbolp anything)
	 (describe-symbol anything))
	((listp anything)
	 (describe-list anything))
	((floatp anything)
	 (describe-flonum anything))
	((bigp anything)
	 (describe-bignum anything))
	((fixp anything)
	 (format t "~%~vX~R is ~[even~;odd~]"
		 indent anything (if (evenp anything) 0 1)))
	((not no-complaints)
	 (format t "~%I don't know how to describe ~S" anything)))
  (terpri)
  anything)

(defun describe-1 (thing)	;an internal subroutine
  (cond ((or (null thing) ;Don't recursively describe relatively boring things
	     (numberp thing) (symbolp thing) (stringp thing))
	 nil)
	(t (let ((indent (+ indent 4)))
		(describe-2 thing t))
	   (terpri))))

(defun describe-symbol (sym)
  (cond ((boundp sym)
	 (let ((prinlevel 2) (prinlength 3))
	   (format t  "~%~vXThe value of ~S is ~S" indent sym (symeval sym)))
	 (describe-1 (symeval sym))))
  (cond ((fboundp sym)
	 (let ((prinlevel 2) (prinlength 3))
	   (format t "~%~vX~S is the function ~S: ~S"
		   indent sym (getd sym) '(???)))
	 (describe-1 (getd sym))))
  (do ((pl (plist sym) (cddr pl))
       (prinlevel 2)
       (prinlength 3))
      ((null pl))
;   (format t "~%~~vXS has property ~S: ~S"	; SMH@MIT-EMS
    (format t "~%~vX~S has property ~S: ~S"
	    indent sym (car pl) (cadr pl))
    (describe-1 (cadr pl)))
  nil)

(defun describe-list (l)
  (format t "~%~vX~S is a list" indent l))

;Fixed indent botch: this is not necessarily called from describe!  SMH@EMS
(defun describe-defstruct
       (x &optional defstruct-type
	  &aux description
	       (indent (cond ((and (boundp 'indent) (fixp indent)) indent)
			     (t 0))))
  (setq description (get (or defstruct-type (named-structure-symbol x))
			 'defstruct-description))
; (format t "~%~vX~S is a ~S~%" indent x (defstruct-description-name)) SMH@EMS
  (format t "~%~vX~S is a ~S~%" indent x
	  (defstruct-description-name description))
  (do l (defstruct-description-slot-alist) (cdr l) (null l)
      (format t "~vX   ~30A~S~%"
	      indent
	      (concat (caar l) ":")
	      (eval `(,(defstruct-slot-description-ref-macro-name (cdar l))
		      ',x)))))

(defun describe-fclosure (cl)
  (format t "~vX~%~S is an fclosure of ~S:~%" cl (fclosure-function cl))
  (loop for pair in (fclosure-alist cl)
	do (format t "~vX   Value cell of ~S:        ~32,7S~%"
		   indent
		   (car pair) (cadr pair))))

(defun describe-flonum (x)
  (format t "~%~vX~S is a flonum.~%  " indent x)
;;  (format T "Excess-2000 exponent ~O, 32-bit mantissa ~O~4,48O~4,48O (including sign)")
  )

(defun describe-bignum (x)
  (let ((len (haulong x))
	(barf nil))
    (format t "~&~S is a bignum.~&It is ~R word~:P long."
	    x len)
    (terpri))
  x)

(defun describe-array (array &aux arraydims ndims)
 (cond ((arrayp array)
	(format t "~vX~%This is a ~S type array."
		indent (car (getaux array)))
	(setq arraydims (cdr (arraydims array)))
	(setq ndims (length arraydims))
	(cond ((> ndims 1)
	       (format t  "~vX~%It is ~D-dimensional, with dimensions "
		       indent ndims)
	       (do l arraydims (cdr l) (null l)
		   (format t "~s " (car l))))
	      (t (format t "~%It is ~S long." (car arraydims)))))
       (t (ferror nil "~S is not an array" array))))

(declare (macros t))

(defmacro mapatoms (fcnt) `(mapc ,fcnt (oblist)))

(declare (special apropos-substring return-list))

(defun apropos (apropos-substring &rest rest
		&aux return-list)
  rest 
  (mapatoms #'apropos-1 pkg)
  return-list)

(defun apropos-1 (symbol)
  (cond ((within-string apropos-substring (get_pname symbol))
	 (push symbol return-list)
	 (format t "~%~s" symbol)
	 (and (fboundp symbol)
	      (format t " - Function"))
	 (and (boundp symbol)
	      (cond ((fboundp symbol) (princ ", Bound"))
		    (t (princ " - Bound")))))))

(defun within-string (s1 s2 &aux (len (flatc s1)))
  (loop for i from 1 to (flatc s2)
	with fc = (getcharn s1 1)
	when (and (= (getcharn s2 i) fc)
		  (eqstr (substring s2 i len) s1))
	return t))
	
EndOfFile
cat >  lisplib/flavors.l  << 'EndOfFile'
; Tasteful Flavors	-*- Mode: Lisp; Package: SI; Base:8 -*-

;; (c) copywrite 1982, Massachusetts Institute of Technology

;; This flavor system is derived from the original Lisp machine
;; flavor system.  As such its distribution may be restricted to
;; Lisp machine software license holders.

(environment-lmlisp (eval compile load) (files flavorm))

(setq |SCCS-flavors| "@(#) flavors.l	1.1	83/03/14 @(#)")

(DECLARE (SPECIAL ERRPORT)
	 (MACROS T))

; A flavor-name is a symbol which names a type of objects defined
; by the combination of several flavors.  The SI:FLAVOR
; property is a data-structure (of type FLAVOR) defining the
; nature of the flavor, as defined below.

; Flavors come in essentially three kinds.  The first kind defines a class
; of flavors, and provides the basic instance variables and methods for
; that class.  This kind typically includes only VANILLA-FLAVOR as a
; component, and uses the :REQUIRED-INSTANCE-VARIABLES and
; :REQUIRED-METHODS options.  The second kind of flavor represents a
; particular option that may be combined in (a "mix-in").  The third
; kind of flavor is the kind that can usefully be instantiated; it is
; a combination of one of the first kind and several of the second kind,
; to achieve the behavior desired for a particular application.

; The following symbols are interesting to outsiders:
; DEFFLAVOR - macro for defining a flavor
; DEFMETHOD - macro for defining a method
; DEFWRAPPER - macro for defining a flavor-wrapper
; INSTANTIATE-FLAVOR - create an object of a specified flavor
; MAKE-INSTANCE - easier to call version of INSTANTIATE-FLAVOR
; COMPILE-FLAVOR-METHODS - macro which does the right thing in the compiler
; RECOMPILE-FLAVOR - function to recompile a flavor and maybe any flavors
;		that depend on it.  Usually this happens automatically.
; FUNCALL-SELF - a macro which, assuming you are a flavor instance, will
;		call yourself without bothering about rebinding the
;		variables.  Will do something totally random if SELF
;		isn't a flavor instance.
; LEXPR-FUNCALL-SELF - LEXPR-FUNCALL version of above
; *ALL-FLAVOR-NAMES* - list of all symbols which have been used as the 
;		name of a flavor
; *FLAVOR-COMPILATIONS* - list of all methods which had to be compiled
;		this is useful for finding flavors which weren't compiled 
;		in qfasl files or which need to be recompiled to bring 
;		them up to date.
; *FLAVOR-COMPILE-TRACE* - if non-NIL, a FORMAT destination for messages about
;		recompilation of combined methods
; FLAVOR-ALLOWS-INIT-KEYWORD-P - determine whether a certain flavor allows
;		a certain keyword in its init-plist.
; FLAVOR-ALLOWED-INIT-KEYWORDS - returns all the init keywords a flavor 
;		handles.

; Roads not taken:
;  o Changing the size of all extant instances of a flavor.
;  o Nothing to stop you from instantiating a flavor of the first or
;    second kind.  In practice you will usually get an error if you try it.

; This macro is used to define a flavor.  Use DEFMETHOD to define
; methods (responses to messages sent to an instance of a flavor.)
(DEFMACRO DEFFLAVOR (NAME INSTANCE-VARIABLES COMPONENT-FLAVORS &REST OPTIONS)
  ;INSTANCE-VARIABLES can be symbols, or lists of symbol and initialization.
  ;COMPONENT-FLAVORS are searched from left to right for methods,
  ; and contribute their instance variables.
  ;OPTIONS are:
  ; (:GETTABLE-INSTANCE-VARIABLES v1 v2...) - enables automatic generation of methods
  ;   for retrieving the values of those instance variables
  ; :GETTABLE-INSTANCE-VARIABLES - (the atomic form) does it for all instance
  ;   variables local to this flavor (declared in this DEFFLAVOR).
  ; (:SETTABLE-INSTANCE-VARIABLES v1 v2...) - enables automatic generation of methods
  ;   for changing the values of instance variables
  ;   The atomic form works too.
  ; (:REQUIRED-INSTANCE-VARIABLES v1 v2...) - any flavor incorporating this
  ;   flavor and actually instantiated must have instance variables with
  ;   the specified names.  This is used for defining general types of
  ;   flavors.
  ; (:REQUIRED-METHODS m1 m2...) - any flavor incorporating this
  ;   flavor and actually instantiated must have methods for the specified
  ;   operations.  This is used for defining general types of flavors.
  ; (:REQUIRED-FLAVORS f1 f2...) - similar,  for component flavors
  ;   rather than methods.
  ; (:INITABLE-INSTANCE-VARIABLES v1 v2...) - these instance variables
  ;   may be initialized via the options to INSTANTIATE-FLAVOR.
  ;   The atomic form works too.
  ;   Settable instance variables are also INITABLE.
  ; (:INIT-KEYWORDS k1 k2...) - specifies keywords for the :INIT operation
  ;   which are legal to give to this flavor.  Just used for error checking.
  ; (:DEFAULT-INIT-PLIST k1 v1 k2 v2...) - specifies defaults to be put
  ;   into the init-plist, if the keywords k1, k2, ... are not already
  ;   specified, when instantiating.  The values v1, v2, ... get evaluated
  ;   when and if they are used.
  ; (:DEFAULT-HANDLER function) - causes function to be called if a message
  ;   is sent for which there is no method.  Defaults to a function which
  ;   gives an error.
  ; (:INCLUDED-FLAVORS f1 f2...) - specifies flavors to be included in this
  ;   flavor.  The difference between this and specifying them as components
  ;   is that included flavors go at the end, so they act as defaults.  This
  ;   makes a difference when this flavor is depended on by other flavors.
  ; :NO-VANILLA-FLAVOR - do not include VANILLA-FLAVOR.
  ;   Normally it is included automatically.  This is for esoteric hacks.
  ; (:ORDERED-INSTANCE-VARIABLES v1 v2...) - requires that in any instance,
  ;   instance variables with these names must exist and come first.  This might
  ;   be for instance variable slots specially referenced by microcode.
  ;   The atomic form works too.
  ; (:OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES v1 v2...) - defines defsubsts which
  ;   act like defstruct accessors for the variables; that is, using these with
  ;   an argument of an instance gets the value of that variable in that instance.
  ;   The name of the defsubst is the flavor-name, hyphen, the variable name.
  ;   If the instance variable is ordered, the accessor will know its index
  ;   in the instance and access it directly, otherwise it will call 
  ;   SYMEVAL-IN-CLOSURE at run-time.
  ;   The atomic form works too.
  ; (:ACCESSOR-PREFIX sym) - uses "sym" as the prefix on the names of the above
  ;   defsubsts instead of "flavor-".
  ; (:SELECT-METHOD-ORDER m1 m2...) - specifies that the keywords m1, m2, ... are
  ;   are important and should have their methods first in the select-method
  ;   table for increased efficiency.
  ; (:METHOD-COMBINATION (type order operation1 operation2...)...)
  ;   Specify ways of combining methods from different flavors.  :DAEMON NIL is the
  ;   the default.  order is usually :BASE-FLAVOR-FIRST or :BASE-FLAVOR-LAST,
  ;   but this depends on type.
  ; (:DOCUMENTATION <args>...)
  ;   The list of args is simply put on the flavor's :DOCUMENTATION property.
  ;   The standard for this is that the arguments may include keyword symbols and
  ;   a documentation string.  To be specified more later.
  ; There may be more.
  (LET ((COPIED-OPTIONS (COPYLIST OPTIONS)))
    (DEFFLAVOR1 NAME INSTANCE-VARIABLES COMPONENT-FLAVORS COPIED-OPTIONS)
    ;; The following is done to determine all the instance variables
    ;; that need to be declared special.
    (IF (NOT (NULL (GETD 'LISZT)))
	(COMPOSE-FLAVOR-COMBINATION (GET-FLAVOR NAME)))
   `(PROGN 'COMPILE
     ;; Define flavor at load time.
     ;; Must come before the compile-time COMPOSE-AUTOMATIC-METHODS,
     ;; which puts methods in the QFASL file.
     (EVAL-WHEN (LOAD)
       (DEFFLAVOR1 ',NAME ',INSTANCE-VARIABLES ',COMPONENT-FLAVORS
		   ',COPIED-OPTIONS))
     ,@(COMPOSE-AUTOMATIC-METHODS (GET NAME 'FLAVOR))
;; Make any instance-variable accessor macros.
     ,@(DO ((VS (DO ((OPTS OPTIONS (CDR OPTS)))
		    ((NULL OPTS) NIL)
		  (AND (LISTP (CAR OPTS))
		       (EQ (CAAR OPTS) ':OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES)
		       (RETURN (CDAR OPTS)))
		  (AND (EQ (CAR OPTS) ':OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES)
		       (RETURN (MAPCAR #'(LAMBDA (X) (IF (ATOM X) X (CAR X)))
				       INSTANCE-VARIABLES))))
		(CDR VS))
	    (PREFIX (OR (CADR (ASSQ ':ACCESSOR-PREFIX OPTIONS))
			(CONCAT NAME "-")))
	    (ORDS (DO ((OPTS OPTIONS (CDR OPTS)))
		      ((NULL OPTS) NIL)
		    (AND (LISTP (CAR OPTS))
			 (EQ (CAAR OPTS) ':ORDERED-INSTANCE-VARIABLES)
			 (RETURN (CDAR OPTS)))
		    (AND (EQ (CAR OPTS) ':ORDERED-INSTANCE-VARIABLES)
			 (RETURN (MAPCAR #'(LAMBDA (X) (IF (ATOM X) X (CAR X)))
					 INSTANCE-VARIABLES)))))
	    (RES NIL (CONS `(DEFSUBST ,(INTERN (CONCAT PREFIX (CAR VS)))
				      (,NAME)
			      ,(IF (MEMQ (CAR VS) ORDS)
; SMH@EMS VVV			   `(VREF ,NAME
;					  ,(+ 9 (* 3 (FIND-POSITION-IN-LIST
;						      (CAR VS) ORDS))))
				   `(INT:FCLOSURE-STACK-STUFF
				     (VREF ,NAME ,(+ 3 (FIND-POSITION-IN-LIST
							(CAR VS) ORDS))))
; SMH@EMS ^^^
				   `(SYMEVAL-IN-FCLOSURE ,NAME ',(CAR VS))))
			   RES)))
	   ((NULL VS) RES))
     ',NAME)))

(DEFMACRO DEFUN-METHOD (FSPEC FLAVOR-NAME ARGLIST &BODY BODY)
  `(DEFUN ,FSPEC ,ARGLIST
     (DECLARE (SPECIAL SELF .OWN-FLAVOR.
		       ,@(FLAVOR-ALL-INSTANCE-VARIABLES
			  (GET-FLAVOR FLAVOR-NAME))))
     . ,BODY))

(DEFMACRO INSTANCE-VARIABLE-BOUNDP (X)
  `(BOUNDP ',X))

(DEFVAR *ALL-FLAVOR-NAMES* NIL)	;List of names of all flavors (mostly for editor)

(DEFVAR *USE-OLD-COMBINED-METHODS* T)
 ;;T means recycle old, NIL means generate new. 
 ;; This is an implicit argument to certain routines. 

(DEFVAR *FLAVOR-PENDING-DEPENDS* NIL)	;Used by DEFFLAVOR1

(DEFVAR *FLAVOR-COMPILATIONS* NIL)	;List of methods compiled

(DEFVAR *FLAVOR-COMPILE-TRACE* NIL)

(DEFSUBST INSTANCE-FLAVOR (INSTANCE)
  (SYMEVAL-IN-FCLOSURE INSTANCE '.OWN-FLAVOR.))

(DEFSUBST INSTANCE-FUNCTION (INSTANCE)
  (FCLOSURE-FUNCTION INSTANCE))

(DEFUN GET-FLAVOR (FLAVOR-OR-NAME &AUX TEMP)
  (COND ((:TYPEP FLAVOR-OR-NAME 'FLAVOR) FLAVOR-OR-NAME)
	((SYMBOLP FLAVOR-OR-NAME)
	 (SETQ TEMP (GET FLAVOR-OR-NAME 'FLAVOR))
	 (CHECK-ARG FLAVOR-OR-NAME (:TYPEP TEMP 'FLAVOR)
		    "the name of a flavor")
	 TEMP)
	(T (CHECK-ARG FLAVOR-OR-NAME (:TYPEP TEMP 'FLAVOR)
		      "the name of a flavor"))))

;;(DEFSUBST INSTANCEP (X)
;;  (AND (FCLOSUREP X) (EQ (FCLOSURE-FUNCTION X) #'FLAVOR-DISPATCH)))

(DEFUN INSTANCE-TYPEP (OB TYPE)
  (IF (NULL TYPE)
      (FLAVOR-NAME (INSTANCE-FLAVOR OB))
      (NOT (NULL (MEMQ TYPE (FLAVOR-DEPENDS-ON-ALL
			     (INSTANCE-FLAVOR OB)))))))
  

;These properties are not discarded by redoing a DEFFLAVOR.
(DEFCONST DEFFLAVOR1-PRESERVED-PROPERTIES
	  '(ADDITIONAL-INSTANCE-VARIABLES
	    COMPILE-FLAVOR-METHODS
	    MAPPED-COMPONENT-FLAVORS
	    INSTANCE-VARIABLE-INITIALIZATIONS
	    ALL-INITABLE-INSTANCE-VARIABLES
	    REMAINING-DEFAULT-PLIST
	    REMAINING-INIT-KEYWORDS))

;These are instance variables that don't belong to this flavor or its components
;but can be accessed by methods of this flavor.
(DEFSUBST FLAVOR-ADDITIONAL-INSTANCE-VARIABLES (FLAVOR)
  (GET (FLAVOR-PLIST FLAVOR) 'ADDITIONAL-INSTANCE-VARIABLES))

;The next four are distillations of info taken from this flavor and its components,
;used for instantiating this flavor.  See COMPOSE-FLAVOR-INITIALIZATIONS.
(DEFSUBST FLAVOR-INSTANCE-VARIABLE-INITIALIZATIONS (FLAVOR)
  (GET (FLAVOR-PLIST FLAVOR) 'INSTANCE-VARIABLE-INITIALIZATIONS))

(DEFSUBST FLAVOR-REMAINING-DEFAULT-PLIST (FLAVOR)
  (GET (FLAVOR-PLIST FLAVOR) 'REMAINING-DEFAULT-PLIST))

(DEFSUBST FLAVOR-REMAINING-INIT-KEYWORDS (FLAVOR)
  (GET (FLAVOR-PLIST FLAVOR) 'REMAINING-INIT-KEYWORDS))

(DEFSUBST FLAVOR-ALL-INITABLE-INSTANCE-VARIABLES (FLAVOR)
  (GET (FLAVOR-PLIST FLAVOR) 'ALL-INITABLE-INSTANCE-VARIABLES))

(DEFUN (FLAVOR :NAMED-STRUCTURE-INVOKE) (OPERATION &OPTIONAL SELF &REST ARGS)
  (SELECTQ OPERATION
	   (:WHICH-OPERATIONS '(:PRINT-SELF :DESCRIBE))
	   (:PRINT-SELF
	    (SI:PRINTING-RANDOM-OBJECT (SELF (CAR ARGS))
	       (FORMAT (CAR ARGS) "FLAVOR ~S" (FLAVOR-NAME SELF))))
	   (:DESCRIBE (DESCRIBE-FLAVOR SELF))
	   (OTHERWISE
	    (FERROR NIL "~S UNKNOWN OPERATION FOR FLAVOR" OPERATION))))

;Format of flavor-method-table:
; New format of a flavor-method-table entry is:
;   (message combination-type combination-order meth...)
; A meth is:
;   (function-spec definition plist)
; Thus the second element of a meth is actually a function-cell.
; The meth's are stored in permanent-storage-area so that they will be compact.
;    [That might not be the best area, the select-methods, and component
;     lists, and instanc-variable lists, and which-operations's, are also there.]
; A magic-list entry is:
;   (message combination-type combination-order (method-type function-spec...)...)
; In the magic-list, there can be more than one method listed under a method-type,
; the base flavor always comes first.  The :COMBINED methods are elided from
; the magic-list.
;
; Special method-types:
;   NIL - no type specified
;   :DEFAULT - like NIL but only taken if there are no type-NIL methods
;   :WRAPPER - wrappers are remembered this way
;   :COMBINED - a daemon-caller; the symbol has a COMBINED-METHOD-DERIVATION property
;		whose value is the complete method table entry from the magic-list.
;		The CDDDR is canonicalized; each contained list of method symbols is
;		of course ordered by the order in which flavors are combined (base
;		flavor first).  Canonical order is alphabetical by method-type.
; Non-special method-types:
;   :BEFORE, :AFTER - these are used by the default combination-type, :DAEMON
;
; Special hair for wrappers: changing a wrapper can invalidate the combined method
; without changing anything in the flavor-method-table entry.  Rather than having
; it automatically recompile, which turns out to be a pain when the wrapper was
; just reloaded or changed trivially, it will fail to recompile and you must use
; RECOMPILE-FLAVOR with a 3rd argument of NIL.
;
; A combination-type of NIL means it has not been explicitly specified.

; Method-combination functions.  Found on the SI:METHOD-COMBINATION property
; of the combination-type.  These are passed the flavor structure, and the
; magic-list entry, and must return the function spec to use as the handler.
; It should also define or compile thew definition for that function spec if nec.
; This function interprets combination-type-arg,
; which for many combination-types is either :BASE-FLAVOR-FIRST or :BASE-FLAVOR-LAST.

;This is an a-list from method type to function to write the code to go
;in the combined method.  Users can add to this.
(DEFCONST *SPECIALLY-COMBINED-METHOD-TYPES*
	  '((:WRAPPER PUT-WRAPPER-INTO-COMBINED-METHOD)))

;Definitions of a meth (the datum which stands for a method)

(DEFSTRUCT (METH :LIST :CONC-NAME (:CONSTRUCTOR NIL))
		;No constructor because defstruct doesn't let me specify the area
  FUNCTION-SPEC
  DEFINITION
  (PLIST NIL))

; If there is no definition, it contains DTP-NULL and a pointer to the meth

; Extract the method-type of a meth
(DEFMACRO METH-METHOD-TYPE (METH)
  `(AND (CDDDR (METH-FUNCTION-SPEC ,METH))
	(THIRD (METH-FUNCTION-SPEC ,METH))))

; Return a meth of specified type from a list of meth's.
(DEFUN METH-LOOKUP (METHOD-TYPE METH-LIST)
  (LOOP FOR METH IN METH-LIST
	WHEN (EQ (METH-METHOD-TYPE METH) METHOD-TYPE)
	  RETURN METH))

(DEFUN NULLIFY-METHOD-DEFINITION (METH)
  (SETF (METH-DEFINITION METH) NIL))

(DEFUN METH-DEFINEDP (METH)
  (NOT (NULL (METH-DEFINITION METH))))

;Function to define or redefine a flavor (used by DEFFLAVOR macro).
;Note that to ease initialization problems, the flavors depended upon need
;not be defined yet.  You will get an error the first time you try to create
;an instance of this flavor if a flavor it depends on is still undefined.
;When redefining a flavor, we reuse the same FLAVOR defstruct so that
;old instances continue to get the latest methods, unless you change
;something incompatibly, in which case you will get a warning.
(DEFUN DEFFLAVOR1 (FLAVOR-NAME INSTANCE-VARIABLES COMPONENT-FLAVORS OPTIONS
		   &AUX FFL ALREADY-EXISTS INSTV IDENTICAL-COMPONENTS
			GETTABLE SETTABLE INITABLE OLD-DEFAULT-HANDLER
			OLD-DEFAULT-INIT-PLIST OLD-LOCAL-IVS OLD-INITABLE-IVS
			OLD-INIT-KWDS
			INIT-KEYWORDS INCLUDES METH-COMB
			(PL (LIST 'FLAVOR-PLIST)))
  (COND ((NOT (MEMQ FLAVOR-NAME *ALL-FLAVOR-NAMES*))
	 (PUSH FLAVOR-NAME *ALL-FLAVOR-NAMES*)))
  ;; Analyze and error check the instance-variable and component-flavor lists
  (SETQ INSTV (MAPCAR #'(LAMBDA (X) (IF (ATOM X) X (CAR X)))
		      INSTANCE-VARIABLES))
  (DOLIST (IV INSTV)
    (IF (OR (NULL IV) (NOT (SYMBOLP IV)))
	(FERROR () "~S, which is not a symbol, was specified as an instance variable" IV)))
  (DOLIST (CF COMPONENT-FLAVORS)
    (IF (OR (NULL CF) (NOT (SYMBOLP CF)))
	(FERROR () "~S, which is not a symbol, was specified as a component flavor" CF)))
  ;; Certain properties are inherited from the old property list, while
  ;; others are generated afresh each time from the defflavor-options.
  (COND ((SETQ ALREADY-EXISTS (GET FLAVOR-NAME 'FLAVOR))
	 (DOLIST (PROP DEFFLAVOR1-PRESERVED-PROPERTIES)
	   (PUTPROP PL (GET (FLAVOR-PLIST ALREADY-EXISTS) PROP)
		    PROP))))
  ;; First, parse all the defflavor options into local variables so we can see
  ;; whether the flavor is being redefined incompatibly.
  (DO ((L OPTIONS (CDR L))
       (OPTION) (ARGS))
      ((NULL L))
    (IF (ATOM (CAR L))
	(SETQ OPTION (CAR L) ARGS NIL)
	(SETQ OPTION (CAAR L) ARGS (CDAR L)))
    (SELECTQ OPTION
	(:GETTABLE-INSTANCE-VARIABLES
	  (VALIDATE-INSTANCE-VARIABLES-SPEC ARGS INSTV FLAVOR-NAME OPTION)
	  (SETQ GETTABLE (OR ARGS INSTV)))
	(:SETTABLE-INSTANCE-VARIABLES
	  (VALIDATE-INSTANCE-VARIABLES-SPEC ARGS INSTV FLAVOR-NAME OPTION)
	  (SETQ SETTABLE (OR ARGS INSTV)))
	((:INITABLE-INSTANCE-VARIABLES :INITABLE-INSTANCE-VARIABLES)
	  (VALIDATE-INSTANCE-VARIABLES-SPEC ARGS INSTV FLAVOR-NAME OPTION)
	  (SETQ INITABLE (OR ARGS INSTV)))
	(:SPECIAL-INSTANCE-VARIABLES)  ; Ignored since all IVs are special
	(:INIT-KEYWORDS
	  (SETQ INIT-KEYWORDS ARGS))
	(:INCLUDED-FLAVORS
	  (SETQ INCLUDES ARGS))
	(:NO-VANILLA-FLAVOR
	  (PUTPROP PL T OPTION))
	(:ORDERED-INSTANCE-VARIABLES
	  ;Don't validate.  User may reasonably want to specify non-local instance
	  ;variables, and any bogus names here will get detected by COMPOSE-FLAVOR-COMBINATION
	  ;(VALIDATE-INSTANCE-VARIABLES-SPEC ARGS INSTV FLAVOR-NAME OPTION)
	  (PUTPROP PL (OR ARGS INSTV) ':ORDERED-INSTANCE-VARIABLES))
	(:OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES
	  (VALIDATE-INSTANCE-VARIABLES-SPEC ARGS INSTV FLAVOR-NAME OPTION)
	  (PUTPROP PL (OR ARGS INSTV) ':OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES))
	(:METHOD-COMBINATION
	  (SETQ METH-COMB ARGS))
	(:DEFAULT-HANDLER
	  (PUTPROP PL (CAR ARGS) OPTION))
	((:REQUIRED-INSTANCE-VARIABLES :REQUIRED-METHODS :REQUIRED-FLAVORS :DOCUMENTATION
	  :DEFAULT-INIT-PLIST :SELECT-METHOD-ORDER :ACCESSOR-PREFIX)
	  (PUTPROP PL ARGS OPTION))
	(OTHERWISE (FERROR () "~S unknown option to DEFFLAVOR" OPTION))))
  ;; All settable instance variables should also be gettable and INITABLE.
  (DOLIST (V SETTABLE)
    (OR (MEMQ V GETTABLE)
	(PUSH V GETTABLE))
    (OR (MEMQ V INITABLE)
	(PUSH V INITABLE)))
  ;; See whether there are any changes in component flavor structure from last time
  (SETQ IDENTICAL-COMPONENTS
	(AND ALREADY-EXISTS
	     (EQUAL COMPONENT-FLAVORS (FLAVOR-DEPENDS-ON ALREADY-EXISTS))
	     (EQUAL INCLUDES (FLAVOR-INCLUDES ALREADY-EXISTS))
	     (EQUAL (GET PL ':REQUIRED-FLAVORS)
		    (GET (FLAVOR-PLIST ALREADY-EXISTS) ':REQUIRED-FLAVORS))))	
  (AND ALREADY-EXISTS
       (SETQ OLD-DEFAULT-HANDLER (GET (FLAVOR-PLIST ALREADY-EXISTS)
				      ':DEFAULT-HANDLER)
	     OLD-DEFAULT-INIT-PLIST (GET (FLAVOR-PLIST ALREADY-EXISTS)
					 ':DEFAULT-INIT-PLIST)
	     OLD-LOCAL-IVS (FLAVOR-LOCAL-INSTANCE-VARIABLES ALREADY-EXISTS)
	     OLD-INITABLE-IVS (FLAVOR-INITABLE-INSTANCE-VARIABLES ALREADY-EXISTS)
	     OLD-INIT-KWDS (FLAVOR-INIT-KEYWORDS ALREADY-EXISTS))) 
  ;; If the flavor is being redefined, and the number or order of instance 
  ;; variables is being changed, and this flavor or any that depends on it
  ;; has a select-method table (i.e. has probably been instantiated), give 
  ;; a warning and disconnect from the old FLAVOR defstruct so that old 
  ;; instances will retain the old information.  The instance variables can 
  ;; get changed either locally or by rearrangement of the component flavors.
  (AND ALREADY-EXISTS
       (IF (AND (EQUAL (GET PL ':ORDERED-INSTANCE-VARIABLES)
		       (GET (FLAVOR-PLIST ALREADY-EXISTS)
			    ':ORDERED-INSTANCE-VARIABLES))
		(OR (EQUAL (FLAVOR-LOCAL-INSTANCE-VARIABLES ALREADY-EXISTS)
			   INSTANCE-VARIABLES)
		    (EQUAL (MAPCAR #'(LAMBDA (X) (IF (ATOM X) X (CAR X)))
				   (FLAVOR-LOCAL-INSTANCE-VARIABLES ALREADY-EXISTS))
			   INSTV))
		(OR IDENTICAL-COMPONENTS
		    (EQUAL (FLAVOR-RELEVANT-COMPONENTS ALREADY-EXISTS
						       COMPONENT-FLAVORS INCLUDES)
			   (FLAVOR-RELEVANT-COMPONENTS ALREADY-EXISTS
						       (FLAVOR-DEPENDS-ON ALREADY-EXISTS)
						       (FLAVOR-INCLUDES ALREADY-EXISTS)))))
	   NIL
	   (SETQ ALREADY-EXISTS (PERFORM-FLAVOR-REDEFINITION FLAVOR-NAME))))
  ;; Make the information structure unless the flavor already exists.
  (LET ((FL (OR ALREADY-EXISTS
		(GET FLAVOR-NAME 'UNDEFINED-FLAVOR)
		(MAKE-FLAVOR FLAVOR-NAME FLAVOR-NAME))))
    (SETF (FLAVOR-LOCAL-INSTANCE-VARIABLES FL) INSTANCE-VARIABLES)
    (SETF (FLAVOR-DEPENDS-ON FL) COMPONENT-FLAVORS)
    (SETF (FLAVOR-PLIST FL) PL)
    (IF GETTABLE
	(SETF (FLAVOR-GETTABLE-INSTANCE-VARIABLES FL) GETTABLE))
    (IF SETTABLE
	(SETF (FLAVOR-SETTABLE-INSTANCE-VARIABLES FL) SETTABLE))
    (SETF (FLAVOR-INITABLE-INSTANCE-VARIABLES FL)
	  (LOOP FOR V IN INITABLE COLLECT (CONS (CORRESPONDING-KEYWORD V) V)))
    (SETF (FLAVOR-INIT-KEYWORDS FL) INIT-KEYWORDS)
    (SETF (FLAVOR-INCLUDES FL) INCLUDES)
    ;; First remove old method-combination declarations, then add new ones
    (DOLIST (MTE (FLAVOR-METHOD-TABLE FL))
      (COND ((LOOP FOR DECL IN METH-COMB NEVER (MEMQ (CAR MTE) (CDDR DECL)))
	     (SETF (SECOND MTE) NIL)
	     (SETF (THIRD MTE) NIL))))
    (DOLIST (DECL METH-COMB)
      (LET ((TYPE (CAR DECL)) (ORDER (CADR DECL)) ELEM)
	;; Don't error-check TYPE now, its definition might not be loaded yet
	(DOLIST (MSG (CDDR DECL))
	  (OR (SETQ ELEM (ASSQ MSG (FLAVOR-METHOD-TABLE FL)))
	      (PUSH (SETQ ELEM (LIST* MSG NIL NIL NIL)) (FLAVOR-METHOD-TABLE FL)))
	  (SETF (SECOND ELEM) TYPE)
	  (SETF (THIRD ELEM) ORDER))))
    ;; Make this a depended-on-by of its depends-on, or remember to do it 
    ;; later in the case of depends-on's not yet defined.
    (DOLIST (COMPONENT-FLAVOR COMPONENT-FLAVORS)
      (COND ((SETQ FFL (GET COMPONENT-FLAVOR 'FLAVOR))
	     (OR (MEMQ FLAVOR-NAME (FLAVOR-DEPENDED-ON-BY FFL))
		 (PUSH FLAVOR-NAME (FLAVOR-DEPENDED-ON-BY FFL))))
	    (T (PUSH (CONS COMPONENT-FLAVOR FLAVOR-NAME)
		     *FLAVOR-PENDING-DEPENDS*))))
    ;; Likewise for its includes
    (DOLIST (INCLUDED-FLAVOR (FLAVOR-INCLUDES FL))
      (COND ((SETQ FFL (GET INCLUDED-FLAVOR 'FLAVOR))
	     (OR (MEMQ FLAVOR-NAME (FLAVOR-DEPENDED-ON-BY FFL))
		 (PUSH FLAVOR-NAME (FLAVOR-DEPENDED-ON-BY FFL))))
	    (T (PUSH (CONS INCLUDED-FLAVOR FLAVOR-NAME)
		     *FLAVOR-PENDING-DEPENDS*))))
    ;; If someone depends on this flavor, which wasn't defined until now, 
    ;; link them up.  If that flavor was flavor-composed, recompose it now.
    (DOLIST (X *FLAVOR-PENDING-DEPENDS*)
      (COND ((EQ (CAR X) FLAVOR-NAME)
	     (OR (MEMQ (CDR X) (FLAVOR-DEPENDED-ON-BY FL))
		 (PUSH (CDR X) (FLAVOR-DEPENDED-ON-BY FL)))
	     (SETQ *FLAVOR-PENDING-DEPENDS*
		   (DELQ X *FLAVOR-PENDING-DEPENDS*)))))
    (PUTPROP FLAVOR-NAME FL 'FLAVOR)
    ;; Now, if the flavor was redefined in a way that changes the methods but
    ;; doesn't invalidate old instances, we have to propagate some changes.
    (IF (AND ALREADY-EXISTS
	     (NOT IDENTICAL-COMPONENTS))
	(PERFORM-FLAVOR-METHOD-ONLY-REDEFINITION FLAVOR-NAME))
    FLAVOR-NAME))

;Check for typos in user-specified lists of instance variables.
;This assumes that only locally-specified (not inherited) instance variables
;may be mentioned in DEFFLAVOR declaration clauses.
(DEFUN VALIDATE-INSTANCE-VARIABLES-SPEC (VARS-SPECD VARS-ALLOWED FLAVOR-NAME
						    OPTION &AUX BAD)
  (DOLIST (VAR VARS-SPECD)
    (OR (MEMQ VAR VARS-ALLOWED) (PUSH VAR BAD)))
  (COND (BAD (FORMAT ERRPORT "~&ERROR: Flavor ~S has misspelled :~A ~%~S"
		     FLAVOR-NAME OPTION (NREVERSE BAD)))))

;List of those components which affect the names, number, and ordering of the
;instance variables.  Don't worry about undefined components, by definition
;they must be different from the already-existing flavor, so the right
;thing will happen.  (I wonder what that comment means?  Undefined components
;will not even appear in the list.)
(DEFUN FLAVOR-RELEVANT-COMPONENTS (FL COMPONENT-FLAVORS INCLUDED-FLAVORS)
  (SETF (FLAVOR-DEPENDS-ON FL) COMPONENT-FLAVORS)
  (SETF (FLAVOR-INCLUDES FL) INCLUDED-FLAVORS)
  (DEL-IF-NOT #'(LAMBDA (FLAVOR)	;Splice out the uninteresting ones
		  (FLAVOR-LOCAL-INSTANCE-VARIABLES FLAVOR))
	      (COMPOSE-FLAVOR-INCLUSION (FLAVOR-NAME FL) NIL)))

;; Now that default structs are vectors, and plain copy works for vectors,
;; this has been removed and replaced by copy. - SMH@EMS
;(DEFUN COPY-HUNK-CONTENTS (H1 H2)
;  (LOOP FOR I FROM 0 TO (1- (HUNKSIZE H2))
;	DO (SETF (CXR I H2) (CXR I H1))))

;Propagate things from an old flavor to a new one which we construct,
;for compiling a file.
(DEFUN FLAVOR-REDEFINITION-FOR-COMPILATION (OLD-FLAVOR NEW-COMPONENTS-P)
  NEW-COMPONENTS-P
  (LET ((NEW-FLAVOR (MAKE-FLAVOR FLAVOR-NAME (FLAVOR-NAME OLD-FLAVOR))))
    ;(COPY-HUNK-CONTENTS OLD-FLAVOR NEW-FLAVOR) ; SMH@EMS
    (SETQ NEW-FLAVOR (COPY OLD-FLAVOR))	; Now works only if vector.
    ;; Do copy any combined methods.  If we have dependents also in this file
    ;; and they have COMPILE-FLAVOR-METHODS in this file,
    ;; they will want to see our combined methods in case they can use them.
    (COPY-METHOD-TABLE OLD-FLAVOR NEW-FLAVOR NIL)
    (SETF (FLAVOR-DEPENDS-ON-ALL NEW-FLAVOR) NIL)	;Will need to be flavor-composed again
    ;; Cause an error if these are looked at before they are valid.
    (SETF (FLAVOR-ALL-INSTANCE-VARIABLES NEW-FLAVOR) 'NOT-COMPUTED)
    (SETF (FLAVOR-DEPENDED-ON-BY NEW-FLAVOR) 'COMPILATION)
    (SETF (FLAVOR-METHOD-HASH-TABLE NEW-FLAVOR) NIL)	;Will need to be method-composed again
    (SETF (FLAVOR-WHICH-OPERATIONS NEW-FLAVOR) NIL)
    NEW-FLAVOR))

(DEFUN COPY-METHOD-TABLE (OLD-FLAVOR NEW-FLAVOR DISCARD-COMBINED-METHODS)
  (LET ((L (COPYLIST (FLAVOR-METHOD-TABLE OLD-FLAVOR))))
    (DO ((TAIL L (CDR TAIL)))
	((NULL TAIL))
      ;; Copy the method-table element, including the list of METH's.
      (SETF (CAR TAIL) (COPYLIST (CAR TAIL)))
      (IF DISCARD-COMBINED-METHODS
	  ;; Flush from the copy all combined methods.
	  (DO ((TAIL2 (CDDDR (CAR TAIL)) (CDR TAIL2)))
	      ((NULL TAIL2))
	    (AND (EQ (METH-METHOD-TYPE (CAR TAIL2)) ':COMBINED)
		 (SETF (CDDDAR TAIL)
		       (DELQ (CAR TAIL2) (CDDDAR TAIL))))))
      ;; Now copy each METH that we didn't delete.
      ;; Copying a METH is not trivial because it can contain a DTP-NULL.
      (DO ((TAIL2 (CDDDR (CAR TAIL)) (CDR TAIL2)))
	  ((NULL TAIL2))
	(LET ((NEW-METH (LIST (FIRST (CAR TAIL2))
			      NIL
			      (COPYLIST (THIRD (CAR TAIL2))))))
	  (IF (METH-DEFINEDP (CAR TAIL2))
	      (SETF (METH-DEFINITION NEW-METH) (METH-DEFINITION (CAR TAIL2)))
	    (NULLIFY-METHOD-DEFINITION NEW-METH))
	  (SETF (CAR TAIL2) NEW-METH))))
    (SETF (FLAVOR-METHOD-TABLE NEW-FLAVOR) L)))

;Record a flavor definition, during compiling a file.
;Instead of setting the name's FLAVOR property, we put an entry on the
;FLAVORS element in the FILE-LOCAL-DECLARATIONS, where COMPILATION-FLAVOR looks.
(DEFVAR FILE-LOCAL-DECLARATIONS ())

(DEFUN COMPILATION-DEFINE-FLAVOR (FLAVOR-NAME FL)
  (LET ((FLL (ASSQ 'FLAVORS FILE-LOCAL-DECLARATIONS)))
    (COND ((NULL FLL)
	   (PUSH (NCONS 'FLAVORS) FILE-LOCAL-DECLARATIONS)
	   (SETQ FLL (CAR FILE-LOCAL-DECLARATIONS))))
    (PUTPROP FLL FL FLAVOR-NAME)))

;Call here when a flavor has been changed in a way that is not compatible
;with old instances of this flavor or its dependents.
;Arranges for those old instances to keep the old flavor structures and 
;methods.  Return new copy of the FLAVOR defstruct, and propagate to those 
;that depend on it.  Note that we tell copy-method-table to discard our 
;combined methods.  This is because they point to METHs in our method table,
;so we must make new combined methods that point at our new method table.
(DEFUN PERFORM-FLAVOR-REDEFINITION (FLAVOR-NAME &AUX FL NFL)
  (SETQ FL (GET FLAVOR-NAME 'FLAVOR))
  (COND ((FLAVOR-METHOD-HASH-TABLE FL)
	 (SETQ NFL (MAKE-FLAVOR))
	 ; (COPY-HUNK-CONTENTS FL NFL) ; SMH@EMS
	 (SETQ NFL (COPY FL))		; Now works only if FL is a vector!
	 (COPY-METHOD-TABLE FL NFL T)			   ;Copy, but discard combined methods
	 (SETQ FL NFL)
	 (SETF (FLAVOR-PLIST FL) (COPYLIST (FLAVOR-PLIST FL)))
	 (PUTPROP FLAVOR-NAME FL 'FLAVOR)
	 (FORMAT ERRPORT "~&Flavor ~S changed incompatibly, old instances will not get the new version.~%"
		 FLAVOR-NAME))
	;; Even if this flavor wasn't instantiated,
	;; probably some of its dependents were,
	;; and their hash tables and combined methods point to our method table.
	(T (COPY-METHOD-TABLE FL FL T)))
  (SETF (FLAVOR-DEPENDS-ON-ALL FL) NIL)	;Will need to be flavor-composed again
  (SETF (FLAVOR-METHOD-HASH-TABLE FL) NIL)	;Will need to be method-composed again
  (SETF (FLAVOR-WHICH-OPERATIONS FL) NIL)
  (DOLIST (FN (FLAVOR-DEPENDED-ON-BY FL))
    (PERFORM-FLAVOR-REDEFINITION FN))
  FL)

;This one is when the old instances don't have to be discarded, but recomposition
;does have to occur because something was changed in the order of flavor combination
(DEFUN PERFORM-FLAVOR-METHOD-ONLY-REDEFINITION (FLAVOR-NAME)
  (LET ((FDEFINE-FILE-PATHNAME NIL))	;Don't give warnings for combined methods
    ;; Reverse the list so that this flavor comes first, followed by directest descendents.
    (DOLIST (FN (REVERSE (FLAVOR-DEPENDED-ON-BY-ALL (GET FLAVOR-NAME 'FLAVOR)
						    (LIST FLAVOR-NAME))))
      (LET ((FL (GET FN 'FLAVOR)))
	(IF (FLAVOR-DEPENDS-ON-ALL FL) (COMPOSE-FLAVOR-COMBINATION FL))
	(IF (FLAVOR-METHOD-HASH-TABLE FL) (COMPOSE-METHOD-COMBINATION FL))))))

(DEFUN DESCRIBE-FLAVOR (FLAVOR-NAME &AUX FL)
  (SETQ FL (IF (SYMBOLP FLAVOR-NAME) (GET-FLAVOR FLAVOR-NAME)
	       FLAVOR-NAME))
  (CHECK-ARG FLAVOR-NAME (:TYPEP FL 'FLAVOR)
	     "a flavor or the name of one")
  (FORMAT T "~&Flavor ~S directly depends on flavors: ~:[none~;~1G~{~S~^, ~}~]~%"
	    FLAVOR-NAME (FLAVOR-DEPENDS-ON FL))
  (AND (FLAVOR-INCLUDES FL)
       (FORMAT T " and directly includes ~{~S~^, ~}~%" (FLAVOR-INCLUDES FL)))
  (AND (FLAVOR-DEPENDED-ON-BY FL)
       (FORMAT T " and is directly depended on by ~{~S~^, ~}~%" (FLAVOR-DEPENDED-ON-BY FL)))
  (AND (FLAVOR-DEPENDS-ON-ALL FL)	;If this has been computed, show it
       (FORMAT T " and directly or indirectly depends on ~{~S~^, ~}~%"
	         (FLAVOR-DEPENDS-ON-ALL FL)))
  (AND (FLAVOR-METHOD-HASH-TABLE FL)	;If has been composed
       (FORMAT T "Flavor ~S has instance variables ~:S~%"
	         FLAVOR-NAME (FLAVOR-ALL-INSTANCE-VARIABLES FL)))
  (COND ((NOT (NULL (FLAVOR-METHOD-TABLE FL)))
	 (FORMAT T "Not counting inherited methods, the methods for ~S are:~%"
		 FLAVOR-NAME)
	 (DOLIST (M (FLAVOR-METHOD-TABLE FL))
	   (FORMAT T "   ")
	   (DO ((TPL (SUBSET 'METH-DEFINEDP (CDDDR M)) (CDR TPL)))
	     ((NULL TPL))
	     (IF (METH-METHOD-TYPE (CAR TPL))
		 (FORMAT T "~A " (METH-METHOD-TYPE (CAR TPL))))
	     (FORMAT T "~A" (CAR M))
	     (IF (CDR TPL) (PRINC ", ")))
	   ;; Print the method combination type if there is any.
	   (AND (CADR M)
		(FORMAT T "    :~A~@[ :~A~]" (CADR M) (CADDR M)))
	   (TERPRI))))
  (AND (FLAVOR-ALL-INSTANCE-VARIABLES FL)
       (FORMAT T "Instance variables: ~{~S~^, ~}~%" (FLAVOR-ALL-INSTANCE-VARIABLES FL)))
  (AND (FLAVOR-GETTABLE-INSTANCE-VARIABLES FL)
       (FORMAT T "Automatically-generated methods to get instance variables: ~{~S~^, ~}~%"
	         (FLAVOR-GETTABLE-INSTANCE-VARIABLES FL)))
  (AND (FLAVOR-SETTABLE-INSTANCE-VARIABLES FL)
       (FORMAT T "Automatically-generated methods to set instance variables: ~{~S~^, ~}~%"
	         (FLAVOR-SETTABLE-INSTANCE-VARIABLES FL)))
  (AND (FLAVOR-INITABLE-INSTANCE-VARIABLES FL)
       (FORMAT T "Instance variables that may be set by initialization: ~{~S~^, ~}~%"
	         (MAPCAR #'CDR (FLAVOR-INITABLE-INSTANCE-VARIABLES FL))))
  (AND (FLAVOR-INIT-KEYWORDS FL)
       (FORMAT T "Keywords in the :INIT message handled by this flavor: ~{~S~^, ~}~%"
	         (FLAVOR-INIT-KEYWORDS FL)))
  (COND ((FLAVOR-PLIST FL)
	 (FORMAT T "Properties:~%")
	 (DO L (CDR (FLAVOR-PLIST FL)) (CDDR L) (NULL L)
	   (FORMAT T "~5X~S:	~S~%" (CAR L) (CADR L)))))
  (COND ((NULL (FLAVOR-METHOD-HASH-TABLE FL))
	 (FORMAT T "Flavor ~S does not yet have a method hash table~%" FLAVOR-NAME))
	(T (FORMAT T "Flavor ~S has method hash table:~%" FLAVOR-NAME)
	   (PRINT (FLAVOR-METHOD-HASH-TABLE FL)))))

;; This is the standard way of defining a method of a class,
;; so that the code will be compiled.  
;; If in place of the lambda-list you have a symbol, and the body
;; is null, that symbol is a function which stands in for the method.
(DEFMACRO DEFMETHOD (SPEC LAMBDA-LIST . BODY)
  (LET ((CLASS-NAME (CAR SPEC))
	(FUNCTION-SPEC (CONS ':METHOD SPEC))
	FUNCTION-NAME)
    (SETQ FUNCTION-NAME (METHOD-FUNCTION-NAME FUNCTION-SPEC))
    `(PROGN 'COMPILE
       (EVAL-WHEN (COMPILE LOAD EVAL)
	  (FLAVOR-NOTICE-METHOD ',FUNCTION-SPEC))
       ;; At load-time, define the method function
       ,(COND ((AND (SYMBOLP LAMBDA-LIST) (NOT (NULL LAMBDA-LIST))
		    (NULL BODY))
	       #-Franz `(FDEFINE ',FUNCTION-SPEC ',LAMBDA-LIST)
	       #+Franz `(DEFUN ,FUNCTION-NAME (OPERATION . ,LAMBDA-LIST)
			       (,lambda-list (operation . ,lambda-list))))
	      ((GET CLASS-NAME 'FLAVOR)
	       `(DEFUN ,FUNCTION-NAME (OPERATION . ,LAMBDA-LIST)
		  (DECLARE (SPECIAL SELF .OWN-FLAVOR.
				    ,@(FLAVOR-ALL-INSTANCE-VARIABLES
				       (GET-FLAVOR CLASS-NAME))))
		  . ,BODY))
	      (T ;; The non-flavor class system
		(FERROR () "Old Class system is not SUPPORTED")))
       ',FUNCTION-SPEC)))

(DEFUN REMOVE-COLON (SYMBOL)
  (IF (= (GETCHARN SYMBOL 1) #/:)
      (CONCAT (SUBSTRING SYMBOL 2))
      SYMBOL))

; This lets you specify code to be wrapped around the invocation of the
; various methods for an operation.  For example,
; (DEFWRAPPER (FOO-FLAVOR :OPERATION) ((ARG1 ARG2) . BODY)
;   `(WITH-FOO-LOCKED (SELF)
;      (PRE-FROBULATE SELF ARG1 ARG2)
;      ,@BODY
;      (POST-FROBULATE SELF ARG2 ARG1)))
;Note that the wrapper needs to be defined at both compile and run times
;so that compiling combined methods as part of the qfasl file works.

#+Franz
(defmacro destructuring-bind (template values . body)
 `(let ((,template ,values)) . ,body))

(DEFMACRO DEFWRAPPER
  ((FLAVOR-NAME OPERATION) (DEFMACRO-LAMBDA . GUTS) &BODY BODY)
  (LET ((FUNCTION-SPEC `(:METHOD ,FLAVOR-NAME :WRAPPER ,OPERATION))
	function-name)
       (setq function-name (method-function-name function-spec))
       `(PROGN ;; 'COMPILE
	       ;; Unfortunately, in Franz wrappers should not be compiled
	       ;; since the actual definition is needed by macrocall.
	       ;; Macrocall is clearly a crock!
	    ;; The following optimization could go away if defmacro were
	    ;; very smart.
	    ,(IF (AND (SYMBOLP DEFMACRO-LAMBDA)
		      (EQUAL DEFMACRO-LAMBDA 'IGNORE))
		 `(DEFMACRO ,function-name (IGNORE . ,GUTS) . ,BODY)
		 `(DEFMACRO ,function-name (ARGLISTNAME . ,GUTS)
		    `(DESTRUCTURING-BIND ,',DEFMACRO-LAMBDA (CDR ,ARGLISTNAME)
					 ,,@BODY)))
	 (flavor-notice-method ',function-spec))))

;This just exists to be called at compile-time from the DEFMETHOD macro,
;so that any combined methods generated by COMPILE-FLAVOR-METHODS will
;know that this method will be around at run time and should be called.
(DEFUN FLAVOR-NOTICE-METHOD (FUNCTION-SPEC)
  (LET ((METH (FLAVOR-METHOD-ENTRY FUNCTION-SPEC NIL T)))
    (COND ((NOT (EQ (METH-DEFINITION METH)
		    (METHOD-FUNCTION-NAME FUNCTION-SPEC)))
	   (SETF (METH-DEFINITION METH) (METHOD-FUNCTION-NAME FUNCTION-SPEC))
	   (RECOMPILE-FLAVOR (SECOND FUNCTION-SPEC)
			     (CAR (LAST FUNCTION-SPEC)))))))

(DEFUN METHOD-FUNCTION-NAME (FUNCTION-SPEC)
  (LET ((FLAVOR (SECOND FUNCTION-SPEC))
	(METHOD-TYPE (THIRD FUNCTION-SPEC))
	(MESSAGE (FOURTH FUNCTION-SPEC)))
    (IF (NULL (CDDDR FUNCTION-SPEC))
	(SETQ MESSAGE (THIRD FUNCTION-SPEC) METHOD-TYPE NIL))
    (IF (NULL METHOD-TYPE)
	(INTERN (FORMAT () "~A-~A-method" FLAVOR (REMOVE-COLON MESSAGE)))
	(INTERN
	 (FORMAT () "~A-~A-~A-method"
		 FLAVOR (REMOVE-COLON METHOD-TYPE) (REMOVE-COLON MESSAGE))))))

;Find or create a method-table entry for the specified method.
;DONT-CREATE is NIL if method is to be created if necessary.
;	The flavor is "created" too, as an UNDEFINED-FLAVOR property
;	of the flavor name, just to record any properties of methods.
;COPY-FLAVOR-IF-UNDEFINED-METH says we are going to alter the METH
;for compilation if it is not defined, so the flavor should be copied in that case.
(DEFUN FLAVOR-METHOD-ENTRY (FUNCTION-SPEC DONT-CREATE
				&OPTIONAL COPY-FLAVOR-IF-UNDEFINED-METH)
			   		  ;; Huh? Unused! -SMH
  (LET ((FLAVOR-NAME (SECOND FUNCTION-SPEC))
	(TYPE (THIRD FUNCTION-SPEC))
	(MESSAGE (FOURTH FUNCTION-SPEC)))
    (IF (NULL MESSAGE) (SETQ MESSAGE TYPE TYPE NIL))	;If no type
    (IF (OR (NULL MESSAGE) (NEQ (FIRST FUNCTION-SPEC) ':METHOD)
	    (> (LENGTH FUNCTION-SPEC) 4)
	    (NOT (SYMBOLP FLAVOR-NAME)) (NOT (SYMBOLP TYPE))
	    (NOT (SYMBOLP MESSAGE)))
	(FERROR () "~S is not a valid function-spec" FUNCTION-SPEC))
    (LET* ((FL (OR (GET-FLAVOR FLAVOR-NAME)
		   (GET FLAVOR-NAME 'UNDEFINED-FLAVOR)
		   (AND (NOT DONT-CREATE)
			(PUTPROP FLAVOR-NAME
				 (MAKE-FLAVOR FLAVOR-NAME FLAVOR-NAME)
				 'UNDEFINED-FLAVOR))))
	   (MTE (AND FL (ASSQ MESSAGE (FLAVOR-METHOD-TABLE FL))))
	   (METH (METH-LOOKUP TYPE (CDDDR MTE))))
      (AND (NULL MTE) (NOT DONT-CREATE)
	   ;; Message not previously known about, put into table
	   FL
	   (PUSH (SETQ MTE (LIST* MESSAGE NIL NIL NIL)) (FLAVOR-METHOD-TABLE FL)))
      ;; Message known, search for the type entry
      (COND (METH)	;Known by flavor
	    (DONT-CREATE NIL)		;Not to be created
	    ((NULL FL) NIL)	;Create, but no flavor defined
	    (T ;; Type not known, create a new meth with an unbound definition cell
	     (LET ((METH (LIST FUNCTION-SPEC NIL NIL)))
	       (NULLIFY-METHOD-DEFINITION METH)
	       (PUSH METH (CDDDR MTE))
	       METH))))))

;;; See if a certain method exists in a flavor
(DEFUN FLAVOR-METHOD-EXISTS (FL TYPE OPERATION &AUX MTE)
  (AND (SETQ MTE (ASSQ OPERATION (FLAVOR-METHOD-TABLE FL)))
       (LET ((METH (METH-LOOKUP TYPE (CDDDR MTE))))
	 (AND METH (METH-DEFINEDP METH)))))

;;; Forcibly remove a method definition from a flavor's method table
;;; Syntax is identical to the beginning of a defmethod for the same method.
(DEFMACRO UNDEFMETHOD (SPEC)
  `(FUNDEFINE '(:METHOD . ,SPEC)))

;Make an object of a particular flavor, taking the init-plist options
;as a rest argument and sending the :INIT message if the flavor
;handles it.
(DEFUN MAKE-INSTANCE (FLAVOR-NAME &REST INIT-OPTIONS)
  (INSTANTIATE-FLAVOR FLAVOR-NAME (CONS 'INSTANCE-OPTIONS INIT-OPTIONS)
		      'MAYBE))

(DEFUN FLAVOR-DISPATCH (MESSAGE &REST ARGUMENTS &AUX FUN)
  (DECLARE (SPECIAL .OWN-FLAVOR.))
  (SETQ FUN (OR (GETHASH MESSAGE (FLAVOR-METHOD-HASH-TABLE .OWN-FLAVOR.))
		(FLAVOR-DEFAULT-HANDLER .OWN-FLAVOR.)))
  (IF (NOT (NULL FUN))
      (LEXPR-FUNCALL FUN MESSAGE ARGUMENTS)
      (FLAVOR-UNCLAIMED-MESSAGE MESSAGE ARGUMENTS)))      

;; The first six slots are for SELF and .OWN-FLAVOR. The values are in the
;; third slot.
; SMH@EMS VVV
; Perforce, %instance-ref no longer used.
;	(DEFSUBST %INSTANCE-REF (INSTANCE INDEX)
;	  (VREF INSTANCE (+ 9. (* 3 INDEX))))
;	(DEFSUBST INSTANCE-FLAVOR (INSTANCE) (VREF INSTANCE 6))
; The previous instance-flavor ought always to be good, if inefficient.
;	(DEFSUBST INSTANCE-FLAVOR (INSTANCE) (VREF INSTANCE 3))
; SMH@EMS ^^^

;Make an object of a particular flavor.
;If the flavor hasn't been composed yet, must do so now.
; Delaying it until the first time it is needed aids initialization,
; e.g. up until now we haven't depended on the depended-on flavors being defined yet.
;Note that INIT-PLIST can be modified, if the :DEFAULT-INIT-PLIST option was
; used or the init methods modify it.
(DEFUN INSTANTIATE-FLAVOR (FLAVOR-NAME INIT-PLIST
		           &OPTIONAL SEND-INIT-MESSAGE-P
				     RETURN-UNHANDLED-KEYWORDS-P ;as second value
			   &AUX FL FFL UNHANDLED-KEYWORDS INSTANCE VARS N TEM)
  (CHECK-ARG FLAVOR-NAME (SETQ FL (GET FLAVOR-NAME 'FLAVOR)) "the name of a flavor")
  ;; Do any composition (compilation) of combined stuff, if not done already
  (OR (FLAVOR-DEPENDS-ON-ALL FL) (COMPOSE-FLAVOR-COMBINATION FL))
  (OR (FLAVOR-METHOD-HASH-TABLE FL) (COMPOSE-METHOD-COMBINATION FL))
  (SETQ VARS (FLAVOR-ALL-INSTANCE-VARIABLES FL))
;; Make the instance object, then fill in its various fields
  (SETQ INSTANCE
	(PROGV `(SELF .OWN-FLAVOR. ,@VARS)
	       `(NIL ,FL)
	       (FCLOSURE `(SELF .OWN-FLAVOR. ,@VARS)
			 #'FLAVOR-DISPATCH)))
  (LOOP FOR I FROM 0 TO (LENGTH VARS)
	WITH IVS = (FLAVOR-INSTANCE-VARIABLE-INITIALIZATIONS FL)
	WHEN (= I (CAAR IVS))
; SMH@EMS VVV
;	DO (PROGN (SETF (%INSTANCE-REF INSTANCE I)
;			(FAST-EVAL (CADAR IVS)))
;		  (POP IVS)))
	DO (PROGN (INT:FCLOSURE-STACK-STUFF (VREF INSTANCE (+ 3 I))
					    (FAST-EVAL (CADAR IVS)))
		  (POP IVS)))
; SMH@EMS ^^^
  (SET-IN-FCLOSURE INSTANCE 'SELF INSTANCE)
  (LET ((VAR-KEYWORDS (FLAVOR-ALL-INITABLE-INSTANCE-VARIABLES FL))
	(REMAINING-KEYWORDS (FLAVOR-REMAINING-INIT-KEYWORDS FL)))
    (COND (VAR-KEYWORDS
	   ;; First, process any user-specified init keywords that
	   ;; set instance variables.  When we process the defaults,
	   ;; we will see that these are already set, and will
	   ;; refrain from evaluating the default forms.  At the same time,
	   ;; we record any init keywords that this flavor doesn't handle.
	   (DO ((PL (CDR INIT-PLIST) (CDDR PL))) ((NULL PL))
	     (COND ((MEMQ (CAR PL) VAR-KEYWORDS)
		    (SET-IN-FCLOSURE INSTANCE (REMOVE-COLON (CAR PL))
				     (CADR PL)))
		   ((NOT (MEMQ (CAR PL) REMAINING-KEYWORDS))
		    (PUSH (CAR PL) UNHANDLED-KEYWORDS))))
	   ;; Now stick any default init plist items that aren't handled by 
	   ;; that onto the actual init plist.
	   (DO ((PL (FLAVOR-REMAINING-DEFAULT-PLIST FL) (CDDR PL)))
	       ((NULL PL))
	     (OR (MEMQ-ALTERNATED (CAR PL) (CDR INIT-PLIST))
		 (PUTPROP INIT-PLIST (FAST-EVAL (CADR PL)) (CAR PL)))))
	  (T
	   ;; Put defaults into the INIT-PLIST
	   (FLAVOR-DEFAULT-INIT-PLIST FLAVOR-NAME INIT-PLIST)
	   ;; For each init keyword, either initialize the corresponding 
	   ;; variable, remember that it will be handled later by an :INIT 
	   ;; method, or give an error for not being handled.
	   (DO L (CDR INIT-PLIST) (CDDR L) (NULL L)
	       (LET ((KEYWORD (CAR L)) (ARG (CADR L)))
		 (DO ((FFLS (FLAVOR-DEPENDS-ON-ALL FL) (CDR FFLS)))
		     ((NULL FFLS) (PUSH KEYWORD UNHANDLED-KEYWORDS))
		   (SETQ FFL (GET (CAR FFLS) 'FLAVOR))
		   (COND ((SETQ TEM (ASSQ KEYWORD (FLAVOR-INITABLE-INSTANCE-VARIABLES FFL)))
			  (SET-IN-FCLOSURE INSTANCE (REMOVE-COLON KEYWORD)
					   ARG)
			  (RETURN))
			 ((MEMQ KEYWORD (FLAVOR-INIT-KEYWORDS FFL))
			  (RETURN)))))))))
  ;; Complain if any keywords weren't handled, unless our caller
  ;; said it wanted to take care of this.
  (AND (NOT RETURN-UNHANDLED-KEYWORDS-P)
       UNHANDLED-KEYWORDS
       (FERROR () "Flavor ~S does not handle the init keyword~P ~{~S~^, ~}"
	       FLAVOR-NAME
	       (LENGTH UNHANDLED-KEYWORDS)
	       UNHANDLED-KEYWORDS))
  (AND (EQ SEND-INIT-MESSAGE-P 'MAYBE)
       (NOT (GET-HANDLER-FOR INSTANCE ':INIT))
       (SETQ SEND-INIT-MESSAGE-P NIL))
  (AND SEND-INIT-MESSAGE-P
       (SEND INSTANCE ':INIT INIT-PLIST))
  (VALUES INSTANCE UNHANDLED-KEYWORDS))

(DEFUN MEMQ-ALTERNATED (ELT LIST)
  (DO ((L LIST (CDDR L))) ((NULL L) NIL)
    (IF (EQ (CAR L) ELT) (RETURN L))))

(DEFUN FAST-EVAL (EXP)
  (COND ((OR (NUMBERP EXP) (STRINGP EXP)
	     (MEMQ EXP '(T NIL)))
	 EXP)
	((SYMBOLP EXP) (SYMEVAL EXP))
	((AND (LISTP EXP) (EQ (CAR EXP) 'QUOTE))
	 (CADR EXP))
	(T (EVAL EXP))))

(DEFUN FLAVOR-DEFAULT-INIT-PLIST (FLAVOR-NAME
				  &OPTIONAL (INIT-PLIST (NCONS NIL))
				  &AUX FL)
  (CHECK-ARG FLAVOR-NAME (SETQ FL (GET FLAVOR-NAME 'FLAVOR))
	     "the name of a flavor")
  ;; Do any composition (compilation) of combined stuff, if not done already
  (OR (FLAVOR-DEPENDS-ON-ALL FL) (COMPOSE-FLAVOR-COMBINATION FL))
  (DOLIST (FFL (FLAVOR-DEPENDS-ON-ALL FL))
    (SETQ FFL (GET FFL 'FLAVOR))
    (DO L (GET (FLAVOR-PLIST FFL) ':DEFAULT-INIT-PLIST) (CDDR L) (NULL L)
      (DO ((M (CDR INIT-PLIST) (CDDR M)))
	  ((NULL M) (PUTPROP INIT-PLIST (EVAL (CADR L)) (CAR L)))
	(AND (EQ (CAR M) (CAR L)) (RETURN)))))
  INIT-PLIST)

;Returns non-NIL if the flavor allows the specified keyword in its init-plist,
;NIL if it doesn't.  The return value is the name of the component flavor
;that actually handles it.
(DEFUN FLAVOR-ALLOWS-INIT-KEYWORD-P (FLAVOR-NAME KEYWORD)
  (MAP-OVER-COMPONENT-FLAVORS 0 T T
      #'(LAMBDA (FL IGNORE KEYWORD)
	  (AND (OR (ASSQ KEYWORD (FLAVOR-INITABLE-INSTANCE-VARIABLES FL))
		   (MEMQ KEYWORD (FLAVOR-INIT-KEYWORDS FL)))
	       (FLAVOR-NAME FL)))
      FLAVOR-NAME NIL KEYWORD))

;;; Given the name of a flavor, return a list of all of the symbols that
;;; are valid init-options for the flavor, sorted alphabetically.
;;; Primary for inquiries by humans.
(DEFUN FLAVOR-ALLOWED-INIT-KEYWORDS (FLAVOR-NAME)
  (LET ((INIT-KEYWORDS NIL))
    (DECLARE (SPECIAL INIT-KEYWORDS))
    (MAP-OVER-COMPONENT-FLAVORS 0 T NIL
	#'(LAMBDA (FLAVOR IGNORE)
	    (DECLARE (SPECIAL INIT-KEYWORDS))
	    (SETQ INIT-KEYWORDS
		  (NCONC (MAPCAR #'(LAMBDA (KWD)
				     (IF (LISTP KWD) (CAR KWD) KWD))
				 (FLAVOR-LOCAL-INIT-KEYWORDS FLAVOR))
			 INIT-KEYWORDS)))
	FLAVOR-NAME NIL)
    (SORT (ELIMINATE-DUPLICATES INIT-KEYWORDS) #'ALPHALESSP)))

(DEFUN FLAVOR-LOCAL-INIT-KEYWORDS (FLAVOR)
  (APPEND (FLAVOR-INITABLE-INSTANCE-VARIABLES FLAVOR)
	  (FLAVOR-INIT-KEYWORDS FLAVOR)))

(DEFUN ELIMINATE-DUPLICATES (LIST &AUX L)
  (DOLIST (E LIST) (OR (MEMQ E L) (PUSH E L)))
  L)

; Function to map over all components of a specified flavor.  We must do the
;  DEPENDS-ON's to all levels first, then the INCLUDES's at all levels and
;  what they depend on.
; Note that it does the specified flavor itself as well as all its components.
; Note well: if there are included flavors, this does not do them in the
;  right order.  Also note well: if there are multiple paths to a component,
;  it will be done more than once.
; RECURSION-STATE is 0 except when recursively calling itself.
; ERROR-P is T if not-yet-defflavored flavors are to be complained about,
;  NIL if they are to be ignored.  This exists to get rid of certain
;  bootstrapping problems.
; RETURN-FIRST-NON-NIL is T if the iteration should terminate as soon
;  as FUNCTION returns a non-null result.
; At each stage FUNCTION is applied to the flavor (not the name), the
;  STATE, and any ARGS.  STATE is updated to whatever the function returns.
; The final STATE is the final result of this function.
; RECURSION-STATE is:
;  0	top-level
;  1	first-pass over just depends-on's
;  6  	second-pass, this flavor reached via depends-on's so don't do it again
;  2	second-pass, this flavor reached via includes's so do it.
(DEFVAR SOME-COMPONENT-UNDEFINED NIL)   ;If we find an undefined component, we put its name here.

(DEFUN MAP-OVER-COMPONENT-FLAVORS (RECURSION-STATE ERROR-P
				   RETURN-FIRST-NON-NIL FUNCTION FLAVOR-NAME
				   STATE &REST ARGS)
  (PROG (FL)
   (*CATCH 'MAP-OVER-COMPONENT-FLAVORS
    (COND ((OR ERROR-P (GET-FLAVOR FLAVOR-NAME))
	   (CHECK-ARG FLAVOR-NAME (SETQ FL (GET-FLAVOR FLAVOR-NAME))
		      "a defined flavor")
	   ;; First do this flavor, unless this is the second pass and it shouldn't be done
	   (OR (BIT-TEST 4 RECURSION-STATE)
	       (SETQ STATE (LEXPR-FUNCALL FUNCTION FL STATE ARGS)))
	   ;; After each call to the function, see if we're supposed to be done now
	   (AND RETURN-FIRST-NON-NIL (NOT (NULL STATE))
		(*THROW 'MAP-OVER-COMPONENT-FLAVORS NIL))
	   ;; Now do the depends-on's.
	   (DOLIST (COMPONENT-FLAVOR (FLAVOR-DEPENDS-ON FL))
	     (SETQ STATE (LEXPR-FUNCALL #'MAP-OVER-COMPONENT-FLAVORS
					    (IF (ZEROP RECURSION-STATE) 1 RECURSION-STATE)
					    ERROR-P RETURN-FIRST-NON-NIL
					    FUNCTION COMPONENT-FLAVOR STATE ARGS))
	     (AND RETURN-FIRST-NON-NIL (NOT (NULL STATE))
		  (*THROW 'MAP-OVER-COMPONENT-FLAVORS NIL)))
	   ;; Unless this is the first pass, do the includes.
	   (OR (BIT-TEST 1 RECURSION-STATE)
	       (DOLIST (COMPONENT-FLAVOR (FLAVOR-INCLUDES FL))
		 (SETQ STATE (LEXPR-FUNCALL #'MAP-OVER-COMPONENT-FLAVORS
						2 ERROR-P RETURN-FIRST-NON-NIL
						FUNCTION COMPONENT-FLAVOR STATE ARGS))
		 (AND RETURN-FIRST-NON-NIL (NOT (NULL STATE))
		      (*THROW 'MAP-OVER-COMPONENT-FLAVORS NIL))))
	   ;; If this is the top-level, run the second pass on its depends-on's
	   ;; which doesn't do them but does do what they include.
	   (OR (NOT (ZEROP RECURSION-STATE))
	       (DOLIST (COMPONENT-FLAVOR (FLAVOR-DEPENDS-ON FL))
		 (SETQ STATE (LEXPR-FUNCALL #'MAP-OVER-COMPONENT-FLAVORS
					    6 ERROR-P RETURN-FIRST-NON-NIL
					    FUNCTION COMPONENT-FLAVOR STATE ARGS))
		 (AND RETURN-FIRST-NON-NIL (NOT (NULL STATE))
		      (*THROW 'MAP-OVER-COMPONENT-FLAVORS NIL)))))
	  ((NULL SOME-COMPONENT-UNDEFINED)
	   (SETQ SOME-COMPONENT-UNDEFINED FLAVOR-NAME)))))
  STATE)

;Call this when a flavor has been changed, it updates that flavor's compiled
; information and that of any that depend on it.
;If a compilation is in progress the compilations performed
; will get output as part of that compilation.
;SINGLE-OPERATION is NIL to do all operations, or the name of an operation
; which needs incremental compilation.
;USE-OLD-COMBINED-METHODS can be NIL to force regeneration of all combined methods.
; This is used if a wrapper has changed or there was a bug in the method-combining routine.
;DO-DEPENDENTS controls whether flavors that depend on this one are also compiled.
(DEFUN RECOMPILE-FLAVOR (FLAVOR-NAME
		         &OPTIONAL (SINGLE-OPERATION NIL) (*USE-OLD-COMBINED-METHODS* T)
				   (DO-DEPENDENTS T)
			 &AUX FL)
  (CHECK-ARG FLAVOR-NAME (SETQ FL (GET FLAVOR-NAME 'FLAVOR)) "the name of a flavor")
  ;; Only update the method combination if it has been done before, else 
  ;; doesn't matter
  (COND ((FLAVOR-METHOD-HASH-TABLE FL)
	 (OR (FLAVOR-DEPENDS-ON-ALL FL)
	     (COMPOSE-FLAVOR-COMBINATION FL))
	 (COMPOSE-METHOD-COMBINATION FL SINGLE-OPERATION)))
  (IF DO-DEPENDENTS
      (LET ((FDEFINE-FILE-PATHNAME NIL))	;Don't give warnings for combined methods
	(DOLIST (FN (FLAVOR-DEPENDED-ON-BY-ALL FL))
	  (IF (FLAVOR-METHOD-HASH-TABLE (GET FN 'FLAVOR))
	      (RECOMPILE-FLAVOR FN SINGLE-OPERATION *USE-OLD-COMBINED-METHODS* NIL))))))

;Make a list of all flavors that depend on this one, not including this flavor itself.
;This is a list of the names, not the defstructs.
(DEFUN FLAVOR-DEPENDED-ON-BY-ALL (FL &OPTIONAL (LIST-SO-FAR NIL) &AUX FFL)
  (DOLIST (FN (FLAVOR-DEPENDED-ON-BY FL))
    (OR (MEMQ FN LIST-SO-FAR)
	(NOT (SETQ FFL (GET FN 'FLAVOR)))
	(SETQ LIST-SO-FAR (FLAVOR-DEPENDED-ON-BY-ALL FFL (CONS FN LIST-SO-FAR)))))
  LIST-SO-FAR)

;This function takes care of flavor-combination.  It sets up the list
;of all component flavors, in appropriate order, and the list of all
;instance variables.  It generally needs to be called only once for a
;flavor, and must be called before method-combination can be dealt with.
(DEFVAR FLAVORS-BEING-COMPOSED NIL)

(DEFUN COMPOSE-FLAVOR-COMBINATION (FL &AUX FLS VARS ORDS REQS SIZE
				   (SOME-COMPONENT-UNDEFINED NIL)
				   (FLAVORS-BEING-COMPOSED
				     (CONS FL FLAVORS-BEING-COMPOSED)))
  ;; Make list of all component flavors' names.
  ;; This list is in outermost-first order.
  ;; Would be nice for this not to have to search to all levels, but for
  ;; the moment that is hard, so I won't do it.
  ;; Included-flavors are hairy: if not otherwise in the list of components, they
  ;; are stuck in after the rightmost component that includes them, along with
  ;; any components of their own not otherwise in the list.
  (SETQ FLS (COPYLIST (COMPOSE-FLAVOR-INCLUSION (FLAVOR-NAME FL) T)))
  ;; Don't mark this flavor as "composed" if there were errors.
  (OR SOME-COMPONENT-UNDEFINED
      (SETF (FLAVOR-DEPENDS-ON-ALL FL) FLS))
  ;; Vanilla-flavor may have been put in by magic, so maintain the dependencies
  ;; in case new methods get added to it later.
  (LET ((VAN (GET-FLAVOR 'SI:VANILLA-FLAVOR))
	(FLAV (FLAVOR-NAME FL)))
    (AND (NOT (NULL VAN))
	 (NEQ FLAV 'SI:VANILLA-FLAVOR)
	 (MEMQ 'SI:VANILLA-FLAVOR FLS)
	 (NOT (MEMQ FLAV (FLAVOR-DEPENDED-ON-BY VAN)))
	 (PUSH FLAV (FLAVOR-DEPENDED-ON-BY VAN))))
  ;; Compute what the instance variables will be, and in what order.
  ;; Also collect the required but not present instance variables, which go onto the
  ;; ADDITIONAL-INSTANCE-VARIABLES property.  The instance variables of the
  ;; :REQUIRED-FLAVORS work the same way.  Such instance variables are ok
  ;; for our methods to access.
  (DOLIST (F FLS)
    (SETQ F (GET-FLAVOR F))
    (DOLIST (V (FLAVOR-LOCAL-INSTANCE-VARIABLES F))
      (OR (ATOM V) (SETQ V (CAR V)))
      (OR (MEMQ V VARS) (PUSH V VARS)))
    (SETQ REQS (UNION REQS
		      (GET (FLAVOR-PLIST F) ':REQUIRED-INSTANCE-VARIABLES)))
    ;; Any variables our required flavors have or require, we require.
    (DOLIST (FF (GET (FLAVOR-PLIST F) ':REQUIRED-FLAVORS))
      (COND ((AND (NOT (MEMQ FF FLS))
		  (SETQ FF (GET-FLAVOR FF))
		  (NOT (MEMQ FF (CDR FLAVORS-BEING-COMPOSED))))
	     (OR (FLAVOR-DEPENDS-ON-ALL FF) (COMPOSE-FLAVOR-COMBINATION FF))
	     (SETQ REQS
		   (UNION REQS (FLAVOR-ALL-INSTANCE-VARIABLES FF)
			  (GET (FLAVOR-PLIST FF) 'ADDITIONAL-INSTANCE-VARIABLES))))))
    (LET ((ORD (GET (FLAVOR-PLIST F) ':ORDERED-INSTANCE-VARIABLES)))
      ;; Merge into existing order requirement.  Shorter of the two must be
      ;; a prefix of the longer, and we take the longer.
      (DO ((L1 ORD (CDR L1))
	   (L2 ORDS (CDR L2)))
	  (NIL)
	(COND ((NULL L1) (RETURN NIL))
	      ((NULL L2) (RETURN (SETQ ORDS ORD)))
	      ((NEQ (CAR L1) (CAR L2))
	       (FERROR () ":ORDERED-INSTANCE-VARIABLES conflict, ~S vs ~S"
		           (CAR L1) (CAR L2)))))))
  ;; Must not merge this with the previous loop,
  ;; to avoid altering order of instance variables
  ;; if a DEFFLAVOR is redone.
  (DOLIST (F FLS)
    (SETQ F (GET-FLAVOR F)))
  ;; This NREVERSE makes it compatible with the old code.  There is no other reason for it.
  (SETQ VARS (NREVERSE VARS))
  ;; Apply ordering requirement by moving those variables to the front.
  (DOLIST (V ORDS)
    (OR (MEMQ V VARS)
	(FERROR () "Flavor ~S lacks instance variable ~S which has an order requirement"
		(FLAVOR-NAME FL) V))
    (SETQ VARS (DELQ V VARS)))
  (SETQ VARS (APPEND ORDS VARS))
  (SETF (FLAVOR-ALL-INSTANCE-VARIABLES FL) (COPYLIST VARS))
  ;; If there are any instance variables required but not present, save them
  ;; so that they can be declared special in methods.
  (DOLIST (V VARS)
    (SETQ REQS (DELQ V REQS)))
  (AND REQS (PUTPROP (FLAVOR-PLIST FL)
		     (COPYLIST REQS)
		     'ADDITIONAL-INSTANCE-VARIABLES))
  NIL)

(DEFUN COMPOSE-FLAVOR-INCLUSION (FLAVOR ERROR-P)
  (MULTIPLE-VALUE-BIND (FLS ADDITIONS) (COMPOSE-FLAVOR-INCLUSION-1 FLAVOR NIL ERROR-P)
    ;; The new additions may themselves imply more components
    (DO L ADDITIONS (CDR L) (NULL L)
      (LET ((MORE-FLS (COMPOSE-FLAVOR-INCLUSION-1 (CAR L) FLS ERROR-P)))
	(DOLIST (F MORE-FLS)
	  ;; This hair inserts F before (after) the thing that indirectly included it
	  ;; and then puts that next on ADDITIONS so it gets composed also
	  (LET ((LL (MEMQ (CAR L) FLS)))
	    (RPLACA (RPLACD LL (CONS (CAR LL) (CDR LL))) F)
	    (RPLACD L (CONS F (CDR L)))))))
    ;; Now attach vanilla-flavor if desired
    (OR (LOOP FOR FLAVOR IN FLS
	      THEREIS (GET (FLAVOR-PLIST (GET-FLAVOR FLAVOR))
			   ':NO-VANILLA-FLAVOR))
	(PUSH 'SI:VANILLA-FLAVOR FLS))
    (NREVERSE FLS)))

(local-declare ((special other-components))
(DEFUN COMPOSE-FLAVOR-INCLUSION-1 (FLAVOR OTHER-COMPONENTS ERROR-P)
  ;; First, make a backwards list of all the normal (non-included) components
  (LET ((FLS (MAP-OVER-COMPONENT-FLAVORS 1 ERROR-P NIL
	       #'(LAMBDA (FL LIST)
		   (SETQ FL (FLAVOR-NAME FL))
		   (OR (MEMQ FL LIST)
		       (MEMQ FL OTHER-COMPONENTS)
		       (PUSH FL LIST))
		   LIST)
	       FLAVOR NIL))
	(ADDITIONS NIL))
    ;; If there are any inclusions that aren't in the list, plug
    ;; them in right after (before in backwards list) their last (first) includer
    (DO L FLS (CDR L) (NULL L)
      (DOLIST (FL (FLAVOR-INCLUDES (GET-FLAVOR (CAR L))))
	(OR (MEMQ FL FLS)
	    (MEMQ FL OTHER-COMPONENTS)
	    (PUSH (CAR (RPLACA (RPLACD L (CONS (CAR L) (CDR L))) FL)) ADDITIONS))))
    (OR (MEMQ FLAVOR FLS)
	(SETQ FLS (NCONC FLS
			 (NREVERSE
			   (LOOP FOR FL IN (FLAVOR-INCLUDES (GET-FLAVOR FLAVOR))
				 UNLESS (OR (MEMQ FL FLS) (MEMQ FL OTHER-COMPONENTS))
				   COLLECT FL
				   AND DO (PUSH FL ADDITIONS))))))
    (VALUES FLS ADDITIONS))))

;Once the flavor-combination stuff has been done, do the method-combination stuff.
;The above function usually only gets called once, but this function gets called
;when a new method is added.
;Specify SINGLE-OPERATION to do this for just one operation, for incremental update.
;NOTE WELL: If a meth is in the method-table at all, it is considered to be defined
; for purposes of compose-method-combination.  Thus merely putprop'ing a method,
; or calling flavor-notice-method, will make the flavor think that method exists
; when it is next composed.  This is necessary to make compile-flavor-methods work.
; (Putprop must create the meth because loading does putprop before fdefine.)
(DEFUN COMPOSE-METHOD-COMBINATION (FL &OPTIONAL (SINGLE-OPERATION NIL)
				   &AUX TEM MAGIC-LIST ORDER DEF HT
				        MSG ELEM HANDLERS FFL PL)
  ;; If we are doing wholesale method composition,
  ;; compose the flavor bindings list also.
  ;; This way it is done often enough, but not at every defmethod.
  (IF (NOT SINGLE-OPERATION)
      (COMPOSE-FLAVOR-INITIALIZATIONS FL))
  ;; Look through all the flavors depended upon and collect the following:
  ;; A list of all the operations handled and all the methods for each, called MAGIC-LIST.
  ;; The default handler for unknown operations.
  ;; The declared order of entries in the select-method alist.
  ;; Also generate any automatically-created methods not already present.
  ;; MAGIC-LIST is roughly the same format as the flavor-method-table, see its comments.
  ;; Each magic-list entry is (message comb-type comb-order (type function-spec...)...)
  (DO ((FFLS (FLAVOR-DEPENDS-ON-ALL FL) (CDR FFLS)))
      ((NULL FFLS))
    (SETQ FFL (GET-FLAVOR (CAR FFLS))
	  PL (FLAVOR-PLIST FFL))
    (COND ((NOT SINGLE-OPERATION)
	   (AND (SETQ TEM (GET PL ':SELECT-METHOD-ORDER))
		(SETQ ORDER (NCONC ORDER (COPYLIST TEM))))))
    ;; Add data from flavor method-table to magic-list
    ;; But skip over combined methods, they are not relevant here
    (DOLIST (MTE (FLAVOR-METHOD-TABLE FFL))
      (SETQ MSG (CAR MTE)) 
     (COND ((OR (NOT SINGLE-OPERATION) (EQ MSG SINGLE-OPERATION))
	     ;; Well, we're supposed to concern ourselves with this operation
	     (SETQ ELEM (ASSQ MSG MAGIC-LIST))	;What we already know about it
	     (COND ((DOLIST (METH (CDDDR MTE))
		      (OR (EQ (METH-METHOD-TYPE METH) ':COMBINED)
			  (NOT (METH-DEFINEDP METH))
			  (RETURN T)))
		    ;; OK, this flavor really contributes to handling this operation
		   (OR ELEM (PUSH (SETQ ELEM (LIST* MSG NIL NIL NIL)) MAGIC-LIST))
		    ;; For each non-combined method for this operation, add it to the front
		    ;; of the magic-list element, thus they are in base-flavor-first order.
		    (DOLIST (METH (CDDDR MTE))
		      (LET ((TYPE (METH-METHOD-TYPE METH)))
			(COND ((EQ TYPE ':COMBINED))
			      ((NOT (METH-DEFINEDP METH)))
			      ((NOT (SETQ TEM (ASSQ TYPE (CDDDR ELEM))))
			       (PUSH (LIST TYPE (METH-FUNCTION-SPEC METH)) (CDDDR ELEM)))
			      ;; Don't let the same method get in twice (how could it?)
			      ((NOT (MEMQ (METH-FUNCTION-SPEC METH) (CDR TEM)))
			       (PUSH (METH-FUNCTION-SPEC METH) (CDR TEM))))))))
	     ;; Pick up method-combination declarations
	     (AND (CADR MTE) (CADR ELEM)	;If both specify combination-type, check
		  (OR (NEQ (CADR MTE) (CADR ELEM)) (NEQ (CADDR MTE) (CADDR ELEM)))
		  (FERROR ()
		      "Method-combination mismatch ~S-~S vs. ~S-~S, check your DEFFLAVOR's"
		      (CADR MTE) (CADDR MTE) (CADR ELEM) (CADDR ELEM)))
	     (COND ((CADR MTE)			;Save combination-type when specified
		    (OR ELEM (PUSH (SETQ ELEM (LIST* MSG NIL NIL NIL)) MAGIC-LIST))
		    (SETF (CADR ELEM) (CADR MTE))
		    (SETF (CADDR ELEM) (CADDR MTE)))) ))))
  ;; This NREVERSE tends to put base-flavor methods last
  (SETQ MAGIC-LIST (NREVERSE MAGIC-LIST))
  ;; Re-order the magic-list according to any declared required order
  (DOLIST (MSG (NREVERSE ORDER))
    (AND (SETQ TEM (ASSQ MSG MAGIC-LIST))
	 (SETQ MAGIC-LIST (CONS TEM (DELQ TEM MAGIC-LIST 1)))))
  ;; Map over the magic-list.  For each entry call the appropriate 
  ;; method-combining routine, which will return a function spec for 
  ;; the handler to use for this operation.
  (DOLIST (MTE MAGIC-LIST)
    ;; Punt if there are no methods at all (just a method-combination declaration)
    (COND ((CDDDR MTE)
	   ;; Process the :DEFAULT methods; if there are any untyped methods the
	   ;; default methods go away, otherwise they become untyped methods.
	   (AND (SETQ TEM (ASSQ ':DEFAULT (CDDDR MTE)))
		(IF (ASSQ NIL (CDDDR MTE))
		    (SETF (CDDDR MTE) (DELQ TEM (CDDDR MTE)))
		    (RPLACA TEM NIL)))
	   (OR (SETQ TEM (GET (OR (CADR MTE) ':DAEMON) 'METHOD-COMBINATION))
	       (FERROR () "~S unknown method combination type for ~S operation"
		           (CADR MTE) (CAR MTE)))
	   (PUSH (FUNCALL TEM FL MTE) HANDLERS))
	  (T (SETQ MAGIC-LIST (DELQ MTE MAGIC-LIST 1)))))
  ;; Get back into declared order.  We now have a list of function specs for handlers.
  (SETQ HANDLERS (NREVERSE HANDLERS))
  (COND (SINGLE-OPERATION
	  ;; If doing SINGLE-OPERATION, put it into the hash table.
	  ;; If the operation is becoming defined and wasn't, or vice versa,
	  ;; must recompute the which-operations list.
	  (OR (COND ((NULL HANDLERS)		;Deleting method
		     (NOT (REMHASH SINGLE-OPERATION
				   (FLAVOR-METHOD-HASH-TABLE FL))))
		    (T
		     (MULTIPLE-VALUE-BIND (NIL PREVIOUSLY-PRESENT)
		       (SWAPHASH SINGLE-OPERATION
				 (SETQ DEF (METHOD-FUNCTION-NAME
					    (CAR HANDLERS)))
				 (FLAVOR-METHOD-HASH-TABLE FL))
		       PREVIOUSLY-PRESENT)))
	      (SETF (FLAVOR-WHICH-OPERATIONS FL) NIL)))
	;; Working on all operations at once.
	(T
	 (SETQ HT (MAKE-HASH-TABLE
		   ':SIZE (FIX (TIMES 1.5 (LENGTH MAGIC-LIST)))))
	 ;; If flavor currently has no hash table, it can't hurt to set 
	 ;; it early
	 (OR (FLAVOR-METHOD-HASH-TABLE FL)
	     (SETF (FLAVOR-METHOD-HASH-TABLE FL) HT))
	 (DO ((HANDLERS HANDLERS (CDR HANDLERS))
	      (ML MAGIC-LIST (CDR ML)))
	   ((NULL ML))
	   (PUTHASH (CAAR ML) (SETQ DEF (METHOD-FUNCTION-NAME (CAR HANDLERS)))
		    HT)
	   (SETF (FLAVOR-METHOD-HASH-TABLE FL) HT)
	   (SETF (FLAVOR-WHICH-OPERATIONS FL) NIL))	;This will have to be recomputed
	 ;; Make sure that the required variables and methods are present.
	 (VERIFY-REQUIRED-FLAVORS-METHODS-AND-IVARS FL MAGIC-LIST)))
  NIL)

(DEFUN VERIFY-REQUIRED-FLAVORS-METHODS-AND-IVARS (FL MAGIC-LIST)
  (DO ((FFLS (FLAVOR-DEPENDS-ON-ALL FL) (CDR FFLS))
       (MISSING-METHODS NIL)
       (MISSING-INSTANCE-VARIABLES NIL)
       (MISSING-FLAVORS NIL)
       (REQUIRING-FLAVOR-ALIST NIL))
      ((NULL FFLS)
       (AND (OR MISSING-INSTANCE-VARIABLES MISSING-METHODS MISSING-FLAVORS)
	    (FERROR () "Flavor ~S is missing ~
				~:[~2*~;instance variable~P ~{~S~^, ~} ~]~
				~:[~3*~;~:[~;and ~]method~P ~{~S~^, ~}~]~
				~:[~3*~;~:[~;and ~]component flavor~P ~{~S~^, ~}~]
Requiring Flavor alist: ~S"
		    (FLAVOR-NAME FL)
		    MISSING-INSTANCE-VARIABLES
		    (LENGTH MISSING-INSTANCE-VARIABLES)
		    MISSING-INSTANCE-VARIABLES
		    MISSING-METHODS
		    MISSING-INSTANCE-VARIABLES
		    (LENGTH MISSING-METHODS)
		    MISSING-METHODS
		    MISSING-FLAVORS
		    (OR MISSING-INSTANCE-VARIABLES MISSING-METHODS)
		    (LENGTH MISSING-FLAVORS)
		    MISSING-FLAVORS
		    REQUIRING-FLAVOR-ALIST)))
    (LET ((PL (FLAVOR-PLIST (GET (CAR FFLS) 'FLAVOR))))
      (DOLIST (REQM (GET PL ':REQUIRED-METHODS))
	(OR (ASSQ REQM MAGIC-LIST)
	    (MEMQ REQM MISSING-METHODS)
	    (PROGN (PUSH REQM MISSING-METHODS)
		   (PUSH (CONS (FIRST FFLS) REQM) REQUIRING-FLAVOR-ALIST))))
      (DOLIST (REQV (GET PL ':REQUIRED-INSTANCE-VARIABLES))
	(OR (MEMQ REQV (FLAVOR-ALL-INSTANCE-VARIABLES FL))
	    (MEMQ REQV MISSING-INSTANCE-VARIABLES)
	    (PROGN (PUSH REQV MISSING-INSTANCE-VARIABLES)
		   (PUSH (CONS (FIRST FFLS) REQV) REQUIRING-FLAVOR-ALIST))))
      (DOLIST (REQF (GET PL ':REQUIRED-FLAVORS))
	(OR (MEMQ REQF (FLAVOR-DEPENDS-ON-ALL FL))
	    (MEMQ REQF MISSING-FLAVORS)
	    (PROGN (PUSH REQF MISSING-FLAVORS)
		   (PUSH (CONS (FIRST FFLS) REQF) REQUIRING-FLAVOR-ALIST)))))))

;This is the default handler for flavors.
(DEFUN FLAVOR-UNCLAIMED-MESSAGE (MESSAGE ARGS)
  (DECLARE (SPECIAL SELF))
  (FORMAT T "The object ")
  (PRINT SELF)
  (FERROR ':UNCLAIMED-MESSAGE " received a ~S message, which went unclaimed.
The rest of the message was ~S~%" MESSAGE ARGS))

;Return an alist of operations and their handlers.
(DEFUN FLAVOR-METHOD-ALIST (FL)
  (IF (SYMBOLP FL) (SETQ FL (GET FL 'FLAVOR)))
  (IF FL
      (LET ((HT (FLAVOR-METHOD-HASH-TABLE FL))
	    (ALIST NIL))
	(AND HT
	     (MAPHASH #'(LAMBDA (OP METH-LOCATIVE &REST IGNORE)
			   (DECLARE (SPECIAL ALIST))
			   (PUSH (CONS OP (CAR METH-LOCATIVE)) ALIST))
		      HT))
	    ALIST)))

;; Make the instance-variable getting and setting methods
;; Updated 7Jul84 SMH@MIT-EMS:  As an apparent efficiency hack, the original
;; Lisp Machine code pushed each defmethod only if **just-compiling** were set
;; or the method were not yet defined.  The **just-compiling** switch has
;; unfortunately disappeared from the Franz version.  This caused
;; REcompilations of a flavor by a single instance of Liszt to omit all
;; automatic methods.  The bypass of the defmethod if the method is already
;; defined has thus been deleted.
(DEFUN COMPOSE-AUTOMATIC-METHODS (FL &AUX VV FORMS)
       (DOLIST (V (FLAVOR-GETTABLE-INSTANCE-VARIABLES FL))
	       (SETQ VV (CORRESPONDING-KEYWORD V))
	       (LET ((METH `(:METHOD ,(FLAVOR-NAME FL) ,VV)))
		    (PUSH `(DEFMETHOD (,(FLAVOR-NAME FL) ,VV) () ,V)
			  FORMS)))
       (DOLIST (V (FLAVOR-SETTABLE-INSTANCE-VARIABLES FL))
	       (SETQ VV (INTERN (FORMAT () ":set-~A" V)))
	       (LET ((METH `(:METHOD ,(FLAVOR-NAME FL) ,VV)))
		    (PUSH `(DEFMETHOD (,(FLAVOR-NAME FL) ,VV) (VALUE)
				      (SETQ ,V VALUE))
			  FORMS)))
       (NREVERSE FORMS))

;Given a symbol return the corresponding one in the keyword package
(DEFUN CORRESPONDING-KEYWORD (SYMBOL)
  (IF (= #/: (GETCHARN SYMBOL 1)) SYMBOL
      (INTERN (CONCAT ":" SYMBOL))))

;Figure out the information needed to instantiate a flavor quickly.

;We store these three properties on the flavor:
;INSTANCE-VARIABLE-INITIALIZATIONS - alist of (ivar-index . init-form)
;REMAINING-DEFAULT-PLIST - a default plist from which kwds that init ivars 
;			   have been removed.
;ALL-INITABLE-INSTANCE-VARIABLES - 
;	a list parallel to FLAVOR-ALL-INSTANCE-VARIABLES which has either
;	the keyword to init with or NIL.
;REMAINING-INIT-KEYWORDS - 
;	the init keywords that are handled and don't just init ivars.

;We also set up the FLAVOR-DEFAULT-HANDLER of the flavor.

(DEFUN COMPOSE-FLAVOR-INITIALIZATIONS (FL &AUX ALIST
				       (REMAINING-DEFAULT-PLIST (LIST NIL))
				       ALL-INITABLE-IVARS)
  (SETQ ALL-INITABLE-IVARS (MAKE-LIST
			    (LENGTH (FLAVOR-ALL-INSTANCE-VARIABLES FL))))
  ;; First make the mask saying which ivars can be inited by init keywords.
  (DOLIST (FFL (FLAVOR-DEPENDS-ON-ALL FL))
    (LET ((FFL (GET-FLAVOR FFL)))
      (OR (FLAVOR-DEFAULT-HANDLER FL)
	  (SETF (FLAVOR-DEFAULT-HANDLER FL)
		(GET (FLAVOR-PLIST FFL) ':DEFAULT-HANDLER)))
      (DOLIST (IIV (FLAVOR-INITABLE-INSTANCE-VARIABLES FFL))
	(LET ((INDEX (FIND-POSITION-IN-LIST (CDR IIV)
			(FLAVOR-ALL-INSTANCE-VARIABLES FL))))
	  (AND INDEX
	       (SETF (NTH INDEX ALL-INITABLE-IVARS)
		     (CAR IIV)))))))
  ;; Then look at all the default init plists, for anything there that
  ;; initializes an instance variable.  If it does, make an entry on ALIST.
  ;; Any that doesn't initialize a variable, put on the "remaining" list.
  (DOLIST (FFL (FLAVOR-DEPENDS-ON-ALL FL))
    (SETQ FFL (GET-FLAVOR FFL))
    (DO ((L (GET (FLAVOR-PLIST FFL) ':DEFAULT-INIT-PLIST) (CDDR L))) ((NULL L))
      (LET* ((KEYWORD (CAR L)) (ARG (CADR L))
	     (INDEX (FIND-POSITION-IN-LIST KEYWORD ALL-INITABLE-IVARS)))
	(IF INDEX
	    (OR (ASSQ INDEX ALIST)
		(PUSH (LIST INDEX ARG)
		      ALIST))
	  ;; This keyword does not just initialize an instance variable.
	    (OR (MEMQ-ALTERNATED KEYWORD (CDR REMAINING-DEFAULT-PLIST))
		(PUTPROP REMAINING-DEFAULT-PLIST ARG KEYWORD))))))
  ;; Then, look for default values provided in list of instance vars.
  (DOLIST (FFL (FLAVOR-DEPENDS-ON-ALL FL))
    (SETQ FFL (GET-FLAVOR FFL))
    (DOLIST (V (FLAVOR-LOCAL-INSTANCE-VARIABLES FFL))
      (AND (NOT (ATOM V))
	   ;; When we find one, put it in if there is no init for that variable yet.
	   (LET ((INDEX (FIND-POSITION-IN-LIST (CAR V)
			       (FLAVOR-ALL-INSTANCE-VARIABLES FL))))
	     (AND (NOT (ASSQ INDEX ALIST))
		  (PUSH (LIST INDEX
			      (CADR V))
			ALIST)))))) 
  (SETF (FLAVOR-INSTANCE-VARIABLE-INITIALIZATIONS FL)
	(SORTCAR ALIST #'LESSP))
  (SETF (FLAVOR-REMAINING-DEFAULT-PLIST FL) (CDR REMAINING-DEFAULT-PLIST))
  (SETF (FLAVOR-ALL-INITABLE-INSTANCE-VARIABLES FL) ALL-INITABLE-IVARS)
  (SETF (FLAVOR-REMAINING-INIT-KEYWORDS FL)
	(LOOP FOR K IN (FLAVOR-ALLOWED-INIT-KEYWORDS FL)
	      UNLESS (MEMQ K ALL-INITABLE-IVARS)
	      COLLECT K)))

; Method-combination functions.  Found on the SI:METHOD-COMBINATION property
; of the combination-type.  These are passed the flavor structure, and the
; magic-list entry, and must return the function-spec for the handler
; to go into the select-method, defining any necessary functions.
; This function interprets combination-type-arg,
; which for many combination-types is either :BASE-FLAVOR-FIRST or :BASE-FLAVOR-LAST.

; :DAEMON combination
; The primary method is the outermost untyped-method (or :DEFAULT).
; The :BEFORE methods are called base-flavor-last, the :AFTER methods are called
; base-flavor-first.  An important optimization is not to generate a combined-method
; if there is only a primary method.  You are allowed to omit the primary method
; if there are any daemons (I'm not convinced this is really a good idea) in which
; case the method's returned value will be NIL.
(DEFUN (:DAEMON METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (LET ((PRIMARY-METHOD (CAR (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL '(:BEFORE :AFTER) T
						  ':BASE-FLAVOR-LAST)))
	(BEFORE-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':BEFORE T T
					     ':BASE-FLAVOR-LAST))
	(AFTER-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':AFTER T T
					    ':BASE-FLAVOR-FIRST))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY)))
    ;; Remove shadowed primary methods from the magic-list-entry so that it won't look like
    ;; we depend on them (which could cause extraneous combined-method recompilation).
    (LET ((MLE (ASSQ NIL (CDDDR MAGIC-LIST-ENTRY))))
      (AND (CDDR MLE)
	   (SETF (CDR MLE) (LIST PRIMARY-METHOD))))
    (OR (AND (NOT WRAPPERS-P) (NULL BEFORE-METHODS) (NULL AFTER-METHODS) PRIMARY-METHOD)
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	   (DAEMON-COMBINATION PRIMARY-METHOD BEFORE-METHODS AFTER-METHODS)))))

(DEFUN DAEMON-COMBINATION (PRIMARY-METHOD BEFORE-METHODS AFTER-METHODS
			   &OPTIONAL OR-METHODS AND-METHODS)
  (LET ((INNER-CALL (AND PRIMARY-METHOD (METHOD-CALL PRIMARY-METHOD))))
    (IF (AND INNER-CALL AFTER-METHODS)
	(SETQ INNER-CALL `(MULTIPLE-VALUE (.VAL1. .VAL2. .VAL3.)
			    ,INNER-CALL)))
    (AND OR-METHODS (SETQ INNER-CALL
			  `(OR ,@(MAPCAR 'METHOD-CALL OR-METHODS)
			       ,INNER-CALL)))
    (AND AND-METHODS (SETQ INNER-CALL
			   `(AND ,@(MAPCAR 'METHOD-CALL AND-METHODS)
				 ,INNER-CALL)))
    `(PROGN 
       ,@(MAPCAR 'METHOD-CALL BEFORE-METHODS)
       ,(IF AFTER-METHODS
	    ;; Kludge to return a few multiple values
	    `(PROG (.VAL1. .VAL2. .VAL3.)
		   ,INNER-CALL
		   ,@(MAPCAR 'METHOD-CALL AFTER-METHODS)
		   (RETURN .VAL1. .VAL2. .VAL3.))
	    ;; No :AFTER methods, hair not required
	    ;; You are allowed to not have a primary method
	    INNER-CALL))))

(DEFUN METHOD-CALL (METHOD)
  `(LEXPR-FUNCALL #',(METHOD-FUNCTION-NAME METHOD) .DAEMON-CALLER-ARGS.))

; :DAEMON-WITH-OVERRIDE combination
; This is the same as :DAEMON (the default), except that :OVERRIDE type methods
; are combined with the :BEFORE-primary-:AFTER methods in an OR.  This allows
; overriding of the main methods function.  For example, a combined method as follows
; might be generated: (OR (FOO-OVERRIDE-BAR-METHOD) (PROGN (FOO-BEFORE-BAR-METHOD)))
(DEFUN (:DAEMON-WITH-OVERRIDE METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (LET ((PRIMARY-METHOD (CAR (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL
						  '(:BEFORE :AFTER :OVERRIDE) T
						  ':BASE-FLAVOR-LAST)))
	(BEFORE-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':BEFORE T T
					     ':BASE-FLAVOR-LAST))
	(AFTER-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':AFTER T T
					    ':BASE-FLAVOR-FIRST))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY))
	(OVERRIDE-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY
					       ':OVERRIDE T T NIL)))
    ;; Remove shadowed primary methods from the magic-list-entry so that it won't look like
    ;; we depend on them (which could cause extraneous combined-method recompilation).
    (LET ((MLE (ASSQ NIL (CDDDR MAGIC-LIST-ENTRY))))
      (AND (CDDR MLE)
	   (SETF (CDR MLE) (LIST PRIMARY-METHOD))))
    (OR (AND (NOT WRAPPERS-P) (NULL BEFORE-METHODS) (NULL AFTER-METHODS)
	     (NULL OVERRIDE-METHODS)
	     PRIMARY-METHOD)
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	  `(OR ,@(MAPCAR 'METHOD-CALL OVERRIDE-METHODS)
	       ,(DAEMON-COMBINATION PRIMARY-METHOD BEFORE-METHODS AFTER-METHODS))))))

; :DAEMON-WITH-OR combination
; This is the same as :DAEMON (the default), except that :OR type methods
; are combined with the primary methods inside an OR, and used in place of
; the primary method in :DAEMON type combination.
; For example, the following combined method might be generated:
; (PROGN (FOO-BEFORE-BAR-METHOD)
;	 (PROG (.VAL1. .VAL2. .VAL3.)
;	       (OR (FOO-OR-BAR-METHOD)
;		   (BAZ-OR-BAR-METHOD)
;		   (MULTIPLE-VALUE (.VAL1. .VAL2. .VAL3.)
;		     (BUZZ-PRIMARY-METHOD)))
;	       (FOO-AFTER-BAR-METHOD)
;	       (RETURN .VAL1. .VAL2. .VAL3.)))

(DEFUN (:DAEMON-WITH-OR METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (LET ((PRIMARY-METHOD (CAR (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL '(:BEFORE :AFTER :OR) T
						  ':BASE-FLAVOR-LAST)))
	(BEFORE-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':BEFORE T T
					     ':BASE-FLAVOR-LAST))
	(AFTER-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':AFTER T T
					    ':BASE-FLAVOR-FIRST))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY))
	(OR-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':OR T T NIL)))
    ;; Remove shadowed primary methods from the magic-list-entry so that it won't look like
    ;; we depend on them (which could cause extraneous combined-method recompilation).
    (LET ((MLE (ASSQ NIL (CDDDR MAGIC-LIST-ENTRY))))
      (AND (CDDR MLE)
	   (SETF (CDR MLE) (LIST PRIMARY-METHOD))))
    (OR (AND (NOT WRAPPERS-P) (NULL BEFORE-METHODS) (NULL AFTER-METHODS)
	     (NULL OR-METHODS)
	     PRIMARY-METHOD)
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	  (DAEMON-COMBINATION PRIMARY-METHOD BEFORE-METHODS AFTER-METHODS
			      OR-METHODS)))))

; :DAEMON-WITH-AND combination
; This is the same as :DAEMON (the default), except that :AND type methods
; are combined with the primary methods inside an AND, and used in place of
; the primary method in :DAEMON type combination.
; For example, the following combined method might be generated:
; (PROGN (FOO-BEFORE-BAR-METHOD)
;	 (PROG (.VAL1. .VAL2. .VAL3.)
;	       (AND (FOO-AND-BAR-METHOD)
;		    (BAZ-AND-BAR-METHOD)
;		    (MULTIPLE-VALUE (.VAL1. .VAL2. .VAL3.)
;		      (BUZZ-PRIMARY-METHOD)))
;	       (FOO-AFTER-BAR-METHOD)
;	       (RETURN .VAL1. .VAL2. .VAL3.)))

(DEFUN (:DAEMON-WITH-AND METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (LET ((PRIMARY-METHOD (CAR (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL '(:BEFORE :AFTER :AND)
						  T ':BASE-FLAVOR-LAST)))
	(BEFORE-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':BEFORE T T
					     ':BASE-FLAVOR-LAST))
	(AFTER-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':AFTER T T
					    ':BASE-FLAVOR-FIRST))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY))
	(AND-METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY ':AND T T NIL)))
    ;; Remove shadowed primary methods from the magic-list-entry so that it won't look like
    ;; we depend on them (which could cause extraneous combined-method recompilation).
    (LET ((MLE (ASSQ NIL (CDDDR MAGIC-LIST-ENTRY))))
      (AND (CDDR MLE)
	   (SETF (CDR MLE) (LIST PRIMARY-METHOD))))
    (OR (AND (NOT WRAPPERS-P) (NULL BEFORE-METHODS) (NULL AFTER-METHODS)
	     (NULL AND-METHODS)
	     PRIMARY-METHOD)
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	  (DAEMON-COMBINATION PRIMARY-METHOD BEFORE-METHODS AFTER-METHODS
			      NIL AND-METHODS)))))

; :LIST combination
; No typed-methods allowed.  Returns a list of the results of all the methods.
; There will always be a combined-method, even if only one method to be called.
(DEFUN (:LIST METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (OR (HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
      (MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	    (CONS 'LIST (MAPCAR 'METHOD-CALL
				(GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL NIL NIL NIL))))))

; :INVERSE-LIST combination
; No typed-methods allowed.  Apply each method to an element of the list.  Given
; the result of a :LIST-combined method with the same ordering, and corresponding
; method definitions, the result that emerged from each component flavor gets handed
; back to that same flavor.  The combined-method returns no particular value.
(DEFUN (:INVERSE-LIST METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (OR (HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
      (MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	 `(LET ((.FOO. (CADR .DAEMON-CALLER-ARGS.)))
	    . ,(DO ((ML (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL NIL NIL NIL) (CDR ML))
		    (R NIL))
		   ((NULL ML) (NREVERSE R))
		 (PUSH `(FUNCALL #',(CAR ML)
			  (CAR .DAEMON-CALLER-ARGS.) (CAR .FOO.))
		       R)
		 (AND (CDR ML) (PUSH '(SETQ .FOO. (CDR .FOO.)) R)))))))

; Combination types PROGN, AND, OR, MAX, MIN, +, APPEND, NCONC
; These just call all the untyped methods, inside the indicated special form.
; As an optimization, if there is only one method it is simply called.
; ?? There should be hair where methods with an extra keyword in them
; get to act as conditionals controlling which other methods get called,
; if anyone can ever specify exactly what this means.
(DEFPROP :PROGN SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :AND SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :OR SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :MAX SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :MIN SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :+ SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :APPEND SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)
(DEFPROP :NCONC SIMPLE-METHOD-COMBINATION METHOD-COMBINATION)

; The following "tasteless" crock is necessary to make all work in Franz:
(eval-when (load eval) (loop for (to . from) in
			     '((:progn . progn)
			       (:and . and)
			       (:or . or)
			       (:max . max)
			       (:min . min)
			       (:+ . +)
			       (:append . append)
			       (:nconc . nconc))
			      do
			      (putd to (getd from))))

(DEFUN SIMPLE-METHOD-COMBINATION (FL MAGIC-LIST-ENTRY)
  (LET ((METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL NIL NIL NIL))
	(WRAPPERS-P (SPECIALLY-COMBINED-METHODS-PRESENT MAGIC-LIST-ENTRY)))
    (OR (AND (NOT WRAPPERS-P) (NULL (CDR METHODS)) (CAR METHODS))
	(HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	   (CONS (CADR MAGIC-LIST-ENTRY)
		 (MAPCAR 'METHOD-CALL
			 METHODS))))))

; :PASS-ON combination
; The values from the individual methods are the arguments to the next one;
; the values from the last method are the values returned by the combined
; method.  Format is 
;    (:METHOD-COMBINATION (:PASS-ON (ORDERING . ARGLIST)) . OPERATION-NAMES)
; ORDERING is :BASE-FLAVOR-FIRST or :BASE-FLAVOR-LAST.  ARGLIST can have 
; &AUX and &OPTIONAL.

(DEFUN (:PASS-ON METHOD-COMBINATION) (FL MAGIC-LIST-ENTRY)
  (LET ((METHODS (GET-CERTAIN-METHODS MAGIC-LIST-ENTRY NIL NIL NIL
				      (CAADDR MAGIC-LIST-ENTRY)))
	(ARGLIST (CDADDR MAGIC-LIST-ENTRY))
	ARGS REST-ARG-P)
    (DO ((L ARGLIST (CDR L))
	 (ARG)
	 (NL NIL))
	((NULL L)
	 (SETQ ARGS (NREVERSE NL)))
      (SETQ ARG (CAR L))
      (AND (LISTP ARG)
	   (SETQ ARG (CAR ARG)))
      (COND ((EQ ARG '&REST)
	     (SETQ REST-ARG-P T))
	    ((EQ ARG '&AUX))
	    (T
	     (PUSH ARG NL))))      
    (OR (HAVE-COMBINED-METHOD FL MAGIC-LIST-ENTRY)
	(MAKE-COMBINED-METHOD FL MAGIC-LIST-ENTRY
	  `(DESTRUCTURING-BIND ,(CONS '.OPERATION. ARGLIST) SI:.DAEMON-CALLER-ARGS.
	     . ,(DO ((METHS METHODS (CDR METHS))
		     (LIST NIL)
		     (METH))
		    ((NULL METHS)
		     (NREVERSE LIST))
		  (SETQ METH `(,(IF REST-ARG-P
				    'LEXPR-FUNCALL
				  'FUNCALL)
			       #',(CAR METHS) .OPERATION. . ,ARGS))
		  (AND (CDR METHS)
		       (SETQ METH (IF (NULL (CDR ARGS))
				      `(SETQ ,(CAR ARGS) ,METH)
				    `(MULTIPLE-VALUE ,ARGS ,METH))))
		  (PUSH METH LIST)))))))

; This function does most of the analysis of the magic-list-entry needed by
; method-combination functions, including most error checking.
; Returns a list of the method symbols for METHOD-TYPE extracted from 
; MAGIC-LIST-ENTRY.  This value is shared with the data structure, don't 
; bash it.  OTHER-METHODS-ALLOWED is a list of method types not to complain
;about (T = allow all).
;   NO-METHODS-OK = NIL means to complain if the returned value would be NIL.
;   ORDERING-DECLARATION is :BASE-FLAVOR-FIRST, :BASE-FLAVOR-LAST, or NIL 
;    meaning take one of those symbols from the MAGIC-LIST-ENTRY."

(DEFUN GET-CERTAIN-METHODS (MAGIC-LIST-ENTRY METHOD-TYPE OTHER-METHODS-ALLOWED
			    NO-METHODS-OK ORDERING-DECLARATION
			    &AUX (METHODS NIL))
  ;; Find the methods of the desired type, and barf at any extraneous methods
  (DOLIST (X (CDDDR MAGIC-LIST-ENTRY))
    (COND ((EQ (CAR X) METHOD-TYPE) (SETQ METHODS (CDR X)))
	  ((ASSQ (CAR X) *SPECIALLY-COMBINED-METHOD-TYPES*) ) ;Wrappers ignored at this level
	  ((OR (EQ OTHER-METHODS-ALLOWED T) (MEMQ (CAR X) OTHER-METHODS-ALLOWED)) )
	  (T (FERROR () "~S ~S method(s) illegal when using :~A method-combination"
		         (CAR X) (CAR MAGIC-LIST-ENTRY)
			 (OR (CADR MAGIC-LIST-ENTRY) ':DAEMON)))))
  ;; Complain if no methods supplied
  (AND (NULL METHODS) (NOT NO-METHODS-OK)
       (FERROR () "No ~S ~S method(s) supplied to :~A method-combination"
	           METHOD-TYPE (CAR MAGIC-LIST-ENTRY) (CADR MAGIC-LIST-ENTRY)))
  ;; Get methods into proper order.  Don't use NREVERSE!
  (SELECTQ (OR ORDERING-DECLARATION (SETQ ORDERING-DECLARATION (CADDR MAGIC-LIST-ENTRY)))
    (:BASE-FLAVOR-FIRST )
    (:BASE-FLAVOR-LAST (SETQ METHODS (REVERSE METHODS)))
    (OTHERWISE (FERROR () "~S invalid method combination order;
 must be :BASE-FLAVOR-FIRST or :BASE-FLAVOR-LAST"
		           ORDERING-DECLARATION)))
  METHODS)

(DEFUN SPECIALLY-COMBINED-METHODS-PRESENT (MLE)
  (LOOP FOR (TYPE) IN (CDDDR MLE)
	THEREIS (ASSQ TYPE *SPECIALLY-COMBINED-METHOD-TYPES*)))

;; It is up to the caller to decide that a combined-method is called for at all.
;; If one is, this function decides whether it already exists OK or needs
;; to be recompiled.  Returns the symbol for the combined method if it is
;; still valid, otherwise returns NIL.
;; Always canonicalizes the magic-list-entry, since it will be needed
;; canonicalized later.
(DEFUN HAVE-COMBINED-METHOD (FL MAGIC-LIST-ENTRY
			     &AUX OPERATION-NAME CMS MTE OLD-MLE OLD-CMS TEM OMETH)
  ;; Canonicalize the magic-list-entry so can compare with EQUAL
  (SETF (CDDDR MAGIC-LIST-ENTRY)		;Canonicalize before comparing
	(SORTCAR (CDDDR MAGIC-LIST-ENTRY) #'ALPHALESSP))	;Sort by method-type
  (SETQ OPERATION-NAME (CAR MAGIC-LIST-ENTRY))
  ;; See if we can inherit one in either the current or future (being-compiled) world,
  ;; or use an existing combined method of this flavor.
  ;; Get the :COMBINED method function spec for this flavor.  Note that if a suitable
  ;; one can be inherited, we will do so.
  ;; *USE-OLD-COMBINED-METHODS* controls whether we reuse an existing one for this
  ;; flavor; if we inherit one it will always be up-to-date already.
  ;; If all OK, return the function spec, else return NIL if new combined method must be made.
  (OR (DOLIST (FFL (FLAVOR-DEPENDS-ON-ALL FL))
	(LET ((FLAVOR1 (GET-FLAVOR FFL)))
	  (AND (OR (NEQ FLAVOR1 FL) *USE-OLD-COMBINED-METHODS*)
	       ;; ^ Combined methods of this flavor can be used only if permitted.
	       (SETQ MTE (ASSQ OPERATION-NAME (FLAVOR-METHOD-TABLE FLAVOR1)))
	       (SETQ OMETH (METH-LOOKUP ':COMBINED (CDDDR MTE)))
	       (METH-DEFINEDP OMETH)
	       (METH-DEFINITION OMETH)
	       (SETQ CMS (METH-FUNCTION-SPEC OMETH))
	       (EQUAL MAGIC-LIST-ENTRY
		      (SETQ TEM (GET (METH-PLIST OMETH) 'COMBINED-METHOD-DERIVATION)))
	       (RETURN CMS)))
	;Save first combined-method seen for tracing, it's the one we would
	;have been most likely to inherit
	(OR OLD-CMS (NULL CMS) (NULL TEM)
	    (SETQ OLD-CMS CMS OLD-MLE TEM)))

      ;; Have to make a new combined method.  Trace if desired, but return NIL in any case.
      (PROGN
	(COND (*FLAVOR-COMPILE-TRACE*
	       (FORMAT *FLAVOR-COMPILE-TRACE*
		       "~&~S's ~S combined method needs to be recompiled~%to come from "
		       (FLAVOR-NAME FL) OPERATION-NAME)
	       (PRINT-COMBINED-METHOD-DERIVATION MAGIC-LIST-ENTRY *FLAVOR-COMPILE-TRACE*)
	       (COND (OLD-CMS
		      (FORMAT *FLAVOR-COMPILE-TRACE*
			      "~%rather than using ~S which comes from " OLD-CMS)
		      (PRINT-COMBINED-METHOD-DERIVATION OLD-MLE *FLAVOR-COMPILE-TRACE*))
		     ((NOT *USE-OLD-COMBINED-METHODS*)
		      (FORMAT *FLAVOR-COMPILE-TRACE* "~%because of forced recompilation.")))))
	NIL)))


(DEFUN PRINT-COMBINED-METHOD-DERIVATION (MLE STREAM)
  (LOOP FOR (TYPE . FUNCTION-SPECS) IN (CDDDR MLE)
	DO (LOOP FOR FUNCTION-SPEC IN FUNCTION-SPECS DO (FORMAT STREAM "~S " FUNCTION-SPEC)))
  (IF (OR (CADR MLE) (CADDR MLE))
      (FORMAT STREAM "with method-combination ~S ~S" (CADR MLE) (CADDR MLE))))

;; This function creates a combined-method, and returns the appropriate function spec.
;; Its main job in life is to take care of wrappers.  Note the combined method
;; always takes a single &REST argument named .DAEMON-CALLER-ARGS.
;; FORM is a single form to be used as the body.
(DEFUN MAKE-COMBINED-METHOD (FL MAGIC-LIST-ENTRY FORM &AUX FSPEC WRAPPERS)
  ;; Get the function spec which will name the combined-method
  (SETQ FSPEC `(:METHOD ,(FLAVOR-NAME FL) :COMBINED ,(CAR MAGIC-LIST-ENTRY)))
  ;; Put the wrappers around the form.  The base-flavor wrapper goes on the inside.
  (SETQ WRAPPERS (GET-SPECIALLY-COMBINED-METHODS MAGIC-LIST-ENTRY FL))
  (DOLIST (METHOD WRAPPERS)
    (SETQ FORM (FUNCALL (CADR (ASSQ (CADDR METHOD) *SPECIALLY-COMBINED-METHOD-TYPES*))
			METHOD FORM)))
  ;; Remember that it's going to be there, for HAVE-COMBINED-METHOD
  (FLAVOR-NOTICE-METHOD FSPEC)
  ;; Compile the function.  It will be inserted into the flavor's tables either
  ;; now or when the QFASL file is loaded.
  (COMPILE-AT-APPROPRIATE-TIME
    FL
    FSPEC
    `(LAMBDA (&REST .DAEMON-CALLER-ARGS.)
       .DAEMON-CALLER-ARGS.
       ,FORM)
    `(FUNCTION-SPEC-PUTPROP ',FSPEC
			    ',MAGIC-LIST-ENTRY
			    'COMBINED-METHOD-DERIVATION))
  FSPEC)


(LOCAL-DECLARE ((SPECIAL *FL*))
(DEFUN GET-SPECIALLY-COMBINED-METHODS (MLE *FL*)
  (SORT (LOOP FOR (TYPE . FSPECS) IN (CDDDR MLE)
	      WHEN (ASSQ TYPE *SPECIALLY-COMBINED-METHOD-TYPES*)
	        APPEND FSPECS)
	#'(LAMBDA (FS1 FS2)
	    (LOOP WITH FL1 = (CADR FS1) AND FL2 = (CADR FS2)
		  FOR SUP IN (FLAVOR-DEPENDS-ON-ALL *FL*)
		  WHEN (EQ SUP FL2) RETURN T	;Base flavor earlier in list
		  WHEN (EQ SUP FL1) RETURN NIL)))))

(DEFUN PUT-WRAPPER-INTO-COMBINED-METHOD (WRAPPER-NAME FORM)
  (LET ((DEF (COND #-Franz ((DECLARED-DEFINITION WRAPPER-NAME))
		   ;; What would the above mean in Franz?
		   ((getd (method-function-name WRAPPER-NAME)))
		   (T (FERROR () "~S supposed to be a wrapper macro, but missing!"
			      WRAPPER-NAME)))))
    (COND ((not (and (dtpr DEF)
		     (eq (CAR DEF) 'MACRO)))
	   (FERROR () "~S, supposed to be a wrapper macro, is poorly formed. Definiton is ~s"
		   WRAPPER-NAME DEF)))
  ;; Here we just put the wrapper in as a macro.  It will be expanded by the compiler.
    `(MACROCALL ,WRAPPER-NAME .DAEMON-CALLER-ARGS. ,FORM)))

;Sort of a macro version of funcall, for wrappers
(DEFMACRO MACROCALL (&REST X)
  (LET ((MACRO (COND #-Franz ((DECLARED-DEFINITION (CAR X)))
		     ((method-function-name (CAR X)))
		     (T (FERROR () "Unable to find definition of wrapper ~s at expand time"
				(CAR X))))))
    (IF (AND (LISTP MACRO) (EQ (CAR MACRO) 'MACRO))
	(FUNCALL (cons 'lambda (CDR MACRO)) X)
	;--- Temporary code so I can test things in the kludge environment
	(IF (AND (SYMBOLP MACRO) (LISTP (getd MACRO))
		 (EQ (CAR (getd MACRO)) 'MACRO))
	    (FUNCALL (cons 'lambda (CDR (getd MACRO))) X)
	    (FERROR () "~S evaluated to ~S, which is not a macro"
		    (CAR X) MACRO)))))

;; Given a functional object, return its subfunction to do the given 
;; operation or NIL.   Returns NIL if it does not reduce to a select-method 
;; or if it does not handle that."
(DEFUN GET-HANDLER-FOR (FUNCTION OPERATION &OPTIONAL (SUPERIORS-P T) &AUX TEM)
  (COND ((SYMBOLP FUNCTION)
	 (COND ((SETQ TEM (GET FUNCTION 'FLAVOR))
		(GET-FLAVOR-HANDLER-FOR TEM OPERATION))))
	((:TYPEP FUNCTION 'FLAVOR)
	 (GET-FLAVOR-HANDLER-FOR (FLAVOR-NAME FUNCTION) OPERATION))
	((INSTANCEP FUNCTION)
; SMH@EMS VVV
;	 (GET-FLAVOR-HANDLER-FOR (FLAVOR-NAME (VREF FUNCTION 6))
;				 OPERATION)
	 (GET-FLAVOR-HANDLER-FOR
	  (FLAVOR-NAME (INT:FCLOSURE-STACK-STUFF (VREF FUNCTION 2)))
				 OPERATION)
; SMH@EMS ^^^
)))

;;; Get the function that would handle an operation for a flavor
(DEFUN GET-FLAVOR-HANDLER-FOR (FLAVOR-NAME OPERATION &AUX FL)
  (CHECK-ARG FLAVOR-NAME (SETQ FL (GET FLAVOR-NAME 'FLAVOR))
	     "the name of a flavor")
  ;; Do any composition (compilation) of combined stuff, if not done already
  (OR (FLAVOR-DEPENDS-ON-ALL FL) (COMPOSE-FLAVOR-COMBINATION FL))
  (OR (FLAVOR-METHOD-HASH-TABLE FL) (COMPOSE-METHOD-COMBINATION FL))
  (GETHASH OPERATION (FLAVOR-METHOD-HASH-TABLE FL)))

(DEFUN SYMEVAL-IN-INSTANCE (INSTANCE VAR)
  (CHECK-ARG INSTANCE INSTANCEP "an instance")
  (SYMEVAL-IN-FCLOSURE INSTANCE VAR))

(DEFSETF SYMEVAL-IN-INSTANCE (E V) `(SET-IN-INSTANCE ,(CADR E) ,(CADDR E) ,V))

(DEFUN SET-IN-INSTANCE (INSTANCE VAR VAL)
  (CHECK-ARG INSTANCE INSTANCEP "an instance")
  (SET-IN-FCLOSURE INSTANCE VAR VAL))

;Interface to the compiler.
(DEFUN COMPILE-AT-APPROPRIATE-TIME (FL NAME LAMBDA-EXP &OPTIONAL FORM-TO-EVAL)
  (PUTD (METHOD-FUNCTION-NAME NAME)
	(LAMBDACVT (CDR LAMBDA-EXP))))

;This macro takes flavor names as "arguments".  It causes the compiler
;to include the appropriate methods in the qfasl file, provided all the
;component flavors are defined.
(DEFMACRO COMPILE-FLAVOR-METHODS (&REST FLAVOR-NAMES)
  `(PROGN 'COMPILE
     (EVAL-WHEN (COMPILE)
       . ,(MAPCAN #'(LAMBDA (FLAVOR-NAME)
		      (NCONC (AND (GET FLAVOR-NAME 'FLAVOR)
				  (NCONS `(PUTPROP (FLAVOR-PLIST
						    (GET ',FLAVOR-NAME 'FLAVOR))
						   T
						   'COMPILE-FLAVOR-METHODS)))
			     (NCONS `(COMPILE-FLAVOR-METHODS-1 ',FLAVOR-NAME))))
		  FLAVOR-NAMES))
     (EVAL-WHEN (LOAD EVAL)
       . ,(MAPCAR #'(LAMBDA (FLAVOR-NAME) `(COMPILE-FLAVOR-METHODS-2 ',FLAVOR-NAME))
		  FLAVOR-NAMES))))

;; Cause the combined-methods to get compiled.
;; Executed only from the compiler, and does something
;; only if compiling to a file.
(DEFUN COMPILE-FLAVOR-METHODS-1 (FLAVOR-NAME &AUX FL)
  (IF (JUST-COMPILING)
      (LET ((*JUST-COMPILING* T)
	    (*USE-OLD-COMBINED-METHODS* NIL))
	(COND ((FLAVOR-COMPONENTS-DEFINED-P FLAVOR-NAME 'COMPILE-FLAVOR-METHODS)
	       (SETQ FL (GET-FLAVOR FLAVOR-NAME))
	       ;; Make sure we are not hacking the installed flavor object,
	       ;; in case there is no defflavor or defmethod for the flavor in this file.
	       (AND (EQ FL (GET FLAVOR-NAME 'FLAVOR))
		    (COMPILATION-DEFINE-FLAVOR
		      FLAVOR-NAME
		      (SETQ FL (FLAVOR-REDEFINITION-FOR-COMPILATION FL NIL))))
	       (OR (FLAVOR-DEPENDS-ON-ALL FL)
		   (COMPOSE-FLAVOR-COMBINATION FL))
	       (COMPOSE-METHOD-COMBINATION FL NIL))))))

;; Do the composition now.  This should normally just generate data-structure
;; as the methods should already all have been compiled, unless something has changed.
(DEFUN COMPILE-FLAVOR-METHODS-2 (FLAVOR-NAME &AUX FL)
  (CHECK-ARG FLAVOR-NAME (SETQ FL (GET FLAVOR-NAME 'FLAVOR)) "the name of a flavor")
  (PUTPROP (FLAVOR-PLIST FL) T 'COMPILE-FLAVOR-METHODS)
  (COND ((FLAVOR-COMPONENTS-DEFINED-P FLAVOR-NAME)
	 (OR (FLAVOR-DEPENDS-ON-ALL FL) (COMPOSE-FLAVOR-COMBINATION FL))
	 (OR (FLAVOR-METHOD-HASH-TABLE FL)
	     (COMPOSE-METHOD-COMBINATION FL))))
  FLAVOR-NAME)

;Returns T if all components of this flavor are defined
(DEFUN FLAVOR-COMPONENTS-DEFINED-P (FLAVOR-NAME &OPTIONAL COMPLAINT &AUX FL)
  (COND ((SETQ FL (GET-FLAVOR FLAVOR-NAME))
	 (OR (NOT (NULL (FLAVOR-DEPENDS-ON-ALL FL)))	;Already composed, be fast
	     (AND (DO ((L (FLAVOR-DEPENDS-ON FL) (CDR L))) ((NULL L) T)
		    (OR (FLAVOR-COMPONENTS-DEFINED-P (CAR L)) (RETURN NIL)))
		  (DO ((L (FLAVOR-INCLUDES FL) (CDR L))) ((NULL L) T)
		    (OR (FLAVOR-COMPONENTS-DEFINED-P (CAR L)) (RETURN NIL))))))
	(COMPLAINT (FORMAT ERRPORT "~&~A - ~S undefined flavor" COMPLAINT FLAVOR-NAME)
		   NIL)
	(T NIL)))

(EVAL-WHEN (EVAL LOAD) (LOAD 'VANILLA))

;; Local Modes:
;; Mode: Lisp
;; Case Search: 1
;; End:
EndOfFile
cat >  lisplib/vanilla.l  << 'EndOfFile'
;; (c) copywrite 1982, Massachusetts Institute of Technology

;; This flavor system is derived from the original Lisp machine
;; flavor system.  As such its distribution may be restricted to
;; Lisp machine software license holders.

(environment-lmlisp (eval compile load) (files flavorm))

(setq |SCCS-vanilla| "@(#) vanilla.l	1.1	83/01/27 @(#)")

;This is a flavor which is automatically made a component of nearly all
;other flavors.  It provides some basic facilities such as PRINT
;and DESCRIBE.

(DEFFLAVOR SI:VANILLA-FLAVOR () ()
  :NO-VANILLA-FLAVOR  ;No instance variables, no other flavors
  (:DOCUMENTATION :MIXIN "The default base flavor.
This flavor provides the normal handlers for the :PRINT, :DESCRIBE, and :WHICH-OPERATIONS
operations.  Only esoteric hacks should give the :NO-VANILLA-FLAVOR option to DEFFLAVOR to
prevent this inclusion."))


(DEFMETHOD (SI:VANILLA-FLAVOR :PRINT-SELF) (STREAM &REST IGNORE)
  (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)))

(DEFMETHOD (SI:VANILLA-FLAVOR :DESCRIBE) ()
  (FORMAT T "~&~S, an object of flavor ~S,~% has instance variable values:~%"
	    SELF (:TYPEP SELF))
  (DO ((IVARS (FLAVOR-ALL-INSTANCE-VARIABLES (INSTANCE-FLAVOR SELF))
	      (CDR IVARS))
       (I 0 (1+ I)))
      ((NULL IVARS))
; SMH@EMS VVV
;   (FORMAT T "~S~%" (%INSTANCE-REF SELF I))
    (FORMAT T " ~S:" (CAR IVARS))
    (MSG (|B| (MAX 1 (DIFF 30 (NWRITN)))))
    (FORMAT T "~S~%" (INT:FCLOSURE-STACK-STUFF (VREF SELF (+ 3 I))))
; SMH@EMS ^^^
))

;The default response to :WHICH-OPERATIONS is a list of all operations
;handled.  The list is consed up just once.  It is computed by examination
;of the method hash table, since that has no duplications.
;This goes to some pains to produce a cdr-coded list, for fast MEMQ'ing.
(DEFMETHOD (SI:VANILLA-FLAVOR :WHICH-OPERATIONS) ()
  (LET ((FL (INSTANCE-FLAVOR SELF)))
    (OR (FLAVOR-WHICH-OPERATIONS FL)
	(LET ((HT (FLAVOR-METHOD-HASH-TABLE FL))
	      W-O)
	  (DECLARE (SPECIAL W-O))
	  (MAPHASH #'(LAMBDA (OP IGNORE)
			     (DECLARE (SPECIAL W-O))
			     (PUSH OP W-O))
			 HT)
	  (SETF (FLAVOR-WHICH-OPERATIONS FL) W-O)
	  W-O))))

#-Franz
(DEFMETHOD (SI:VANILLA-FLAVOR :OPERATION-HANDLED-P) (OP)
  (LET ((FL (INSTANCE-FLAVOR SELF)))
    (IF (ARRAYP (FLAVOR-METHOD-HASH-TABLE FL))
	(MULTIPLE-VALUE-BIND (NIL DEFINEDP)
	    (WITHOUT-INTERRUPTS
	      (GETHASH OP (FLAVOR-METHOD-HASH-TABLE FL)))
	  DEFINEDP)
      (LET ((WO (OR (FLAVOR-WHICH-OPERATIONS FL) (FUNCALL-SELF ':WHICH-OPERATIONS))))
	(NOT (NOT (MEMQ OP WO)))))))

#+Franz					; 8Jul84 SMH@EMS
(DEFMETHOD (SI:VANILLA-FLAVOR :OPERATION-HANDLED-P) (OP)
	   (LET ((WO (OR (FLAVOR-WHICH-OPERATIONS (INSTANCE-FLAVOR SELF))
			 (FUNCALL-SELF ':WHICH-OPERATIONS))))
		(NOT (NOT (MEMQ OP WO)))))

#-Franz
(DEFMETHOD (SI:VANILLA-FLAVOR :SEND-IF-HANDLES) (OP &REST TO-SEND)
  (LET ((FL (INSTANCE-FLAVOR SELF)))
    (IF (ARRAYP (FLAVOR-METHOD-HASH-TABLE FL))
	(MULTIPLE-VALUE-BIND (FN-LOCATION DEFINEDP)
	    (GETHASH OP (FLAVOR-METHOD-HASH-TABLE FL))
	  (IF DEFINEDP (LEXPR-FUNCALL (CAR FN-LOCATION) OP TO-SEND)))
	(LET ((WO (OR (FLAVOR-WHICH-OPERATIONS FL)
		      (FUNCALL-SELF ':WHICH-OPERATIONS))))
	  (AND (MEMQ OP WO)
	       (LEXPR-FUNCALL-SELF OP TO-SEND))))))

#+Franz					; 8Jul84 SMH@EMS
(DEFMETHOD (SI:VANILLA-FLAVOR :SEND-IF-HANDLES) (OP &REST TO-SEND)
	   (LET ((WO (OR (FLAVOR-WHICH-OPERATIONS (INSTANCE-FLAVOR SELF))
			 (FUNCALL-SELF ':WHICH-OPERATIONS))))
		(AND (MEMQ OP WO)
		     (LEXPR-FUNCALL-SELF OP TO-SEND))))

(DEFMETHOD (SI:VANILLA-FLAVOR :GET-HANDLER-FOR) (OP)
  (GET-HANDLER-FOR SELF OP))

;Useful methods for debugging.
;They all cause the instance variables of SELF to be bound as specials.
(DEFMETHOD (SI:VANILLA-FLAVOR :EVAL-INSIDE-YOURSELF) (FORM)
  (EVAL FORM))

(DEFMETHOD (SI:VANILLA-FLAVOR :FUNCALL-INSIDE-YOURSELF) (FUNCTION &REST ARGS)
  (APPLY FUNCTION ARGS))

(DEFMETHOD (SI:VANILLA-FLAVOR :BREAK) ()
  (*BREAK T SELF))

;;; This flavor is a useful mixin that provides messages for a property list protocol.

(DEFFLAVOR SI:PROPERTY-LIST-MIXIN ((PROPERTY-LIST (LIST 'PROPERTY-LIST))) ()
  :SETTABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN "A mixin that provides property list messages."))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :GET) (INDICATOR)
  (GET PROPERTY-LIST INDICATOR))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :GETL) (INDICATOR-LIST)
  (GETL PROPERTY-LIST INDICATOR-LIST))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :PUTPROP) (PROPERTY INDICATOR)
  (PUTPROP PROPERTY-LIST PROPERTY INDICATOR))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :REMPROP) (INDICATOR)
  (REMPROP PROPERTY-LIST INDICATOR))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :PUSH-PROPERTY) (PROPERTY INDICATOR)
  (PUSH PROPERTY (GET PROPERTY-LIST INDICATOR)))

(DEFMETHOD (SI:PROPERTY-LIST-MIXIN :PLIST) () PROPERTY-LIST)
EndOfFile
# end of Franz Lisp Distribution
